<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-08-06T15:49:34+00:00</updated><id>/feed.xml</id><title type="html">blank</title><subtitle>My personal website focusing on Java EE/Jakarta EE and Spring.
</subtitle><entry><title type="html">Using Enum in Symfony</title><link href="/blog/2022/using-enum-in-symfony/" rel="alternate" type="text/html" title="Using Enum in Symfony" /><published>2022-02-27T00:00:00+00:00</published><updated>2022-02-27T00:00:00+00:00</updated><id>/blog/2022/using-enum-in-symfony</id><content type="html" xml:base="/blog/2022/using-enum-in-symfony/">&lt;p&gt;PHP 8.1 introduces the official &lt;em&gt;Enum&lt;/em&gt; support. &lt;a href=&quot;https://www.doctrine-project.org/2022/01/11/orm-2.11.html&quot;&gt;Doctrine brought Enum type support in its ORM framework&lt;/a&gt;, and &lt;a href=&quot;https://symfony.com/blog/new-in-symfony-5-4-php-enumerations-support&quot;&gt;Symfony added serialization and deserialization support of a Enum type&lt;/a&gt;.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*zM0-IX7pIVhjXuP1aJtb4w.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@kakachen?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;te chan&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;It is time to migrate your projects to use PHP Enum if you are using 3rd-party enumeration solutions.&lt;/p&gt;&lt;p&gt;To use PHP &lt;em&gt;Enum&lt;/em&gt;, you have to upgrade to PHP 8.1, and set the PHP version to 8.1 in the project composer file.&lt;/p&gt;&lt;pre&gt;{&lt;br&gt;    //...&lt;br&gt;    &amp;quot;require&amp;quot;: {&lt;br&gt;        &amp;quot;php&amp;quot;: &amp;quot;&amp;gt;=8.1&amp;quot;,&lt;br&gt;        //...&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Creating Enum Class&lt;/h3&gt;&lt;p&gt;For example, we will add a Status to the Post entity, and defined several fixed values of the post status.&lt;/p&gt;&lt;pre&gt;&amp;lt;?php&lt;/pre&gt;&lt;pre&gt;namespace App\Entity;&lt;/pre&gt;&lt;pre&gt;enum Status: string&lt;br&gt;{&lt;br&gt;    case Draft = &amp;quot;DRAFT&amp;quot;;&lt;br&gt;    case PendingModerated = &amp;quot;PENDING_MODERATED&amp;quot;;&lt;br&gt;    case Published = &amp;quot;PUBLISHED&amp;quot;;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Here we use a &lt;em&gt;string&lt;/em&gt; backed enum, add a field in the Post class.&lt;/p&gt;&lt;pre&gt;#[Column(type: &amp;quot;string&amp;quot;, enumType: Status::class)]&lt;br&gt;private Status $status;&lt;/pre&gt;&lt;p&gt;Note, set the &lt;em&gt;enumType&lt;/em&gt; as the Status class. It will store the status value as a string in the database tables.&lt;/p&gt;&lt;p&gt;In the Post constructor, assign a default value to the status.&lt;/p&gt;&lt;pre&gt;public function __construct()&lt;br&gt;{&lt;br&gt;    $this-&amp;gt;status = Status::Draft;&lt;br&gt;    //...&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Now everything is ok.&lt;/p&gt;&lt;h3&gt;Creating HttpMethod&lt;/h3&gt;&lt;p&gt;When we setup the Route attribute on the Controller class, we use a literal value to set up the HTTP method.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;/pre&gt;&lt;p&gt;For the &lt;em&gt;methods&lt;/em&gt; value, there are only several options available to choose. Obviously, if introducing &lt;em&gt;Enum&lt;/em&gt;, it will provide a &lt;em&gt;type-safe&lt;/em&gt; way to setup the values and decrease the typo errors.&lt;/p&gt;&lt;p&gt;Create an Enum named HttpMethod.&lt;/p&gt;&lt;pre&gt;&amp;lt;?php&lt;/pre&gt;&lt;pre&gt;namespace App\Annotation;&lt;/pre&gt;&lt;pre&gt;enum HttpMethod&lt;br&gt;{&lt;br&gt;    case GET;&lt;br&gt;    case POST;&lt;br&gt;    case HEAD;&lt;br&gt;    case OPTIONS;&lt;br&gt;    case PATCH;&lt;br&gt;    case PUT;&lt;br&gt;    case DELETE;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Then refactor the Route attribute and create a series of attributes(Get, Post, Put, Delete, etc.) that are mapped to different HTTP methods.&lt;/p&gt;&lt;pre&gt;//file : src/Annotation/Get.php&lt;br&gt;#[Attribute]&lt;br&gt;class Get extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::GET-&amp;gt;name];&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;pre&gt;//file : src/Annotation/Head.php&lt;br&gt;#[Attribute]&lt;br&gt;class Head extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::HEAD-&amp;gt;name];&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;pre&gt;//file : src/Annotation/Options.php&lt;br&gt;#[Attribute]&lt;br&gt;class Options extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::OPTIONS-&amp;gt;name];&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;pre&gt;//file : src/Annotation/Patch.php&lt;br&gt;#[Attribute]&lt;br&gt;class Patch extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::PATCH-&amp;gt;name];&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//file : src/Annotation/Post.php&lt;br&gt;#[Attribute]&lt;br&gt;class Post extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::POST-&amp;gt;name];&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//file : src/Annotation/Put.php&lt;br&gt;#[Attribute]&lt;br&gt;class Put extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::PUT-&amp;gt;name];&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//file : src/Annotation/Delete.php&lt;br&gt;#[Attribute]&lt;br&gt;class Delete extends Route&lt;br&gt;{&lt;br&gt;    public function getMethods()&lt;br&gt;    {&lt;br&gt;        return [HttpMethod::DELETE-&amp;gt;name];&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Now you can polish the PostController, use these attributes instead. As you see, the naming of the new attributes literally look more clear.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;/posts&amp;quot;, name: &amp;quot;posts_&amp;quot;)]&lt;br&gt;class PostController extends AbstractController&lt;br&gt;{&lt;/pre&gt;&lt;pre&gt;    // constructor...&lt;/pre&gt;&lt;pre&gt;    // #[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    #[Get(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;)]&lt;br&gt;    public function all(#[QueryParam] string $keyword,&lt;br&gt;                        #[QueryParam] int $offset = 0,&lt;br&gt;                        #[QueryParam] int $limit = 20): Response&lt;br&gt;    {&lt;br&gt;        //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    // #[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    #[Get(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;)]&lt;br&gt;    public function getById(Uuid $id): Response&lt;br&gt;    {&lt;br&gt;       //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    //#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;create&amp;quot;, methods: [&amp;quot;POST&amp;quot;])]&lt;br&gt;    #[Post(path: &amp;quot;&amp;quot;, name: &amp;quot;create&amp;quot;)]&lt;br&gt;    public function create(#[Body] CreatePostDto $data): Response&lt;br&gt;    {&lt;br&gt;        //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    //#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;update&amp;quot;, methods: [&amp;quot;PUT&amp;quot;])]&lt;br&gt;    #[Put(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;update&amp;quot;)]&lt;br&gt;    public function update(Uuid $id, #[Body] UpdatePostDto $data): Response&lt;br&gt;    {&lt;br&gt;        //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    // #[Route(path: &amp;quot;/{id}/status&amp;quot;, name: &amp;quot;update_status&amp;quot;, methods: [&amp;quot;PUT&amp;quot;])]&lt;br&gt;    #[Put(path: &amp;quot;/{id}/status&amp;quot;, name: &amp;quot;update_status&amp;quot;)]&lt;br&gt;    public function updateStatus(Uuid $id, #[Body] UpdatePostStatusDto $data): Response&lt;br&gt;    {&lt;br&gt;       //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    //#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;delete&amp;quot;, methods: [&amp;quot;DELETE&amp;quot;])]&lt;br&gt;    #[Delete(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;delete&amp;quot;)]&lt;br&gt;    public function deleteById(Uuid $id): Response&lt;br&gt;    {&lt;br&gt;        //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    // comments sub resources.&lt;br&gt;    //#[Route(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;commentByPostId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    #[GET(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;commentByPostId&amp;quot;)]&lt;br&gt;    public function getComments(Uuid $id): Response&lt;br&gt;    {&lt;br&gt;      //...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    //#[Route(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;addComments&amp;quot;, methods: [&amp;quot;POST&amp;quot;])]&lt;br&gt;    #[Post(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;addComments&amp;quot;)]&lt;br&gt;    public function addComment(Uuid $id, Request $request): Response&lt;br&gt;    {&lt;br&gt;		//...&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Run the application again to make sure it works.&lt;/p&gt;&lt;h4&gt;Get &lt;a href=&quot;https://github.com/hantsy/symfony-rest-sample&quot;&gt;the source codes&lt;/a&gt; from my Github.&lt;/h4&gt;&lt;h4&gt;BTW, I have updated my original Symfony posts into a step-by-step guide, read it online: &lt;a href=&quot;https://hantsy.github.io/symfony-rest-sample/&quot;&gt;https://hantsy.github.io/symfony-rest-sample/&lt;/a&gt;&lt;/h4&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8f32d9cfaa0f&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/using-enum-in-symfony-8f32d9cfaa0f&quot;&gt;Using Enum in Symfony&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">PHP 8.1 introduces the official Enum support. Doctrine brought Enum type support in its ORM framework, and Symfony added serialization and deserialization support of a Enum type.Photo by te chan on UnsplashIt is time to migrate your projects to use PHP Enum if you are using 3rd-party enumeration solutions.To use PHP Enum, you have to upgrade to PHP 8.1, and set the PHP version to 8.1 in the project composer file.{ //... &amp;quot;require&amp;quot;: { &amp;quot;php&amp;quot;: &amp;quot;&amp;gt;=8.1&amp;quot;, //... }}Creating Enum ClassFor example, we will add a Status to the Post entity, and defined several fixed values of the post status.&amp;lt;?phpnamespace App\Entity;enum Status: string{ case Draft = &amp;quot;DRAFT&amp;quot;; case PendingModerated = &amp;quot;PENDING_MODERATED&amp;quot;; case Published = &amp;quot;PUBLISHED&amp;quot;;}Here we use a string backed enum, add a field in the Post class.#[Column(type: &amp;quot;string&amp;quot;, enumType: Status::class)]private Status $status;Note, set the enumType as the Status class. It will store the status value as a string in the database tables.In the Post constructor, assign a default value to the status.public function __construct(){ $this-&amp;gt;status = Status::Draft; //...}Now everything is ok.Creating HttpMethodWhen we setup the Route attribute on the Controller class, we use a literal value to set up the HTTP method.#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]For the methods value, there are only several options available to choose. Obviously, if introducing Enum, it will provide a type-safe way to setup the values and decrease the typo errors.Create an Enum named HttpMethod.&amp;lt;?phpnamespace App\Annotation;enum HttpMethod{ case GET; case POST; case HEAD; case OPTIONS; case PATCH; case PUT; case DELETE;}Then refactor the Route attribute and create a series of attributes(Get, Post, Put, Delete, etc.) that are mapped to different HTTP methods.//file : src/Annotation/Get.php#[Attribute]class Get extends Route{ public function getMethods() { return [HttpMethod::GET-&amp;gt;name]; }}//file : src/Annotation/Head.php#[Attribute]class Head extends Route{ public function getMethods() { return [HttpMethod::HEAD-&amp;gt;name]; }}//file : src/Annotation/Options.php#[Attribute]class Options extends Route{ public function getMethods() { return [HttpMethod::OPTIONS-&amp;gt;name]; }}//file : src/Annotation/Patch.php#[Attribute]class Patch extends Route{ public function getMethods() { return [HttpMethod::PATCH-&amp;gt;name]; }}//file : src/Annotation/Post.php#[Attribute]class Post extends Route{ public function getMethods() { return [HttpMethod::POST-&amp;gt;name]; }}//file : src/Annotation/Put.php#[Attribute]class Put extends Route{ public function getMethods() { return [HttpMethod::PUT-&amp;gt;name]; }}//file : src/Annotation/Delete.php#[Attribute]class Delete extends Route{ public function getMethods() { return [HttpMethod::DELETE-&amp;gt;name]; }}Now you can polish the PostController, use these attributes instead. As you see, the naming of the new attributes literally look more clear.#[Route(path: &amp;quot;/posts&amp;quot;, name: &amp;quot;posts_&amp;quot;)]class PostController extends AbstractController{ // constructor... // #[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] #[Get(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;)] public function all(#[QueryParam] string $keyword, #[QueryParam] int $offset = 0, #[QueryParam] int $limit = 20): Response { //... } // #[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] #[Get(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;)] public function getById(Uuid $id): Response { //... } //#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;create&amp;quot;, methods: [&amp;quot;POST&amp;quot;])] #[Post(path: &amp;quot;&amp;quot;, name: &amp;quot;create&amp;quot;)] public function create(#[Body] CreatePostDto $data): Response { //... } //#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;update&amp;quot;, methods: [&amp;quot;PUT&amp;quot;])] #[Put(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;update&amp;quot;)] public function update(Uuid $id, #[Body] UpdatePostDto $data): Response { //... } // #[Route(path: &amp;quot;/{id}/status&amp;quot;, name: &amp;quot;update_status&amp;quot;, methods: [&amp;quot;PUT&amp;quot;])] #[Put(path: &amp;quot;/{id}/status&amp;quot;, name: &amp;quot;update_status&amp;quot;)] public function updateStatus(Uuid $id, #[Body] UpdatePostStatusDto $data): Response { //... } //#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;delete&amp;quot;, methods: [&amp;quot;DELETE&amp;quot;])] #[Delete(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;delete&amp;quot;)] public function deleteById(Uuid $id): Response { //... } // comments sub resources. //#[Route(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;commentByPostId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] #[GET(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;commentByPostId&amp;quot;)] public function getComments(Uuid $id): Response { //... } //#[Route(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;addComments&amp;quot;, methods: [&amp;quot;POST&amp;quot;])] #[Post(path: &amp;quot;/{id}/comments&amp;quot;, name: &amp;quot;addComments&amp;quot;)] public function addComment(Uuid $id, Request $request): Response { //... }}Run the application again to make sure it works.Get the source codes from my Github.BTW, I have updated my original Symfony posts into a step-by-step guide, read it online: https://hantsy.github.io/symfony-rest-sample/Using Enum in Symfony was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building Micronaut applications with Micronaut Mongo Reative</title><link href="/blog/2022/building-micronaut-applications-with-micronaut-mongo-reative/" rel="alternate" type="text/html" title="Building Micronaut applications with Micronaut Mongo Reative" /><published>2022-02-05T00:00:00+00:00</published><updated>2022-02-05T00:00:00+00:00</updated><id>/blog/2022/building-micronaut-applications-with-micronaut-mongo-reative</id><content type="html" xml:base="/blog/2022/building-micronaut-applications-with-micronaut-mongo-reative/">&lt;p&gt;In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;Photo by &amp;lt;a href=”https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&amp;quot;&amp;gt;Fabian Mardi&amp;lt;/a&amp;gt; on &amp;lt;a href=”https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&amp;quot;&amp;gt;Unsplash&amp;lt;/a&amp;gt;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*HcHUQFoIAU88lHg24zJINA.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Fabian Mardi&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Getting Started&lt;/h3&gt;&lt;p&gt;Open your browser and navigate to &lt;a href=&quot;https://micronaut.io/launch&quot;&gt;Micronaut Launch&lt;/a&gt; to generate a new project skeleton for this post. Select the following items on this page.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java version: &lt;strong&gt;17&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Language: &lt;strong&gt;Java&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Build tool: &lt;strong&gt;Gradle&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Test framework: &lt;strong&gt;Spock&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Included Features: &lt;strong&gt;mongo-reactive&lt;/strong&gt; etc.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Click &lt;strong&gt;GENERATE PROJECT&lt;/strong&gt; button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.&lt;/p&gt;&lt;p&gt;In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests.&lt;/p&gt;&lt;p&gt;Create a Mongo document entity class.&lt;/p&gt;&lt;pre&gt;@Data&lt;br&gt;@Builder&lt;br&gt;@NoArgsConstructor&lt;br&gt;@AllArgsConstructor(staticName = &amp;quot;of&amp;quot;)&lt;br&gt;public class Customer {&lt;br&gt;    private ObjectId id;&lt;br&gt;    private String name;&lt;br&gt;    private int age;&lt;br&gt;    private Address address;&lt;/pre&gt;&lt;pre&gt;    public static Customer of(String name, int age, Address address) {&lt;br&gt;        return Customer.of(null, name, age, address);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The Address is an embedded Document in a Customer Document.&lt;/p&gt;&lt;pre&gt;@Data&lt;br&gt;@Builder&lt;br&gt;@NoArgsConstructor&lt;br&gt;@AllArgsConstructor(staticName = &amp;quot;of&amp;quot;)&lt;br&gt;public class Address {&lt;br&gt;    private String street;&lt;br&gt;    private String city;&lt;br&gt;    private String zip;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Create a Repository class to perform CRUD operations on Customer.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;@Slf4j&lt;br&gt;public class CustomerRepository {&lt;br&gt;    private final MongoClient mongoClient;&lt;br&gt;    private final DefaultMongoConfiguration mongoConfiguration;&lt;/pre&gt;&lt;pre&gt;    public Flux&amp;lt;Customer&amp;gt; findAll() {&lt;br&gt;        return Flux.from(customersCollection().find());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;Customer&amp;gt; findById(ObjectId id) {&lt;br&gt;        return Mono.from(customersCollection().find(Filters.eq(id)));&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;ObjectId&amp;gt; insertOne(Customer data) {&lt;br&gt;        return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false)))&lt;br&gt;                .mapNotNull(result -&amp;gt; result.getInsertedId().asObjectId().getValue());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;Map&amp;lt;Integer, BsonValue&amp;gt;&amp;gt; insertMany(List&amp;lt;Customer&amp;gt; data) {&lt;br&gt;        return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true)))&lt;br&gt;                .map(InsertManyResult::getInsertedIds);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;Long&amp;gt; deleteById(ObjectId id) {&lt;br&gt;        return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions()))&lt;br&gt;                .map(DeleteResult::getDeletedCount);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public void init() {&lt;br&gt;        var people = List.of(&lt;br&gt;                Customer.of(&amp;quot;Charles Babbage&amp;quot;, 45, Address.of(&amp;quot;5 Devonshire Street&amp;quot;, &amp;quot;London&amp;quot;, &amp;quot;W11&amp;quot;)),&lt;br&gt;                Customer.of(&amp;quot;Alan Turing&amp;quot;, 28, Address.of(&amp;quot;Bletchley Hall&amp;quot;, &amp;quot;Bletchley Park&amp;quot;, &amp;quot;MK12&amp;quot;)),&lt;br&gt;                Customer.of(&amp;quot;Timothy Berners-Lee&amp;quot;, 61, Address.of(&amp;quot;Colehill&amp;quot;, &amp;quot;Wimborne&amp;quot;, null))&lt;br&gt;        );&lt;br&gt;        Mono.from(customersCollection().drop())&lt;br&gt;                .then()&lt;br&gt;                .thenMany(this.insertMany(people))&lt;br&gt;                .subscribe(&lt;br&gt;                        result -&amp;gt; result.forEach((key, value) -&amp;gt; log.debug(&amp;quot;saved key: {}, value: {}&amp;quot;, key, value)),&lt;br&gt;                        error -&amp;gt; log.debug(&amp;quot;initialization failed: {}&amp;quot;, error),&lt;br&gt;                        () -&amp;gt; log.debug(&amp;quot;done&amp;quot;)&lt;br&gt;                );&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;Long&amp;gt; deleteAll() {&lt;br&gt;        return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions()))&lt;br&gt;                .map(DeleteResult::getDeletedCount);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private MongoCollection&amp;lt;Customer&amp;gt; customersCollection() {&lt;br&gt;        return mongoClient&lt;br&gt;                .getDatabase(&amp;quot;userdb&amp;quot;)&lt;br&gt;                .getCollection(&amp;quot;customers&amp;quot;, Customer.class);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;When a mongo.uri is set in the &lt;em&gt;application.yml&lt;/em&gt;, there is a &lt;strong&gt;reactive&lt;/strong&gt; MongoClient bean is available.&lt;/p&gt;&lt;p&gt;In the above codes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the &lt;em&gt;customers&lt;/em&gt; document _id in MongoDB automatically.&lt;/li&gt;&lt;li&gt;The MongoClient provides methods for CRUD operations, but it is based on the &lt;em&gt;Reactive Streams&lt;/em&gt; APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Now let’s create a test to test the CustomerRepository.&lt;/p&gt;&lt;pre&gt;@MicronautTest(startApplication = false)&lt;br&gt;@Slf4j&lt;br&gt;class CustomerRepositorySpec extends Specification {&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    EmbeddedApplication&amp;lt;?&amp;gt; application&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    CustomerRepository customerRepository;&lt;/pre&gt;&lt;pre&gt;    def setup() {&lt;br&gt;        CountDownLatch latch = new CountDownLatch(1)&lt;br&gt;        customerRepository.deleteAll()&lt;br&gt;                .doOnTerminate(_ -&amp;gt; latch.countDown())&lt;br&gt;                .subscribe(it -&amp;gt; log.debug &amp;quot;deleted customers: {}&amp;quot;, it)&lt;br&gt;        latch.await(1000, TimeUnit.MILLISECONDS)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;application is not running&amp;#39;() {&lt;br&gt;        expect:&lt;br&gt;        !application.running&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;test findAll&amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        this.customerRepository.insertMany(List.of(Customer.of(&amp;quot;Jack&amp;quot;, 40, null)))&lt;br&gt;                .block(Duration.ofMillis(5000L))&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        def result = this.customerRepository.findAll()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        StepVerifier.create(result)&lt;br&gt;                .expectNextMatches(it -&amp;gt; it.name == &amp;quot;Jack&amp;quot;)&lt;br&gt;                .expectComplete()&lt;br&gt;                .verify()&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation.&lt;/p&gt;&lt;p&gt;Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten.&lt;/p&gt;&lt;p&gt;In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams.&lt;/p&gt;&lt;p&gt;If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification.&lt;/p&gt;&lt;pre&gt;@Shared&lt;br&gt;@AutoCleanup&lt;br&gt;GenericContainer mongo = new GenericContainer(&amp;quot;mongo&amp;quot;)&lt;br&gt;    .withExposedPorts(27017)&lt;/pre&gt;&lt;pre&gt;def setupSpec() {        &lt;br&gt;    mongo.start()&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;@Requires(notEnv = &amp;quot;mock&amp;quot;)&lt;br&gt;@Slf4j&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;public class DataInitializer {&lt;br&gt;    private final CustomerRepository customerRepository;&lt;/pre&gt;&lt;pre&gt;    @EventListener&lt;br&gt;    public void onStart(ServerStartupEvent event) {&lt;br&gt;        log.debug(&amp;quot;starting data initialization...&amp;quot;);&lt;br&gt;        this.customerRepository.init();&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Try to create a controller to expose the RESTful APIs.&lt;/p&gt;&lt;pre&gt;@Controller(&amp;quot;/customers&amp;quot;)&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;@Slf4j&lt;br&gt;public class CustomerController {&lt;br&gt;    private final CustomerRepository customerRepository;&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/&amp;quot;, produces = {MediaType.APPLICATION_JSON})&lt;br&gt;    public Flux&amp;lt;?&amp;gt; all() {&lt;br&gt;        return this.customerRepository.findAll();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/{id}&amp;quot;, produces = {MediaType.APPLICATION_JSON})&lt;br&gt;    public Mono&amp;lt;MutableHttpResponse&amp;lt;Customer&amp;gt;&amp;gt; byId(@PathVariable ObjectId id) {&lt;br&gt;        return this.customerRepository.findById(id)&lt;br&gt;                .map(HttpResponse::ok)&lt;br&gt;                .switchIfEmpty(Mono.just(notFound()));&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Post(uri = &amp;quot;/&amp;quot;, consumes = {MediaType.APPLICATION_JSON})&lt;br&gt;    public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; create(@Body Customer data) {&lt;br&gt;        return this.customerRepository.insertOne(data)&lt;br&gt;                .map(id -&amp;gt; created(URI.create(&amp;quot;/customers/&amp;quot; + id.toHexString())));&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Delete(uri = &amp;quot;/{id}&amp;quot;)&lt;br&gt;    public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; delete(@PathVariable ObjectId id) {&lt;br&gt;        return this.customerRepository.deleteById(id)&lt;br&gt;                .map(deleted -&amp;gt; {&lt;br&gt;                    if (deleted &amp;gt; 0) {&lt;br&gt;                        return noContent();&lt;br&gt;                    } else {&lt;br&gt;                        return notFound();&lt;br&gt;                    }&lt;br&gt;                });&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;public class StringToObjectIdConverter implements TypeConverter&amp;lt;String, ObjectId&amp;gt; {&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public Optional&amp;lt;ObjectId&amp;gt; convert(String object, Class&amp;lt;ObjectId&amp;gt; targetType, ConversionContext context) {&lt;br&gt;        return Optional.of(new ObjectId(object));&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;public class ObjectIdJsonSerializer extends JsonSerializer&amp;lt;ObjectId&amp;gt; {&lt;br&gt;    &lt;br&gt;    @Override&lt;br&gt;    public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException {&lt;br&gt;        gen.writeString(value.toHexString());&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Create a test for the CustomerController.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = [&amp;quot;mock&amp;quot;])&lt;br&gt;class CustomerControllerSpec extends Specification {&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    EmbeddedApplication&amp;lt;?&amp;gt; application&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    @Client(&amp;quot;/&amp;quot;)&lt;br&gt;    ReactorHttpClient client&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    CustomerRepository customerRepository&lt;/pre&gt;&lt;pre&gt;    def &amp;#39;test it works&amp;#39;() {&lt;br&gt;        expect:&lt;br&gt;        application.running&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;get all customers&amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        1 * customerRepository.findAll() &amp;gt;&amp;gt; Flux.just(Customer.of(ObjectId.get(), &amp;quot;Jack&amp;quot;, 40, null), Customer.of(ObjectId.get(), &amp;quot;Rose&amp;quot;, 20, null))&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.GET(&amp;quot;/customers&amp;quot;), String).log()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        //1 * customers.findAll() &amp;gt;&amp;gt; Flux.just(Customer.of(ObjectId.get(), &amp;quot;Jack&amp;quot;, 40, null), Customer.of(ObjectId.get(), &amp;quot;Rose&amp;quot;, 20, null))&lt;br&gt;        StepVerifier.create(resFlux)&lt;br&gt;        //.expectNextCount(1)&lt;br&gt;                .consumeNextWith(s -&amp;gt; {&lt;br&gt;                    assert s.getStatus() == HttpStatus.OK&lt;br&gt;                    assert s.body().contains(&amp;#39;Jack&amp;#39;)&lt;br&gt;                })&lt;br&gt;                .expectComplete()&lt;br&gt;                .verify()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;create a new customer&amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        def objId = ObjectId.get()&lt;br&gt;        1 * customerRepository.insertOne(_) &amp;gt;&amp;gt; Mono.just(objId)&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        def body = Customer.of(null, &amp;quot;Jack&amp;quot;, 40, null)&lt;br&gt;        Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.POST(&amp;quot;/customers&amp;quot;, body), String).log()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        StepVerifier.create(resFlux)&lt;br&gt;                .consumeNextWith(s -&amp;gt; {&lt;br&gt;                    assert s.getStatus() == HttpStatus.CREATED&lt;br&gt;                    assert s.header(&amp;quot;Location&amp;quot;) == &amp;#39;/customers/&amp;#39; + objId.toHexString()&lt;br&gt;                })&lt;br&gt;                .expectComplete()&lt;br&gt;                .verify()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;get customer by id &amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        1 * customerRepository.findById(_) &amp;gt;&amp;gt; Mono.just(Customer.of(ObjectId.get(), &amp;quot;Jack&amp;quot;, 40, null))&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.GET(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        StepVerifier.create(resFlux)&lt;br&gt;                .consumeNextWith(s -&amp;gt; {&lt;br&gt;                    assert s.getStatus() == HttpStatus.OK&lt;br&gt;                    assert s.body().contains(&amp;#39;Jack&amp;#39;)&lt;br&gt;                })&lt;br&gt;                .expectComplete()&lt;br&gt;                .verify()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;get customer by none-existing id &amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        1 * customerRepository.findById(_) &amp;gt;&amp;gt; Mono.empty()&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.GET(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        StepVerifier.create(resFlux)&lt;br&gt;                .consumeErrorWith(error -&amp;gt; {&lt;br&gt;                    assert error instanceof HttpClientResponseException&lt;br&gt;                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND&lt;br&gt;                })&lt;br&gt;                .verify()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;delete customer by id &amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        1 * customerRepository.deleteById(_) &amp;gt;&amp;gt; Mono.just(1L)&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.DELETE(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        StepVerifier.create(resFlux)&lt;br&gt;                .consumeNextWith(s -&amp;gt; {&lt;br&gt;                    assert s.getStatus() == HttpStatus.NO_CONTENT&lt;br&gt;                })&lt;br&gt;                .expectComplete()&lt;br&gt;                .verify()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    void &amp;#39;delete customer by none-existing id &amp;#39;() {&lt;br&gt;        given:&lt;br&gt;        1 * customerRepository.deleteById(_) &amp;gt;&amp;gt; Mono.just(0L)&lt;/pre&gt;&lt;pre&gt;        when:&lt;br&gt;        Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.DELETE(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log()&lt;/pre&gt;&lt;pre&gt;        then:&lt;br&gt;        StepVerifier.create(resFlux)&lt;br&gt;                .consumeErrorWith(error -&amp;gt; {&lt;br&gt;                    assert error instanceof HttpClientResponseException&lt;br&gt;                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND&lt;br&gt;                })&lt;br&gt;                .verify()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @MockBean(CustomerRepository)&lt;br&gt;    CustomerRepository mockedCustomerRepository() {// must use explicit type declaration&lt;br&gt;        Mock(CustomerRepository)&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place.&lt;/p&gt;&lt;p&gt;Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service.&lt;/p&gt;&lt;p&gt;Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage.&lt;/p&gt;&lt;p&gt;Firstly declare a GridFSBucket bean.&lt;/p&gt;&lt;pre&gt;@Factory&lt;br&gt;public class GridFSConfig {&lt;/pre&gt;&lt;pre&gt;    @Bean&lt;br&gt;    GridFSBucket gridFSBucket(MongoClient client) {&lt;br&gt;        return GridFSBuckets.create(client.getDatabase(&amp;quot;photos&amp;quot;))&lt;br&gt;                .withChunkSizeBytes(4096)&lt;br&gt;                //.withReadConcern(ReadConcern.MAJORITY)&lt;br&gt;                .withWriteConcern(WriteConcern.MAJORITY);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Now create a controller to handle the file upload and download.&lt;/p&gt;&lt;pre&gt;@Controller(&amp;quot;/photos&amp;quot;)&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;@Slf4j&lt;br&gt;public class PhotoController {&lt;/pre&gt;&lt;pre&gt;    private final GridFSBucket bucket;&lt;/pre&gt;&lt;pre&gt;    @Post(uri = &amp;quot;/&amp;quot;, consumes = {MediaType.MULTIPART_FORM_DATA})&lt;br&gt;    public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; upload(StreamingFileUpload file) {&lt;br&gt;        var filename = file.getFilename();&lt;br&gt;        var name = file.getName();&lt;br&gt;        var contentType = file.getContentType();&lt;br&gt;        var size = file.getSize();&lt;br&gt;        log.debug(&amp;quot;uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} &amp;quot;, filename, name, contentType, size);&lt;br&gt;        var options = new GridFSUploadOptions();&lt;br&gt;        contentType.ifPresent(c -&amp;gt; options.metadata(new Document(&amp;quot;contentType&amp;quot;, c)));&lt;br&gt;        return Mono.from(this.bucket.uploadFromPublisher(&lt;br&gt;                                filename,&lt;br&gt;                                Mono.from(file).mapNotNull(partData -&amp;gt; {&lt;br&gt;                                    try {&lt;br&gt;                                        return partData.getByteBuffer();&lt;br&gt;                                    } catch (IOException e) {&lt;br&gt;                                        e.printStackTrace();&lt;br&gt;                                    }&lt;br&gt;                                    return null;&lt;br&gt;                                }),&lt;br&gt;                                options&lt;br&gt;                        )&lt;br&gt;                )&lt;br&gt;                .map(ObjectId::toHexString)&lt;br&gt;                .map(id -&amp;gt; ok(Map.of(&amp;quot;id&amp;quot;, id)));&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/{id}&amp;quot;, produces = {MediaType.APPLICATION_OCTET_STREAM})&lt;br&gt;    public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; download(@PathVariable ObjectId id) {&lt;br&gt;        return Mono.from(this.bucket.downloadToPublisher(id))&lt;br&gt;                .map(HttpResponse::ok);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Delete(uri = &amp;quot;/{id}&amp;quot;)&lt;br&gt;    public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; delete(@PathVariable ObjectId id) {&lt;br&gt;        return Mono.from(this.bucket.delete(id))&lt;br&gt;                .map(v -&amp;gt; noContent());&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method.&lt;/p&gt;&lt;h4&gt;Get the complete &lt;a href=&quot;https://github.com/hantsy/micronaut-sandbox/tree/master/album-service&quot;&gt;source codes&lt;/a&gt; from my Github.&lt;/h4&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9c418b403bc1&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/building-micronaut-applications-with-micronaut-mongo-reative-9c418b403bc1&quot;&gt;Building Micronaut applications with Micronaut Mongo Reative&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties.Photo by Fabian Mardi on UnsplashGetting StartedOpen your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page.Java version: 17Language: JavaBuild tool: GradleTest framework: SpockIncluded Features: mongo-reactive etc.Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests.Create a Mongo document entity class.@Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &amp;quot;of&amp;quot;)public class Customer { private ObjectId id; private String name; private int age; private Address address; public static Customer of(String name, int age, Address address) { return Customer.of(null, name, age, address); }}The Address is an embedded Document in a Customer Document.@Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &amp;quot;of&amp;quot;)public class Address { private String street; private String city; private String zip;}Create a Repository class to perform CRUD operations on Customer.@Singleton@RequiredArgsConstructor@Slf4jpublic class CustomerRepository { private final MongoClient mongoClient; private final DefaultMongoConfiguration mongoConfiguration; public Flux&amp;lt;Customer&amp;gt; findAll() { return Flux.from(customersCollection().find()); } public Mono&amp;lt;Customer&amp;gt; findById(ObjectId id) { return Mono.from(customersCollection().find(Filters.eq(id))); } public Mono&amp;lt;ObjectId&amp;gt; insertOne(Customer data) { return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false))) .mapNotNull(result -&amp;gt; result.getInsertedId().asObjectId().getValue()); } public Mono&amp;lt;Map&amp;lt;Integer, BsonValue&amp;gt;&amp;gt; insertMany(List&amp;lt;Customer&amp;gt; data) { return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true))) .map(InsertManyResult::getInsertedIds); } public Mono&amp;lt;Long&amp;gt; deleteById(ObjectId id) { return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } public void init() { var people = List.of( Customer.of(&amp;quot;Charles Babbage&amp;quot;, 45, Address.of(&amp;quot;5 Devonshire Street&amp;quot;, &amp;quot;London&amp;quot;, &amp;quot;W11&amp;quot;)), Customer.of(&amp;quot;Alan Turing&amp;quot;, 28, Address.of(&amp;quot;Bletchley Hall&amp;quot;, &amp;quot;Bletchley Park&amp;quot;, &amp;quot;MK12&amp;quot;)), Customer.of(&amp;quot;Timothy Berners-Lee&amp;quot;, 61, Address.of(&amp;quot;Colehill&amp;quot;, &amp;quot;Wimborne&amp;quot;, null)) ); Mono.from(customersCollection().drop()) .then() .thenMany(this.insertMany(people)) .subscribe( result -&amp;gt; result.forEach((key, value) -&amp;gt; log.debug(&amp;quot;saved key: {}, value: {}&amp;quot;, key, value)), error -&amp;gt; log.debug(&amp;quot;initialization failed: {}&amp;quot;, error), () -&amp;gt; log.debug(&amp;quot;done&amp;quot;) ); } public Mono&amp;lt;Long&amp;gt; deleteAll() { return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } private MongoCollection&amp;lt;Customer&amp;gt; customersCollection() { return mongoClient .getDatabase(&amp;quot;userdb&amp;quot;) .getCollection(&amp;quot;customers&amp;quot;, Customer.class); }}When a mongo.uri is set in the application.yml, there is a reactive MongoClient bean is available.In the above codes:The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the customers document _id in MongoDB automatically.The MongoClient provides methods for CRUD operations, but it is based on the Reactive Streams APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs.Now let’s create a test to test the CustomerRepository.@MicronautTest(startApplication = false)@Slf4jclass CustomerRepositorySpec extends Specification { @Inject EmbeddedApplication&amp;lt;?&amp;gt; application @Inject CustomerRepository customerRepository; def setup() { CountDownLatch latch = new CountDownLatch(1) customerRepository.deleteAll() .doOnTerminate(_ -&amp;gt; latch.countDown()) .subscribe(it -&amp;gt; log.debug &amp;quot;deleted customers: {}&amp;quot;, it) latch.await(1000, TimeUnit.MILLISECONDS) } void &amp;#39;application is not running&amp;#39;() { expect: !application.running } void &amp;#39;test findAll&amp;#39;() { given: this.customerRepository.insertMany(List.of(Customer.of(&amp;quot;Jack&amp;quot;, 40, null))) .block(Duration.ofMillis(5000L)) when: def result = this.customerRepository.findAll() then: StepVerifier.create(result) .expectNextMatches(it -&amp;gt; it.name == &amp;quot;Jack&amp;quot;) .expectComplete() .verify() }}To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation.Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten.In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams.If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification.@Shared@AutoCleanupGenericContainer mongo = new GenericContainer(&amp;quot;mongo&amp;quot;) .withExposedPorts(27017)def setupSpec() { mongo.start()}Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose.@Singleton@Requires(notEnv = &amp;quot;mock&amp;quot;)@Slf4j@RequiredArgsConstructorpublic class DataInitializer { private final CustomerRepository customerRepository; @EventListener public void onStart(ServerStartupEvent event) { log.debug(&amp;quot;starting data initialization...&amp;quot;); this.customerRepository.init(); }}Try to create a controller to expose the RESTful APIs.@Controller(&amp;quot;/customers&amp;quot;)@RequiredArgsConstructor@Slf4jpublic class CustomerController { private final CustomerRepository customerRepository; @Get(uri = &amp;quot;/&amp;quot;, produces = {MediaType.APPLICATION_JSON}) public Flux&amp;lt;?&amp;gt; all() { return this.customerRepository.findAll(); } @Get(uri = &amp;quot;/{id}&amp;quot;, produces = {MediaType.APPLICATION_JSON}) public Mono&amp;lt;MutableHttpResponse&amp;lt;Customer&amp;gt;&amp;gt; byId(@PathVariable ObjectId id) { return this.customerRepository.findById(id) .map(HttpResponse::ok) .switchIfEmpty(Mono.just(notFound())); } @Post(uri = &amp;quot;/&amp;quot;, consumes = {MediaType.APPLICATION_JSON}) public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; create(@Body Customer data) { return this.customerRepository.insertOne(data) .map(id -&amp;gt; created(URI.create(&amp;quot;/customers/&amp;quot; + id.toHexString()))); } @Delete(uri = &amp;quot;/{id}&amp;quot;) public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; delete(@PathVariable ObjectId id) { return this.customerRepository.deleteById(id) .map(deleted -&amp;gt; { if (deleted &amp;gt; 0) { return noContent(); } else { return notFound(); } }); }}To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId.@Singletonpublic class StringToObjectIdConverter implements TypeConverter&amp;lt;String, ObjectId&amp;gt; { @Override public Optional&amp;lt;ObjectId&amp;gt; convert(String object, Class&amp;lt;ObjectId&amp;gt; targetType, ConversionContext context) { return Optional.of(new ObjectId(object)); }}In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object.@Singletonpublic class ObjectIdJsonSerializer extends JsonSerializer&amp;lt;ObjectId&amp;gt; { @Override public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeString(value.toHexString()); }}Create a test for the CustomerController.@MicronautTest(environments = [&amp;quot;mock&amp;quot;])class CustomerControllerSpec extends Specification { @Inject EmbeddedApplication&amp;lt;?&amp;gt; application @Inject @Client(&amp;quot;/&amp;quot;) ReactorHttpClient client @Inject CustomerRepository customerRepository def &amp;#39;test it works&amp;#39;() { expect: application.running } void &amp;#39;get all customers&amp;#39;() { given: 1 * customerRepository.findAll() &amp;gt;&amp;gt; Flux.just(Customer.of(ObjectId.get(), &amp;quot;Jack&amp;quot;, 40, null), Customer.of(ObjectId.get(), &amp;quot;Rose&amp;quot;, 20, null)) when: Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.GET(&amp;quot;/customers&amp;quot;), String).log() then: //1 * customers.findAll() &amp;gt;&amp;gt; Flux.just(Customer.of(ObjectId.get(), &amp;quot;Jack&amp;quot;, 40, null), Customer.of(ObjectId.get(), &amp;quot;Rose&amp;quot;, 20, null)) StepVerifier.create(resFlux) //.expectNextCount(1) .consumeNextWith(s -&amp;gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&amp;#39;Jack&amp;#39;) }) .expectComplete() .verify() } void &amp;#39;create a new customer&amp;#39;() { given: def objId = ObjectId.get() 1 * customerRepository.insertOne(_) &amp;gt;&amp;gt; Mono.just(objId) when: def body = Customer.of(null, &amp;quot;Jack&amp;quot;, 40, null) Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.POST(&amp;quot;/customers&amp;quot;, body), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&amp;gt; { assert s.getStatus() == HttpStatus.CREATED assert s.header(&amp;quot;Location&amp;quot;) == &amp;#39;/customers/&amp;#39; + objId.toHexString() }) .expectComplete() .verify() } void &amp;#39;get customer by id &amp;#39;() { given: 1 * customerRepository.findById(_) &amp;gt;&amp;gt; Mono.just(Customer.of(ObjectId.get(), &amp;quot;Jack&amp;quot;, 40, null)) when: Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.GET(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&amp;gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&amp;#39;Jack&amp;#39;) }) .expectComplete() .verify() } void &amp;#39;get customer by none-existing id &amp;#39;() { given: 1 * customerRepository.findById(_) &amp;gt;&amp;gt; Mono.empty() when: Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.GET(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&amp;gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } void &amp;#39;delete customer by id &amp;#39;() { given: 1 * customerRepository.deleteById(_) &amp;gt;&amp;gt; Mono.just(1L) when: Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.DELETE(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&amp;gt; { assert s.getStatus() == HttpStatus.NO_CONTENT }) .expectComplete() .verify() } void &amp;#39;delete customer by none-existing id &amp;#39;() { given: 1 * customerRepository.deleteById(_) &amp;gt;&amp;gt; Mono.just(0L) when: Flux&amp;lt;HttpResponse&amp;lt;String&amp;gt;&amp;gt; resFlux = client.exchange(HttpRequest.DELETE(&amp;quot;/customers/&amp;quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&amp;gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } @MockBean(CustomerRepository) CustomerRepository mockedCustomerRepository() {// must use explicit type declaration Mock(CustomerRepository) }}In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place.Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service.Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage.Firstly declare a GridFSBucket bean.@Factorypublic class GridFSConfig { @Bean GridFSBucket gridFSBucket(MongoClient client) { return GridFSBuckets.create(client.getDatabase(&amp;quot;photos&amp;quot;)) .withChunkSizeBytes(4096) //.withReadConcern(ReadConcern.MAJORITY) .withWriteConcern(WriteConcern.MAJORITY); }}Now create a controller to handle the file upload and download.@Controller(&amp;quot;/photos&amp;quot;)@RequiredArgsConstructor@Slf4jpublic class PhotoController { private final GridFSBucket bucket; @Post(uri = &amp;quot;/&amp;quot;, consumes = {MediaType.MULTIPART_FORM_DATA}) public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; upload(StreamingFileUpload file) { var filename = file.getFilename(); var name = file.getName(); var contentType = file.getContentType(); var size = file.getSize(); log.debug(&amp;quot;uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} &amp;quot;, filename, name, contentType, size); var options = new GridFSUploadOptions(); contentType.ifPresent(c -&amp;gt; options.metadata(new Document(&amp;quot;contentType&amp;quot;, c))); return Mono.from(this.bucket.uploadFromPublisher( filename, Mono.from(file).mapNotNull(partData -&amp;gt; { try { return partData.getByteBuffer(); } catch (IOException e) { e.printStackTrace(); } return null; }), options ) ) .map(ObjectId::toHexString) .map(id -&amp;gt; ok(Map.of(&amp;quot;id&amp;quot;, id))); } @Get(uri = &amp;quot;/{id}&amp;quot;, produces = {MediaType.APPLICATION_OCTET_STREAM}) public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; download(@PathVariable ObjectId id) { return Mono.from(this.bucket.downloadToPublisher(id)) .map(HttpResponse::ok); } @Delete(uri = &amp;quot;/{id}&amp;quot;) public Mono&amp;lt;HttpResponse&amp;lt;?&amp;gt;&amp;gt; delete(@PathVariable ObjectId id) { return Mono.from(this.bucket.delete(id)) .map(v -&amp;gt; noContent()); }}To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method.Get the complete source codes from my Github.Building Micronaut applications with Micronaut Mongo Reative was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines</title><link href="/blog/2021/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines/" rel="alternate" type="text/html" title="Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines" /><published>2021-12-08T00:00:00+00:00</published><updated>2021-12-08T00:00:00+00:00</updated><id>/blog/2021/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines</id><content type="html" xml:base="/blog/2021/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines/">&lt;p&gt;In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*qU5tVqVsr_jHM71udRktIw.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@ling_gigi?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Gigi&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model.&lt;/p&gt;&lt;h3&gt;Getting Started&lt;/h3&gt;&lt;p&gt;Open your browser and navigate to &lt;a href=&quot;https://micronaut.io/launch&quot;&gt;Micronaut Launch&lt;/a&gt; to generate a new project skeleton for this post. Select the following items on this page.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java version: &lt;strong&gt;17&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Language: &lt;strong&gt;Kotlin&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Build tool: &lt;strong&gt;Gradle Kotlin&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Test framework: &lt;strong&gt;Kotest&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Included Features: &lt;strong&gt;data-r2dbc&lt;/strong&gt;, &lt;strong&gt;postgres&lt;/strong&gt;, &lt;strong&gt;kotlin-extension-functions&lt;/strong&gt; etc.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Click &lt;strong&gt;GENERATE PROJECT&lt;/strong&gt; button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.&lt;/p&gt;&lt;p&gt;Open &lt;em&gt;pom.xml&lt;/em&gt; file, add Kotlin Coroutines into the project dependencies.&lt;/p&gt;&lt;pre&gt;//kotlin coroutines&lt;br&gt;implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&amp;quot;)&lt;br&gt;implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&amp;quot;)&lt;/pre&gt;&lt;p&gt;The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API.&lt;/p&gt;&lt;p&gt;Create an Entity mapped to a table in the database.&lt;/p&gt;&lt;pre&gt;@MappedEntity(value = &amp;quot;posts&amp;quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)&lt;br&gt;data class Post(&lt;br&gt;    @AutoPopulated//generated value UUID does not work here.&lt;br&gt;    @field:Id var id: UUID? = null,&lt;br&gt;    var title: String,&lt;br&gt;    var content: String,&lt;br&gt;    var status: Status? = Status.DRAFT,&lt;br&gt;    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()&lt;br&gt;)&lt;/pre&gt;&lt;p&gt;Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database.&lt;/p&gt;&lt;p&gt;Create a Repository interface for Post entity.&lt;/p&gt;&lt;pre&gt;@R2dbcRepository(dialect = Dialect.POSTGRES)&lt;br&gt;interface PostRepository : CoroutineCrudRepository&amp;lt;Post, UUID&amp;gt;, CoroutineJpaSpecificationExecutor&amp;lt;Post&amp;gt;&lt;/pre&gt;&lt;p&gt;Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a &lt;em&gt;suspend&lt;/em&gt; result in the functions.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;The &lt;/em&gt;&lt;em&gt;@R2dbcRepository requires a &lt;/em&gt;&lt;em&gt;dialect here, else it will fail at the application startup.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post.&lt;/p&gt;&lt;p&gt;Let’s move to the Controller, create a new controller class named PostController.&lt;/p&gt;&lt;pre&gt;@Controller(&amp;quot;/posts&amp;quot;)&lt;br&gt;class PostController(private val posts: PostRepository) {&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/&amp;quot;, produces = [MediaType.APPLICATION_JSON])&lt;br&gt;    fun all(): HttpResponse&amp;lt;Flow&amp;lt;Post&amp;gt;&amp;gt; = ok(posts.findAll())&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/{id}&amp;quot;, produces = [MediaType.APPLICATION_JSON])&lt;br&gt;    suspend fun byId(@PathVariable id: UUID): HttpResponse&amp;lt;Any&amp;gt; {&lt;br&gt;        val post = posts.findById(id) ?: return notFound()&lt;br&gt;        return ok(post)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])&lt;br&gt;    suspend fun create(@Body body: Post): HttpResponse&amp;lt;Any&amp;gt; {&lt;br&gt;        val saved = posts.save(body)&lt;br&gt;        return created(URI.create(&amp;quot;/posts/&amp;quot; + saved.id))&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context.&lt;/p&gt;&lt;p&gt;Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;class DataInitializer(private val posts: PostRepository) {&lt;/pre&gt;&lt;pre&gt;    @EventListener//does not support `suspend`&lt;br&gt;    fun onStartUp(e: ServerStartupEvent) {&lt;br&gt;        log.info(&amp;quot;starting data initialization at StartUpEvent: $e&amp;quot;)&lt;/pre&gt;&lt;pre&gt;        runBlocking {&lt;br&gt;            val deleteAll = posts.deleteAll()&lt;br&gt;            log.info(&amp;quot;deleted posts: $deleteAll&amp;quot;)&lt;/pre&gt;&lt;pre&gt;            val data = listOf(&lt;br&gt;                Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin Coroutine&amp;quot;, content = &amp;quot;test&amp;quot;),&lt;br&gt;                Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&amp;quot;, content = &amp;quot;test&amp;quot;)&lt;br&gt;            )&lt;br&gt;            data.forEach { log.debug(&amp;quot;saving: $it&amp;quot;) }&lt;br&gt;            posts.saveAll(data)&lt;br&gt;                .onEach { log.debug(&amp;quot;saved post: $it&amp;quot;) }&lt;br&gt;                .onCompletion { log.debug(&amp;quot;completed.&amp;quot;) }&lt;br&gt;                .flowOn(Dispatchers.IO)&lt;br&gt;                .launchIn(this);&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        log.info(&amp;quot;data initialization is done...&amp;quot;)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    companion object DataInitializer {&lt;br&gt;        private val log = LoggerFactory.getLogger(DataInitializer::class.java)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the &lt;em&gt;suspend&lt;/em&gt; functions in sequence.&lt;/p&gt;&lt;h3&gt;JPA Criteria API&lt;/h3&gt;&lt;p&gt;Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines.&lt;/p&gt;&lt;p&gt;Add jakarta-persistence-api into dependencies to provide JPA Criteria API.&lt;/p&gt;&lt;pre&gt;implementation(&amp;quot;jakarta.persistence:jakarta.persistence-api:3.0.0&amp;quot;)&lt;/pre&gt;&lt;p&gt;Let’s reuse Specifications we have created in the last post.&lt;/p&gt;&lt;p&gt;Create a test to verify the criteria defined in the Specifications.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = [Environment.TEST], startApplication = false)&lt;br&gt;class PostRepositoryTest(&lt;br&gt;    private val posts: PostRepository,&lt;br&gt;    private val template: R2dbcOperations&lt;br&gt;) : StringSpec({&lt;/pre&gt;&lt;pre&gt;    &amp;quot;save and find posts&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;;&lt;br&gt;        Mono&lt;br&gt;            .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt;&lt;br&gt;                Mono.from(&lt;br&gt;                    status.connection.createStatement(sql)&lt;br&gt;                        .bind(0, &amp;quot;test title&amp;quot;)&lt;br&gt;                        .bind(1, &amp;quot;test content&amp;quot;)&lt;br&gt;                        .bind(2, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;                        .execute()&lt;br&gt;                ).flatMap { Mono.from(it.rowsUpdated) }&lt;br&gt;            })&lt;br&gt;            .log()&lt;br&gt;            .`as` { StepVerifier.create(it) }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .verifyComplete()&lt;/pre&gt;&lt;pre&gt;        runBlocking {&lt;br&gt;            val all = posts.findAll().toList()&lt;br&gt;            all shouldHaveSize 1&lt;br&gt;            log.debug(&amp;quot;all posts: $all&amp;quot;)&lt;br&gt;            all.map { it.title }.forAny { it shouldContain &amp;quot;test&amp;quot; }&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;find by title&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;;&lt;br&gt;        Mono&lt;br&gt;            .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt;&lt;br&gt;                Mono.from(&lt;br&gt;                    status.connection.createStatement(sql)&lt;br&gt;                        .bind(0, &amp;quot;test title&amp;quot;)&lt;br&gt;                        .bind(1, &amp;quot;test content&amp;quot;)&lt;br&gt;                        .bind(2, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;                        .execute()&lt;br&gt;                ).flatMap { Mono.from(it.rowsUpdated) }&lt;br&gt;            })&lt;br&gt;            .`as` { StepVerifier.create(it) }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .verifyComplete()&lt;/pre&gt;&lt;pre&gt;        runBlocking {&lt;br&gt;            val all = posts.findAll(Specifications.titleLike(&amp;quot;test&amp;quot;)).toList()&lt;br&gt;            log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size)&lt;br&gt;            all shouldHaveSize 1&lt;/pre&gt;&lt;pre&gt;            val all2 = posts.findAll(Specifications.titleLike(&amp;quot;test2&amp;quot;)).toList()&lt;br&gt;            log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size)&lt;br&gt;            all2 shouldHaveSize 0&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;find by keyword&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;;&lt;br&gt;        Flux&lt;br&gt;            .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt;&lt;br&gt;                val statement = status.connection.createStatement(sql)&lt;br&gt;                statement&lt;br&gt;                    .bind(0, &amp;quot;test title&amp;quot;)&lt;br&gt;                    .bind(1, &amp;quot;test content&amp;quot;)&lt;br&gt;                    .bind(2, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;                    .add()&lt;br&gt;                statement.bind(0, &amp;quot;test2 title&amp;quot;)&lt;br&gt;                    .bind(1, &amp;quot;test2 content&amp;quot;)&lt;br&gt;                    .bind(2, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;                    .add()&lt;/pre&gt;&lt;pre&gt;                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }&lt;br&gt;            })&lt;br&gt;            .`as` { StepVerifier.create(it) }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .verifyComplete()&lt;/pre&gt;&lt;pre&gt;        runBlocking {&lt;br&gt;            val all = posts.findAll(Specifications.byKeyword(&amp;quot;test&amp;quot;)).toList()&lt;br&gt;            log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size)&lt;br&gt;            all shouldHaveSize 2&lt;/pre&gt;&lt;pre&gt;            val all2 = posts.findAll(Specifications.byKeyword(&amp;quot;test2&amp;quot;)).toList()&lt;br&gt;            log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size)&lt;br&gt;            all2 shouldHaveSize 1&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;update posts&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;;&lt;br&gt;        Flux&lt;br&gt;            .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt;&lt;br&gt;                val statement = status.connection.createStatement(sql)&lt;br&gt;                statement&lt;br&gt;                    .bind(0, &amp;quot;test title&amp;quot;)&lt;br&gt;                    .bind(1, &amp;quot;test content&amp;quot;)&lt;br&gt;                    .bind(2, &amp;quot;PENDING_MODERATED&amp;quot;)&lt;br&gt;                    .add()&lt;/pre&gt;&lt;pre&gt;                statement&lt;br&gt;                    .bind(0, &amp;quot;test2 title&amp;quot;)&lt;br&gt;                    .bind(1, &amp;quot;test2 content&amp;quot;)&lt;br&gt;                    .bind(2, &amp;quot;PENDING_MODERATED&amp;quot;)&lt;br&gt;                    .add()&lt;/pre&gt;&lt;pre&gt;                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }&lt;br&gt;            })&lt;br&gt;            .`as` { StepVerifier.create(it) }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .verifyComplete()&lt;/pre&gt;&lt;pre&gt;        runBlocking {&lt;br&gt;            val updated = posts.updateAll(Specifications.rejectAllPendingModerated())&lt;br&gt;            log.debug(&amp;quot;updated posts size:{}&amp;quot;, updated)&lt;br&gt;            updated shouldBe 2&lt;/pre&gt;&lt;pre&gt;            val all = posts.findAll().toList()&lt;br&gt;            all shouldHaveSize 2&lt;br&gt;            all.map { it.status }.forAny { it shouldBe Status.REJECTED }&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;remove posts&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;;&lt;br&gt;        Flux&lt;br&gt;            .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt;&lt;br&gt;                val statement = status.connection.createStatement(sql)&lt;br&gt;                statement&lt;br&gt;                    .bind(0, &amp;quot;test title&amp;quot;)&lt;br&gt;                    .bind(1, &amp;quot;test content&amp;quot;)&lt;br&gt;                    .bind(2, &amp;quot;REJECTED&amp;quot;)&lt;br&gt;                    .add()&lt;br&gt;                statement&lt;br&gt;                    .bind(0, &amp;quot;test2 title&amp;quot;)&lt;br&gt;                    .bind(1, &amp;quot;test2 content&amp;quot;)&lt;br&gt;                    .bind(2, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;                    .add()&lt;/pre&gt;&lt;pre&gt;                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }&lt;br&gt;            })&lt;br&gt;            .`as` { StepVerifier.create(it) }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .consumeNextWith { it shouldBeEqualComparingTo 1 }&lt;br&gt;            .verifyComplete()&lt;/pre&gt;&lt;pre&gt;        runBlocking {&lt;br&gt;            val deleted = posts.deleteAll(Specifications.removeAllRejected())&lt;br&gt;            log.debug(&amp;quot;deleted posts size:{}&amp;quot;, deleted)&lt;br&gt;            deleted shouldBe 1&lt;/pre&gt;&lt;pre&gt;            val all = posts.findAll().toList()&lt;br&gt;            all shouldHaveSize 1&lt;br&gt;            all.map { it.status }.forAny { it shouldBe Status.DRAFT }&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}) {&lt;br&gt;    companion object {&lt;br&gt;        private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    override fun beforeEach(testCase: TestCase) {&lt;br&gt;        val sql = &amp;quot;delete from posts&amp;quot;;&lt;/pre&gt;&lt;pre&gt;        val latch = CountDownLatch(1)&lt;br&gt;        Mono&lt;br&gt;            .from(&lt;br&gt;                this.template.withConnection { conn: Connection -&amp;gt;&lt;br&gt;                    Mono.from(conn.beginTransaction())&lt;br&gt;                        .then(Mono.from(conn.createStatement(sql).execute())&lt;br&gt;                            .flatMap { Mono.from(it.rowsUpdated) }&lt;br&gt;                            .doOnNext { log.debug(&amp;quot;deleted rows: $it &amp;quot;) }&lt;br&gt;                        )&lt;br&gt;                        .then(Mono.from(conn.commitTransaction()))&lt;br&gt;                        .doOnError { Mono.from(conn.rollbackTransaction()).then() }&lt;br&gt;                }&lt;br&gt;            )&lt;br&gt;            .log()&lt;br&gt;            .doOnTerminate { latch.countDown() }&lt;br&gt;            .subscribe(&lt;br&gt;                { data -&amp;gt; log.debug(&amp;quot;deleted posts: $data &amp;quot;) },&lt;br&gt;                { error -&amp;gt; log.error(&amp;quot;error of cleaning posts: $error&amp;quot;) },&lt;br&gt;                { log.info(&amp;quot;done&amp;quot;) }&lt;br&gt;            )&lt;/pre&gt;&lt;pre&gt;        latch.await(5000, TimeUnit.MILLISECONDS)&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;We converted the existing Jdbc version to R2dbc, there are some mainly difference.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.&lt;/li&gt;&lt;li&gt;R2dbc Connection is based on ReactiveStreams API.&lt;/li&gt;&lt;li&gt;When binding parameters to the SQL statement, the parameter indices start with &lt;strong&gt;0&lt;/strong&gt;.&lt;/li&gt;&lt;li&gt;The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2...&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Testing Controller&lt;/h3&gt;&lt;p&gt;In this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context.&lt;/p&gt;&lt;p&gt;The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies.&lt;/p&gt;&lt;pre&gt;//gradle.properties&lt;br&gt;kotlinCoVersion=1.6.0-RC&lt;/pre&gt;&lt;pre&gt;//build.gradle.kt&lt;br&gt;val kotlinCoVersion=project.properties.get(&amp;quot;kotlinCoVersoin&amp;quot;)&lt;/pre&gt;&lt;pre&gt;//update versions of kotlin coroutines&lt;br&gt;implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&amp;quot;)&lt;br&gt;implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&amp;quot;)&lt;/pre&gt;&lt;pre&gt;testImplementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&amp;quot;)&lt;/pre&gt;&lt;blockquote&gt;&lt;em&gt;There is &lt;/em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/70243380/test-kotlin-coroutines-with-runblockingtest-failed&quot;&gt;&lt;em&gt;an issue&lt;/em&gt;&lt;/a&gt;&lt;em&gt; to use &lt;/em&gt;&lt;em&gt;runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use &lt;/em&gt;&lt;em&gt;runTest instead.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;Similar to the runBlocking, you can use runTest to wrap the testing functionality.&lt;/p&gt;&lt;pre&gt;@Test&lt;br&gt;fun `test GET all posts endpoint with runTest`() = runTest {&lt;br&gt;    val response = client.exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java).awaitSingle()&lt;br&gt;    response.status shouldBe HttpStatus.OK&lt;br&gt;    response.body()!!.map { it.title }.forAny {&lt;br&gt;        it shouldContain &amp;quot;Micronaut&amp;quot;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;blockquote&gt;&lt;em&gt;The &lt;/em&gt;&lt;em&gt;runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = [&amp;quot;mock&amp;quot;])&lt;br&gt;class PostControllerTest(&lt;br&gt;    private val postRepository: PostRepository,&lt;br&gt;    @Client(&amp;quot;/&amp;quot;) private var client: HttpClient&lt;br&gt;) : FunSpec({&lt;/pre&gt;&lt;pre&gt;    test(&amp;quot;test get posts endpoint&amp;quot;) {&lt;br&gt;        val posts = getMock(postRepository)&lt;br&gt;        coEvery { posts.findAll() }&lt;br&gt;            .returns(&lt;br&gt;                flowOf(&lt;br&gt;                    Post(&lt;br&gt;                        id = UUID.randomUUID(),&lt;br&gt;                        title = &amp;quot;test title&amp;quot;,&lt;br&gt;                        content = &amp;quot;test content&amp;quot;,&lt;br&gt;                        status = Status.DRAFT,&lt;br&gt;                        createdAt = LocalDateTime.now()&lt;br&gt;                    )&lt;br&gt;                )&lt;br&gt;            )&lt;br&gt;        val response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java)&lt;/pre&gt;&lt;pre&gt;        response.status shouldBe HttpStatus.OK&lt;br&gt;        response.body()!![0].title shouldBe &amp;quot;test title&amp;quot;&lt;/pre&gt;&lt;pre&gt;        coVerify(exactly = 1) { posts.findAll() }&lt;br&gt;    }&lt;br&gt;}) {&lt;br&gt;    @MockBean(PostRepository::class)&lt;br&gt;    fun mockedPostRepository() = mockk&amp;lt;PostRepository&amp;gt;()&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause.&lt;/p&gt;&lt;h4&gt;Get the complete &lt;a href=&quot;https://github.com/hantsy/micronaut-sandbox/tree/master/r2dbc-kotlin-co&quot;&gt;source codes&lt;/a&gt; from my Github.&lt;/h4&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a1416db5a7d0&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines-a1416db5a7d0&quot;&gt;Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines.Photo by Gigi on UnsplashIn contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model.Getting StartedOpen your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page.Java version: 17Language: KotlinBuild tool: Gradle KotlinTest framework: KotestIncluded Features: data-r2dbc, postgres, kotlin-extension-functions etc.Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.Open pom.xml file, add Kotlin Coroutines into the project dependencies.//kotlin coroutinesimplementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&amp;quot;)implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&amp;quot;)The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API.Create an Entity mapped to a table in the database.@MappedEntity(value = &amp;quot;posts&amp;quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @AutoPopulated//generated value UUID does not work here. @field:Id var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now())Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database.Create a Repository interface for Post entity.@R2dbcRepository(dialect = Dialect.POSTGRES)interface PostRepository : CoroutineCrudRepository&amp;lt;Post, UUID&amp;gt;, CoroutineJpaSpecificationExecutor&amp;lt;Post&amp;gt;Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a suspend result in the functions.The @R2dbcRepository requires a dialect here, else it will fail at the application startup.Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post.Let’s move to the Controller, create a new controller class named PostController.@Controller(&amp;quot;/posts&amp;quot;)class PostController(private val posts: PostRepository) { @Get(uri = &amp;quot;/&amp;quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&amp;lt;Flow&amp;lt;Post&amp;gt;&amp;gt; = ok(posts.findAll()) @Get(uri = &amp;quot;/{id}&amp;quot;, produces = [MediaType.APPLICATION_JSON]) suspend fun byId(@PathVariable id: UUID): HttpResponse&amp;lt;Any&amp;gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) suspend fun create(@Body body: Post): HttpResponse&amp;lt;Any&amp;gt; { val saved = posts.save(body) return created(URI.create(&amp;quot;/posts/&amp;quot; + saved.id)) }}It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context.Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent.@Singletonclass DataInitializer(private val posts: PostRepository) { @EventListener//does not support `suspend` fun onStartUp(e: ServerStartupEvent) { log.info(&amp;quot;starting data initialization at StartUpEvent: $e&amp;quot;) runBlocking { val deleteAll = posts.deleteAll() log.info(&amp;quot;deleted posts: $deleteAll&amp;quot;) val data = listOf( Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin Coroutine&amp;quot;, content = &amp;quot;test&amp;quot;), Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&amp;quot;, content = &amp;quot;test&amp;quot;) ) data.forEach { log.debug(&amp;quot;saving: $it&amp;quot;) } posts.saveAll(data) .onEach { log.debug(&amp;quot;saved post: $it&amp;quot;) } .onCompletion { log.debug(&amp;quot;completed.&amp;quot;) } .flowOn(Dispatchers.IO) .launchIn(this); } log.info(&amp;quot;data initialization is done...&amp;quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) }}The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the suspend functions in sequence.JPA Criteria APIMicronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines.Add jakarta-persistence-api into dependencies to provide JPA Criteria API.implementation(&amp;quot;jakarta.persistence:jakarta.persistence-api:3.0.0&amp;quot;)Let’s reuse Specifications we have created in the last post.Create a test to verify the criteria defined in the Specifications.@MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: R2dbcOperations) : StringSpec({ &amp;quot;save and find posts&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt; Mono.from( status.connection.createStatement(sql) .bind(0, &amp;quot;test title&amp;quot;) .bind(1, &amp;quot;test content&amp;quot;) .bind(2, &amp;quot;DRAFT&amp;quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .log() .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll().toList() all shouldHaveSize 1 log.debug(&amp;quot;all posts: $all&amp;quot;) all.map { it.title }.forAny { it shouldContain &amp;quot;test&amp;quot; } } } &amp;quot;find by title&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt; Mono.from( status.connection.createStatement(sql) .bind(0, &amp;quot;test title&amp;quot;) .bind(1, &amp;quot;test content&amp;quot;) .bind(2, &amp;quot;DRAFT&amp;quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.titleLike(&amp;quot;test&amp;quot;)).toList() log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&amp;quot;test2&amp;quot;)).toList() log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size) all2 shouldHaveSize 0 } } &amp;quot;find by keyword&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt; val statement = status.connection.createStatement(sql) statement .bind(0, &amp;quot;test title&amp;quot;) .bind(1, &amp;quot;test content&amp;quot;) .bind(2, &amp;quot;DRAFT&amp;quot;) .add() statement.bind(0, &amp;quot;test2 title&amp;quot;) .bind(1, &amp;quot;test2 content&amp;quot;) .bind(2, &amp;quot;DRAFT&amp;quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.byKeyword(&amp;quot;test&amp;quot;)).toList() log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&amp;quot;test2&amp;quot;)).toList() log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size) all2 shouldHaveSize 1 } } &amp;quot;update posts&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt; val statement = status.connection.createStatement(sql) statement .bind(0, &amp;quot;test title&amp;quot;) .bind(1, &amp;quot;test content&amp;quot;) .bind(2, &amp;quot;PENDING_MODERATED&amp;quot;) .add() statement .bind(0, &amp;quot;test2 title&amp;quot;) .bind(1, &amp;quot;test2 content&amp;quot;) .bind(2, &amp;quot;PENDING_MODERATED&amp;quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&amp;quot;updated posts size:{}&amp;quot;, updated) updated shouldBe 2 val all = posts.findAll().toList() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } } &amp;quot;remove posts&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values ($1, $2, $3)&amp;quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&amp;lt;Connection&amp;gt; -&amp;gt; val statement = status.connection.createStatement(sql) statement .bind(0, &amp;quot;test title&amp;quot;) .bind(1, &amp;quot;test content&amp;quot;) .bind(2, &amp;quot;REJECTED&amp;quot;) .add() statement .bind(0, &amp;quot;test2 title&amp;quot;) .bind(1, &amp;quot;test2 content&amp;quot;) .bind(2, &amp;quot;DRAFT&amp;quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&amp;quot;deleted posts size:{}&amp;quot;, deleted) deleted shouldBe 1 val all = posts.findAll().toList() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } }}) { companion object { private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java) } override fun beforeEach(testCase: TestCase) { val sql = &amp;quot;delete from posts&amp;quot;; val latch = CountDownLatch(1) Mono .from( this.template.withConnection { conn: Connection -&amp;gt; Mono.from(conn.beginTransaction()) .then(Mono.from(conn.createStatement(sql).execute()) .flatMap { Mono.from(it.rowsUpdated) } .doOnNext { log.debug(&amp;quot;deleted rows: $it &amp;quot;) } ) .then(Mono.from(conn.commitTransaction())) .doOnError { Mono.from(conn.rollbackTransaction()).then() } } ) .log() .doOnTerminate { latch.countDown() } .subscribe( { data -&amp;gt; log.debug(&amp;quot;deleted posts: $data &amp;quot;) }, { error -&amp;gt; log.error(&amp;quot;error of cleaning posts: $error&amp;quot;) }, { log.info(&amp;quot;done&amp;quot;) } ) latch.await(5000, TimeUnit.MILLISECONDS) }}We converted the existing Jdbc version to R2dbc, there are some mainly difference.Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.R2dbc Connection is based on ReactiveStreams API.When binding parameters to the SQL statement, the parameter indices start with 0.The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2...Testing ControllerIn this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context.The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies.//gradle.propertieskotlinCoVersion=1.6.0-RC//build.gradle.ktval kotlinCoVersion=project.properties.get(&amp;quot;kotlinCoVersoin&amp;quot;)//update versions of kotlin coroutinesimplementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&amp;quot;)implementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&amp;quot;)testImplementation(&amp;quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&amp;quot;)There is an issue to use runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use runTest instead.Similar to the runBlocking, you can use runTest to wrap the testing functionality.@Testfun `test GET all posts endpoint with runTest`() = runTest { val response = client.exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java).awaitSingle() response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &amp;quot;Micronaut&amp;quot; }}The runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines.We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc.@MicronautTest(environments = [&amp;quot;mock&amp;quot;])class PostControllerTest( private val postRepository: PostRepository, @Client(&amp;quot;/&amp;quot;) private var client: HttpClient) : FunSpec({ test(&amp;quot;test get posts endpoint&amp;quot;) { val posts = getMock(postRepository) coEvery { posts.findAll() } .returns( flowOf( Post( id = UUID.randomUUID(), title = &amp;quot;test title&amp;quot;, content = &amp;quot;test content&amp;quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &amp;quot;test title&amp;quot; coVerify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun mockedPostRepository() = mockk&amp;lt;PostRepository&amp;gt;()}Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause.Get the complete source codes from my Github.Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building Micronaut applications with Micronaut Data Jdbc and Kotlin</title><link href="/blog/2021/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin/" rel="alternate" type="text/html" title="Building Micronaut applications with Micronaut Data Jdbc and Kotlin" /><published>2021-12-02T00:00:00+00:00</published><updated>2021-12-02T00:00:00+00:00</updated><id>/blog/2021/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin</id><content type="html" xml:base="/blog/2021/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin/">&lt;p&gt;Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*vpMi-XOcWMHQnUiqVqNeOg.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@dongmingwei?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;mingwei dong&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Getting Started&lt;/h3&gt;&lt;p&gt;Open your browser and navigate to &lt;a href=&quot;https://micronaut.io/launch&quot;&gt;Micronaut Launch&lt;/a&gt; to generate a new project skeleton for this post. Select the following items on this page.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java version: &lt;strong&gt;17&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Language: &lt;strong&gt;Kotlin&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Build tool: &lt;strong&gt;Gradle&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Test framework: &lt;strong&gt;Kotest&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Included Features: &lt;strong&gt;data-jdbc&lt;/strong&gt;, &lt;strong&gt;postgres&lt;/strong&gt;, etc.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Click &lt;strong&gt;GENERATE PROJECT&lt;/strong&gt; button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.&lt;/p&gt;&lt;p&gt;Create an Entity class.&lt;/p&gt;&lt;pre&gt;@MappedEntity(value = &amp;quot;posts&amp;quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)&lt;br&gt;data class Post(&lt;br&gt;    @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null,&lt;br&gt;    var title: String,&lt;br&gt;    var content: String,&lt;br&gt;    var status: Status? = Status.DRAFT,&lt;br&gt;    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()&lt;br&gt;)&lt;/pre&gt;&lt;p&gt;Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted.&lt;/p&gt;&lt;p&gt;The status is an enum class.&lt;/p&gt;&lt;pre&gt;enum class Status {&lt;br&gt;    DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED&lt;br&gt;}&lt;/pre&gt;&lt;blockquote&gt;&lt;em&gt;Note: The &lt;/em&gt;&lt;em&gt;ID and &lt;/em&gt;&lt;em&gt;GeneratedValue is from &lt;/em&gt;&lt;em&gt;io.micronaut.data.annotation package.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;Create a Repository for Post Entity class.&lt;/p&gt;&lt;pre&gt;@JdbcRepository&lt;br&gt;interface PostRepository : PageableRepository&amp;lt;Post, UUID&amp;gt;&lt;/pre&gt;&lt;p&gt;Here we used a JdbcRepository to indicate this Repository is a &lt;strong&gt;data-jdbc&lt;/strong&gt; Repository.&lt;/p&gt;&lt;p&gt;Create a bean to initialize some sample data.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;@Requires(notEnv = [&amp;quot;mock&amp;quot;])&lt;br&gt;class DataInitializer(private val posts: PostRepository) {&lt;/pre&gt;&lt;pre&gt;    @EventListener&lt;br&gt;    fun onStartUp(e: ServerStartupEvent) {&lt;br&gt;        log.info(&amp;quot;starting data initialization at ServerStartupEvent: $e&amp;quot;)&lt;/pre&gt;&lt;pre&gt;        posts.deleteAll()&lt;/pre&gt;&lt;pre&gt;        val data = listOf(&lt;br&gt;            Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin&amp;quot;, content = &amp;quot;test&amp;quot;),&lt;br&gt;            Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin: part 2&amp;quot;, content = &amp;quot;test&amp;quot;)&lt;br&gt;        )&lt;br&gt;        data.forEach { log.debug(&amp;quot;saving: $it&amp;quot;) }&lt;br&gt;        posts.saveAll(data).forEach { log.debug(&amp;quot;saved post: $it&amp;quot;) }&lt;br&gt;        log.info(&amp;quot;data initialization is done...&amp;quot;)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    companion object DataInitializer {&lt;br&gt;        private val log = LoggerFactory.getLogger(DataInitializer::class.java)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Now create a controller to expose RESTful APIs.&lt;/p&gt;&lt;pre&gt;@Controller(&amp;quot;/posts&amp;quot;)&lt;br&gt;class PostController(private val posts: PostRepository) {&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/&amp;quot;, produces = [MediaType.APPLICATION_JSON])&lt;br&gt;    fun all(): HttpResponse&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; = ok(posts.findAll().toList())&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/{id}&amp;quot;, produces = [MediaType.APPLICATION_JSON])&lt;br&gt;    fun byId(@PathVariable id: UUID): HttpResponse&amp;lt;Any&amp;gt; {&lt;br&gt;        val post = posts.findById(id) ?: return notFound()&lt;br&gt;        return ok(post)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])&lt;br&gt;    fun create(@Body body: Post): HttpResponse&amp;lt;Any&amp;gt; {&lt;br&gt;        val saved = posts.save(body)&lt;br&gt;        return created(URI.create(&amp;quot;/posts/&amp;quot; + saved.id))&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the &lt;em&gt;application.yaml&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the &lt;em&gt;docker-compose.yaml&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;# docker compose up postgres&lt;/pre&gt;&lt;p&gt;Now run the application.&lt;/p&gt;&lt;pre&gt;# gradlew run &lt;br&gt;// or &lt;br&gt;# gradlew build&lt;br&gt;# java build/xxx.jar&lt;/pre&gt;&lt;p&gt;You can use curl command to test the &lt;em&gt;/posts&lt;/em&gt; endpoint.&lt;/p&gt;&lt;pre&gt;# curl &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt;&lt;/pre&gt;&lt;h3&gt;Query by Specification&lt;/h3&gt;&lt;p&gt;If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the &lt;strong&gt;data-jdbc&lt;/strong&gt; also supports query by JPA Specification.&lt;/p&gt;&lt;p&gt;Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies.&lt;/p&gt;&lt;p&gt;Change PostRepository, make it extends JpaSpecificationExecutor.&lt;/p&gt;&lt;pre&gt;@JdbcRepository&lt;br&gt;interface PostRepository : PageableRepository&amp;lt;Post, UUID&amp;gt;, JpaSpecificationExecutor&amp;lt;Post&amp;gt;&lt;/pre&gt;&lt;p&gt;Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification.&lt;/p&gt;&lt;pre&gt;object Specifications {&lt;/pre&gt;&lt;pre&gt;    fun titleLike(title: String): PredicateSpecification&amp;lt;Post&amp;gt; {&lt;br&gt;        return PredicateSpecification&amp;lt;Post&amp;gt; { root, criteriaBuilder -&amp;gt;&lt;br&gt;            criteriaBuilder.like(&lt;br&gt;                root.get(&amp;quot;title&amp;quot;),&lt;br&gt;                &amp;quot;%$title%&amp;quot;&lt;br&gt;            )&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    fun byKeyword(q: String): QuerySpecification&amp;lt;Post&amp;gt; {&lt;br&gt;        return QuerySpecification&amp;lt;Post&amp;gt; { root, query, criteriaBuilder -&amp;gt;&lt;br&gt;            criteriaBuilder.or(&lt;br&gt;                criteriaBuilder.like(root.get(&amp;quot;title&amp;quot;), &amp;quot;%$q%&amp;quot;),&lt;br&gt;                criteriaBuilder.like(root.get(&amp;quot;content&amp;quot;), &amp;quot;%$q%&amp;quot;)&lt;br&gt;            )&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    fun rejectAllPendingModerated(): UpdateSpecification&amp;lt;Post&amp;gt; {&lt;br&gt;        return UpdateSpecification&amp;lt;Post&amp;gt; {root, query, criteriaBuilder -&amp;gt;&lt;br&gt;            query.set(root.get(&amp;quot;status&amp;quot;), Status.REJECTED)&lt;br&gt;            criteriaBuilder.equal(root.get&amp;lt;Status&amp;gt;(&amp;quot;status&amp;quot;), Status.PENDING_MODERATED)&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    fun removeAllRejected(): DeleteSpecification&amp;lt;Post&amp;gt; {&lt;br&gt;        return DeleteSpecification&amp;lt;Post&amp;gt; {root, query, criteriaBuilder -&amp;gt;&lt;br&gt;            criteriaBuilder.equal(root.get&amp;lt;Status&amp;gt;(&amp;quot;status&amp;quot;), Status.REJECTED)&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Let’s create some tests to verify these Specifications.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = [Environment.TEST], startApplication = false)&lt;br&gt;open class PostRepositoryAnnotationSpec() : AnnotationSpec() {&lt;br&gt;    companion object {&lt;br&gt;        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    private lateinit var posts: PostRepository&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    private lateinit var template: JdbcOperations&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    private lateinit var tx: TransactionOperations&amp;lt;Any&amp;gt;&lt;/pre&gt;&lt;pre&gt;    @BeforeEach&lt;br&gt;    fun beforeEach() {&lt;br&gt;        val callback: TransactionCallback&amp;lt;Any, Int&amp;gt; = TransactionCallback { _: TransactionStatus&amp;lt;Any&amp;gt; -&amp;gt;&lt;br&gt;            val sql = &amp;quot;delete from posts&amp;quot;;&lt;br&gt;            this.template.prepareStatement(sql) {&lt;br&gt;                it.executeUpdate()&lt;br&gt;            }&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        val cnt = tx.executeWrite(callback)&lt;br&gt;        println(&amp;quot;deleted $cnt&amp;quot;);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    fun `test save and find posts`() {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.executeUpdate()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt shouldBeEqualComparingTo 1&lt;br&gt;        val all = posts.findAll()&lt;br&gt;        all shouldHaveSize 1&lt;br&gt;        log.debug(&amp;quot;all posts: $all&amp;quot;)&lt;br&gt;        all.map { it.title }.forAny { it shouldContain &amp;quot;test&amp;quot; }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    fun `find by title`() {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.executeUpdate()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt shouldBeEqualComparingTo 1&lt;br&gt;        val all = posts.findAll(Specifications.titleLike(&amp;quot;test&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size)&lt;br&gt;        all shouldHaveSize 1&lt;/pre&gt;&lt;pre&gt;        val all2 = posts.findAll(Specifications.titleLike(&amp;quot;test2&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size)&lt;br&gt;        all2 shouldHaveSize 0&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    fun `find by keyword`() {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.setString(1, &amp;quot;test2 title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test2 content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.executeBatch()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt.any { it == 1 }&lt;br&gt;        val all = posts.findAll(Specifications.byKeyword(&amp;quot;test&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size)&lt;br&gt;        all shouldHaveSize 2&lt;/pre&gt;&lt;pre&gt;        val all2 = posts.findAll(Specifications.byKeyword(&amp;quot;test2&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size)&lt;br&gt;        all2 shouldHaveSize 1&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    fun `update posts`() {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.setString(1, &amp;quot;test2 title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test2 content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.executeBatch()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt.any { it == 1 }&lt;br&gt;        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())&lt;br&gt;        log.debug(&amp;quot;updated posts size:{}&amp;quot;, updated)&lt;br&gt;        updated shouldBe 2&lt;/pre&gt;&lt;pre&gt;        val all = posts.findAll()&lt;br&gt;        all shouldHaveSize 2&lt;br&gt;        all.map { it.status }.forAny { it shouldBe Status.REJECTED }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    fun `remove posts`() {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;REJECTED&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.setString(1, &amp;quot;test2 title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test2 content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.executeBatch()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt.any { it == 1 }&lt;br&gt;        val deleted = posts.deleteAll(Specifications.removeAllRejected())&lt;br&gt;        log.debug(&amp;quot;deleted posts size:{}&amp;quot;, deleted)&lt;br&gt;        deleted shouldBe 1&lt;/pre&gt;&lt;pre&gt;        val all = posts.findAll()&lt;br&gt;        all shouldHaveSize 1&lt;br&gt;        all.map { it.status }.forAny { it shouldBe Status.DRAFT }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests.&lt;/p&gt;&lt;p&gt;In this application, we use Kotest as testing framework.&lt;/p&gt;&lt;p&gt;Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest.&lt;/p&gt;&lt;p&gt;The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework.&lt;/p&gt;&lt;h3&gt;Kotest&lt;/h3&gt;&lt;p&gt;The simplest is SpringSpec, use a &lt;em&gt;string&lt;/em&gt; to describe functionality. Let&amp;#39;s rewrite the above testing codes with StringSepc.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = [Environment.TEST], startApplication = false)&lt;br&gt;class PostRepositoryTest(&lt;br&gt;    private val posts: PostRepository,&lt;br&gt;    private val template: JdbcOperations,&lt;br&gt;    private val tx: TransactionOperations&amp;lt;Any&amp;gt;&lt;br&gt;) : StringSpec({&lt;/pre&gt;&lt;pre&gt;    &amp;quot;test save and find posts&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.executeUpdate()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt shouldBeEqualComparingTo 1&lt;br&gt;        val all = posts.findAll()&lt;br&gt;        all shouldHaveSize 1&lt;br&gt;        log.debug(&amp;quot;all posts: $all&amp;quot;)&lt;br&gt;        all.map { it.title }.forAny { it shouldContain &amp;quot;test&amp;quot; }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;find by title&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.executeUpdate()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt shouldBeEqualComparingTo 1&lt;br&gt;        val all = posts.findAll(Specifications.titleLike(&amp;quot;test&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size)&lt;br&gt;        all shouldHaveSize 1&lt;/pre&gt;&lt;pre&gt;        val all2 = posts.findAll(Specifications.titleLike(&amp;quot;test2&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size)&lt;br&gt;        all2 shouldHaveSize 0&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;find by keyword&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.setString(1, &amp;quot;test2 title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test2 content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.executeBatch()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt.any { it == 1 }&lt;br&gt;        val all = posts.findAll(Specifications.byKeyword(&amp;quot;test&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size)&lt;br&gt;        all shouldHaveSize 2&lt;/pre&gt;&lt;pre&gt;        val all2 = posts.findAll(Specifications.byKeyword(&amp;quot;test2&amp;quot;))&lt;br&gt;        log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size)&lt;br&gt;        all2 shouldHaveSize 1&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;update posts&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.setString(1, &amp;quot;test2 title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test2 content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.executeBatch()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt.any { it == 1 }&lt;br&gt;        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())&lt;br&gt;        log.debug(&amp;quot;updated posts size:{}&amp;quot;, updated)&lt;br&gt;        updated shouldBe 2&lt;/pre&gt;&lt;pre&gt;        val all = posts.findAll()&lt;br&gt;        all shouldHaveSize 2&lt;br&gt;        all.map { it.status }.forAny { it shouldBe Status.REJECTED }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;remove posts&amp;quot; {&lt;br&gt;        val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;;&lt;br&gt;        val insertedCnt = template.prepareStatement(sql) {&lt;br&gt;            it.setString(1, &amp;quot;test title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;REJECTED&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.setString(1, &amp;quot;test2 title&amp;quot;)&lt;br&gt;            it.setString(2, &amp;quot;test2 content&amp;quot;)&lt;br&gt;            it.setString(3, &amp;quot;DRAFT&amp;quot;)&lt;br&gt;            it.addBatch()&lt;br&gt;            it.executeBatch()&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        insertedCnt.any { it == 1 }&lt;br&gt;        val deleted = posts.deleteAll(Specifications.removeAllRejected())&lt;br&gt;        log.debug(&amp;quot;deleted posts size:{}&amp;quot;, deleted)&lt;br&gt;        deleted shouldBe 1&lt;/pre&gt;&lt;pre&gt;        val all = posts.findAll()&lt;br&gt;        all shouldHaveSize 1&lt;br&gt;        all.map { it.status }.forAny { it shouldBe Status.DRAFT }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}) {&lt;br&gt;    companion object {&lt;br&gt;        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    override fun beforeEach(testCase: TestCase) {&lt;br&gt;        val callback: TransactionCallback&amp;lt;Any, Int&amp;gt; = TransactionCallback { _: TransactionStatus&amp;lt;Any&amp;gt; -&amp;gt;&lt;br&gt;            val sql = &amp;quot;delete from posts&amp;quot;;&lt;br&gt;            this.template.prepareStatement(sql) {&lt;br&gt;                it.executeUpdate()&lt;br&gt;            }&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        val cnt = tx.executeWrite(callback)&lt;br&gt;        println(&amp;quot;deleted $cnt&amp;quot;);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Create a test to test PostController, here we use FunSpec which wraps tests in a test method block.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = [&amp;quot;mock&amp;quot;])&lt;br&gt;class PostControllerTest(&lt;br&gt;    private val postsBean: PostRepository,&lt;br&gt;    @Client(&amp;quot;/&amp;quot;) private var client: HttpClient&lt;br&gt;) : FunSpec({&lt;/pre&gt;&lt;pre&gt;    test(&amp;quot;test get posts endpoint&amp;quot;) {&lt;br&gt;        val posts = getMock(postsBean)&lt;br&gt;        every { posts.findAll() }&lt;br&gt;            .returns(&lt;br&gt;                listOf(&lt;br&gt;                    Post(&lt;br&gt;                        id = UUID.randomUUID(),&lt;br&gt;                        title = &amp;quot;test title&amp;quot;,&lt;br&gt;                        content = &amp;quot;test content&amp;quot;,&lt;br&gt;                        status = Status.DRAFT,&lt;br&gt;                        createdAt = LocalDateTime.now()&lt;br&gt;                    )&lt;br&gt;                )&lt;br&gt;            )&lt;br&gt;        val response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java)&lt;/pre&gt;&lt;pre&gt;        response.status shouldBe HttpStatus.OK&lt;br&gt;        response.body()!![0].title shouldBe &amp;quot;test title&amp;quot;&lt;/pre&gt;&lt;pre&gt;        verify(exactly = 1) { posts.findAll() }&lt;br&gt;    }&lt;br&gt;}) {&lt;br&gt;    @MockBean(PostRepository::class)&lt;br&gt;    fun posts() = mockk&amp;lt;PostRepository&amp;gt;()&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Here we use &lt;strong&gt;mockk&lt;/strong&gt; to create a mocked PostRepository and the MockBean is located in the body of SpringSpec.&lt;/p&gt;&lt;p&gt;The following is an integration example which use SpringSpec .&lt;/p&gt;&lt;pre&gt;@MicronautTest&lt;br&gt;class IntegrationTests(&lt;br&gt;    private val application: EmbeddedApplication&amp;lt;*&amp;gt;,&lt;br&gt;    @Client(&amp;quot;/&amp;quot;) private val client: HttpClient&lt;br&gt;) : StringSpec({&lt;/pre&gt;&lt;pre&gt;    &amp;quot;test the server is running&amp;quot; {&lt;br&gt;        assert(application.isRunning)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    &amp;quot;test GET /posts endpoint&amp;quot; {&lt;br&gt;        val response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java)&lt;/pre&gt;&lt;pre&gt;        response.status shouldBe HttpStatus.OK&lt;br&gt;        response.body()!!.map { it.title }.forAny {&lt;br&gt;            it shouldContain &amp;quot;Micronaut&amp;quot;&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;})&lt;/pre&gt;&lt;p&gt;Get the complete &lt;a href=&quot;https://github.com/hantsy/micronaut-sandbox/tree/master/jdbc-kotlin&quot;&gt;source codes&lt;/a&gt; from my Github.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=81c1b6cf4b10&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin-81c1b6cf4b10&quot;&gt;Building Micronaut applications with Micronaut Data Jdbc and Kotlin&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest.Photo by mingwei dong on UnsplashGetting StartedOpen your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page.Java version: 17Language: KotlinBuild tool: GradleTest framework: KotestIncluded Features: data-jdbc, postgres, etc.Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.Create an Entity class.@MappedEntity(value = &amp;quot;posts&amp;quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now())Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted.The status is an enum class.enum class Status { DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED}Note: The ID and GeneratedValue is from io.micronaut.data.annotation package.Create a Repository for Post Entity class.@JdbcRepositoryinterface PostRepository : PageableRepository&amp;lt;Post, UUID&amp;gt;Here we used a JdbcRepository to indicate this Repository is a data-jdbc Repository.Create a bean to initialize some sample data.@Singleton@Requires(notEnv = [&amp;quot;mock&amp;quot;])class DataInitializer(private val posts: PostRepository) { @EventListener fun onStartUp(e: ServerStartupEvent) { log.info(&amp;quot;starting data initialization at ServerStartupEvent: $e&amp;quot;) posts.deleteAll() val data = listOf( Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin&amp;quot;, content = &amp;quot;test&amp;quot;), Post(title = &amp;quot;Building Restful APIs with Micronaut and Kotlin: part 2&amp;quot;, content = &amp;quot;test&amp;quot;) ) data.forEach { log.debug(&amp;quot;saving: $it&amp;quot;) } posts.saveAll(data).forEach { log.debug(&amp;quot;saved post: $it&amp;quot;) } log.info(&amp;quot;data initialization is done...&amp;quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) }}Now create a controller to expose RESTful APIs.@Controller(&amp;quot;/posts&amp;quot;)class PostController(private val posts: PostRepository) { @Get(uri = &amp;quot;/&amp;quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; = ok(posts.findAll().toList()) @Get(uri = &amp;quot;/{id}&amp;quot;, produces = [MediaType.APPLICATION_JSON]) fun byId(@PathVariable id: UUID): HttpResponse&amp;lt;Any&amp;gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) fun create(@Body body: Post): HttpResponse&amp;lt;Any&amp;gt; { val saved = posts.save(body) return created(URI.create(&amp;quot;/posts/&amp;quot; + saved.id)) }}Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the application.yaml.Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the docker-compose.yaml.# docker compose up postgresNow run the application.# gradlew run // or # gradlew build# java build/xxx.jarYou can use curl command to test the /posts endpoint.# curl http://localhost:8080/postsQuery by SpecificationIf you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the data-jdbc also supports query by JPA Specification.Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies.Change PostRepository, make it extends JpaSpecificationExecutor.@JdbcRepositoryinterface PostRepository : PageableRepository&amp;lt;Post, UUID&amp;gt;, JpaSpecificationExecutor&amp;lt;Post&amp;gt;Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification.object Specifications { fun titleLike(title: String): PredicateSpecification&amp;lt;Post&amp;gt; { return PredicateSpecification&amp;lt;Post&amp;gt; { root, criteriaBuilder -&amp;gt; criteriaBuilder.like( root.get(&amp;quot;title&amp;quot;), &amp;quot;%$title%&amp;quot; ) } } fun byKeyword(q: String): QuerySpecification&amp;lt;Post&amp;gt; { return QuerySpecification&amp;lt;Post&amp;gt; { root, query, criteriaBuilder -&amp;gt; criteriaBuilder.or( criteriaBuilder.like(root.get(&amp;quot;title&amp;quot;), &amp;quot;%$q%&amp;quot;), criteriaBuilder.like(root.get(&amp;quot;content&amp;quot;), &amp;quot;%$q%&amp;quot;) ) } } fun rejectAllPendingModerated(): UpdateSpecification&amp;lt;Post&amp;gt; { return UpdateSpecification&amp;lt;Post&amp;gt; {root, query, criteriaBuilder -&amp;gt; query.set(root.get(&amp;quot;status&amp;quot;), Status.REJECTED) criteriaBuilder.equal(root.get&amp;lt;Status&amp;gt;(&amp;quot;status&amp;quot;), Status.PENDING_MODERATED) } } fun removeAllRejected(): DeleteSpecification&amp;lt;Post&amp;gt; { return DeleteSpecification&amp;lt;Post&amp;gt; {root, query, criteriaBuilder -&amp;gt; criteriaBuilder.equal(root.get&amp;lt;Status&amp;gt;(&amp;quot;status&amp;quot;), Status.REJECTED) } }}Let’s create some tests to verify these Specifications.@MicronautTest(environments = [Environment.TEST], startApplication = false)open class PostRepositoryAnnotationSpec() : AnnotationSpec() { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } @Inject private lateinit var posts: PostRepository @Inject private lateinit var template: JdbcOperations @Inject private lateinit var tx: TransactionOperations&amp;lt;Any&amp;gt; @BeforeEach fun beforeEach() { val callback: TransactionCallback&amp;lt;Any, Int&amp;gt; = TransactionCallback { _: TransactionStatus&amp;lt;Any&amp;gt; -&amp;gt; val sql = &amp;quot;delete from posts&amp;quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&amp;quot;deleted $cnt&amp;quot;); } @Test fun `test save and find posts`() { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&amp;quot;all posts: $all&amp;quot;) all.map { it.title }.forAny { it shouldContain &amp;quot;test&amp;quot; } } @Test fun `find by title`() { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&amp;quot;test&amp;quot;)) log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&amp;quot;test2&amp;quot;)) log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size) all2 shouldHaveSize 0 } @Test fun `find by keyword`() { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.addBatch() it.setString(1, &amp;quot;test2 title&amp;quot;) it.setString(2, &amp;quot;test2 content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&amp;quot;test&amp;quot;)) log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&amp;quot;test2&amp;quot;)) log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size) all2 shouldHaveSize 1 } @Test fun `update posts`() { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;) it.addBatch() it.setString(1, &amp;quot;test2 title&amp;quot;) it.setString(2, &amp;quot;test2 content&amp;quot;) it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&amp;quot;updated posts size:{}&amp;quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } @Test fun `remove posts`() { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;REJECTED&amp;quot;) it.addBatch() it.setString(1, &amp;quot;test2 title&amp;quot;) it.setString(2, &amp;quot;test2 content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&amp;quot;deleted posts size:{}&amp;quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } }}Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests.In this application, we use Kotest as testing framework.Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest.The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework.KotestThe simplest is SpringSpec, use a string to describe functionality. Let&amp;#39;s rewrite the above testing codes with StringSepc.@MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: JdbcOperations, private val tx: TransactionOperations&amp;lt;Any&amp;gt;) : StringSpec({ &amp;quot;test save and find posts&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&amp;quot;all posts: $all&amp;quot;) all.map { it.title }.forAny { it shouldContain &amp;quot;test&amp;quot; } } &amp;quot;find by title&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&amp;quot;test&amp;quot;)) log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&amp;quot;test2&amp;quot;)) log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size) all2 shouldHaveSize 0 } &amp;quot;find by keyword&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.addBatch() it.setString(1, &amp;quot;test2 title&amp;quot;) it.setString(2, &amp;quot;test2 content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&amp;quot;test&amp;quot;)) log.debug(&amp;quot;all posts size:{}&amp;quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&amp;quot;test2&amp;quot;)) log.debug(&amp;quot;all2 posts size:{}&amp;quot;, all2.size) all2 shouldHaveSize 1 } &amp;quot;update posts&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;) it.addBatch() it.setString(1, &amp;quot;test2 title&amp;quot;) it.setString(2, &amp;quot;test2 content&amp;quot;) it.setString(3, &amp;quot;PENDING_MODERATED&amp;quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&amp;quot;updated posts size:{}&amp;quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } &amp;quot;remove posts&amp;quot; { val sql = &amp;quot;insert into posts(title, content, status) values (?, ?, ?)&amp;quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &amp;quot;test title&amp;quot;) it.setString(2, &amp;quot;test content&amp;quot;) it.setString(3, &amp;quot;REJECTED&amp;quot;) it.addBatch() it.setString(1, &amp;quot;test2 title&amp;quot;) it.setString(2, &amp;quot;test2 content&amp;quot;) it.setString(3, &amp;quot;DRAFT&amp;quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&amp;quot;deleted posts size:{}&amp;quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } }}) { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } override fun beforeEach(testCase: TestCase) { val callback: TransactionCallback&amp;lt;Any, Int&amp;gt; = TransactionCallback { _: TransactionStatus&amp;lt;Any&amp;gt; -&amp;gt; val sql = &amp;quot;delete from posts&amp;quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&amp;quot;deleted $cnt&amp;quot;); }}Create a test to test PostController, here we use FunSpec which wraps tests in a test method block.@MicronautTest(environments = [&amp;quot;mock&amp;quot;])class PostControllerTest( private val postsBean: PostRepository, @Client(&amp;quot;/&amp;quot;) private var client: HttpClient) : FunSpec({ test(&amp;quot;test get posts endpoint&amp;quot;) { val posts = getMock(postsBean) every { posts.findAll() } .returns( listOf( Post( id = UUID.randomUUID(), title = &amp;quot;test title&amp;quot;, content = &amp;quot;test content&amp;quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &amp;quot;test title&amp;quot; verify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun posts() = mockk&amp;lt;PostRepository&amp;gt;()}Here we use mockk to create a mocked PostRepository and the MockBean is located in the body of SpringSpec.The following is an integration example which use SpringSpec .@MicronautTestclass IntegrationTests( private val application: EmbeddedApplication&amp;lt;*&amp;gt;, @Client(&amp;quot;/&amp;quot;) private val client: HttpClient) : StringSpec({ &amp;quot;test the server is running&amp;quot; { assert(application.isRunning) } &amp;quot;test GET /posts endpoint&amp;quot; { val response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, Array&amp;lt;Post&amp;gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &amp;quot;Micronaut&amp;quot; } }})Get the complete source codes from my Github.Building Micronaut applications with Micronaut Data Jdbc and Kotlin was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building Restful APIs with Symfony 5 and PHP 8</title><link href="/blog/2021/building-restful-apis-with-symfony-5-and-php-8/" rel="alternate" type="text/html" title="Building Restful APIs with Symfony 5 and PHP 8" /><published>2021-11-22T00:00:00+00:00</published><updated>2021-11-22T00:00:00+00:00</updated><id>/blog/2021/building-restful-apis-with-symfony-5-and-php-8</id><content type="html" xml:base="/blog/2021/building-restful-apis-with-symfony-5-and-php-8/">&lt;p&gt;Symfony is a full-featured modularized PHP framework that is used for building all kinds of applications, from traditional web applications to small Microservice components.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*7zVWP_mRMsd2gPIrKrxrNA.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@kakachen?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;te chan&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Get your feet wet&lt;/h3&gt;&lt;p&gt;Install PHP 8 and PHP Composer tools.&lt;/p&gt;&lt;pre&gt;# choco php composer&lt;/pre&gt;&lt;p&gt;Install [Symfony CLI](symfony check:requirements), check the system requirements.&lt;/p&gt;&lt;pre&gt;# symfony check:requirements&lt;/pre&gt;&lt;pre&gt;Symfony Requirements Checker&lt;br&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~&lt;/pre&gt;&lt;pre&gt;&amp;gt; PHP is using the following php.ini file:&lt;br&gt;C:\tools\php80\php.ini&lt;/pre&gt;&lt;pre&gt;&amp;gt; Checking Symfony requirements:&lt;/pre&gt;&lt;pre&gt;....................WWW.........&lt;/pre&gt;&lt;pre&gt;                                              &lt;br&gt; [OK]                                         &lt;br&gt; Your system is ready to run Symfony projects &lt;br&gt;                                              &lt;/pre&gt;&lt;pre&gt;Optional recommendations to improve your setup&lt;br&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&lt;/pre&gt;&lt;pre&gt; * intl extension should be available&lt;br&gt;   &amp;gt; Install and enable the intl extension (used for validators).&lt;/pre&gt;&lt;pre&gt; * a PHP accelerator should be installed&lt;br&gt;   &amp;gt; Install and/or enable a PHP accelerator (highly recommended).&lt;/pre&gt;&lt;pre&gt; * realpath_cache_size should be at least 5M in php.ini&lt;br&gt;   &amp;gt; Setting &amp;quot;realpath_cache_size&amp;quot; to e.g. &amp;quot;5242880&amp;quot; or &amp;quot;5M&amp;quot; in&lt;br&gt;   &amp;gt; php.ini* may improve performance on Windows significantly in some&lt;br&gt;   &amp;gt; cases.&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;Note  The command console can use a different php.ini file&lt;br&gt;~~~~  than the one used by your web server.&lt;br&gt;      Please check that both the console and the web server&lt;br&gt;      are using the same PHP version and configuration.&lt;/pre&gt;&lt;p&gt;According to the &lt;em&gt;recommendations&lt;/em&gt; info, adjust your PHP configuration in the &lt;em&gt;php.ini&lt;/em&gt;. And we will use Postgres as database in the sample application, make sure pdo_pgsql and pgsql modules are enabled.&lt;/p&gt;&lt;p&gt;Finally, you can confirm the enabled modules by the following command.&lt;/p&gt;&lt;pre&gt;# php -m&lt;/pre&gt;&lt;p&gt;Create a new Symfony project.&lt;/p&gt;&lt;pre&gt;# symfony new rest-sample&lt;/pre&gt;&lt;pre&gt;// a classic website application&lt;br&gt;# symfony new web-sample --full&lt;/pre&gt;&lt;p&gt;By default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application.&lt;/p&gt;&lt;p&gt;Alternatively, you can create it using Composer.&lt;/p&gt;&lt;pre&gt;# composer create-project symfony/skeleton rest-sample&lt;/pre&gt;&lt;pre&gt;//start a classic website application&lt;br&gt;# composer create-project symfony/website-skeleton web-sample&lt;/pre&gt;&lt;p&gt;Enter the generated project root folder, start the application.&lt;/p&gt;&lt;pre&gt;# symfony server:start&lt;/pre&gt;&lt;pre&gt; [WARNING] run &amp;quot;symfony.exe server:ca:install&amp;quot; first if you want to run the web server with TLS support, or use &amp;quot;--no-  &lt;br&gt; tls&amp;quot; to avoid this warning                                                                                             &lt;br&gt;                                                                                                                       &lt;br&gt;Tailing PHP-CGI log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)&lt;br&gt;Tailing Web Server log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158.log)&lt;br&gt;                                                                                                                        &lt;br&gt; [OK] Web server listening                                                                                              &lt;br&gt;      The Web server is using PHP CGI 8.0.10                                                                            &lt;br&gt;      &lt;a href=&quot;http://127.0.0.1:8000&quot;&gt;http://127.0.0.1:8000&lt;/a&gt;                                                                                             &lt;br&gt;                                                                                                                        &lt;/pre&gt;&lt;pre&gt;[Web Server ] Oct  4 13:33:01 |DEBUG  | PHP    Reloading PHP versions&lt;br&gt;[Web Server ] Oct  4 13:33:01 |DEBUG  | PHP    Using PHP version 8.0.10 (from default version in $PATH)&lt;br&gt;[Web Server ] Oct  4 13:33:01 |INFO   | PHP    listening path=&amp;quot;C:\\tools\\php80\\php-cgi.exe&amp;quot; php=&amp;quot;8.0.10&amp;quot; port=61738&lt;/pre&gt;&lt;h3&gt;Hello , Symfony&lt;/h3&gt;&lt;p&gt;Create a simple class to a resource entity in the HTTP response.&lt;/p&gt;&lt;pre&gt;class Post&lt;br&gt;{&lt;br&gt;    private ?string $id = null;&lt;/pre&gt;&lt;pre&gt;    private string $title;&lt;/pre&gt;&lt;pre&gt;    private string $content;&lt;br&gt;    &lt;br&gt;    //getters and setters.&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;And use a factory to create a new Post instance.&lt;/p&gt;&lt;pre&gt;class PostFactory&lt;br&gt;{&lt;br&gt;    public static function create(string $title, string $content): Post&lt;br&gt;    {&lt;br&gt;        $post = new Post();&lt;br&gt;        $post-&amp;gt;setTitle($title);&lt;br&gt;        $post-&amp;gt;setContent($content);&lt;br&gt;        return $post;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Let’s create a simple Controller class.&lt;/p&gt;&lt;p&gt;To use the newest PHP 8 attributes to configure the routing rules, apply the following changes in the project configurations.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Open &lt;em&gt;config/packages/doctrine.yaml&lt;/em&gt;, remove doctrine/orm/mapping/App/type or change its value to attribute&lt;/li&gt;&lt;li&gt;Open &lt;em&gt;composer.json&lt;/em&gt;, change PHP version to &amp;gt;=8.0.0.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To render the response body into a JSON string, use a JsonReponse to wrap the response.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;/posts&amp;quot;, name: &amp;quot;posts_&amp;quot;)]&lt;br&gt;class PostController&lt;br&gt;{&lt;/pre&gt;&lt;pre&gt;    #[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    function all(): Response&lt;br&gt;    {&lt;br&gt;        $post1 = PostFactory::create(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;);&lt;br&gt;        $post1-&amp;gt;setId(&amp;quot;1&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        $post2 = PostFactory::create(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;);&lt;br&gt;        $post2-&amp;gt;setId(&amp;quot;2&amp;quot;);&lt;br&gt;        $data = [$post1-&amp;gt;asArray(), $post2-&amp;gt;asArray()];&lt;br&gt;        return new JsonResponse($data, 200, [&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;]);&lt;br&gt;        //return $this-&amp;gt;json($data, 200, [&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;]);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The first parameter of JsonReponse accepts an array as data, so add a function in the Post class to archive this purpose.&lt;/p&gt;&lt;pre&gt;class Post{&lt;br&gt;    //...&lt;br&gt;    public function asArray(): array&lt;br&gt;    {&lt;br&gt;        return [&lt;br&gt;            &amp;#39;id&amp;#39; =&amp;gt; $this-&amp;gt;id,&lt;br&gt;            &amp;#39;title&amp;#39; =&amp;gt; $this-&amp;gt;title,&lt;br&gt;            &amp;#39;content&amp;#39; =&amp;gt; $this-&amp;gt;content&lt;br&gt;        ];&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Run the application, use curl to test the /posts endpoint.&lt;/p&gt;&lt;pre&gt;# curl &lt;a href=&quot;http://localhost:8000/posts&quot;&gt;http://localhost:8000/posts&lt;/a&gt;&lt;/pre&gt;&lt;p&gt;Symfony provides a simple AbstractController which includes several functions to simplfy the response and adopt the container and dependency injection management.&lt;/p&gt;&lt;p&gt;In the above controller, extends from AbstractController, simply call $this-&amp;gt;json to render the response in JSON format, no need to transform the data to an array before rendering response.&lt;/p&gt;&lt;pre&gt;class PostController extends AbstractController&lt;br&gt;{&lt;/pre&gt;&lt;pre&gt;    function all(): Response&lt;br&gt;    {&lt;br&gt;        //...&lt;br&gt;        return $this-&amp;gt;json($data, 200, [&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;]);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Connecting to Database&lt;/h3&gt;&lt;p&gt;Doctrine is a popular ORM framework , it is highly inspired by the existing Java ORM tooling, such as JPA spec and Hibernate framework. There are two core components in Doctrine, doctrine/dbal and doctrine/orm, the former is a low level APIs for database operations, if you know Java development, consider it as the &lt;em&gt;Jdbc&lt;/em&gt; layer. The later is the advanced ORM framework, the public APIs are similar to JPA/Hibernate.&lt;/p&gt;&lt;p&gt;Install Doctrine into the project.&lt;/p&gt;&lt;pre&gt;# composer require symfony/orm-pack&lt;br&gt;# composer require --dev symfony/maker-bundle&lt;/pre&gt;&lt;p&gt;The &lt;strong&gt;pack&lt;/strong&gt; is a virtual Symfony package, it will install a series of packages and basic configurations.&lt;/p&gt;&lt;p&gt;Open the .env file in the project root folder, edit the DATABASE_URL value, setup the database name, username, password to connect.&lt;/p&gt;&lt;pre&gt;DATABASE_URL=&amp;quot;postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;amp;charset=utf8&amp;quot;&lt;/pre&gt;&lt;p&gt;Use the following command to generate a docker compose file template.&lt;/p&gt;&lt;pre&gt;# php bin/console make:docker:database&lt;/pre&gt;&lt;p&gt;We change it to the following to start up a Postgres database in development.&lt;/p&gt;&lt;pre&gt;version: &amp;quot;3.5&amp;quot; # specify docker-compose version, v3.5 is compatible with docker 17.12.0+&lt;/pre&gt;&lt;pre&gt;# Define the services/containers to be run&lt;br&gt;services:&lt;/pre&gt;&lt;pre&gt;  postgres:&lt;br&gt;    image: postgres:${POSTGRES_VERSION:-13}-alpine&lt;br&gt;    ports:&lt;br&gt;      - &amp;quot;5432:5432&amp;quot;&lt;br&gt;    environment:&lt;br&gt;      POSTGRES_DB: ${POSTGRES_DB:-blogdb}&lt;br&gt;      # You should definitely change the password in production&lt;br&gt;      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password}&lt;br&gt;      POSTGRES_USER: ${POSTGRES_USER:-user}&lt;br&gt;    volumes:&lt;br&gt;      - ./data/blogdb:/var/lib/postgresql/data:rw&lt;br&gt;      - ./pg-initdb.d:/docker-entrypoint-initdb.d&lt;/pre&gt;&lt;p&gt;We will use UUID as data type of the primary key, add a script to enable uuid-ossp extension in Postgres when it is starting up.&lt;/p&gt;&lt;pre&gt;-- file: pg-initdb.d/ini.sql&lt;br&gt;SET search_path TO public;&lt;br&gt;DROP EXTENSION IF EXISTS &amp;quot;uuid-ossp&amp;quot;;&lt;br&gt;CREATE EXTENSION &amp;quot;uuid-ossp&amp;quot; SCHEMA public;&lt;/pre&gt;&lt;p&gt;Open &lt;em&gt;config/packages/test/doctrine.yaml&lt;/em&gt;, comment out dbname_suffix line. We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production.&lt;/p&gt;&lt;p&gt;Now startup the application and make sure there is no exception in the console, that means the database connection is successful.&lt;/p&gt;&lt;pre&gt;symfony server:start&lt;/pre&gt;&lt;p&gt;Before starting the application, make sure the database is running. Run the following command to start up the Postgres in Docker.&lt;/p&gt;&lt;pre&gt;# docker compose up postgres&lt;br&gt;# docker ps -a # to list all containers and make the postgres is running&lt;/pre&gt;&lt;h3&gt;Building Data Models&lt;/h3&gt;&lt;p&gt;Now we will build the Entities that will be used in the next sections. We are modeling a simple blog system, it includes the following concepts.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A Post presents an article post in the blog system.&lt;/li&gt;&lt;li&gt;A Comment presents the comments under a specific post.&lt;/li&gt;&lt;li&gt;The common Tag can be applied on different posts, which categorizes posts by topic, categories , etc.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;You can draft your model relations in mind or through some graphic data modeling tools.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Post and comments is a one-to-many relation&lt;/li&gt;&lt;li&gt;Post and tag is a many-to-many relation&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It is easy to convert the idea to real codes via Doctrine Entity. Run the following command to create Post, Comment and Tag entities.&lt;/p&gt;&lt;p&gt;In the Doctrine ORM 2.10.x and Dbal 3.x, the UUID type ID generator is deprecated. We will switch to the Uuid form symfony\uid.&lt;/p&gt;&lt;p&gt;Install symfony\uid firstly.&lt;/p&gt;&lt;pre&gt;# composer require symfony/uid&lt;/pre&gt;&lt;p&gt;Simply, you can use the following command to create entities quickly.&lt;/p&gt;&lt;pre&gt;# php bin/console make:entity  # following the interactive steps to create them one by one.&lt;/pre&gt;&lt;p&gt;Finally we got three entities in the &lt;em&gt;src/Entity&lt;/em&gt; folder. Modify them as you expected.&lt;/p&gt;&lt;pre&gt;// src/Entity/Post.php&lt;br&gt;#[Entity(repositoryClass: PostRepository::class)]&lt;br&gt;class Post&lt;br&gt;{&lt;br&gt;    #[Id]&lt;br&gt;    //#[GeneratedValue(strategy: &amp;quot;UUID&amp;quot;)&lt;br&gt;    //#[Column(type: &amp;quot;string&amp;quot;, unique: true)]&lt;br&gt;    #[Column(type: &amp;quot;uuid&amp;quot;, unique: true)]&lt;br&gt;    #[GeneratedValue(strategy: &amp;quot;CUSTOM&amp;quot;)]&lt;br&gt;    #[CustomIdGenerator(class: UuidGenerator::class)]&lt;br&gt;    private ?Uuid $id = null;&lt;/pre&gt;&lt;pre&gt;    #[Column(type: &amp;quot;string&amp;quot;, length: 255)]&lt;br&gt;    private string $title;&lt;/pre&gt;&lt;pre&gt;    #[Column(type: &amp;quot;string&amp;quot;, length: 255)]&lt;br&gt;    private string $content;&lt;/pre&gt;&lt;pre&gt;    #[Column(name: &amp;quot;created_at&amp;quot;, type: &amp;quot;datetime&amp;quot;, nullable: true)]&lt;br&gt;    private DateTime|null $createdAt = null;&lt;/pre&gt;&lt;pre&gt;    #[Column(name: &amp;quot;published_at&amp;quot;, type: &amp;quot;datetime&amp;quot;, nullable: true)]&lt;br&gt;    private DateTime|null $publishedAt = null;&lt;/pre&gt;&lt;pre&gt;    #[OneToMany(mappedBy: &amp;quot;post&amp;quot;, targetEntity: Comment::class, cascade: [&amp;#39;persist&amp;#39;, &amp;#39;merge&amp;#39;, &amp;quot;remove&amp;quot;], fetch: &amp;#39;LAZY&amp;#39;, orphanRemoval: true)]&lt;br&gt;    private Collection $comments;&lt;/pre&gt;&lt;pre&gt;    #[ManyToMany(targetEntity: Tag::class, mappedBy: &amp;quot;posts&amp;quot;, cascade: [&amp;#39;persist&amp;#39;, &amp;#39;merge&amp;#39;], fetch: &amp;#39;EAGER&amp;#39;)]&lt;br&gt;    private Collection $tags;&lt;/pre&gt;&lt;pre&gt;    public function __construct()&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;createdAt = new DateTime();&lt;br&gt;        $this-&amp;gt;comments = new ArrayCollection();&lt;br&gt;        $this-&amp;gt;tags = new ArrayCollection();&lt;br&gt;    }&lt;br&gt;    //other getters and setters&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;// src/Entity/Comment.php&lt;br&gt;#[Entity(repositoryClass: CommentRepository::class)]&lt;br&gt;class Comment&lt;br&gt;{&lt;br&gt;    #[Id]&lt;br&gt;    //#[GeneratedValue(strategy: &amp;quot;UUID&amp;quot;)]&lt;br&gt;    #[Column(type: &amp;quot;uuid&amp;quot;, unique: true)]&lt;br&gt;    #[GeneratedValue(strategy: &amp;quot;CUSTOM&amp;quot;)]&lt;br&gt;    #[CustomIdGenerator(class: UuidGenerator::class)]&lt;br&gt;    private ?Uuid $id = null;&lt;/pre&gt;&lt;pre&gt;    #[Column(type: &amp;quot;string&amp;quot;, length: 255)]&lt;br&gt;    private string $content;&lt;/pre&gt;&lt;pre&gt;    #[Column(name: &amp;quot;created_at&amp;quot;, type: &amp;quot;datetime&amp;quot;, nullable: true)]&lt;br&gt;    private DateTime|null $createdAt = null;&lt;/pre&gt;&lt;pre&gt;    #[ManyToOne(targetEntity: &amp;quot;Post&amp;quot;, inversedBy: &amp;quot;comments&amp;quot;)]&lt;br&gt;    #[JoinColumn(name: &amp;quot;post_id&amp;quot;, referencedColumnName: &amp;quot;id&amp;quot;)]&lt;br&gt;    private Post $post;&lt;/pre&gt;&lt;pre&gt;    public function __construct()&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;createdAt = new DateTime();&lt;br&gt;    }&lt;br&gt;    //other getters and setters&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//src/Entity/Tag.php&lt;br&gt;#[Entity(repositoryClass: TagRepository::class)]&lt;br&gt;class Tag&lt;br&gt;{&lt;br&gt;    #[Id]&lt;br&gt;    //#[GeneratedValue(strategy: &amp;quot;UUID&amp;quot;)&lt;br&gt;    //#[Column(type: &amp;quot;string&amp;quot;, unique: true)]&lt;br&gt;    #[Column(type: &amp;quot;uuid&amp;quot;, unique: true)]&lt;br&gt;    #[GeneratedValue(strategy: &amp;quot;CUSTOM&amp;quot;)]&lt;br&gt;    #[CustomIdGenerator(class: UuidGenerator::class)]&lt;br&gt;    private ?Uuid $id = null;&lt;/pre&gt;&lt;pre&gt;    #[Column(type: &amp;quot;string&amp;quot;, length: 255)]&lt;br&gt;    private ?string $name;&lt;/pre&gt;&lt;pre&gt;    #[ManyToMany(targetEntity: Post::class, inversedBy: &amp;quot;tags&amp;quot;)]&lt;br&gt;    private Collection $posts;&lt;/pre&gt;&lt;pre&gt;    public function __construct()&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;posts = new ArrayCollection();&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;At the same time, it generated three Repository classes for these entities.&lt;/p&gt;&lt;pre&gt;// src/Repository/PostRepsoitory.php&lt;br&gt;class PostRepository extends ServiceEntityRepository&lt;br&gt;{&lt;br&gt;    public function __construct(ManagerRegistry $registry)&lt;br&gt;    {&lt;br&gt;        parent::__construct($registry, Post::class);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;// src/Repository/CommentRepsoitory.php&lt;br&gt;class CommentRepository extends ServiceEntityRepository&lt;br&gt;{&lt;br&gt;    public function __construct(ManagerRegistry $registry)&lt;br&gt;    {&lt;br&gt;        parent::__construct($registry, Comment::class);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//src/Repository/TagRepository.php&lt;br&gt;class TagRepository extends ServiceEntityRepository&lt;br&gt;{&lt;br&gt;    public function __construct(ManagerRegistry $registry)&lt;br&gt;    {&lt;br&gt;        parent::__construct($registry, Tag::class);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;You can use Doctrine migration to generate a &lt;em&gt;Migration&lt;/em&gt; file to maintain database schema in a production environment.&lt;/p&gt;&lt;p&gt;Run the following command to generate a &lt;em&gt;Migration&lt;/em&gt; file.&lt;/p&gt;&lt;pre&gt;# php bin/console make:migration&lt;/pre&gt;&lt;p&gt;After it is executed, a Migration file is generated in the &lt;em&gt;migrations&lt;/em&gt; folder, its naming is like Version20211104031420. It is a simple class extended AbstractMigration, the up function is use for upgrade to this version and down function is use for downgrade to the previous version.&lt;/p&gt;&lt;p&gt;To apply Migrations on database automaticially.&lt;/p&gt;&lt;pre&gt;# php bin/console doctrine:migrations:migrate&lt;/pre&gt;&lt;pre&gt;# return to prev version&lt;br&gt;# php bin/console doctrine:migrations:migrate prev&lt;/pre&gt;&lt;pre&gt;# migrate to next&lt;br&gt;# php bin/console doctrine:migrations:migrate next&lt;/pre&gt;&lt;pre&gt;# These alias are defined : first, latest, prev, current and next&lt;/pre&gt;&lt;pre&gt;# certain version fully qualified class name&lt;br&gt;# php bin/console doctrine:migrations:migrate FQCN&lt;/pre&gt;&lt;p&gt;Doctrine bundle also includes some command to maintain database and schema. eg.&lt;/p&gt;&lt;pre&gt;# php bin/console doctrine:database:create&lt;br&gt;# php bin/console doctrine:database:drop&lt;/pre&gt;&lt;pre&gt;// schema create, drop, update and validate&lt;br&gt;# php bin/console doctrine:schema:create&lt;br&gt;# php bin/console doctrine:schema:drop&lt;br&gt;# php bin/console doctrine:schema:update&lt;br&gt;# php bin/console doctrine:schema:validate&lt;/pre&gt;&lt;h3&gt;Adding Sample Data&lt;/h3&gt;&lt;p&gt;Create a custom command to load some sample data.&lt;/p&gt;&lt;pre&gt;# php bin/console make:command add-post&lt;/pre&gt;&lt;p&gt;It will generate a AddPostCommand under &lt;em&gt;src/Command&lt;/em&gt; folder.&lt;/p&gt;&lt;pre&gt;#[AsCommand(&lt;br&gt;    name: &amp;#39;app:add-post&amp;#39;,&lt;br&gt;    description: &amp;#39;Add a short description for your command&amp;#39;,&lt;br&gt;)]&lt;br&gt;class AddPostCommand extends Command&lt;br&gt;{&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    public function __construct(private EntityManagerInterface $manager)&lt;br&gt;    {&lt;br&gt;        parent::__construct();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    protected function configure(): void&lt;br&gt;    {&lt;br&gt;        $this&lt;br&gt;            -&amp;gt;addArgument(&amp;#39;title&amp;#39;, InputArgument::REQUIRED, &amp;#39;Title of a post&amp;#39;)&lt;br&gt;            -&amp;gt;addArgument(&amp;#39;content&amp;#39;, InputArgument::REQUIRED, &amp;#39;Content of a post&amp;#39;)&lt;br&gt;            //-&amp;gt;addOption(&amp;#39;option1&amp;#39;, null, InputOption::VALUE_NONE, &amp;#39;Option description&amp;#39;)&lt;br&gt;        ;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    protected function execute(InputInterface $input, OutputInterface $output): int&lt;br&gt;    {&lt;br&gt;        $io = new SymfonyStyle($input, $output);&lt;br&gt;        $title = $input-&amp;gt;getArgument(&amp;#39;title&amp;#39;);&lt;/pre&gt;&lt;pre&gt;        if ($title) {&lt;br&gt;            $io-&amp;gt;note(sprintf(&amp;#39;Title: %s&amp;#39;, $title));&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        $content = $input-&amp;gt;getArgument(&amp;#39;content&amp;#39;);&lt;/pre&gt;&lt;pre&gt;        if ($content) {&lt;br&gt;            $io-&amp;gt;note(sprintf(&amp;#39;Content: %s&amp;#39;, $content));&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        $entity = PostFactory::create($title, $content);&lt;br&gt;        $this -&amp;gt;manager-&amp;gt;persist($entity);&lt;br&gt;        $this -&amp;gt;manager-&amp;gt;flush();&lt;/pre&gt;&lt;pre&gt;//        if ($input-&amp;gt;getOption(&amp;#39;option1&amp;#39;)) {&lt;br&gt;//            // ...&lt;br&gt;//        }&lt;/pre&gt;&lt;pre&gt;        $io-&amp;gt;success(&amp;#39;Post is saved: &amp;#39;.$entity);&lt;/pre&gt;&lt;pre&gt;        return Command::SUCCESS;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The Doctrine EntityManagerInterface is managed by Symfony &lt;em&gt;Service Container&lt;/em&gt;, and use for data persistence operations.&lt;/p&gt;&lt;p&gt;Run the following command to add a post into the database.&lt;/p&gt;&lt;pre&gt;# php bin/console app:add-post &amp;quot;test title&amp;quot; &amp;quot;test content&amp;quot;&lt;br&gt; ! [NOTE] Title: test title                                               &lt;br&gt; ! [NOTE] Content: test content                                                             &lt;br&gt; [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=]&lt;/pre&gt;&lt;h3&gt;Testing Repository&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://phpunit.de&quot;&gt;PHPUnit&lt;/a&gt; is the most popular testing framework in PHP world, Symfony integrates PHPUnit tightly.&lt;/p&gt;&lt;p&gt;Run the following command to install PHPUnit and Symfony &lt;strong&gt;test-pack&lt;/strong&gt;. The &lt;strong&gt;test-pack&lt;/strong&gt; will install all essential packages for testing Symfony components and add PHPUnit configuration, such as &lt;em&gt;phpunit.xml.dist&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;# composer require --dev phpunit/phpunit symfony/test-pack&lt;/pre&gt;&lt;p&gt;An simple test example written in pure PHPUnit.&lt;/p&gt;&lt;pre&gt;class PostTest extends TestCase&lt;br&gt;{&lt;/pre&gt;&lt;pre&gt;    public function testPost()&lt;br&gt;    {&lt;br&gt;        $p = PostFactory::create(&amp;quot;tests title&amp;quot;, &amp;quot;tests content&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        $this-&amp;gt;assertEquals(&amp;quot;tests title&amp;quot;, $p-&amp;gt;getTitle());&lt;br&gt;        $this-&amp;gt;assertEquals(&amp;quot;tests content&amp;quot;, $p-&amp;gt;getContent());&lt;br&gt;        $this-&amp;gt;assertNotNull( $p-&amp;gt;getCreatedAt());&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Symfony provides some specific base classes(KernelTestCase, WebTestCase, etc.) to simplfy the testing work in a Symfony project.&lt;/p&gt;&lt;p&gt;The following is an example of testing a Repository - PostRepository. The KernelTestCase contains facilities to bootstrap application kernel and provides service container.&lt;/p&gt;&lt;pre&gt;class PostRepositoryTest extends KernelTestCase&lt;br&gt;{&lt;/pre&gt;&lt;pre&gt;    private EntityManagerInterface $entityManager;&lt;/pre&gt;&lt;pre&gt;    private PostRepository $postRepository;&lt;/pre&gt;&lt;pre&gt;    protected function setUp(): void&lt;br&gt;    {&lt;br&gt;        //(1) boot the Symfony kernel&lt;br&gt;        $kernel = self::bootKernel();&lt;br&gt;        $this-&amp;gt;assertSame(&amp;#39;test&amp;#39;, $kernel-&amp;gt;getEnvironment());&lt;br&gt;        $this-&amp;gt;entityManager = $kernel-&amp;gt;getContainer()&lt;br&gt;            -&amp;gt;get(&amp;#39;doctrine&amp;#39;)&lt;br&gt;            -&amp;gt;getManager();&lt;/pre&gt;&lt;pre&gt;        //(2) use static::getContainer() to access the service container&lt;br&gt;        $container = static::getContainer();&lt;/pre&gt;&lt;pre&gt;        //(3) get PostRepository from container.&lt;br&gt;        $this-&amp;gt;postRepository = $container-&amp;gt;get(PostRepository::class);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    protected function tearDown(): void&lt;br&gt;    {&lt;br&gt;        parent::tearDown();&lt;br&gt;        $this-&amp;gt;entityManager-&amp;gt;close();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public function testCreatePost(): void&lt;br&gt;    {&lt;br&gt;        $entity = PostFactory::create(&amp;quot;test post&amp;quot;, &amp;quot;test content&amp;quot;);&lt;br&gt;        $this-&amp;gt;entityManager-&amp;gt;persist($entity);&lt;br&gt;        $this-&amp;gt;entityManager-&amp;gt;flush();&lt;br&gt;        $this-&amp;gt;assertNotNull($entity-&amp;gt;getId());&lt;/pre&gt;&lt;pre&gt;        $byId = $this-&amp;gt;postRepository-&amp;gt;findOneBy([&amp;quot;id&amp;quot; =&amp;gt; $entity-&amp;gt;getId()]);&lt;br&gt;        $this-&amp;gt;assertEquals(&amp;quot;test post&amp;quot;, $byId-&amp;gt;getTitle());&lt;br&gt;        $this-&amp;gt;assertEquals(&amp;quot;test content&amp;quot;, $byId-&amp;gt;getContent());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;In the above codes, in the setUp function, boot up the application kernel, after it is booted, a test scoped &lt;em&gt;Service Container&lt;/em&gt; is available. Then get EntityManagerInterface and PostRepository from service container.&lt;/p&gt;&lt;p&gt;In the testCreatePost function, persists a Post entity, and find this post by id and verify the &lt;em&gt;title&lt;/em&gt; and &lt;em&gt;content&lt;/em&gt; fields.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes are similar to the legacy JUnit 4 code style.&lt;/em&gt;&lt;/blockquote&gt;&lt;h3&gt;Creating PostController: Exposing your first Rest API&lt;/h3&gt;&lt;p&gt;Similar to other MVC framework, we can expose RESTful APIs via Symfony Controller component. Follow the REST convention, we are planning to create the following APIs to a blog system.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;GET /posts Get all posts.&lt;/li&gt;&lt;li&gt;GET /posts/{id} Get a single post by ID, if not found, return status 404&lt;/li&gt;&lt;li&gt;POST /posts Create a new post from request body, add the new post URI to response header Location, and return status 201&lt;/li&gt;&lt;li&gt;DELETE /posts/{id} Delete a single post by ID, return status 204. If the post was not found, return status 404 instead.&lt;/li&gt;&lt;li&gt;…&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Run the following command to create a Controller skeleton. Follow the interactive guide to create a controller named PostController.&lt;/p&gt;&lt;pre&gt;# php bin/console make:constroller&lt;/pre&gt;&lt;p&gt;Open &lt;em&gt;src/Controller/PostController.php&lt;/em&gt; in IDE.&lt;/p&gt;&lt;p&gt;Add Route attribute on class level and two functions: one for fetching all posts and another for getting single post by ID.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;/posts&amp;quot;, name: &amp;quot;posts_&amp;quot;)]&lt;br&gt;class PostController extends AbstractController&lt;br&gt;{&lt;br&gt;    public function __construct(private PostRepository      $posts)&lt;br&gt;    {&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    #[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    function all(): Response&lt;br&gt;    {&lt;br&gt;        $data = $this-&amp;gt;posts-&amp;gt;findAll();&lt;br&gt;        return $this-&amp;gt;json($data);&lt;br&gt;    }&lt;br&gt;    &lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Start up the application, and try to access the &lt;a href=&quot;http://localhost:8000/posts&quot;&gt;&lt;em&gt;http://localhost:8000/posts&lt;/em&gt;&lt;/a&gt;, it will throw a circular dependencies exception when rendering the models in JSON view directly. There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view. Add a Ignore attribute on Comment.post and Tag.posts.&lt;/p&gt;&lt;pre&gt;//src/Entity/Comment.php&lt;br&gt;class Comment&lt;br&gt;{&lt;br&gt;    #[Ignore]&lt;br&gt;    private Post $post;&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//src/Entity/Tag.php&lt;br&gt;class Tag&lt;br&gt;{&lt;br&gt;    #[Ignore]&lt;br&gt;    private Collection $posts;&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Testing Controller&lt;/h3&gt;&lt;p&gt;As described in the previous sections, to test Controller/API, create a test class to extend WebTestCase, which provides a plenty of facilities to handle request and assert response.&lt;/p&gt;&lt;p&gt;Run the following command to create a test skeleton.&lt;/p&gt;&lt;pre&gt;# php bin/console make:test&lt;/pre&gt;&lt;p&gt;Follow the interactive steps to create a test base on WebTestCase.&lt;/p&gt;&lt;pre&gt;class PostControllerTest extends WebTestCase&lt;br&gt;{&lt;br&gt;    public function testGetAllPosts(): void&lt;br&gt;    {&lt;br&gt;        $client = static::createClient();&lt;br&gt;        $crawler = $client-&amp;gt;request(&amp;#39;GET&amp;#39;, &amp;#39;/posts&amp;#39;);&lt;/pre&gt;&lt;pre&gt;        $this-&amp;gt;assertResponseIsSuccessful();&lt;/pre&gt;&lt;pre&gt;        //&lt;br&gt;        $response = $client-&amp;gt;getResponse();&lt;br&gt;        $data = $response-&amp;gt;getContent();&lt;br&gt;        //dump($data);&lt;br&gt;        $this-&amp;gt;assertStringContainsString(&amp;quot;Symfony and PHP&amp;quot;, $data);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;If you try to run the test, it will fail. At the moment, there is no any data for testing.&lt;/p&gt;&lt;h3&gt;Preparing Data for Testing Purpose&lt;/h3&gt;&lt;p&gt;The doctrine/doctrine-fixtures-bundle is use for populate sample data for testing purpose, and dama/doctrine-test-bundle ensures the data is restored before evey test is running.&lt;/p&gt;&lt;p&gt;Install doctrine/doctrine-fixtures-bundle and dama/doctrine-test-bundle.&lt;/p&gt;&lt;pre&gt;composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundle&lt;/pre&gt;&lt;p&gt;Create a new Fixture.&lt;/p&gt;&lt;pre&gt;# php bin/console make:fixtures&lt;/pre&gt;&lt;p&gt;In the load fucntion, persist some data for tests.&lt;/p&gt;&lt;pre&gt;class AppFixtures extends Fixture&lt;br&gt;{&lt;br&gt;    public function load(ObjectManager $manager): void&lt;br&gt;    {&lt;br&gt;        $data = PostFactory::create(&amp;quot;Building Restful APIs with Symfony and PHP 8&amp;quot;, &amp;quot;test content&amp;quot;);&lt;br&gt;        $data-&amp;gt;addTag(Tag::of( &amp;quot;Symfony&amp;quot;))&lt;br&gt;            -&amp;gt;addTag( Tag::of(&amp;quot;PHP 8&amp;quot;))&lt;br&gt;            -&amp;gt;addComment(Comment::of(&amp;quot;test comment 1&amp;quot;))&lt;br&gt;            -&amp;gt;addComment(Comment::of(&amp;quot;test comment 2&amp;quot;));&lt;/pre&gt;&lt;pre&gt;        $manager-&amp;gt;persist($data);&lt;br&gt;        $manager-&amp;gt;flush();&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Run the command to load the sample data into database manually.&lt;/p&gt;&lt;pre&gt;# php bin/console doctrine:fixtures:load&lt;/pre&gt;&lt;p&gt;Add the following extension configuration into the phpunit.xml.dist, thus the data will be purged and recreated for every test running.&lt;/p&gt;&lt;pre&gt;&amp;lt;extensions&amp;gt;&lt;br&gt;    &amp;lt;extension class=&amp;quot;DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension&amp;quot;/&amp;gt;&lt;br&gt;&amp;lt;/extensions&amp;gt;&lt;/pre&gt;&lt;p&gt;Run the following command to execute PostControllerTest.php .&lt;/p&gt;&lt;pre&gt;# php .\vendor\bin\phpunit .\tests\Controller\PostControllerTest.php&lt;/pre&gt;&lt;h3&gt;Paginating Result&lt;/h3&gt;&lt;p&gt;There are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a &lt;em&gt;keyword&lt;/em&gt; provided by request to match Post &lt;em&gt;title&lt;/em&gt; or &lt;em&gt;content&lt;/em&gt; fields, a &lt;em&gt;offset&lt;/em&gt; to set the offset position of the pagination, and a &lt;em&gt;limit&lt;/em&gt; to set the limited size of the elements per page. Create a function in the PostRepository, accepts a &lt;em&gt;keyword&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; and &lt;em&gt;limit&lt;/em&gt; as arguments.&lt;/p&gt;&lt;pre&gt;public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page&lt;br&gt;{&lt;br&gt;    $query = $this-&amp;gt;createQueryBuilder(&amp;quot;p&amp;quot;)&lt;br&gt;        -&amp;gt;andWhere(&amp;quot;p.title like :q or p.content like :q&amp;quot;)&lt;br&gt;        -&amp;gt;setParameter(&amp;#39;q&amp;#39;, &amp;quot;%&amp;quot; . $q . &amp;quot;%&amp;quot;)&lt;br&gt;        -&amp;gt;orderBy(&amp;#39;p.createdAt&amp;#39;, &amp;#39;DESC&amp;#39;)&lt;br&gt;        -&amp;gt;setMaxResults($limit)&lt;br&gt;        -&amp;gt;setFirstResult($offset)&lt;br&gt;        -&amp;gt;getQuery();&lt;/pre&gt;&lt;pre&gt;    $paginator = new Paginator($query, $fetchJoinCollection = false);&lt;br&gt;    $c = count($paginator);&lt;br&gt;    $content = new ArrayCollection();&lt;br&gt;    foreach ($paginator as $post) {&lt;br&gt;        $content-&amp;gt;add(PostSummaryDto::of($post-&amp;gt;getId(), $post-&amp;gt;getTitle()));&lt;br&gt;    }&lt;br&gt;    return Page::of ($content, $c, $offset, $limit);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Firstly, create a dynamic query using createQueryBuilder , then create a Doctrine Paginator instance to execute the query. The Paginator implements Countable interface, use count to get the count of total elements. Finally, we use a custom Page object to wrap the result.&lt;/p&gt;&lt;pre&gt;class Page&lt;br&gt;{&lt;br&gt;    private Collection $content;&lt;br&gt;    private int $totalElements;&lt;br&gt;    private int $offset;&lt;br&gt;    private int $limit;&lt;/pre&gt;&lt;pre&gt;    #[Pure] public function __construct()&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;content = new ArrayCollection();&lt;br&gt;    }&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page&lt;br&gt;    {&lt;br&gt;        $page = new Page();&lt;br&gt;        $page-&amp;gt;setContent($content)&lt;br&gt;            -&amp;gt;setTotalElements($totalElements)&lt;br&gt;            -&amp;gt;setOffset($offset)&lt;br&gt;            -&amp;gt;setLimit($limit);&lt;/pre&gt;&lt;pre&gt;        return $page;&lt;br&gt;    }&lt;br&gt;    &lt;br&gt;    //&lt;br&gt;    //getters&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;h3&gt;Customzing ArgumentResolver&lt;/h3&gt;&lt;p&gt;In the PostController , let&amp;#39;s improve the the function which serves the route /posts, make it accept query parameters like &lt;em&gt;/posts?q=Symfony&amp;amp;offset=0&amp;amp;limit=10&lt;/em&gt;, and ensure the parameters are optional.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    function all(Request $req): Response&lt;br&gt;    {&lt;br&gt;        $keyword = $req-&amp;gt;query-&amp;gt;get(&amp;#39;q&amp;#39;)??&amp;#39;&amp;#39;;&lt;br&gt;        $offset = $req-&amp;gt;query-&amp;gt;get(&amp;#39;offset&amp;#39;)??0;&lt;br&gt;        $limit = $req-&amp;gt;query-&amp;gt;get(&amp;#39;limit&amp;#39;)??10;&lt;br&gt;        &lt;br&gt;        $data = $this-&amp;gt;posts-&amp;gt;findByKeyword($keyword, $offset, $limit);&lt;br&gt;        return $this-&amp;gt;json($data);&lt;br&gt;    }&lt;/pre&gt;&lt;p&gt;It works but the query parameters handling looks a little ugly. It is great if they can be handled as the route path parameters.&lt;/p&gt;&lt;p&gt;We can create a custom ArgumentResolver to resolve the bound query arguments.&lt;/p&gt;&lt;p&gt;Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this ArgumentResolver.&lt;/p&gt;&lt;pre&gt;#[Attribute(Attribute::TARGET_PARAMETER)]&lt;br&gt;final class QueryParam&lt;br&gt;{&lt;br&gt;    private null|string $name;&lt;br&gt;    private bool $required;&lt;/pre&gt;&lt;pre&gt;    /**&lt;br&gt;     * @param string|null $name&lt;br&gt;     * @param bool $required&lt;br&gt;     */&lt;br&gt;    public function __construct(?string $name = null, bool $required = false)&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;name = $name;&lt;br&gt;        $this-&amp;gt;required = $required;&lt;br&gt;    }&lt;br&gt;    &lt;br&gt;    //getters and setters&lt;br&gt;    &lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Create a custom ArgumentResolver implements the built-in ArgugmentResolverInterface.&lt;/p&gt;&lt;pre&gt;class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface&lt;br&gt;{&lt;br&gt;    public function __construct()&lt;br&gt;    {&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private LoggerInterface $logger;&lt;/pre&gt;&lt;pre&gt;    /**&lt;br&gt;     * @inheritDoc&lt;br&gt;     */&lt;br&gt;    public function resolve(Request $request, ArgumentMetadata $argument)&lt;br&gt;    {&lt;br&gt;        $argumentName = $argument-&amp;gt;getName();&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;info(&amp;quot;Found [QueryParam] annotation/attribute on argument &amp;#39;&amp;quot; . $argumentName . &amp;quot;&amp;#39;, applying [QueryParamValueResolver]&amp;quot;);&lt;br&gt;        $type = $argument-&amp;gt;getType();&lt;br&gt;        $nullable = $argument-&amp;gt;isNullable();&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The method argument type: &amp;#39;&amp;quot; . $type . &amp;quot;&amp;#39; and nullable: &amp;#39;&amp;quot; . $nullable . &amp;quot;&amp;#39;&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        //read name property from QueryParam&lt;br&gt;        $attr = $argument-&amp;gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;QueryParam:&amp;quot; . $attr);&lt;br&gt;        //if name property is not set in `QueryParam`, use the argument name instead.&lt;br&gt;        $name = $attr-&amp;gt;getName() ?? $argumentName;&lt;br&gt;        $required = $attr-&amp;gt;isRequired() ?? false;&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;Polished QueryParam values: name=&amp;#39;&amp;quot; . $name . &amp;quot;&amp;#39;, required=&amp;#39;&amp;quot; . $required . &amp;quot;&amp;#39;&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        //fetch query name from request&lt;br&gt;        $value = $request-&amp;gt;query-&amp;gt;get($name);&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The request query parameter value: &amp;#39;&amp;quot; . $value . &amp;quot;&amp;#39;&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        //if default value is set and query param value is not set, use default value instead.&lt;br&gt;        if (!$value &amp;amp;&amp;amp; $argument-&amp;gt;hasDefaultValue()) {&lt;br&gt;            $value = $argument-&amp;gt;getDefaultValue();&lt;br&gt;            $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;After set default value: &amp;#39;&amp;quot; . $value . &amp;quot;&amp;#39;&amp;quot;);&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        if ($required &amp;amp;&amp;amp; !$value) {&lt;br&gt;            throw new \InvalidArgumentException(&amp;quot;Request query parameter &amp;#39;&amp;quot; . $name . &amp;quot;&amp;#39; is required, but not set.&amp;quot;);&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;final resolved value: &amp;#39;&amp;quot; . $value . &amp;quot;&amp;#39;&amp;quot;);&lt;br&gt;        &lt;br&gt;        //must return  a `yield` clause&lt;br&gt;        yield match ($type) {&lt;br&gt;            &amp;#39;int&amp;#39; =&amp;gt; $value ? (int)$value : 0,&lt;br&gt;            &amp;#39;float&amp;#39; =&amp;gt; $value ? (float)$value : .0,&lt;br&gt;            &amp;#39;bool&amp;#39; =&amp;gt; (bool)$value,&lt;br&gt;            &amp;#39;string&amp;#39; =&amp;gt; $value ? (string)$value : ($nullable ? null : &amp;#39;&amp;#39;),&lt;br&gt;            null =&amp;gt; null&lt;br&gt;        };&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public function supports(Request $request, ArgumentMetadata $argument): bool&lt;br&gt;    {&lt;br&gt;        $attrs = $argument-&amp;gt;getAttributes(QueryParam::class);&lt;br&gt;        return count($attrs) &amp;gt; 0;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public function setLogger(LoggerInterface $logger)&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;logger = $logger;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;At runtime, it calls the supports function to check it the current request satisfy the requirement, if it is ok, then invoke the resovle funtion.&lt;/p&gt;&lt;p&gt;In the supports function, we check if the argument is annotated with a QueryParam, if it is existed, then resolved the argument from request query string.&lt;/p&gt;&lt;p&gt;Now change the function that serves &lt;em&gt;/posts&lt;/em&gt; endpoint to the following.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;function all(#[QueryParam] $keyword,&lt;br&gt;    #[QueryParam] int $offset = 0,&lt;br&gt;    #[QueryParam] int $limit = 20): Response&lt;br&gt;    {&lt;br&gt;        $data = $this-&amp;gt;posts-&amp;gt;findByKeyword($keyword || &amp;#39;&amp;#39;, $offset, $limit);&lt;br&gt;        return $this-&amp;gt;json($data);&lt;br&gt;    }&lt;/pre&gt;&lt;p&gt;Run the application and test the &lt;em&gt;/posts&lt;/em&gt; using curl.&lt;/p&gt;&lt;pre&gt;# curl &lt;a href=&quot;http://localhost:8000/posts&quot;&gt;http://localhost:8000/posts&lt;/a&gt;&lt;br&gt;{&lt;br&gt;    &amp;quot;content&amp;quot;:[&lt;br&gt;    	{&lt;br&gt;            &amp;quot;id&amp;quot;:&amp;quot;1ec3e1e0-17b3-6ed2-a01c-edecc112b436&amp;quot;,&lt;br&gt;            &amp;quot;title&amp;quot;:&amp;quot;Building Restful APIs with Symfony and PHP 8&amp;quot;&lt;br&gt;        }&lt;br&gt;    ],&lt;br&gt;    &amp;quot;totalElements&amp;quot;:1,&lt;br&gt;    &amp;quot;offset&amp;quot;:0,&lt;br&gt;    &amp;quot;limit&amp;quot;:20&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Get Post by ID&lt;/h3&gt;&lt;p&gt;Follow the design in the previous section, add another function to PostController to map route /posts/{id} .&lt;/p&gt;&lt;pre&gt;class PostController extends AbstractController&lt;br&gt;{&lt;br&gt;	//other functions...&lt;/pre&gt;&lt;pre&gt;    #[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;    function getById(Uuid $id): Response&lt;br&gt;    {&lt;br&gt;        $data = $this-&amp;gt;posts-&amp;gt;findOneBy([&amp;quot;id&amp;quot; =&amp;gt; $id]);&lt;br&gt;        if ($data) {&lt;br&gt;            return $this-&amp;gt;json($data);&lt;br&gt;        } else {&lt;br&gt;            return $this-&amp;gt;json([&amp;quot;error&amp;quot; =&amp;gt; &amp;quot;Post was not found by id:&amp;quot; . $id], 404);&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Run the application, and try to access &lt;a href=&quot;http://localhost:8000/posts/%7Bid%7D&quot;&gt;&lt;em&gt;http://localhost:8000/posts/{id}&lt;/em&gt;&lt;/a&gt;, it will throw an exception like this.&lt;/p&gt;&lt;pre&gt;App\Controller\PostController::getById(): Argument #1 ($id) must be of type Symfony\Component\Uid\Uuid, string given, cal&lt;br&gt;led in D:\hantsylabs\symfony5-sample\rest-sample\vendor\symfony\http-kernel\HttpKernel.php on line 156&lt;/pre&gt;&lt;p&gt;The id in the URI is a string, can not be used as Uuid directly.&lt;/p&gt;&lt;p&gt;Symfony provides ParamConverter to convert the request attributes to the target type. We can create a custom ParamConverter to archive the purpose.&lt;/p&gt;&lt;h3&gt;Customizing ParamConverter&lt;/h3&gt;&lt;p&gt;Create a new class UuidParamCovnerter under &lt;em&gt;src/Request/&lt;/em&gt; folder.&lt;/p&gt;&lt;pre&gt;class UuidParamConverter implements ParamConverterInterface&lt;br&gt;{&lt;br&gt;    public function __construct(private LoggerInterface $logger)&lt;br&gt;    {&lt;br&gt;    }&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    /**&lt;br&gt;     * @inheritDoc&lt;br&gt;     */&lt;br&gt;    public function apply(Request $request, ParamConverter $configuration): bool&lt;br&gt;    {&lt;/pre&gt;&lt;pre&gt;        $param = $configuration-&amp;gt;getName();&lt;/pre&gt;&lt;pre&gt;        if (!$request-&amp;gt;attributes-&amp;gt;has($param)) {&lt;br&gt;            return false;&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        $value = $request-&amp;gt;attributes-&amp;gt;get($param);&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;info(&amp;quot;parameter value:&amp;quot; . $value);&lt;br&gt;        if (!$value &amp;amp;&amp;amp; $configuration-&amp;gt;isOptional()) {&lt;br&gt;            $request-&amp;gt;attributes-&amp;gt;set($param, null);&lt;/pre&gt;&lt;pre&gt;            return true;&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        $data = Uuid::fromString($value);&lt;br&gt;        $request-&amp;gt;attributes-&amp;gt;set($param, $data);&lt;/pre&gt;&lt;pre&gt;        return true;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    /**&lt;br&gt;     * @inheritDoc&lt;br&gt;     */&lt;br&gt;    public function supports(ParamConverter $configuration): bool&lt;br&gt;    {&lt;br&gt;        $className = $configuration-&amp;gt;getClass();&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;info(&amp;quot;converting to UUID :{c}&amp;quot;, [&amp;quot;c&amp;quot; =&amp;gt; $className]);&lt;br&gt;        return $className &amp;amp;&amp;amp; $className == Uuid::class;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In the above codes,&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The supports function to check the execution environment if matching the requirements&lt;/li&gt;&lt;li&gt;The apply function to perform the conversion. if supports returns false, this conversion step will be skipped.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Creating a Post&lt;/h3&gt;&lt;p&gt;Follow the REST convention, define the following rule to serve an endpoint to handle the request.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Request matches Http verbs/HTTP Method: POST&lt;/li&gt;&lt;li&gt;Request matches route endpoint: &lt;em&gt;/posts&lt;/em&gt;&lt;/li&gt;&lt;li&gt;Set request header Content-Type value to &lt;em&gt;application/json&lt;/em&gt;, and use request body to hold request data as JSON format&lt;/li&gt;&lt;li&gt;If successful, return a CREATED(201) Http Status code, and set the response header &lt;em&gt;Location&lt;/em&gt; value to the URI of the new created post.&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;create&amp;quot;, methods: [&amp;quot;POST&amp;quot;])]&lt;br&gt;public function create(Request $request): Response&lt;br&gt;{&lt;br&gt;    $data = $this-&amp;gt;serializer-&amp;gt;deserialize($request-&amp;gt;getContent(), CreatePostDto::class, &amp;#39;json&amp;#39;);&lt;br&gt;    $entity = PostFactory::create($data-&amp;gt;getTitle(), $data-&amp;gt;getContent());&lt;br&gt;    $this-&amp;gt;posts-&amp;gt;getEntityManager()-&amp;gt;persist($entity);&lt;/pre&gt;&lt;pre&gt;    return $this-&amp;gt;json([], 201, [&amp;quot;Location&amp;quot; =&amp;gt; &amp;quot;/posts/&amp;quot; . $entity-&amp;gt;getId()]);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The posts-&amp;gt;getEntityManager() overrides parent methods to get a EntityManager from parent class, you can also inject ObjectManager or EntityManagerInterface in the PostController directly to do the persistence work. The Doctrine Repository is mainly designated to build query criteria and execute custom queries.&lt;/p&gt;&lt;p&gt;Create a test function to verify in the PostControllerTest file.&lt;/p&gt;&lt;pre&gt;public function testCreatePost(): void&lt;br&gt;{&lt;br&gt;    $client = static::createClient();&lt;br&gt;    $data = CreatePostDto::of(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;);&lt;br&gt;    $crawler = $client-&amp;gt;request(&lt;br&gt;        &amp;#39;POST&amp;#39;,&lt;br&gt;        &amp;#39;/posts&amp;#39;,&lt;br&gt;        [],&lt;br&gt;        [],&lt;br&gt;        [],&lt;br&gt;        $this-&amp;gt;getContainer()-&amp;gt;get(&amp;#39;serializer&amp;#39;)-&amp;gt;serialize($data, &amp;#39;json&amp;#39;)&lt;br&gt;    );&lt;/pre&gt;&lt;pre&gt;    $this-&amp;gt;assertResponseIsSuccessful();&lt;/pre&gt;&lt;pre&gt;    $response = $client-&amp;gt;getResponse();&lt;br&gt;    $url = $response-&amp;gt;headers-&amp;gt;get(&amp;#39;Location&amp;#39;);&lt;br&gt;    //dump($data);&lt;br&gt;    $this-&amp;gt;assertNotNull($url);&lt;br&gt;    $this-&amp;gt;assertStringStartsWith(&amp;quot;/posts/&amp;quot;, $url);&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Converting Request Body&lt;/h3&gt;&lt;p&gt;We can also use an Annotation/Attribute to erase the raw codes of handling Request object through introducing a custom ArgumentResolver.&lt;/p&gt;&lt;p&gt;Create a Body &lt;em&gt;Attribute&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;#[Attribute(Attribute::TARGET_PARAMETER)]&lt;br&gt;final class Body&lt;br&gt;{&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Then create a BodyValueResolver.&lt;/p&gt;&lt;pre&gt;class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface&lt;br&gt;{&lt;br&gt;    public function __construct(private SerializerInterface $serializer)&lt;br&gt;    {&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private LoggerInterface $logger;&lt;/pre&gt;&lt;pre&gt;    /**&lt;br&gt;     * @inheritDoc&lt;br&gt;     */&lt;br&gt;    public function resolve(Request $request, ArgumentMetadata $argument)&lt;br&gt;    {&lt;br&gt;        $type = $argument-&amp;gt;getType();&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The argument type:&amp;#39;&amp;quot; . $type . &amp;quot;&amp;#39;&amp;quot;);&lt;br&gt;        $format = $request-&amp;gt;getContentType() ?? &amp;#39;json&amp;#39;;&lt;br&gt;        $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The request format:&amp;#39;&amp;quot; . $format . &amp;quot;&amp;#39;&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        //read request body&lt;br&gt;        $content = $request-&amp;gt;getContent();&lt;br&gt;        $data = $this-&amp;gt;serializer-&amp;gt;deserialize($content, $type, $format);&lt;br&gt;       // $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;deserialized data:{0}&amp;quot;, [$data]);&lt;br&gt;        yield $data;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    /**&lt;br&gt;     * @inheritDoc&lt;br&gt;     */&lt;br&gt;    public function supports(Request $request, ArgumentMetadata $argument): bool&lt;br&gt;    {&lt;br&gt;        $attrs = $argument-&amp;gt;getAttributes(Body::class);&lt;br&gt;        return count($attrs) &amp;gt; 0;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public function setLogger(LoggerInterface $logger)&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;logger = $logger;&lt;br&gt;    }&lt;/pre&gt;&lt;p&gt;In the supports method, it simply detects if the method argument annotated with a Body attribute, then apply resolve method to deserialize the request body content to a typed object.&lt;/p&gt;&lt;p&gt;Run the application and test the endpoint through &lt;em&gt;/posts&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;curl -v &lt;a href=&quot;http://localhost:8000/posts&quot;&gt;http://localhost:8000/posts&lt;/a&gt; -H &amp;quot;Content-Type:application/json&amp;quot; -d &amp;quot;{\&amp;quot;title\&amp;quot;:\&amp;quot;test title\&amp;quot;,\&amp;quot;content\&amp;quot;:\&amp;quot;test content\&amp;quot;}&amp;quot;&lt;br&gt;&amp;gt; POST /posts HTTP/1.1&lt;br&gt;&amp;gt; Host: localhost:8000&lt;br&gt;&amp;gt; User-Agent: curl/7.55.1&lt;br&gt;&amp;gt; Accept: */*&lt;br&gt;&amp;gt; Content-Type:application/json&lt;br&gt;&amp;gt; Content-Length: 47&lt;br&gt;&amp;gt;&lt;br&gt;&amp;lt; HTTP/1.1 201 Created&lt;br&gt;&amp;lt; Cache-Control: no-cache, private&lt;br&gt;&amp;lt; Content-Type: application/json&lt;br&gt;&amp;lt; Date: Sun, 21 Nov 2021 08:42:49 GMT&lt;br&gt;&amp;lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e&lt;br&gt;&amp;lt; X-Powered-By: PHP/8.0.10&lt;br&gt;&amp;lt; X-Robots-Tag: noindex&lt;br&gt;&amp;lt; Content-Length: 2&lt;br&gt;&amp;lt;&lt;br&gt;[]&lt;/pre&gt;&lt;h3&gt;Exception Handling&lt;/h3&gt;&lt;p&gt;Symfony kernel provides a event machoism to raise an Exception in Controller class and handle them in your custom EventListener or EventSubscriber .&lt;/p&gt;&lt;p&gt;For example, create a PostNotFoundException.&lt;/p&gt;&lt;pre&gt;class PostNotFoundException extends \RuntimeException&lt;br&gt;{&lt;/pre&gt;&lt;pre&gt;    public function __construct(Uuid $uuid)&lt;br&gt;    {&lt;br&gt;        parent::__construct(&amp;quot;Post #&amp;quot; . $uuid . &amp;quot; was not found&amp;quot;);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Create a EventListener to catch this exception, and handle the exception as expected.&lt;/p&gt;&lt;pre&gt;class ExceptionListener implements LoggerAwareInterface&lt;br&gt;{&lt;br&gt;    private LoggerInterface $logger;&lt;/pre&gt;&lt;pre&gt;    public function __construct()&lt;br&gt;    {&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public function onKernelException(ExceptionEvent $event)&lt;br&gt;    {&lt;br&gt;        // You get the exception object from the received event&lt;br&gt;        $exception = $event-&amp;gt;getThrowable();&lt;br&gt;        $data = [&amp;quot;error&amp;quot; =&amp;gt; $exception-&amp;gt;getMessage()];&lt;/pre&gt;&lt;pre&gt;        // Customize your response object to display the exception details&lt;br&gt;        $response = new JsonResponse($data);&lt;/pre&gt;&lt;pre&gt;        // HttpExceptionInterface is a special type of exception that&lt;br&gt;        // holds status code and header details&lt;/pre&gt;&lt;pre&gt;        if ($exception instanceof PostNotFoundException) {&lt;br&gt;            $response-&amp;gt;setStatusCode(Response::HTTP_NOT_FOUND);&lt;br&gt;        } else if ($exception instanceof HttpExceptionInterface) {&lt;br&gt;            $response-&amp;gt;setStatusCode($exception-&amp;gt;getStatusCode());&lt;br&gt;            $response-&amp;gt;headers-&amp;gt;replace($exception-&amp;gt;getHeaders());&lt;br&gt;        } else {&lt;br&gt;            $response-&amp;gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        // sends the modified response object to the event&lt;br&gt;        $event-&amp;gt;setResponse($response);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public function setLogger(LoggerInterface $logger)&lt;br&gt;    {&lt;br&gt;        $this-&amp;gt;logger = $logger;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Register this ExceptionListener in &lt;em&gt;config/service.yml&lt;/em&gt; file.&lt;/p&gt;&lt;pre&gt;App\EventListener\ExceptionListener:&lt;br&gt;    tags:&lt;br&gt;      - { name: kernel.event_listener, event: kernel.exception, priority: 50 }&lt;/pre&gt;&lt;p&gt;It indicates it binds event.exception event to ExceptionListener, and set priority to set the order at execution time.&lt;/p&gt;&lt;p&gt;Run the following command to show all registered EventListener/EventSubscribers on event &lt;em&gt;kernel.exception&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;php bin/console debug:event-subscriber kernel.exception&lt;/pre&gt;&lt;p&gt;Change the getById function to the following.&lt;/p&gt;&lt;pre&gt;#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]&lt;br&gt;function getById(Uuid $id): Response&lt;br&gt;{&lt;br&gt;    $data = $this-&amp;gt;posts-&amp;gt;findOneBy([&amp;quot;id&amp;quot; =&amp;gt; $id]);&lt;br&gt;    if ($data) {&lt;br&gt;   		return $this-&amp;gt;json($data);&lt;br&gt;    } else {&lt;br&gt;    	throw new PostNotFoundException($id);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Add a test to verify if the post is not found and get a 404 status code.&lt;/p&gt;&lt;pre&gt;public function testGetANoneExistingPost(): void&lt;br&gt;{&lt;br&gt;    $client = static::createClient();&lt;br&gt;    $id = Uuid::v4();&lt;br&gt;    $crawler = $client-&amp;gt;request(&amp;#39;GET&amp;#39;, &amp;#39;/posts/&amp;#39; . $id);&lt;/pre&gt;&lt;pre&gt;    //&lt;br&gt;    $response = $client-&amp;gt;getResponse();&lt;br&gt;    $this-&amp;gt;assertResponseStatusCodeSame(404);&lt;br&gt;    $data = $response-&amp;gt;getContent();&lt;br&gt;    $this-&amp;gt;assertStringContainsString(&amp;quot;Post #&amp;quot; . $id . &amp;quot; was not found&amp;quot;, $data);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Run the application again, and try to access a single Post through a none existing id.&lt;/p&gt;&lt;pre&gt;curl &lt;a href=&quot;http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438&quot;&gt;http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438&lt;/a&gt; -H &amp;quot;Accept: application/json&amp;quot; -v&lt;br&gt;&amp;gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1&lt;br&gt;&amp;gt; Host: localhost:8000&lt;br&gt;&amp;gt; User-Agent: curl/7.55.1&lt;br&gt;&amp;gt; Accept: application/json&lt;br&gt;&amp;gt;&lt;br&gt;&amp;lt; HTTP/1.1 404 Not Found&lt;br&gt;&amp;lt; Cache-Control: no-cache, private&lt;br&gt;&amp;lt; Content-Type: application/json&lt;br&gt;&amp;lt; Date: Mon, 22 Nov 2021 03:57:51 GMT&lt;br&gt;&amp;lt; X-Powered-By: PHP/8.0.10&lt;br&gt;&amp;lt; X-Robots-Tag: noindex&lt;br&gt;&amp;lt; Content-Length: 69&lt;br&gt;&amp;lt;&lt;br&gt;{&amp;quot;error&amp;quot;:&amp;quot;Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.&amp;quot;}&lt;/pre&gt;&lt;h4&gt;Get the &lt;a href=&quot;https://github.com/hantsy/symfony5-sample/tree/master/rest-sample&quot;&gt;complete source codes&lt;/a&gt; from my Github.&lt;/h4&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=35368a6246ad&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/building-restful-apis-with-symfony-5-and-php-8-35368a6246ad&quot;&gt;Building Restful APIs with Symfony 5 and PHP 8&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">Symfony is a full-featured modularized PHP framework that is used for building all kinds of applications, from traditional web applications to small Microservice components.Photo by te chan on UnsplashGet your feet wetInstall PHP 8 and PHP Composer tools.# choco php composerInstall [Symfony CLI](symfony check:requirements), check the system requirements.# symfony check:requirementsSymfony Requirements Checker~~~~~~~~~~~~~~~~~~~~~~~~~~~~&amp;gt; PHP is using the following php.ini file:C:\tools\php80\php.ini&amp;gt; Checking Symfony requirements:....................WWW......... [OK] Your system is ready to run Symfony projects Optional recommendations to improve your setup~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * intl extension should be available &amp;gt; Install and enable the intl extension (used for validators). * a PHP accelerator should be installed &amp;gt; Install and/or enable a PHP accelerator (highly recommended). * realpath_cache_size should be at least 5M in php.ini &amp;gt; Setting &amp;quot;realpath_cache_size&amp;quot; to e.g. &amp;quot;5242880&amp;quot; or &amp;quot;5M&amp;quot; in &amp;gt; php.ini* may improve performance on Windows significantly in some &amp;gt; cases.Note The command console can use a different php.ini file~~~~ than the one used by your web server. Please check that both the console and the web server are using the same PHP version and configuration.According to the recommendations info, adjust your PHP configuration in the php.ini. And we will use Postgres as database in the sample application, make sure pdo_pgsql and pgsql modules are enabled.Finally, you can confirm the enabled modules by the following command.# php -mCreate a new Symfony project.# symfony new rest-sample// a classic website application# symfony new web-sample --fullBy default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application.Alternatively, you can create it using Composer.# composer create-project symfony/skeleton rest-sample//start a classic website application# composer create-project symfony/website-skeleton web-sampleEnter the generated project root folder, start the application.# symfony server:start [WARNING] run &amp;quot;symfony.exe server:ca:install&amp;quot; first if you want to run the web server with TLS support, or use &amp;quot;--no- tls&amp;quot; to avoid this warning Tailing PHP-CGI log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)Tailing Web Server log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158.log) [OK] Web server listening The Web server is using PHP CGI 8.0.10 http://127.0.0.1:8000 [Web Server ] Oct 4 13:33:01 |DEBUG | PHP Reloading PHP versions[Web Server ] Oct 4 13:33:01 |DEBUG | PHP Using PHP version 8.0.10 (from default version in $PATH)[Web Server ] Oct 4 13:33:01 |INFO | PHP listening path=&amp;quot;C:\\tools\\php80\\php-cgi.exe&amp;quot; php=&amp;quot;8.0.10&amp;quot; port=61738Hello , SymfonyCreate a simple class to a resource entity in the HTTP response.class Post{ private ?string $id = null; private string $title; private string $content; //getters and setters.}And use a factory to create a new Post instance.class PostFactory{ public static function create(string $title, string $content): Post { $post = new Post(); $post-&amp;gt;setTitle($title); $post-&amp;gt;setContent($content); return $post; }}Let’s create a simple Controller class.To use the newest PHP 8 attributes to configure the routing rules, apply the following changes in the project configurations.Open config/packages/doctrine.yaml, remove doctrine/orm/mapping/App/type or change its value to attributeOpen composer.json, change PHP version to &amp;gt;=8.0.0.To render the response body into a JSON string, use a JsonReponse to wrap the response.#[Route(path: &amp;quot;/posts&amp;quot;, name: &amp;quot;posts_&amp;quot;)]class PostController{ #[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] function all(): Response { $post1 = PostFactory::create(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;); $post1-&amp;gt;setId(&amp;quot;1&amp;quot;); $post2 = PostFactory::create(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;); $post2-&amp;gt;setId(&amp;quot;2&amp;quot;); $data = [$post1-&amp;gt;asArray(), $post2-&amp;gt;asArray()]; return new JsonResponse($data, 200, [&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;]); //return $this-&amp;gt;json($data, 200, [&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;]); }}The first parameter of JsonReponse accepts an array as data, so add a function in the Post class to archive this purpose.class Post{ //... public function asArray(): array { return [ &amp;#39;id&amp;#39; =&amp;gt; $this-&amp;gt;id, &amp;#39;title&amp;#39; =&amp;gt; $this-&amp;gt;title, &amp;#39;content&amp;#39; =&amp;gt; $this-&amp;gt;content ]; }}Run the application, use curl to test the /posts endpoint.# curl http://localhost:8000/postsSymfony provides a simple AbstractController which includes several functions to simplfy the response and adopt the container and dependency injection management.In the above controller, extends from AbstractController, simply call $this-&amp;gt;json to render the response in JSON format, no need to transform the data to an array before rendering response.class PostController extends AbstractController{ function all(): Response { //... return $this-&amp;gt;json($data, 200, [&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;]); }}Connecting to DatabaseDoctrine is a popular ORM framework , it is highly inspired by the existing Java ORM tooling, such as JPA spec and Hibernate framework. There are two core components in Doctrine, doctrine/dbal and doctrine/orm, the former is a low level APIs for database operations, if you know Java development, consider it as the Jdbc layer. The later is the advanced ORM framework, the public APIs are similar to JPA/Hibernate.Install Doctrine into the project.# composer require symfony/orm-pack# composer require --dev symfony/maker-bundleThe pack is a virtual Symfony package, it will install a series of packages and basic configurations.Open the .env file in the project root folder, edit the DATABASE_URL value, setup the database name, username, password to connect.DATABASE_URL=&amp;quot;postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;amp;charset=utf8&amp;quot;Use the following command to generate a docker compose file template.# php bin/console make:docker:databaseWe change it to the following to start up a Postgres database in development.version: &amp;quot;3.5&amp;quot; # specify docker-compose version, v3.5 is compatible with docker 17.12.0+# Define the services/containers to be runservices: postgres: image: postgres:${POSTGRES_VERSION:-13}-alpine ports: - &amp;quot;5432:5432&amp;quot; environment: POSTGRES_DB: ${POSTGRES_DB:-blogdb} # You should definitely change the password in production POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password} POSTGRES_USER: ${POSTGRES_USER:-user} volumes: - ./data/blogdb:/var/lib/postgresql/data:rw - ./pg-initdb.d:/docker-entrypoint-initdb.dWe will use UUID as data type of the primary key, add a script to enable uuid-ossp extension in Postgres when it is starting up.-- file: pg-initdb.d/ini.sqlSET search_path TO public;DROP EXTENSION IF EXISTS &amp;quot;uuid-ossp&amp;quot;;CREATE EXTENSION &amp;quot;uuid-ossp&amp;quot; SCHEMA public;Open config/packages/test/doctrine.yaml, comment out dbname_suffix line. We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production.Now startup the application and make sure there is no exception in the console, that means the database connection is successful.symfony server:startBefore starting the application, make sure the database is running. Run the following command to start up the Postgres in Docker.# docker compose up postgres# docker ps -a # to list all containers and make the postgres is runningBuilding Data ModelsNow we will build the Entities that will be used in the next sections. We are modeling a simple blog system, it includes the following concepts.A Post presents an article post in the blog system.A Comment presents the comments under a specific post.The common Tag can be applied on different posts, which categorizes posts by topic, categories , etc.You can draft your model relations in mind or through some graphic data modeling tools.Post and comments is a one-to-many relationPost and tag is a many-to-many relationIt is easy to convert the idea to real codes via Doctrine Entity. Run the following command to create Post, Comment and Tag entities.In the Doctrine ORM 2.10.x and Dbal 3.x, the UUID type ID generator is deprecated. We will switch to the Uuid form symfony\uid.Install symfony\uid firstly.# composer require symfony/uidSimply, you can use the following command to create entities quickly.# php bin/console make:entity # following the interactive steps to create them one by one.Finally we got three entities in the src/Entity folder. Modify them as you expected.// src/Entity/Post.php#[Entity(repositoryClass: PostRepository::class)]class Post{ #[Id] //#[GeneratedValue(strategy: &amp;quot;UUID&amp;quot;) //#[Column(type: &amp;quot;string&amp;quot;, unique: true)] #[Column(type: &amp;quot;uuid&amp;quot;, unique: true)] #[GeneratedValue(strategy: &amp;quot;CUSTOM&amp;quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &amp;quot;string&amp;quot;, length: 255)] private string $title; #[Column(type: &amp;quot;string&amp;quot;, length: 255)] private string $content; #[Column(name: &amp;quot;created_at&amp;quot;, type: &amp;quot;datetime&amp;quot;, nullable: true)] private DateTime|null $createdAt = null; #[Column(name: &amp;quot;published_at&amp;quot;, type: &amp;quot;datetime&amp;quot;, nullable: true)] private DateTime|null $publishedAt = null; #[OneToMany(mappedBy: &amp;quot;post&amp;quot;, targetEntity: Comment::class, cascade: [&amp;#39;persist&amp;#39;, &amp;#39;merge&amp;#39;, &amp;quot;remove&amp;quot;], fetch: &amp;#39;LAZY&amp;#39;, orphanRemoval: true)] private Collection $comments; #[ManyToMany(targetEntity: Tag::class, mappedBy: &amp;quot;posts&amp;quot;, cascade: [&amp;#39;persist&amp;#39;, &amp;#39;merge&amp;#39;], fetch: &amp;#39;EAGER&amp;#39;)] private Collection $tags; public function __construct() { $this-&amp;gt;createdAt = new DateTime(); $this-&amp;gt;comments = new ArrayCollection(); $this-&amp;gt;tags = new ArrayCollection(); } //other getters and setters}// src/Entity/Comment.php#[Entity(repositoryClass: CommentRepository::class)]class Comment{ #[Id] //#[GeneratedValue(strategy: &amp;quot;UUID&amp;quot;)] #[Column(type: &amp;quot;uuid&amp;quot;, unique: true)] #[GeneratedValue(strategy: &amp;quot;CUSTOM&amp;quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &amp;quot;string&amp;quot;, length: 255)] private string $content; #[Column(name: &amp;quot;created_at&amp;quot;, type: &amp;quot;datetime&amp;quot;, nullable: true)] private DateTime|null $createdAt = null; #[ManyToOne(targetEntity: &amp;quot;Post&amp;quot;, inversedBy: &amp;quot;comments&amp;quot;)] #[JoinColumn(name: &amp;quot;post_id&amp;quot;, referencedColumnName: &amp;quot;id&amp;quot;)] private Post $post; public function __construct() { $this-&amp;gt;createdAt = new DateTime(); } //other getters and setters}//src/Entity/Tag.php#[Entity(repositoryClass: TagRepository::class)]class Tag{ #[Id] //#[GeneratedValue(strategy: &amp;quot;UUID&amp;quot;) //#[Column(type: &amp;quot;string&amp;quot;, unique: true)] #[Column(type: &amp;quot;uuid&amp;quot;, unique: true)] #[GeneratedValue(strategy: &amp;quot;CUSTOM&amp;quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &amp;quot;string&amp;quot;, length: 255)] private ?string $name; #[ManyToMany(targetEntity: Post::class, inversedBy: &amp;quot;tags&amp;quot;)] private Collection $posts; public function __construct() { $this-&amp;gt;posts = new ArrayCollection(); }}At the same time, it generated three Repository classes for these entities.// src/Repository/PostRepsoitory.phpclass PostRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Post::class); }}// src/Repository/CommentRepsoitory.phpclass CommentRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Comment::class); }}//src/Repository/TagRepository.phpclass TagRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Tag::class); }}You can use Doctrine migration to generate a Migration file to maintain database schema in a production environment.Run the following command to generate a Migration file.# php bin/console make:migrationAfter it is executed, a Migration file is generated in the migrations folder, its naming is like Version20211104031420. It is a simple class extended AbstractMigration, the up function is use for upgrade to this version and down function is use for downgrade to the previous version.To apply Migrations on database automaticially.# php bin/console doctrine:migrations:migrate# return to prev version# php bin/console doctrine:migrations:migrate prev# migrate to next# php bin/console doctrine:migrations:migrate next# These alias are defined : first, latest, prev, current and next# certain version fully qualified class name# php bin/console doctrine:migrations:migrate FQCNDoctrine bundle also includes some command to maintain database and schema. eg.# php bin/console doctrine:database:create# php bin/console doctrine:database:drop// schema create, drop, update and validate# php bin/console doctrine:schema:create# php bin/console doctrine:schema:drop# php bin/console doctrine:schema:update# php bin/console doctrine:schema:validateAdding Sample DataCreate a custom command to load some sample data.# php bin/console make:command add-postIt will generate a AddPostCommand under src/Command folder.#[AsCommand( name: &amp;#39;app:add-post&amp;#39;, description: &amp;#39;Add a short description for your command&amp;#39;,)]class AddPostCommand extends Command{ public function __construct(private EntityManagerInterface $manager) { parent::__construct(); } protected function configure(): void { $this -&amp;gt;addArgument(&amp;#39;title&amp;#39;, InputArgument::REQUIRED, &amp;#39;Title of a post&amp;#39;) -&amp;gt;addArgument(&amp;#39;content&amp;#39;, InputArgument::REQUIRED, &amp;#39;Content of a post&amp;#39;) //-&amp;gt;addOption(&amp;#39;option1&amp;#39;, null, InputOption::VALUE_NONE, &amp;#39;Option description&amp;#39;) ; } protected function execute(InputInterface $input, OutputInterface $output): int { $io = new SymfonyStyle($input, $output); $title = $input-&amp;gt;getArgument(&amp;#39;title&amp;#39;); if ($title) { $io-&amp;gt;note(sprintf(&amp;#39;Title: %s&amp;#39;, $title)); } $content = $input-&amp;gt;getArgument(&amp;#39;content&amp;#39;); if ($content) { $io-&amp;gt;note(sprintf(&amp;#39;Content: %s&amp;#39;, $content)); } $entity = PostFactory::create($title, $content); $this -&amp;gt;manager-&amp;gt;persist($entity); $this -&amp;gt;manager-&amp;gt;flush();// if ($input-&amp;gt;getOption(&amp;#39;option1&amp;#39;)) {// // ...// } $io-&amp;gt;success(&amp;#39;Post is saved: &amp;#39;.$entity); return Command::SUCCESS; }}The Doctrine EntityManagerInterface is managed by Symfony Service Container, and use for data persistence operations.Run the following command to add a post into the database.# php bin/console app:add-post &amp;quot;test title&amp;quot; &amp;quot;test content&amp;quot; ! [NOTE] Title: test title ! [NOTE] Content: test content [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=]Testing RepositoryPHPUnit is the most popular testing framework in PHP world, Symfony integrates PHPUnit tightly.Run the following command to install PHPUnit and Symfony test-pack. The test-pack will install all essential packages for testing Symfony components and add PHPUnit configuration, such as phpunit.xml.dist.# composer require --dev phpunit/phpunit symfony/test-packAn simple test example written in pure PHPUnit.class PostTest extends TestCase{ public function testPost() { $p = PostFactory::create(&amp;quot;tests title&amp;quot;, &amp;quot;tests content&amp;quot;); $this-&amp;gt;assertEquals(&amp;quot;tests title&amp;quot;, $p-&amp;gt;getTitle()); $this-&amp;gt;assertEquals(&amp;quot;tests content&amp;quot;, $p-&amp;gt;getContent()); $this-&amp;gt;assertNotNull( $p-&amp;gt;getCreatedAt()); }}Symfony provides some specific base classes(KernelTestCase, WebTestCase, etc.) to simplfy the testing work in a Symfony project.The following is an example of testing a Repository - PostRepository. The KernelTestCase contains facilities to bootstrap application kernel and provides service container.class PostRepositoryTest extends KernelTestCase{ private EntityManagerInterface $entityManager; private PostRepository $postRepository; protected function setUp(): void { //(1) boot the Symfony kernel $kernel = self::bootKernel(); $this-&amp;gt;assertSame(&amp;#39;test&amp;#39;, $kernel-&amp;gt;getEnvironment()); $this-&amp;gt;entityManager = $kernel-&amp;gt;getContainer() -&amp;gt;get(&amp;#39;doctrine&amp;#39;) -&amp;gt;getManager(); //(2) use static::getContainer() to access the service container $container = static::getContainer(); //(3) get PostRepository from container. $this-&amp;gt;postRepository = $container-&amp;gt;get(PostRepository::class); } protected function tearDown(): void { parent::tearDown(); $this-&amp;gt;entityManager-&amp;gt;close(); } public function testCreatePost(): void { $entity = PostFactory::create(&amp;quot;test post&amp;quot;, &amp;quot;test content&amp;quot;); $this-&amp;gt;entityManager-&amp;gt;persist($entity); $this-&amp;gt;entityManager-&amp;gt;flush(); $this-&amp;gt;assertNotNull($entity-&amp;gt;getId()); $byId = $this-&amp;gt;postRepository-&amp;gt;findOneBy([&amp;quot;id&amp;quot; =&amp;gt; $entity-&amp;gt;getId()]); $this-&amp;gt;assertEquals(&amp;quot;test post&amp;quot;, $byId-&amp;gt;getTitle()); $this-&amp;gt;assertEquals(&amp;quot;test content&amp;quot;, $byId-&amp;gt;getContent()); }}In the above codes, in the setUp function, boot up the application kernel, after it is booted, a test scoped Service Container is available. Then get EntityManagerInterface and PostRepository from service container.In the testCreatePost function, persists a Post entity, and find this post by id and verify the title and content fields.Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes are similar to the legacy JUnit 4 code style.Creating PostController: Exposing your first Rest APISimilar to other MVC framework, we can expose RESTful APIs via Symfony Controller component. Follow the REST convention, we are planning to create the following APIs to a blog system.GET /posts Get all posts.GET /posts/{id} Get a single post by ID, if not found, return status 404POST /posts Create a new post from request body, add the new post URI to response header Location, and return status 201DELETE /posts/{id} Delete a single post by ID, return status 204. If the post was not found, return status 404 instead.…Run the following command to create a Controller skeleton. Follow the interactive guide to create a controller named PostController.# php bin/console make:constrollerOpen src/Controller/PostController.php in IDE.Add Route attribute on class level and two functions: one for fetching all posts and another for getting single post by ID.#[Route(path: &amp;quot;/posts&amp;quot;, name: &amp;quot;posts_&amp;quot;)]class PostController extends AbstractController{ public function __construct(private PostRepository $posts) { } #[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] function all(): Response { $data = $this-&amp;gt;posts-&amp;gt;findAll(); return $this-&amp;gt;json($data); } }Start up the application, and try to access the http://localhost:8000/posts, it will throw a circular dependencies exception when rendering the models in JSON view directly. There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view. Add a Ignore attribute on Comment.post and Tag.posts.//src/Entity/Comment.phpclass Comment{ #[Ignore] private Post $post;}//src/Entity/Tag.phpclass Tag{ #[Ignore] private Collection $posts;}Testing ControllerAs described in the previous sections, to test Controller/API, create a test class to extend WebTestCase, which provides a plenty of facilities to handle request and assert response.Run the following command to create a test skeleton.# php bin/console make:testFollow the interactive steps to create a test base on WebTestCase.class PostControllerTest extends WebTestCase{ public function testGetAllPosts(): void { $client = static::createClient(); $crawler = $client-&amp;gt;request(&amp;#39;GET&amp;#39;, &amp;#39;/posts&amp;#39;); $this-&amp;gt;assertResponseIsSuccessful(); // $response = $client-&amp;gt;getResponse(); $data = $response-&amp;gt;getContent(); //dump($data); $this-&amp;gt;assertStringContainsString(&amp;quot;Symfony and PHP&amp;quot;, $data); }}If you try to run the test, it will fail. At the moment, there is no any data for testing.Preparing Data for Testing PurposeThe doctrine/doctrine-fixtures-bundle is use for populate sample data for testing purpose, and dama/doctrine-test-bundle ensures the data is restored before evey test is running.Install doctrine/doctrine-fixtures-bundle and dama/doctrine-test-bundle.composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundleCreate a new Fixture.# php bin/console make:fixturesIn the load fucntion, persist some data for tests.class AppFixtures extends Fixture{ public function load(ObjectManager $manager): void { $data = PostFactory::create(&amp;quot;Building Restful APIs with Symfony and PHP 8&amp;quot;, &amp;quot;test content&amp;quot;); $data-&amp;gt;addTag(Tag::of( &amp;quot;Symfony&amp;quot;)) -&amp;gt;addTag( Tag::of(&amp;quot;PHP 8&amp;quot;)) -&amp;gt;addComment(Comment::of(&amp;quot;test comment 1&amp;quot;)) -&amp;gt;addComment(Comment::of(&amp;quot;test comment 2&amp;quot;)); $manager-&amp;gt;persist($data); $manager-&amp;gt;flush(); }}Run the command to load the sample data into database manually.# php bin/console doctrine:fixtures:loadAdd the following extension configuration into the phpunit.xml.dist, thus the data will be purged and recreated for every test running.&amp;lt;extensions&amp;gt; &amp;lt;extension class=&amp;quot;DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension&amp;quot;/&amp;gt;&amp;lt;/extensions&amp;gt;Run the following command to execute PostControllerTest.php .# php .\vendor\bin\phpunit .\tests\Controller\PostControllerTest.phpPaginating ResultThere are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a keyword provided by request to match Post title or content fields, a offset to set the offset position of the pagination, and a limit to set the limited size of the elements per page. Create a function in the PostRepository, accepts a keyword, offset and limit as arguments.public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page{ $query = $this-&amp;gt;createQueryBuilder(&amp;quot;p&amp;quot;) -&amp;gt;andWhere(&amp;quot;p.title like :q or p.content like :q&amp;quot;) -&amp;gt;setParameter(&amp;#39;q&amp;#39;, &amp;quot;%&amp;quot; . $q . &amp;quot;%&amp;quot;) -&amp;gt;orderBy(&amp;#39;p.createdAt&amp;#39;, &amp;#39;DESC&amp;#39;) -&amp;gt;setMaxResults($limit) -&amp;gt;setFirstResult($offset) -&amp;gt;getQuery(); $paginator = new Paginator($query, $fetchJoinCollection = false); $c = count($paginator); $content = new ArrayCollection(); foreach ($paginator as $post) { $content-&amp;gt;add(PostSummaryDto::of($post-&amp;gt;getId(), $post-&amp;gt;getTitle())); } return Page::of ($content, $c, $offset, $limit);}Firstly, create a dynamic query using createQueryBuilder , then create a Doctrine Paginator instance to execute the query. The Paginator implements Countable interface, use count to get the count of total elements. Finally, we use a custom Page object to wrap the result.class Page{ private Collection $content; private int $totalElements; private int $offset; private int $limit; #[Pure] public function __construct() { $this-&amp;gt;content = new ArrayCollection(); } public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page { $page = new Page(); $page-&amp;gt;setContent($content) -&amp;gt;setTotalElements($totalElements) -&amp;gt;setOffset($offset) -&amp;gt;setLimit($limit); return $page; } // //getters}Customzing ArgumentResolverIn the PostController , let&amp;#39;s improve the the function which serves the route /posts, make it accept query parameters like /posts?q=Symfony&amp;amp;offset=0&amp;amp;limit=10, and ensure the parameters are optional.#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] function all(Request $req): Response { $keyword = $req-&amp;gt;query-&amp;gt;get(&amp;#39;q&amp;#39;)??&amp;#39;&amp;#39;; $offset = $req-&amp;gt;query-&amp;gt;get(&amp;#39;offset&amp;#39;)??0; $limit = $req-&amp;gt;query-&amp;gt;get(&amp;#39;limit&amp;#39;)??10; $data = $this-&amp;gt;posts-&amp;gt;findByKeyword($keyword, $offset, $limit); return $this-&amp;gt;json($data); }It works but the query parameters handling looks a little ugly. It is great if they can be handled as the route path parameters.We can create a custom ArgumentResolver to resolve the bound query arguments.Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this ArgumentResolver.#[Attribute(Attribute::TARGET_PARAMETER)]final class QueryParam{ private null|string $name; private bool $required; /** * @param string|null $name * @param bool $required */ public function __construct(?string $name = null, bool $required = false) { $this-&amp;gt;name = $name; $this-&amp;gt;required = $required; } //getters and setters }Create a custom ArgumentResolver implements the built-in ArgugmentResolverInterface.class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct() { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $argumentName = $argument-&amp;gt;getName(); $this-&amp;gt;logger-&amp;gt;info(&amp;quot;Found [QueryParam] annotation/attribute on argument &amp;#39;&amp;quot; . $argumentName . &amp;quot;&amp;#39;, applying [QueryParamValueResolver]&amp;quot;); $type = $argument-&amp;gt;getType(); $nullable = $argument-&amp;gt;isNullable(); $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The method argument type: &amp;#39;&amp;quot; . $type . &amp;quot;&amp;#39; and nullable: &amp;#39;&amp;quot; . $nullable . &amp;quot;&amp;#39;&amp;quot;); //read name property from QueryParam $attr = $argument-&amp;gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;QueryParam:&amp;quot; . $attr); //if name property is not set in `QueryParam`, use the argument name instead. $name = $attr-&amp;gt;getName() ?? $argumentName; $required = $attr-&amp;gt;isRequired() ?? false; $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;Polished QueryParam values: name=&amp;#39;&amp;quot; . $name . &amp;quot;&amp;#39;, required=&amp;#39;&amp;quot; . $required . &amp;quot;&amp;#39;&amp;quot;); //fetch query name from request $value = $request-&amp;gt;query-&amp;gt;get($name); $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The request query parameter value: &amp;#39;&amp;quot; . $value . &amp;quot;&amp;#39;&amp;quot;); //if default value is set and query param value is not set, use default value instead. if (!$value &amp;amp;&amp;amp; $argument-&amp;gt;hasDefaultValue()) { $value = $argument-&amp;gt;getDefaultValue(); $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;After set default value: &amp;#39;&amp;quot; . $value . &amp;quot;&amp;#39;&amp;quot;); } if ($required &amp;amp;&amp;amp; !$value) { throw new \InvalidArgumentException(&amp;quot;Request query parameter &amp;#39;&amp;quot; . $name . &amp;quot;&amp;#39; is required, but not set.&amp;quot;); } $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;final resolved value: &amp;#39;&amp;quot; . $value . &amp;quot;&amp;#39;&amp;quot;); //must return a `yield` clause yield match ($type) { &amp;#39;int&amp;#39; =&amp;gt; $value ? (int)$value : 0, &amp;#39;float&amp;#39; =&amp;gt; $value ? (float)$value : .0, &amp;#39;bool&amp;#39; =&amp;gt; (bool)$value, &amp;#39;string&amp;#39; =&amp;gt; $value ? (string)$value : ($nullable ? null : &amp;#39;&amp;#39;), null =&amp;gt; null }; } public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&amp;gt;getAttributes(QueryParam::class); return count($attrs) &amp;gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&amp;gt;logger = $logger; }}At runtime, it calls the supports function to check it the current request satisfy the requirement, if it is ok, then invoke the resovle funtion.In the supports function, we check if the argument is annotated with a QueryParam, if it is existed, then resolved the argument from request query string.Now change the function that serves /posts endpoint to the following.#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;all&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]function all(#[QueryParam] $keyword, #[QueryParam] int $offset = 0, #[QueryParam] int $limit = 20): Response { $data = $this-&amp;gt;posts-&amp;gt;findByKeyword($keyword || &amp;#39;&amp;#39;, $offset, $limit); return $this-&amp;gt;json($data); }Run the application and test the /posts using curl.# curl http://localhost:8000/posts{ &amp;quot;content&amp;quot;:[ { &amp;quot;id&amp;quot;:&amp;quot;1ec3e1e0-17b3-6ed2-a01c-edecc112b436&amp;quot;, &amp;quot;title&amp;quot;:&amp;quot;Building Restful APIs with Symfony and PHP 8&amp;quot; } ], &amp;quot;totalElements&amp;quot;:1, &amp;quot;offset&amp;quot;:0, &amp;quot;limit&amp;quot;:20}Get Post by IDFollow the design in the previous section, add another function to PostController to map route /posts/{id} .class PostController extends AbstractController{ //other functions... #[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])] function getById(Uuid $id): Response { $data = $this-&amp;gt;posts-&amp;gt;findOneBy([&amp;quot;id&amp;quot; =&amp;gt; $id]); if ($data) { return $this-&amp;gt;json($data); } else { return $this-&amp;gt;json([&amp;quot;error&amp;quot; =&amp;gt; &amp;quot;Post was not found by id:&amp;quot; . $id], 404); } }}Run the application, and try to access http://localhost:8000/posts/{id}, it will throw an exception like this.App\Controller\PostController::getById(): Argument #1 ($id) must be of type Symfony\Component\Uid\Uuid, string given, called in D:\hantsylabs\symfony5-sample\rest-sample\vendor\symfony\http-kernel\HttpKernel.php on line 156The id in the URI is a string, can not be used as Uuid directly.Symfony provides ParamConverter to convert the request attributes to the target type. We can create a custom ParamConverter to archive the purpose.Customizing ParamConverterCreate a new class UuidParamCovnerter under src/Request/ folder.class UuidParamConverter implements ParamConverterInterface{ public function __construct(private LoggerInterface $logger) { } /** * @inheritDoc */ public function apply(Request $request, ParamConverter $configuration): bool { $param = $configuration-&amp;gt;getName(); if (!$request-&amp;gt;attributes-&amp;gt;has($param)) { return false; } $value = $request-&amp;gt;attributes-&amp;gt;get($param); $this-&amp;gt;logger-&amp;gt;info(&amp;quot;parameter value:&amp;quot; . $value); if (!$value &amp;amp;&amp;amp; $configuration-&amp;gt;isOptional()) { $request-&amp;gt;attributes-&amp;gt;set($param, null); return true; } $data = Uuid::fromString($value); $request-&amp;gt;attributes-&amp;gt;set($param, $data); return true; } /** * @inheritDoc */ public function supports(ParamConverter $configuration): bool { $className = $configuration-&amp;gt;getClass(); $this-&amp;gt;logger-&amp;gt;info(&amp;quot;converting to UUID :{c}&amp;quot;, [&amp;quot;c&amp;quot; =&amp;gt; $className]); return $className &amp;amp;&amp;amp; $className == Uuid::class; }}In the above codes,The supports function to check the execution environment if matching the requirementsThe apply function to perform the conversion. if supports returns false, this conversion step will be skipped.Creating a PostFollow the REST convention, define the following rule to serve an endpoint to handle the request.Request matches Http verbs/HTTP Method: POSTRequest matches route endpoint: /postsSet request header Content-Type value to application/json, and use request body to hold request data as JSON formatIf successful, return a CREATED(201) Http Status code, and set the response header Location value to the URI of the new created post.#[Route(path: &amp;quot;&amp;quot;, name: &amp;quot;create&amp;quot;, methods: [&amp;quot;POST&amp;quot;])]public function create(Request $request): Response{ $data = $this-&amp;gt;serializer-&amp;gt;deserialize($request-&amp;gt;getContent(), CreatePostDto::class, &amp;#39;json&amp;#39;); $entity = PostFactory::create($data-&amp;gt;getTitle(), $data-&amp;gt;getContent()); $this-&amp;gt;posts-&amp;gt;getEntityManager()-&amp;gt;persist($entity); return $this-&amp;gt;json([], 201, [&amp;quot;Location&amp;quot; =&amp;gt; &amp;quot;/posts/&amp;quot; . $entity-&amp;gt;getId()]);}The posts-&amp;gt;getEntityManager() overrides parent methods to get a EntityManager from parent class, you can also inject ObjectManager or EntityManagerInterface in the PostController directly to do the persistence work. The Doctrine Repository is mainly designated to build query criteria and execute custom queries.Create a test function to verify in the PostControllerTest file.public function testCreatePost(): void{ $client = static::createClient(); $data = CreatePostDto::of(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;); $crawler = $client-&amp;gt;request( &amp;#39;POST&amp;#39;, &amp;#39;/posts&amp;#39;, [], [], [], $this-&amp;gt;getContainer()-&amp;gt;get(&amp;#39;serializer&amp;#39;)-&amp;gt;serialize($data, &amp;#39;json&amp;#39;) ); $this-&amp;gt;assertResponseIsSuccessful(); $response = $client-&amp;gt;getResponse(); $url = $response-&amp;gt;headers-&amp;gt;get(&amp;#39;Location&amp;#39;); //dump($data); $this-&amp;gt;assertNotNull($url); $this-&amp;gt;assertStringStartsWith(&amp;quot;/posts/&amp;quot;, $url);}Converting Request BodyWe can also use an Annotation/Attribute to erase the raw codes of handling Request object through introducing a custom ArgumentResolver.Create a Body Attribute.#[Attribute(Attribute::TARGET_PARAMETER)]final class Body{}Then create a BodyValueResolver.class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct(private SerializerInterface $serializer) { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $type = $argument-&amp;gt;getType(); $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The argument type:&amp;#39;&amp;quot; . $type . &amp;quot;&amp;#39;&amp;quot;); $format = $request-&amp;gt;getContentType() ?? &amp;#39;json&amp;#39;; $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;The request format:&amp;#39;&amp;quot; . $format . &amp;quot;&amp;#39;&amp;quot;); //read request body $content = $request-&amp;gt;getContent(); $data = $this-&amp;gt;serializer-&amp;gt;deserialize($content, $type, $format); // $this-&amp;gt;logger-&amp;gt;debug(&amp;quot;deserialized data:{0}&amp;quot;, [$data]); yield $data; } /** * @inheritDoc */ public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&amp;gt;getAttributes(Body::class); return count($attrs) &amp;gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&amp;gt;logger = $logger; }In the supports method, it simply detects if the method argument annotated with a Body attribute, then apply resolve method to deserialize the request body content to a typed object.Run the application and test the endpoint through /posts.curl -v http://localhost:8000/posts -H &amp;quot;Content-Type:application/json&amp;quot; -d &amp;quot;{\&amp;quot;title\&amp;quot;:\&amp;quot;test title\&amp;quot;,\&amp;quot;content\&amp;quot;:\&amp;quot;test content\&amp;quot;}&amp;quot;&amp;gt; POST /posts HTTP/1.1&amp;gt; Host: localhost:8000&amp;gt; User-Agent: curl/7.55.1&amp;gt; Accept: */*&amp;gt; Content-Type:application/json&amp;gt; Content-Length: 47&amp;gt;&amp;lt; HTTP/1.1 201 Created&amp;lt; Cache-Control: no-cache, private&amp;lt; Content-Type: application/json&amp;lt; Date: Sun, 21 Nov 2021 08:42:49 GMT&amp;lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e&amp;lt; X-Powered-By: PHP/8.0.10&amp;lt; X-Robots-Tag: noindex&amp;lt; Content-Length: 2&amp;lt;[]Exception HandlingSymfony kernel provides a event machoism to raise an Exception in Controller class and handle them in your custom EventListener or EventSubscriber .For example, create a PostNotFoundException.class PostNotFoundException extends \RuntimeException{ public function __construct(Uuid $uuid) { parent::__construct(&amp;quot;Post #&amp;quot; . $uuid . &amp;quot; was not found&amp;quot;); }}Create a EventListener to catch this exception, and handle the exception as expected.class ExceptionListener implements LoggerAwareInterface{ private LoggerInterface $logger; public function __construct() { } public function onKernelException(ExceptionEvent $event) { // You get the exception object from the received event $exception = $event-&amp;gt;getThrowable(); $data = [&amp;quot;error&amp;quot; =&amp;gt; $exception-&amp;gt;getMessage()]; // Customize your response object to display the exception details $response = new JsonResponse($data); // HttpExceptionInterface is a special type of exception that // holds status code and header details if ($exception instanceof PostNotFoundException) { $response-&amp;gt;setStatusCode(Response::HTTP_NOT_FOUND); } else if ($exception instanceof HttpExceptionInterface) { $response-&amp;gt;setStatusCode($exception-&amp;gt;getStatusCode()); $response-&amp;gt;headers-&amp;gt;replace($exception-&amp;gt;getHeaders()); } else { $response-&amp;gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR); } // sends the modified response object to the event $event-&amp;gt;setResponse($response); } public function setLogger(LoggerInterface $logger) { $this-&amp;gt;logger = $logger; }}Register this ExceptionListener in config/service.yml file.App\EventListener\ExceptionListener: tags: - { name: kernel.event_listener, event: kernel.exception, priority: 50 }It indicates it binds event.exception event to ExceptionListener, and set priority to set the order at execution time.Run the following command to show all registered EventListener/EventSubscribers on event kernel.exception.php bin/console debug:event-subscriber kernel.exceptionChange the getById function to the following.#[Route(path: &amp;quot;/{id}&amp;quot;, name: &amp;quot;byId&amp;quot;, methods: [&amp;quot;GET&amp;quot;])]function getById(Uuid $id): Response{ $data = $this-&amp;gt;posts-&amp;gt;findOneBy([&amp;quot;id&amp;quot; =&amp;gt; $id]); if ($data) { return $this-&amp;gt;json($data); } else { throw new PostNotFoundException($id); }}Add a test to verify if the post is not found and get a 404 status code.public function testGetANoneExistingPost(): void{ $client = static::createClient(); $id = Uuid::v4(); $crawler = $client-&amp;gt;request(&amp;#39;GET&amp;#39;, &amp;#39;/posts/&amp;#39; . $id); // $response = $client-&amp;gt;getResponse(); $this-&amp;gt;assertResponseStatusCodeSame(404); $data = $response-&amp;gt;getContent(); $this-&amp;gt;assertStringContainsString(&amp;quot;Post #&amp;quot; . $id . &amp;quot; was not found&amp;quot;, $data);}Run the application again, and try to access a single Post through a none existing id.curl http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 -H &amp;quot;Accept: application/json&amp;quot; -v&amp;gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1&amp;gt; Host: localhost:8000&amp;gt; User-Agent: curl/7.55.1&amp;gt; Accept: application/json&amp;gt;&amp;lt; HTTP/1.1 404 Not Found&amp;lt; Cache-Control: no-cache, private&amp;lt; Content-Type: application/json&amp;lt; Date: Mon, 22 Nov 2021 03:57:51 GMT&amp;lt; X-Powered-By: PHP/8.0.10&amp;lt; X-Robots-Tag: noindex&amp;lt; Content-Length: 69&amp;lt;{&amp;quot;error&amp;quot;:&amp;quot;Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.&amp;quot;}Get the complete source codes from my Github.Building Restful APIs with Symfony 5 and PHP 8 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building Restful APIs with Micronaut</title><link href="/blog/2021/building-restful-apis-with-micronaut/" rel="alternate" type="text/html" title="Building Restful APIs with Micronaut" /><published>2021-10-27T00:00:00+00:00</published><updated>2021-10-27T00:00:00+00:00</updated><id>/blog/2021/building-restful-apis-with-micronaut</id><content type="html" xml:base="/blog/2021/building-restful-apis-with-micronaut/">&lt;p&gt;Similar to Spring Boot, Micronaut is a JVM based framework and designated for building Microservice and cloud native applications.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*zQQZFdnK1KadoGtvK5pRDA.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@onice?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Joey Huang&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Unlike Spring Boot, Micronaut process IOC at compile time and erases runtime reflection, so it is easier to build native image.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Spring also started a Spring native project, but it is in the early stage.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;For developers that new to Micronaut, it is easy to develop your applications using Micronaut if you have some knowledge of Spring Boot. In this post, I will share my experience to create a simple Restful API application from scratch using Micronaut from a Spring developer view.&lt;/p&gt;&lt;h3&gt;Generating project skeleton&lt;/h3&gt;&lt;p&gt;Similar to &lt;a href=&quot;https://start.spring.io&quot;&gt;Spring Initializr&lt;/a&gt;, Micronaut provides an online service named &lt;strong&gt;Launch&lt;/strong&gt; to help your generate a project skeleton.&lt;/p&gt;&lt;p&gt;Open your browser, go to &lt;a href=&quot;https://micronaut.io/launch/&quot;&gt;Micronaut Launch&lt;/a&gt;, you will see the following screen.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/0*XfXojoTfgHQQe4Yp.png&quot; /&gt;&lt;/figure&gt;&lt;p&gt;In the &lt;strong&gt;Java version&lt;/strong&gt; field, select the latest LTS version &lt;strong&gt;17&lt;/strong&gt;. Then click the &lt;strong&gt;Features&lt;/strong&gt; button, add &lt;em&gt;lombok&lt;/em&gt;, &lt;em&gt;data hibernate jpa&lt;/em&gt;, &lt;em&gt;assertj&lt;/em&gt;, &lt;em&gt;postgres&lt;/em&gt;, &lt;em&gt;testcontainers&lt;/em&gt;. Finally, hit the &lt;strong&gt;GENERATE PROJECT&lt;/strong&gt; button to produce the project files into an archive for download.&lt;/p&gt;&lt;p&gt;Extract the project files into disk, and import to your IDE.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;You can also create a Micronaut project using Micronaut CLI, check &lt;/em&gt;&lt;a href=&quot;https://micronaut-projects.github.io/micronaut-starter/latest/guide/#installation&quot;&gt;&lt;em&gt;Micronaut Starter documentation&lt;/em&gt;&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;&lt;/blockquote&gt;&lt;h3&gt;Exploring project structure&lt;/h3&gt;&lt;p&gt;Let’s have a look at the files in the project.&lt;/p&gt;&lt;pre&gt;.&lt;br&gt;├── build.gradle&lt;br&gt;├── gradle&lt;br&gt;│   └── wrapper&lt;br&gt;│       ├── gradle-wrapper.jar&lt;br&gt;│       └── gradle-wrapper.properties&lt;br&gt;├── gradle.properties&lt;br&gt;├── gradlew&lt;br&gt;├── gradlew.bat&lt;br&gt;├── micronaut-cli.yml&lt;br&gt;├── settings.gradle&lt;br&gt;└── src&lt;br&gt;    ├── main&lt;br&gt;    │   ├── java&lt;br&gt;    │   │   └── com&lt;br&gt;    │   │       └── example&lt;br&gt;    │   │           └── Application.java&lt;br&gt;    │   └── resources&lt;br&gt;    │       ├── application.yml&lt;br&gt;    │       └── logback.xml&lt;br&gt;    └── test&lt;br&gt;        ├── java&lt;br&gt;        │   └── com&lt;br&gt;        │       └── example&lt;br&gt;        │           └── DemoTest.java&lt;br&gt;        └── resources&lt;br&gt;            ├── application-test.yml&lt;br&gt;            └── logback-test.xml&lt;/pre&gt;&lt;p&gt;Besides Gradle build scripts related resources, it is similar to the Spring Boot project structure.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The Application is the entry class of the application.&lt;/li&gt;&lt;li&gt;The &lt;em&gt;src/main/resources/application.yml&lt;/em&gt; is the application configuration.&lt;/li&gt;&lt;li&gt;The &lt;em&gt;src/main/resources/logback.xml&lt;/em&gt; is logging configuration.&lt;/li&gt;&lt;li&gt;The DemoTest is an example of using @MicronautTest.&lt;/li&gt;&lt;li&gt;Under the &lt;em&gt;src/test/resources&lt;/em&gt; folder, there are some config resources for test purpose.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let’s have a look at &lt;em&gt;build.gradle&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;It uses com.github.johnrengelman.shadow to package the application into a jar archive. The micronaut plugin will process the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native image.&lt;/p&gt;&lt;h3&gt;Declaring a Bean&lt;/h3&gt;&lt;p&gt;In Micronaut, it used JSR330(aka @Inject) specification to annotate the injectable beans. JSR330 originally is lead by SpringSource(now VMware) and Google.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Spring also has built-in JSR330 support, by default it is not activated. You should add &lt;/em&gt;&lt;em&gt;inject artifact in your project dependencies to enable it.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;When a class is annotated with @Singleton means there is only one instance shared in the application scope, @Prototype will produce a new instance for every injection.&lt;/p&gt;&lt;p&gt;Micronaut provides a @Factory to produces simple beans in groups, for example.&lt;/p&gt;&lt;pre&gt;@Factory&lt;br&gt;class MyConfig{&lt;br&gt;    &lt;br&gt;    @Singleton&lt;br&gt;    public Foo foo(){}&lt;br&gt;    &lt;br&gt;    @Singleton&lt;br&gt;    public Bar bar(){}&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;As described in former sections, Micronaut process IOC at compile time. When building the application, explore the project &lt;em&gt;build/classes&lt;/em&gt; folder, you will find there are a lot of extra classes generated at compile time which names are start with a USD(“&lt;strong&gt;$&lt;/strong&gt;”) symbol.&lt;/p&gt;&lt;h3&gt;Setup database&lt;/h3&gt;&lt;p&gt;Open &lt;em&gt;src/main/resources/application.yml&lt;/em&gt;, the datasources is configured when generating the project. Change the properties according to your environment.&lt;/p&gt;&lt;pre&gt;datasources:&lt;br&gt;  default:&lt;br&gt;    url: jdbc:postgresql://localhost:5432/blogdb&lt;br&gt;    driverClassName: org.postgresql.Driver&lt;br&gt;    username: user&lt;br&gt;    password: password&lt;br&gt;    schema-generate: CREATE_DROP&lt;br&gt;    dialect: POSTGRES&lt;br&gt;jpa.default.properties.hibernate.hbm2ddl.auto: update&lt;/pre&gt;&lt;p&gt;Create a docker compose file to bootstrap Postgres in docker container.&lt;/p&gt;&lt;pre&gt;version: &amp;#39;3.7&amp;#39; # specify docker-compose version&lt;/pre&gt;&lt;pre&gt;services:&lt;br&gt;  postgres:&lt;br&gt;    image: postgres&lt;br&gt;    ports:&lt;br&gt;      - &amp;quot;5432:5432&amp;quot;&lt;br&gt;    restart: always&lt;br&gt;    environment:&lt;br&gt;      POSTGRES_PASSWORD: password&lt;br&gt;      POSTGRES_DB: blogdb&lt;br&gt;      POSTGRES_USER: user&lt;br&gt;    volumes:&lt;br&gt;      - ./data:/var/lib/postgresql&lt;br&gt;      - ./pg-initdb.d:/docker-entrypoint-initdb.d&lt;/pre&gt;&lt;p&gt;Start up Postgres database.&lt;/p&gt;&lt;pre&gt;docker compose up postgres&lt;/pre&gt;&lt;h3&gt;Data Accessing with Micronaut Data&lt;/h3&gt;&lt;p&gt;We added &lt;em&gt;data-jpa&lt;/em&gt; feature when generating the project, which enables Micronaut data support. If you have experience of Spring Data JPA , it is easy to migrate to Micronaut Data.&lt;/p&gt;&lt;p&gt;I have used a simple blog application in the former examples when demonstrating other frameworks. In this post, I will reuse the blog application concept.&lt;/p&gt;&lt;p&gt;Basically it includes two JPA entities, Post and Comment, it is a OneToMany relation.&lt;/p&gt;&lt;pre&gt;@Getter&lt;br&gt;@Setter&lt;br&gt;@NoArgsConstructor&lt;br&gt;@AllArgsConstructor&lt;br&gt;@Builder&lt;br&gt;@Entity&lt;br&gt;@Table(name = &amp;quot;posts&amp;quot;)&lt;br&gt;public class Post implements Serializable {&lt;/pre&gt;&lt;pre&gt;    @Id&lt;br&gt;    @GeneratedValue(generator = &amp;quot;uuid&amp;quot;)&lt;br&gt;    @GenericGenerator(name = &amp;quot;uuid&amp;quot;, strategy = &amp;quot;uuid2&amp;quot;)&lt;br&gt;    UUID id;&lt;br&gt;    String title;&lt;br&gt;    String content;&lt;/pre&gt;&lt;pre&gt;    @Builder.Default&lt;br&gt;    Status status = Status.DRAFT;&lt;/pre&gt;&lt;pre&gt;    @Builder.Default&lt;br&gt;    LocalDateTime createdAt = LocalDateTime.now();&lt;/pre&gt;&lt;pre&gt;    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = &amp;quot;post&amp;quot;)&lt;br&gt;    @Builder.Default&lt;br&gt;    @OrderColumn(name = &amp;quot;comment_idx&amp;quot;)&lt;br&gt;    List&amp;lt;Comment&amp;gt; comments = new ArrayList&amp;lt;&amp;gt;();&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public boolean equals(Object o) {&lt;br&gt;        if (this == o) return true;&lt;br&gt;        if (o == null || getClass() != o.getClass()) return false;&lt;br&gt;        Post post = (Post) o;&lt;br&gt;        return getTitle().equals(post.getTitle());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public int hashCode() {&lt;br&gt;        return Objects.hash(getTitle());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public String toString() {&lt;br&gt;        return &amp;quot;Post{&amp;quot; +&lt;br&gt;                &amp;quot;id=&amp;quot; + id +&lt;br&gt;                &amp;quot;, title=&amp;#39;&amp;quot; + title + &amp;#39;\&amp;#39;&amp;#39; +&lt;br&gt;                &amp;quot;, content=&amp;#39;&amp;quot; + content + &amp;#39;\&amp;#39;&amp;#39; +&lt;br&gt;                &amp;quot;, status=&amp;quot; + status +&lt;br&gt;                &amp;quot;, createdAt=&amp;quot; + createdAt +&lt;br&gt;                &amp;#39;}&amp;#39;;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;// Comment entity &lt;br&gt;@Getter&lt;br&gt;@Setter&lt;br&gt;@NoArgsConstructor&lt;br&gt;@AllArgsConstructor&lt;br&gt;@Builder&lt;br&gt;@Entity&lt;br&gt;@Table(name = &amp;quot;comments&amp;quot;)&lt;br&gt;public class Comment implements Serializable {&lt;/pre&gt;&lt;pre&gt;    @Id&lt;br&gt;    @GeneratedValue(generator = &amp;quot;uuid&amp;quot;)&lt;br&gt;    @GenericGenerator(name = &amp;quot;uuid&amp;quot;, strategy = &amp;quot;uuid2&amp;quot;)&lt;br&gt;    private UUID id;&lt;/pre&gt;&lt;pre&gt;    @ManyToOne&lt;br&gt;    @JoinColumn(name = &amp;quot;post_id&amp;quot;)&lt;br&gt;    private Post post;&lt;/pre&gt;&lt;pre&gt;    private String content;&lt;/pre&gt;&lt;pre&gt;    @Builder.Default&lt;br&gt;    @Column(name = &amp;quot;created_at&amp;quot;)&lt;br&gt;    private LocalDateTime createdAt = LocalDateTime.now();&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public boolean equals(Object o) {&lt;br&gt;        if (this == o) return true;&lt;br&gt;        if (o == null || getClass() != o.getClass()) return false;&lt;br&gt;        Comment comment = (Comment) o;&lt;br&gt;        return getContent().equals(comment.getContent());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public int hashCode() {&lt;br&gt;        return Objects.hash(getContent());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public String toString() {&lt;br&gt;        return &amp;quot;Comment{&amp;quot; +&lt;br&gt;                &amp;quot;id=&amp;quot; + id +&lt;br&gt;                &amp;quot;, content=&amp;#39;&amp;quot; + content + &amp;#39;\&amp;#39;&amp;#39; +&lt;br&gt;                &amp;quot;, createdAt=&amp;quot; + createdAt +&lt;br&gt;                &amp;#39;}&amp;#39;;&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;They are standard JPA @Entity classes.&lt;/p&gt;&lt;p&gt;An JPA entity class should be annotated with an @Entity annotation, and includes a @Id field to identify this entity and a none-arguments constructor. Here we use Lombok to generate setters and getters, and constructors at compile time. We use IDE to generate equals and hasCode according to the business requirements.&lt;/p&gt;&lt;pre&gt;@Repository&lt;br&gt;public interface PostRepository extends JpaRepository&amp;lt;Post, UUID&amp;gt;{&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;pre&gt;@Repository&lt;br&gt;public interface CommentRepository extends JpaRepository&amp;lt;Comment, UUID&amp;gt; {&lt;/pre&gt;&lt;pre&gt;    List&amp;lt;Comment&amp;gt; findByPost(Post post);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Add a DataInitializer bean to initialize some sample data.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;@Slf4j&lt;br&gt;public class DataInitializer implements ApplicationEventListener&amp;lt;ApplicationStartupEvent&amp;gt; {&lt;br&gt;    private final PostRepository posts;&lt;/pre&gt;&lt;pre&gt;    private final TransactionOperations&amp;lt;?&amp;gt; tx;&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public void onApplicationEvent(ApplicationStartupEvent event) {&lt;br&gt;        log.info(&amp;quot;initializing sample data...&amp;quot;);&lt;br&gt;        var data = List.of(Post.builder().title(&amp;quot;Getting started wit Micronaut&amp;quot;).content(&amp;quot;test&amp;quot;).build(),&lt;br&gt;                Post.builder().title(&amp;quot;Getting started wit Micronaut: part 2&amp;quot;).content(&amp;quot;test&amp;quot;).build());&lt;br&gt;        tx.executeWrite(status -&amp;gt; {&lt;br&gt;            this.posts.deleteAll();&lt;br&gt;            this.posts.saveAll(data);&lt;br&gt;            return null;&lt;br&gt;        });&lt;br&gt;        tx.executeRead(status -&amp;gt; {&lt;br&gt;            this.posts.findAll().forEach(p -&amp;gt; log.info(&amp;quot;saved post: {}&amp;quot;, p));&lt;br&gt;            return null;&lt;br&gt;        });&lt;br&gt;        log.info(&amp;quot;data initialization is done...&amp;quot;);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Write a test to verify functionality of PostRepository. Similar to the @SpringBootTest, Micronaut provides a @MicronautTest.&lt;/p&gt;&lt;pre&gt;@MicronautTest(application = Application.class, startApplication = false)&lt;br&gt;class PostRepositoryTest {&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    PostRepository posts;&lt;/pre&gt;&lt;pre&gt;    @PersistenceContext&lt;br&gt;    EntityManager entityManager;&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    void testCreatePost() {&lt;br&gt;        var entity = Post.builder().title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build();&lt;br&gt;        this.entityManager.persist(entity);&lt;/pre&gt;&lt;pre&gt;        assertThat(entity.getId()).isNotNull();&lt;br&gt;        assertTrue(posts.findById(entity.getId()).isPresent());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Here we set startApplication = false, it does not start the embedded server to host the application, to test against the database, we do not need a running application&lt;/p&gt;&lt;p&gt;We have add testcontainers feature, it will configure a Postgres for test automatically. Check the testcontainers config in the src/test/resources/application-test.yml.&lt;/p&gt;&lt;pre&gt;datasources:&lt;br&gt;  default:&lt;br&gt;    url: jdbc:tc:postgresql:12:///postgres&lt;br&gt;    driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver&lt;/pre&gt;&lt;p&gt;When there is a tc as database host name, testcontainer will start up a Postgres database automaticially.&lt;/p&gt;&lt;h3&gt;Exposing Restful APIs&lt;/h3&gt;&lt;p&gt;Similar to Spring WebMVC, in Micronaut, we can use a controller to expose Restful APIs.&lt;/p&gt;&lt;pre&gt;@Controller(&amp;quot;/posts&amp;quot;)&lt;br&gt;@RequiredArgsConstructor(onConstructor_ = {@Inject})&lt;br&gt;@Validated&lt;br&gt;public class PostController {&lt;br&gt;    private final PostRepository posts;&lt;br&gt;    private final CommentRepository comments;&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/&amp;quot;, produces = MediaType.APPLICATION_JSON)&lt;br&gt;    public HttpResponse&amp;lt;List&amp;lt;PostSummaryDto&amp;gt;&amp;gt; getAll() {&lt;br&gt;        var body = posts.findAll()&lt;br&gt;                .stream()&lt;br&gt;                .map(p -&amp;gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt()))&lt;br&gt;                .toList();&lt;br&gt;        return ok(body);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Get(uri = &amp;quot;/{id}&amp;quot;, produces = MediaType.APPLICATION_JSON)&lt;br&gt;    public HttpResponse&amp;lt;?&amp;gt; getById(@PathVariable UUID id) {&lt;br&gt;        return posts.findById(id)&lt;br&gt;                .map(p -&amp;gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt())))&lt;br&gt;                //.orElseThrow(() -&amp;gt; new PostNotFoundException(id));&lt;br&gt;        .orElseGet(HttpResponse::notFound);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;A controller is annotated with @Controller, you can set a base uri that can be applied on all methods. The @Get, @Post,@Put, @Delete is mapped to handle varied HTTP methods, it is similar to the Spring&amp;#39;s @GetMapping, @PostMapping, etc. You can set media types using &lt;em&gt;consumes&lt;/em&gt; or &lt;em&gt;produces&lt;/em&gt; attributes in these annotations to limit the request and response content type, or use standalone annotations @Consumes and @Produces to set up the media types.&lt;/p&gt;&lt;p&gt;Start up the application via Gradle command.&lt;/p&gt;&lt;pre&gt;./gradlew run&lt;/pre&gt;&lt;blockquote&gt;&lt;em&gt;Do not forget to start up Postgres firstly.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;Use curl to test the /posts endpoint.&lt;/p&gt;&lt;pre&gt;curl &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt;&lt;br&gt;[ {&lt;br&gt;  &amp;quot;id&amp;quot; : &amp;quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&amp;quot;,&lt;br&gt;  &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;,&lt;br&gt;  &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-14T22:00:28.80933&amp;quot;&lt;br&gt;}, {&lt;br&gt;  &amp;quot;id&amp;quot; : &amp;quot;8c6147ea-8de4-473f-b97d-e211c8e43bac&amp;quot;,&lt;br&gt;  &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut: part 2&amp;quot;,&lt;br&gt;  &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-14T22:00:28.80933&amp;quot;&lt;br&gt;} ]&lt;/pre&gt;&lt;pre&gt;curl &lt;a href=&quot;http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;&gt;http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&lt;/a&gt;&lt;br&gt; {&lt;br&gt;  &amp;quot;id&amp;quot; : &amp;quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&amp;quot;,&lt;br&gt;  &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;,&lt;br&gt;  &amp;quot;content&amp;quot;: &amp;quot;test&amp;quot;,&lt;br&gt;  &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-14T22:00:28.80933&amp;quot;&lt;br&gt;}&lt;/pre&gt;&lt;blockquote&gt;&lt;em&gt;Micronaut CLI provides commands to generate controller, bean, etc. Run &lt;/em&gt;&lt;em&gt;mn --help to get all available commands.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;Write a test for the PostController.&lt;/p&gt;&lt;pre&gt;@MicronautTest(environments = Environment.TEST)&lt;br&gt;public class PostControllerTest {&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    @Client(&amp;quot;/&amp;quot;)&lt;br&gt;    HttpClient client;&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    PostRepository posts;&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    CommentRepository comments;&lt;/pre&gt;&lt;pre&gt;    @MockBean(PostRepository.class)&lt;br&gt;    PostRepository posts() {&lt;br&gt;        return mock(PostRepository.class);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @MockBean(CommentRepository.class)&lt;br&gt;    CommentRepository comments() {&lt;br&gt;        return mock(CommentRepository.class);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    @DisplayName(&amp;quot;test GET &amp;#39;/posts&amp;#39; endpoint&amp;quot;)&lt;br&gt;    public void testGetAllPosts() throws Exception {&lt;br&gt;        when(this.posts.findAll()).thenReturn(&lt;br&gt;                List.of(Post.builder().id(UUID.randomUUID()).title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build())&lt;br&gt;        );&lt;br&gt;        var response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, PostSummaryDto[].class);&lt;br&gt;        assertEquals(HttpStatus.OK, response.status());&lt;br&gt;        var body = response.body();&lt;br&gt;        assertThat(body.length).isEqualTo(1);&lt;br&gt;        assertThat(body[0].title()).isEqualTo(&amp;quot;test title&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        verify(this.posts, times(1)).findAll();&lt;br&gt;        verifyNoMoreInteractions(this.posts);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    @DisplayName(&amp;quot;test GET &amp;#39;/posts/{id}&amp;#39; endpoint&amp;quot;)&lt;br&gt;    public void testGetSinglePost() throws Exception {&lt;br&gt;        when(this.posts.findById(any(UUID.class))).thenReturn(&lt;br&gt;                Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build())&lt;br&gt;        );&lt;br&gt;        var request = HttpRequest.GET(UriBuilder.of(&amp;quot;/posts/{id}&amp;quot;).expand(Map.of(&amp;quot;id&amp;quot;, UUID.randomUUID())));&lt;br&gt;        var response = client.toBlocking().exchange(request, PostDetailsDto.class);&lt;br&gt;        assertEquals(HttpStatus.OK, response.status());&lt;br&gt;        var body = response.body();&lt;br&gt;        assertThat(body.title()).isEqualTo(&amp;quot;test title&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        verify(this.posts, times(1)).findById(any(UUID.class));&lt;br&gt;        verifyNoMoreInteractions(this.posts);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    @DisplayName(&amp;quot;test GET &amp;#39;/posts/{id}&amp;#39; endpoint that does not exist&amp;quot;)&lt;br&gt;    public void testGetSinglePost_notFound() throws Exception {&lt;br&gt;        when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null));&lt;br&gt;        var request = HttpRequest.GET(UriBuilder.of(&amp;quot;/posts/{id}&amp;quot;).expand(Map.of(&amp;quot;id&amp;quot;, UUID.randomUUID())));&lt;br&gt;        var exception = assertThrows(HttpClientResponseException.class, () -&amp;gt; client.toBlocking().exchange(request, PostDetailsDto.class));&lt;/pre&gt;&lt;pre&gt;        assertEquals(HttpStatus.NOT_FOUND, exception.getStatus());&lt;br&gt;        verify(this.posts, times(1)).findById(any(UUID.class));&lt;br&gt;        verifyNoMoreInteractions(this.posts);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In this test, we use Mockito to mock all dependent beans(PostRepository and CommentRepository) in the PostController. To mock beans in the test context, Micronaut provides a MockBean to produce a mocked instance to replace the &lt;em&gt;real&lt;/em&gt; beans.&lt;/p&gt;&lt;p&gt;Similar to Spring’s RestTemplate or WebClient, Micronaut provides a HttpClient to send request to a certain URI, by default it uses the &lt;em&gt;ReactiveStream&lt;/em&gt;s compatible API, If you are stick on the traditional blocking API, call the toBlocking() method to switch to use it.&lt;/p&gt;&lt;p&gt;The exchange method will return a HTTP response object, and the retrieve method returns the response body directly.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code, it will throws a &lt;/em&gt;&lt;em&gt;HttpClientResponseException instead. In contrast, in ReactiveStreams APIs, it will emit the exception to error channel.&lt;/em&gt;&lt;/blockquote&gt;&lt;h3&gt;Exception Handling&lt;/h3&gt;&lt;p&gt;In the above PostController, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real world application, we can use an exception to envelope the exception case. Like Spring WebMVC, Micronaut also provides exception handling mechanism.&lt;/p&gt;&lt;p&gt;For example, create an PostNotFoundException to stand for the case post was not found by id.&lt;/p&gt;&lt;p&gt;Create a PostNotFoundException class.&lt;/p&gt;&lt;pre&gt;public class PostNotFoundException extends RuntimeException {&lt;br&gt;    public PostNotFoundException(UUID id) {&lt;br&gt;        super(&amp;quot;Post[id=&amp;quot; + id + &amp;quot;] was not found&amp;quot;);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In the PostController, throw the exception.&lt;/p&gt;&lt;pre&gt;@Get(uri = &amp;quot;/{id}&amp;quot;, produces = MediaType.APPLICATION_JSON)&lt;br&gt;public HttpResponse&amp;lt;?&amp;gt; getById(@PathVariable UUID id) {&lt;br&gt;    return posts.findById(id)&lt;br&gt;        .map(p -&amp;gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt())))&lt;br&gt;        .orElseThrow(() -&amp;gt; new PostNotFoundException(id));&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Add a PostNotFoundExceptionHandler to handle PostNotFoundException.&lt;/p&gt;&lt;pre&gt;@Produces&lt;br&gt;@Singleton&lt;br&gt;@Requires(classes = { PostNotFoundException.class})&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;public class PostNotFoundExceptionHandler implements ExceptionHandler&amp;lt;PostNotFoundException, HttpResponse&amp;lt;?&amp;gt;&amp;gt; {&lt;br&gt;    private final ErrorResponseProcessor&amp;lt;?&amp;gt; errorResponseProcessor;&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public HttpResponse&amp;lt;?&amp;gt; handle(HttpRequest request, PostNotFoundException exception) {&lt;br&gt;        return errorResponseProcessor.processResponse(&lt;br&gt;                ErrorContext.builder(request)&lt;br&gt;                        .cause(exception)&lt;br&gt;                        .errorMessage(exception.getMessage())&lt;br&gt;                        .build(),&lt;br&gt;                HttpResponse.notFound()&lt;br&gt;        );&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Open your terminal, use curl to test the /posts/{id} endpoint with an none-existing id.&lt;/p&gt;&lt;pre&gt;# curl &lt;a href=&quot;http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;&gt;http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&lt;/a&gt; -v&lt;br&gt;&amp;gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1&lt;br&gt;&amp;gt; Host: localhost:8080&lt;br&gt;&amp;gt; User-Agent: curl/7.55.1&lt;br&gt;&amp;gt; Accept: */*&lt;br&gt;&amp;gt;&lt;br&gt;&amp;lt; HTTP/1.1 404 Not Found&lt;br&gt;&amp;lt; Content-Type: application/json&lt;br&gt;&amp;lt; date: Mon, 25 Oct 2021 07:02:01 GMT&lt;br&gt;&amp;lt; content-length: 301&lt;br&gt;&amp;lt; connection: keep-alive&lt;br&gt;&amp;lt;&lt;br&gt;{&lt;br&gt;  &amp;quot;message&amp;quot; : &amp;quot;Not Found&amp;quot;,&lt;br&gt;  &amp;quot;_links&amp;quot; : {&lt;br&gt;    &amp;quot;self&amp;quot; : {&lt;br&gt;      &amp;quot;href&amp;quot; : &amp;quot;/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&amp;quot;,&lt;br&gt;      &amp;quot;templated&amp;quot; : false&lt;br&gt;    }&lt;br&gt;  },&lt;br&gt;  &amp;quot;_embedded&amp;quot; : {&lt;br&gt;    &amp;quot;errors&amp;quot; : [ {&lt;br&gt;      &amp;quot;message&amp;quot; : &amp;quot;Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found&amp;quot;&lt;br&gt;    } ]&lt;br&gt;  }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Pagination&lt;/h3&gt;&lt;p&gt;Similar to Spring Data, Micronaut Data provides pagination for long query result, the findAll accepts a Pageable parameter, and returns a Page result. Micronaut Data also includes a Specification to adopt JPA Criteria APIs for type safe query.&lt;/p&gt;&lt;p&gt;Change PostRepository , add JpaSpecificationExecutor&amp;lt;Post&amp;gt; to extends list.&lt;/p&gt;&lt;pre&gt;@Repository&lt;br&gt;public interface PostRepository extends JpaRepository&amp;lt;Post, UUID&amp;gt;, JpaSpecificationExecutor&amp;lt;Post&amp;gt; {&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Create a specific PostSpecifications to group all specifications for querying posts. Currently only add one for query by keyword and status.&lt;/p&gt;&lt;pre&gt;public class PostSpecifications {&lt;br&gt;    private PostSpecifications(){&lt;br&gt;        // forbid to instantiate&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public static Specification&amp;lt;Post&amp;gt; filterByKeywordAndStatus(&lt;br&gt;            final String keyword,&lt;br&gt;            final Status status&lt;br&gt;    ) {&lt;br&gt;        return (Root&amp;lt;Post&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder cb) -&amp;gt; {&lt;br&gt;            List&amp;lt;Predicate&amp;gt; predicates = new ArrayList&amp;lt;&amp;gt;();&lt;br&gt;            if (StringUtils.hasText(keyword)) {&lt;br&gt;                predicates.add(&lt;br&gt;                        cb.or(&lt;br&gt;                                cb.like(root.get(Post_.title), &amp;quot;%&amp;quot; + keyword + &amp;quot;%&amp;quot;),&lt;br&gt;                                cb.like(root.get(Post_.content), &amp;quot;%&amp;quot; + keyword + &amp;quot;%&amp;quot;)&lt;br&gt;                        )&lt;br&gt;                );&lt;br&gt;            }&lt;/pre&gt;&lt;pre&gt;            if (status != null) {&lt;br&gt;                predicates.add(cb.equal(root.get(Post_.status), status));&lt;br&gt;            }&lt;/pre&gt;&lt;pre&gt;            return cb.and(predicates.toArray(new Predicate[0]));&lt;br&gt;        };&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Change the getAll method of PostController to the following.&lt;/p&gt;&lt;pre&gt;@Get(uri = &amp;quot;/&amp;quot;, produces = MediaType.APPLICATION_JSON)&lt;br&gt;@Transactional&lt;br&gt;public HttpResponse&amp;lt;Page&amp;lt;PostSummaryDto&amp;gt;&amp;gt; getAll(@QueryValue(defaultValue = &amp;quot;&amp;quot;) String q,&lt;br&gt;                                                 @QueryValue(defaultValue = &amp;quot;&amp;quot;) String status,&lt;br&gt;                                                 @QueryValue(defaultValue = &amp;quot;0&amp;quot;) int page,&lt;br&gt;                                                 @QueryValue(defaultValue = &amp;quot;10&amp;quot;) int size) {&lt;br&gt;    var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(&amp;quot;createdAt&amp;quot;)));&lt;br&gt;    var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null;&lt;br&gt;    var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable);&lt;br&gt;    var body = data.map(p -&amp;gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt()));&lt;br&gt;    return ok(body);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;All the query parameters are optional.&lt;/p&gt;&lt;p&gt;Let’s use curl to test the &lt;em&gt;/posts&lt;/em&gt; endpiont.&lt;/p&gt;&lt;pre&gt;# curl &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt;&lt;br&gt;{&lt;br&gt;  &amp;quot;content&amp;quot; : [ {&lt;br&gt;    &amp;quot;id&amp;quot; : &amp;quot;c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6&amp;quot;,&lt;br&gt;    &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;,&lt;br&gt;    &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:35:03.732951&amp;quot;&lt;br&gt;  }, {&lt;br&gt;    &amp;quot;id&amp;quot; : &amp;quot;0a79185c-5981-4301-86d1-c266b26b4980&amp;quot;,&lt;br&gt;    &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut: part 2&amp;quot;,&lt;br&gt;    &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:35:03.732951&amp;quot;&lt;br&gt;  } ],&lt;br&gt;  &amp;quot;pageable&amp;quot; : {&lt;br&gt;    &amp;quot;number&amp;quot; : 0,&lt;br&gt;    &amp;quot;sort&amp;quot; : {&lt;br&gt;      &amp;quot;orderBy&amp;quot; : [ {&lt;br&gt;        &amp;quot;property&amp;quot; : &amp;quot;createdAt&amp;quot;,&lt;br&gt;        &amp;quot;direction&amp;quot; : &amp;quot;DESC&amp;quot;,&lt;br&gt;        &amp;quot;ignoreCase&amp;quot; : false,&lt;br&gt;        &amp;quot;ascending&amp;quot; : false&lt;br&gt;      } ],&lt;br&gt;      &amp;quot;sorted&amp;quot; : true&lt;br&gt;    },&lt;br&gt;    &amp;quot;size&amp;quot; : 10,&lt;br&gt;    &amp;quot;offset&amp;quot; : 0,&lt;br&gt;    &amp;quot;sorted&amp;quot; : true,&lt;br&gt;    &amp;quot;unpaged&amp;quot; : false&lt;br&gt;  },&lt;br&gt;  &amp;quot;totalSize&amp;quot; : 2,&lt;br&gt;  &amp;quot;totalPages&amp;quot; : 1,&lt;br&gt;  &amp;quot;empty&amp;quot; : false,&lt;br&gt;  &amp;quot;size&amp;quot; : 10,&lt;br&gt;  &amp;quot;offset&amp;quot; : 0,&lt;br&gt;  &amp;quot;numberOfElements&amp;quot; : 2,&lt;br&gt;  &amp;quot;pageNumber&amp;quot; : 0&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Customizing JsonSerializer&lt;/h3&gt;&lt;p&gt;The Page object rendered result is a little tedious, most of case, we do not need all these fields, we can customize it via Jackson JsonSerializer.&lt;/p&gt;&lt;pre&gt;@Singleton&lt;br&gt;public class PageJsonSerializer extends JsonSerializer&amp;lt;Page&amp;lt;?&amp;gt;&amp;gt; {&lt;br&gt;    @Override&lt;br&gt;    public void serialize(Page&amp;lt;?&amp;gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException {&lt;br&gt;        gen.writeStartObject();&lt;br&gt;        gen.writeNumberField(&amp;quot;pageNumber&amp;quot;, value.getPageNumber());&lt;br&gt;        if (value.getNumberOfElements() != value.getSize()) {&lt;br&gt;            //only display it in the last page when number of elements is not equal to page size.&lt;br&gt;            gen.writeNumberField(&amp;quot;numberOfElements&amp;quot;, value.getNumberOfElements());&lt;br&gt;        }&lt;br&gt;        gen.writeNumberField(&amp;quot;size&amp;quot;, value.getSize());&lt;br&gt;        gen.writeNumberField(&amp;quot;totalPages&amp;quot;, value.getTotalPages());&lt;br&gt;        gen.writeNumberField(&amp;quot;totalSize&amp;quot;, value.getTotalSize());&lt;br&gt;        gen.writeObjectField(&amp;quot;content&amp;quot;, value.getContent());&lt;br&gt;        gen.writeEndObject();&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Run the application again, and hint &lt;em&gt;/posts&lt;/em&gt; endpoint.&lt;/p&gt;&lt;pre&gt;# curl &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt;&lt;br&gt;{&lt;br&gt;  &amp;quot;pageNumber&amp;quot; : 0,&lt;br&gt;  &amp;quot;numberOfElements&amp;quot; : 2,&lt;br&gt;  &amp;quot;size&amp;quot; : 10,&lt;br&gt;  &amp;quot;totalPages&amp;quot; : 1,&lt;br&gt;  &amp;quot;totalSize&amp;quot; : 2,&lt;br&gt;  &amp;quot;content&amp;quot; : [ {&lt;br&gt;    &amp;quot;id&amp;quot; : &amp;quot;53fb77d5-4159-4a80-bab9-c76d9a535b36&amp;quot;,&lt;br&gt;    &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;,&lt;br&gt;    &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:47:05.545594&amp;quot;&lt;br&gt;  }, {&lt;br&gt;    &amp;quot;id&amp;quot; : &amp;quot;aa02fd49-0c24-4f12-b204-2e48213c7a1e&amp;quot;,&lt;br&gt;    &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut: part 2&amp;quot;,&lt;br&gt;    &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:47:05.545594&amp;quot;&lt;br&gt;  } ]&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Modify the testing codes to verify changes.&lt;/p&gt;&lt;pre&gt;class PostControllerTest{&lt;br&gt;    //...&lt;br&gt;    &lt;br&gt;    @Test&lt;br&gt;    @DisplayName(&amp;quot;test GET &amp;#39;/posts&amp;#39; endpoint&amp;quot;)&lt;br&gt;    public void testGetAllPosts() throws Exception {&lt;br&gt;        var content = List.of(Post.builder().id(UUID.randomUUID()).title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build());&lt;br&gt;        when(this.posts.findAll(isA(Specification.class), isA(Pageable.class))).thenReturn(&lt;br&gt;                Page.of(content, Pageable.from(0, 20), 1)&lt;br&gt;        );&lt;br&gt;        var request = HttpRequest.GET(&amp;quot;/posts&amp;quot;);&lt;br&gt;        var response = client.toBlocking().exchange(request, String.class);&lt;br&gt;        assertEquals(HttpStatus.OK, response.status());&lt;br&gt;        var body = response.body();&lt;br&gt;        assertThat(JsonPath.from(body).getInt(&amp;quot;totalSize&amp;quot;)).isEqualTo(1);&lt;br&gt;        assertThat(JsonPath.from(body).getString(&amp;quot;content[0].title&amp;quot;)).isEqualTo(&amp;quot;test title&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        verify(this.posts, times(1)).findAll(isA(Specification.class), isA(Pageable.class));&lt;br&gt;        verifyNoMoreInteractions(this.posts);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Creating Posts&lt;/h3&gt;&lt;p&gt;We have discussed how to query posts by key word and get single post by id, in this section, we will focus on creating a new post.&lt;/p&gt;&lt;p&gt;According the REST convention, we will use a POST HTTP method to send a request on endpoint &lt;em&gt;/posts&lt;/em&gt; and accept JSON data as request body.&lt;/p&gt;&lt;pre&gt;@io.micronaut.http.annotation.Post(uri = &amp;quot;/&amp;quot;, consumes = MediaType.APPLICATION_JSON)&lt;br&gt;@Transactional&lt;br&gt;public HttpResponse&amp;lt;Void&amp;gt; create(@Body CreatePostCommand dto) {&lt;br&gt;    var data = Post.builder().title(dto.title()).content(dto.content()).build();&lt;br&gt;    var saved = this.posts.save(data);&lt;br&gt;    return HttpResponse.created(URI.create(&amp;quot;/posts/&amp;quot; + saved.getId()));&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The request body is deserialized as a POJO by built-in Jackson JsonDesearilizers, it is annotated with a @Body annotation to indicate which target class it will be desearilized to. After the post data is saved, set the response header Location to the URI of accessing the new post.&lt;/p&gt;&lt;p&gt;Run the application, and try to add a post via curl, and then access the newly created post.&lt;/p&gt;&lt;pre&gt;# curl -X POST -v  -H &amp;quot;Content-Type:application/json&amp;quot; &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt; -d &amp;quot;{\&amp;quot;title\&amp;quot;:\&amp;quot;test title\&amp;quot;,\&amp;quot;content\&amp;quot;:\&amp;quot;test content\&amp;quot;}&amp;quot;&lt;br&gt;&amp;gt; POST /posts HTTP/1.1&lt;br&gt;&amp;gt; Host: localhost:8080&lt;br&gt;&amp;gt; User-Agent: curl/7.55.1&lt;br&gt;&amp;gt; Accept: */*&lt;br&gt;&amp;gt; Content-Type:application/json&lt;br&gt;&amp;gt; Content-Length: 47&lt;br&gt;&amp;gt;&lt;br&gt;* upload completely sent off: 47 out of 47 bytes&lt;br&gt;&amp;lt; HTTP/1.1 201 Created&lt;br&gt;&amp;lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&lt;br&gt;&amp;lt; date: Mon, 25 Oct 2021 09:07:40 GMT&lt;br&gt;&amp;lt; connection: keep-alive&lt;br&gt;&amp;lt; transfer-encoding: chunked&lt;br&gt;&amp;lt;&lt;br&gt;# curl &lt;a href=&quot;http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&quot;&gt;http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&lt;/a&gt;&lt;br&gt;{&lt;br&gt;  &amp;quot;id&amp;quot; : &amp;quot;7db15639-62e3-4d3e-9cf4-f54413502ea6&amp;quot;,&lt;br&gt;  &amp;quot;title&amp;quot; : &amp;quot;test title&amp;quot;,&lt;br&gt;  &amp;quot;content&amp;quot; : &amp;quot;test content&amp;quot;,&lt;br&gt;  &amp;quot;status&amp;quot; : &amp;quot;DRAFT&amp;quot;,&lt;br&gt;  &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T17:07:40.87621&amp;quot;&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Data Validation&lt;/h3&gt;&lt;p&gt;Generally, in a real application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support.&lt;/p&gt;&lt;p&gt;In the above CreatPostCommand class, add Bean Validation annotations on the fields.&lt;/p&gt;&lt;pre&gt;@Introspected&lt;br&gt;public record CreatePostCommand(@NotBlank String title, @NotBlank String content) {&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;You have to add @Introspected annotation to let micronaut plugin to preprocess bean validation annotations at compile time, and let Bean Validation works without any reflections APIs at runtime time.&lt;/p&gt;&lt;p&gt;In the PostController, add a @Validated on the class and a @Valid on the method argument.&lt;/p&gt;&lt;pre&gt;@Validated&lt;br&gt;public class PostController {&lt;br&gt;    public HttpResponse&amp;lt;Void&amp;gt; create(@Body @Valid CreatePostCommand dto) {...}&lt;br&gt;    //...&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Let’s try to create a post. Note, set the content field empty.&lt;/p&gt;&lt;pre&gt;curl -X POST -v  -H &amp;quot;Content-Type:application/json&amp;quot; &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt; -d &amp;quot;{\&amp;quot;title\&amp;quot;:\&amp;quot;test title\&amp;quot;,\&amp;quot;content\&amp;quot;:\&amp;quot;\&amp;quot;}&amp;quot;&lt;br&gt;&amp;gt; POST /posts HTTP/1.1&lt;br&gt;&amp;gt; Host: localhost:8080&lt;br&gt;&amp;gt; User-Agent: curl/7.55.1&lt;br&gt;&amp;gt; Accept: */*&lt;br&gt;&amp;gt; Content-Type:application/json&lt;br&gt;&amp;gt; Content-Length: 35&lt;br&gt;&amp;gt;&lt;br&gt;* upload completely sent off: 35 out of 35 bytes&lt;br&gt;&amp;lt; HTTP/1.1 400 Bad Request&lt;br&gt;&amp;lt; Content-Type: application/json&lt;br&gt;&amp;lt; date: Mon, 25 Oct 2021 09:23:22 GMT&lt;br&gt;&amp;lt; content-length: 237&lt;br&gt;&amp;lt; connection: keep-alive&lt;br&gt;&amp;lt;&lt;br&gt;{&lt;br&gt;  &amp;quot;message&amp;quot; : &amp;quot;Bad Request&amp;quot;,&lt;br&gt;  &amp;quot;_embedded&amp;quot; : {&lt;br&gt;    &amp;quot;errors&amp;quot; : [ {&lt;br&gt;      &amp;quot;message&amp;quot; : &amp;quot;dto.content: must not be blank&amp;quot;&lt;br&gt;    } ]&lt;br&gt;  },&lt;br&gt;  &amp;quot;_links&amp;quot; : {&lt;br&gt;    &amp;quot;self&amp;quot; : {&lt;br&gt;      &amp;quot;href&amp;quot; : &amp;quot;/posts&amp;quot;,&lt;br&gt;      &amp;quot;templated&amp;quot; : false&lt;br&gt;    }&lt;br&gt;  }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Deleting a Post&lt;/h3&gt;&lt;p&gt;According to REST convention, to delete a single post, send a DELETE request on /posts/{id}, if it is successful, returns a 204 status. If the id is not existed, returns a 404 instead.&lt;/p&gt;&lt;p&gt;Add the following codes to the PostController.&lt;/p&gt;&lt;pre&gt;@Delete(uri = &amp;quot;/{id}&amp;quot;, produces = MediaType.APPLICATION_JSON)&lt;br&gt;@Transactional&lt;br&gt;public HttpResponse&amp;lt;?&amp;gt; deleteById(@PathVariable UUID id) {&lt;br&gt;    return posts.findById(id)&lt;br&gt;        .map(p -&amp;gt; {&lt;br&gt;            this.posts.delete(p);&lt;br&gt;            return HttpResponse.noContent();&lt;br&gt;        })&lt;br&gt;        .orElseThrow(() -&amp;gt; new PostNotFoundException(id));&lt;br&gt;    //.orElseGet(HttpResponse::notFound);&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Processing Subresources&lt;/h3&gt;&lt;p&gt;In our application, the a Comment resource, it should be a subresource of Post resource when adding comments or fetching comments of a specific post, we can design comments resource like this.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;POST /posts/{id}/comments , add a Comment resource to a specific Post.&lt;/li&gt;&lt;li&gt;GET /posts/{id}/comments, get all comments of a certain Post which id value is the path variable id.&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;// nested comments endpoints&lt;br&gt;@Get(uri = &amp;quot;/{id}/comments&amp;quot;, produces = MediaType.APPLICATION_JSON)&lt;br&gt;public HttpResponse&amp;lt;?&amp;gt; getCommentsByPostId(@PathVariable UUID id) {&lt;br&gt;    return posts.findById(id)&lt;br&gt;        .map(post -&amp;gt; {&lt;br&gt;            var comments = this.comments.findByPost(post);&lt;br&gt;            return ok(comments.stream().map(c -&amp;gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt())));&lt;br&gt;        })&lt;br&gt;        .orElseThrow(() -&amp;gt; new PostNotFoundException(id));&lt;br&gt;    //.orElseGet(HttpResponse::notFound);&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;@io.micronaut.http.annotation.Post(uri = &amp;quot;/{id}/comments&amp;quot;, consumes = MediaType.APPLICATION_JSON)&lt;br&gt;@Transactional&lt;br&gt;public HttpResponse&amp;lt;?&amp;gt; create(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) {&lt;/pre&gt;&lt;pre&gt;    return posts.findById(id)&lt;br&gt;        .map(post -&amp;gt; {&lt;br&gt;            var data = Comment.builder().content(dto.content()).post(post).build();&lt;br&gt;            post.getComments().add(data);&lt;br&gt;            var saved = this.comments.save(data);&lt;br&gt;            return HttpResponse.created(URI.create(&amp;quot;/comments/&amp;quot; + saved.getId()));&lt;br&gt;        })&lt;br&gt;        .orElseThrow(() -&amp;gt; new PostNotFoundException(id));&lt;br&gt;    // .orElseGet(HttpResponse::notFound);&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;h3&gt;Integration Tests&lt;/h3&gt;&lt;p&gt;The following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server.&lt;/p&gt;&lt;pre&gt;@MicronautTest&lt;br&gt;@Slf4j&lt;br&gt;class IntegrationTests {&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    @Client(&amp;quot;/&amp;quot;)&lt;br&gt;    HttpClient client;&lt;/pre&gt;&lt;pre&gt;    @Inject&lt;br&gt;    EmbeddedApplication&amp;lt;?&amp;gt; application;&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    void testItWorks() {&lt;br&gt;        Assertions.assertTrue(application.isRunning());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    void testGetAllPosts() {&lt;br&gt;        var response = client.exchange(HttpRequest.GET(&amp;quot;/posts&amp;quot;), String.class);&lt;/pre&gt;&lt;pre&gt;        var bodyFlux = Flux.from(response).map(HttpResponse::body);&lt;br&gt;        StepVerifier.create(bodyFlux)&lt;br&gt;                .consumeNextWith(posts -&amp;gt; assertThat(JsonPath.from(posts).getInt(&amp;quot;totalSize&amp;quot;)).isGreaterThanOrEqualTo(2))&lt;br&gt;                .verifyComplete();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    public void testCrudFlow() {&lt;br&gt;        //create a new post&lt;br&gt;        var request = HttpRequest.POST(&amp;quot;/posts&amp;quot;, new CreatePostCommand(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;));&lt;br&gt;        var blockingHttpClient = client.toBlocking();&lt;br&gt;        var response = blockingHttpClient.exchange(request);&lt;br&gt;        assertThat(response.status().getCode()).isEqualTo(201);&lt;br&gt;        var savedUrl = response.getHeaders().get(&amp;quot;Location&amp;quot;);&lt;br&gt;        assertThat(savedUrl).isNotNull();&lt;br&gt;        log.debug(&amp;quot;saved post url: {}&amp;quot;, savedUrl);&lt;/pre&gt;&lt;pre&gt;        //get by id&lt;br&gt;        var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class);&lt;br&gt;        assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200);&lt;/pre&gt;&lt;pre&gt;        // add comments&lt;br&gt;        var addCommentRequest = HttpRequest.POST(savedUrl + &amp;quot;/comments&amp;quot;, new CreateCommentCommand(&amp;quot;test content&amp;quot;));&lt;br&gt;        var addCommentResponse = blockingHttpClient.exchange(addCommentRequest);&lt;br&gt;        assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201);&lt;br&gt;        var savedCommentUrl = addCommentResponse.getHeaders().get(&amp;quot;Location&amp;quot;);&lt;br&gt;        assertThat(savedCommentUrl).isNotNull();&lt;/pre&gt;&lt;pre&gt;        // get all comments&lt;br&gt;        var getAllCommentsRequest = HttpRequest.GET(savedUrl + &amp;quot;/comments&amp;quot;);&lt;br&gt;        var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class));&lt;br&gt;        assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200);&lt;br&gt;        assertThat(getAllCommentsResponse.body().size()).isEqualTo(1);&lt;/pre&gt;&lt;pre&gt;        //delete by id&lt;br&gt;        var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl));&lt;br&gt;        assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204);&lt;/pre&gt;&lt;pre&gt;        //get by id again(404)&lt;br&gt;        var e = Assertions.assertThrows(HttpClientResponseException.class, () -&amp;gt;&lt;br&gt;                blockingHttpClient.exchange(HttpRequest.GET(savedUrl)));&lt;br&gt;        var getPostResponse2 = e.getResponse();&lt;br&gt;        assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;In the testGetAllPosts test, we try to use reactive HttpClient APIs and use reactor-test&amp;#39;s StepVerifier to assert the data in a reactive data stream.&lt;/p&gt;&lt;p&gt;The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post.&lt;/p&gt;&lt;p&gt;In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using RestAssured and Java 11 new HttpClient, check &lt;a href=&quot;https://github.com/hantsy/micronaut-sandbox/tree/master/post-service&quot;&gt;the source codes&lt;/a&gt; and explore them yourself.&lt;/p&gt;&lt;p&gt;The example codes are hosted on my GitHub, check &lt;a href=&quot;https://github.com/hantsy/micronaut-sandbox/tree/master/post-service&quot;&gt;hantsy/micronaut-sandbox#post-service&lt;/a&gt;.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=98f4eb39211c&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/building-restful-apis-with-micronaut-98f4eb39211c&quot;&gt;Building Restful APIs with Micronaut&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">Similar to Spring Boot, Micronaut is a JVM based framework and designated for building Microservice and cloud native applications.Photo by Joey Huang on UnsplashUnlike Spring Boot, Micronaut process IOC at compile time and erases runtime reflection, so it is easier to build native image.Spring also started a Spring native project, but it is in the early stage.For developers that new to Micronaut, it is easy to develop your applications using Micronaut if you have some knowledge of Spring Boot. In this post, I will share my experience to create a simple Restful API application from scratch using Micronaut from a Spring developer view.Generating project skeletonSimilar to Spring Initializr, Micronaut provides an online service named Launch to help your generate a project skeleton.Open your browser, go to Micronaut Launch, you will see the following screen.In the Java version field, select the latest LTS version 17. Then click the Features button, add lombok, data hibernate jpa, assertj, postgres, testcontainers. Finally, hit the GENERATE PROJECT button to produce the project files into an archive for download.Extract the project files into disk, and import to your IDE.You can also create a Micronaut project using Micronaut CLI, check Micronaut Starter documentation.Exploring project structureLet’s have a look at the files in the project..├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle.properties├── gradlew├── gradlew.bat├── micronaut-cli.yml├── settings.gradle└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── Application.java │ └── resources │ ├── application.yml │ └── logback.xml └── test ├── java │ └── com │ └── example │ └── DemoTest.java └── resources ├── application-test.yml └── logback-test.xmlBesides Gradle build scripts related resources, it is similar to the Spring Boot project structure.The Application is the entry class of the application.The src/main/resources/application.yml is the application configuration.The src/main/resources/logback.xml is logging configuration.The DemoTest is an example of using @MicronautTest.Under the src/test/resources folder, there are some config resources for test purpose.Let’s have a look at build.gradle.It uses com.github.johnrengelman.shadow to package the application into a jar archive. The micronaut plugin will process the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native image.Declaring a BeanIn Micronaut, it used JSR330(aka @Inject) specification to annotate the injectable beans. JSR330 originally is lead by SpringSource(now VMware) and Google.Spring also has built-in JSR330 support, by default it is not activated. You should add inject artifact in your project dependencies to enable it.When a class is annotated with @Singleton means there is only one instance shared in the application scope, @Prototype will produce a new instance for every injection.Micronaut provides a @Factory to produces simple beans in groups, for example.@Factoryclass MyConfig{ @Singleton public Foo foo(){} @Singleton public Bar bar(){}}As described in former sections, Micronaut process IOC at compile time. When building the application, explore the project build/classes folder, you will find there are a lot of extra classes generated at compile time which names are start with a USD(“$”) symbol.Setup databaseOpen src/main/resources/application.yml, the datasources is configured when generating the project. Change the properties according to your environment.datasources: default: url: jdbc:postgresql://localhost:5432/blogdb driverClassName: org.postgresql.Driver username: user password: password schema-generate: CREATE_DROP dialect: POSTGRESjpa.default.properties.hibernate.hbm2ddl.auto: updateCreate a docker compose file to bootstrap Postgres in docker container.version: &amp;#39;3.7&amp;#39; # specify docker-compose versionservices: postgres: image: postgres ports: - &amp;quot;5432:5432&amp;quot; restart: always environment: POSTGRES_PASSWORD: password POSTGRES_DB: blogdb POSTGRES_USER: user volumes: - ./data:/var/lib/postgresql - ./pg-initdb.d:/docker-entrypoint-initdb.dStart up Postgres database.docker compose up postgresData Accessing with Micronaut DataWe added data-jpa feature when generating the project, which enables Micronaut data support. If you have experience of Spring Data JPA , it is easy to migrate to Micronaut Data.I have used a simple blog application in the former examples when demonstrating other frameworks. In this post, I will reuse the blog application concept.Basically it includes two JPA entities, Post and Comment, it is a OneToMany relation.@Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &amp;quot;posts&amp;quot;)public class Post implements Serializable { @Id @GeneratedValue(generator = &amp;quot;uuid&amp;quot;) @GenericGenerator(name = &amp;quot;uuid&amp;quot;, strategy = &amp;quot;uuid2&amp;quot;) UUID id; String title; String content; @Builder.Default Status status = Status.DRAFT; @Builder.Default LocalDateTime createdAt = LocalDateTime.now(); @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = &amp;quot;post&amp;quot;) @Builder.Default @OrderColumn(name = &amp;quot;comment_idx&amp;quot;) List&amp;lt;Comment&amp;gt; comments = new ArrayList&amp;lt;&amp;gt;(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Post post = (Post) o; return getTitle().equals(post.getTitle()); } @Override public int hashCode() { return Objects.hash(getTitle()); } @Override public String toString() { return &amp;quot;Post{&amp;quot; + &amp;quot;id=&amp;quot; + id + &amp;quot;, title=&amp;#39;&amp;quot; + title + &amp;#39;\&amp;#39;&amp;#39; + &amp;quot;, content=&amp;#39;&amp;quot; + content + &amp;#39;\&amp;#39;&amp;#39; + &amp;quot;, status=&amp;quot; + status + &amp;quot;, createdAt=&amp;quot; + createdAt + &amp;#39;}&amp;#39;; }}// Comment entity @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &amp;quot;comments&amp;quot;)public class Comment implements Serializable { @Id @GeneratedValue(generator = &amp;quot;uuid&amp;quot;) @GenericGenerator(name = &amp;quot;uuid&amp;quot;, strategy = &amp;quot;uuid2&amp;quot;) private UUID id; @ManyToOne @JoinColumn(name = &amp;quot;post_id&amp;quot;) private Post post; private String content; @Builder.Default @Column(name = &amp;quot;created_at&amp;quot;) private LocalDateTime createdAt = LocalDateTime.now(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Comment comment = (Comment) o; return getContent().equals(comment.getContent()); } @Override public int hashCode() { return Objects.hash(getContent()); } @Override public String toString() { return &amp;quot;Comment{&amp;quot; + &amp;quot;id=&amp;quot; + id + &amp;quot;, content=&amp;#39;&amp;quot; + content + &amp;#39;\&amp;#39;&amp;#39; + &amp;quot;, createdAt=&amp;quot; + createdAt + &amp;#39;}&amp;#39;; }}They are standard JPA @Entity classes.An JPA entity class should be annotated with an @Entity annotation, and includes a @Id field to identify this entity and a none-arguments constructor. Here we use Lombok to generate setters and getters, and constructors at compile time. We use IDE to generate equals and hasCode according to the business requirements.@Repositorypublic interface PostRepository extends JpaRepository&amp;lt;Post, UUID&amp;gt;{}@Repositorypublic interface CommentRepository extends JpaRepository&amp;lt;Comment, UUID&amp;gt; { List&amp;lt;Comment&amp;gt; findByPost(Post post);}Add a DataInitializer bean to initialize some sample data.@Singleton@RequiredArgsConstructor@Slf4jpublic class DataInitializer implements ApplicationEventListener&amp;lt;ApplicationStartupEvent&amp;gt; { private final PostRepository posts; private final TransactionOperations&amp;lt;?&amp;gt; tx; @Override public void onApplicationEvent(ApplicationStartupEvent event) { log.info(&amp;quot;initializing sample data...&amp;quot;); var data = List.of(Post.builder().title(&amp;quot;Getting started wit Micronaut&amp;quot;).content(&amp;quot;test&amp;quot;).build(), Post.builder().title(&amp;quot;Getting started wit Micronaut: part 2&amp;quot;).content(&amp;quot;test&amp;quot;).build()); tx.executeWrite(status -&amp;gt; { this.posts.deleteAll(); this.posts.saveAll(data); return null; }); tx.executeRead(status -&amp;gt; { this.posts.findAll().forEach(p -&amp;gt; log.info(&amp;quot;saved post: {}&amp;quot;, p)); return null; }); log.info(&amp;quot;data initialization is done...&amp;quot;); }}Write a test to verify functionality of PostRepository. Similar to the @SpringBootTest, Micronaut provides a @MicronautTest.@MicronautTest(application = Application.class, startApplication = false)class PostRepositoryTest { @Inject PostRepository posts; @PersistenceContext EntityManager entityManager; @Test void testCreatePost() { var entity = Post.builder().title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build(); this.entityManager.persist(entity); assertThat(entity.getId()).isNotNull(); assertTrue(posts.findById(entity.getId()).isPresent()); }}Here we set startApplication = false, it does not start the embedded server to host the application, to test against the database, we do not need a running applicationWe have add testcontainers feature, it will configure a Postgres for test automatically. Check the testcontainers config in the src/test/resources/application-test.yml.datasources: default: url: jdbc:tc:postgresql:12:///postgres driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriverWhen there is a tc as database host name, testcontainer will start up a Postgres database automaticially.Exposing Restful APIsSimilar to Spring WebMVC, in Micronaut, we can use a controller to expose Restful APIs.@Controller(&amp;quot;/posts&amp;quot;)@RequiredArgsConstructor(onConstructor_ = {@Inject})@Validatedpublic class PostController { private final PostRepository posts; private final CommentRepository comments; @Get(uri = &amp;quot;/&amp;quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&amp;lt;List&amp;lt;PostSummaryDto&amp;gt;&amp;gt; getAll() { var body = posts.findAll() .stream() .map(p -&amp;gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())) .toList(); return ok(body); } @Get(uri = &amp;quot;/{id}&amp;quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&amp;lt;?&amp;gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&amp;gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) //.orElseThrow(() -&amp;gt; new PostNotFoundException(id)); .orElseGet(HttpResponse::notFound); }}A controller is annotated with @Controller, you can set a base uri that can be applied on all methods. The @Get, @Post,@Put, @Delete is mapped to handle varied HTTP methods, it is similar to the Spring&amp;#39;s @GetMapping, @PostMapping, etc. You can set media types using consumes or produces attributes in these annotations to limit the request and response content type, or use standalone annotations @Consumes and @Produces to set up the media types.Start up the application via Gradle command../gradlew runDo not forget to start up Postgres firstly.Use curl to test the /posts endpoint.curl http://localhost:8080/posts[ { &amp;quot;id&amp;quot; : &amp;quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-14T22:00:28.80933&amp;quot;}, { &amp;quot;id&amp;quot; : &amp;quot;8c6147ea-8de4-473f-b97d-e211c8e43bac&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut: part 2&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-14T22:00:28.80933&amp;quot;} ]curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf { &amp;quot;id&amp;quot; : &amp;quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;test&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-14T22:00:28.80933&amp;quot;}Micronaut CLI provides commands to generate controller, bean, etc. Run mn --help to get all available commands.Write a test for the PostController.@MicronautTest(environments = Environment.TEST)public class PostControllerTest { @Inject @Client(&amp;quot;/&amp;quot;) HttpClient client; @Inject PostRepository posts; @Inject CommentRepository comments; @MockBean(PostRepository.class) PostRepository posts() { return mock(PostRepository.class); } @MockBean(CommentRepository.class) CommentRepository comments() { return mock(CommentRepository.class); } @Test @DisplayName(&amp;quot;test GET &amp;#39;/posts&amp;#39; endpoint&amp;quot;) public void testGetAllPosts() throws Exception { when(this.posts.findAll()).thenReturn( List.of(Post.builder().id(UUID.randomUUID()).title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build()) ); var response = client.toBlocking().exchange(&amp;quot;/posts&amp;quot;, PostSummaryDto[].class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.length).isEqualTo(1); assertThat(body[0].title()).isEqualTo(&amp;quot;test title&amp;quot;); verify(this.posts, times(1)).findAll(); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&amp;quot;test GET &amp;#39;/posts/{id}&amp;#39; endpoint&amp;quot;) public void testGetSinglePost() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn( Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build()) ); var request = HttpRequest.GET(UriBuilder.of(&amp;quot;/posts/{id}&amp;quot;).expand(Map.of(&amp;quot;id&amp;quot;, UUID.randomUUID()))); var response = client.toBlocking().exchange(request, PostDetailsDto.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.title()).isEqualTo(&amp;quot;test title&amp;quot;); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&amp;quot;test GET &amp;#39;/posts/{id}&amp;#39; endpoint that does not exist&amp;quot;) public void testGetSinglePost_notFound() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null)); var request = HttpRequest.GET(UriBuilder.of(&amp;quot;/posts/{id}&amp;quot;).expand(Map.of(&amp;quot;id&amp;quot;, UUID.randomUUID()))); var exception = assertThrows(HttpClientResponseException.class, () -&amp;gt; client.toBlocking().exchange(request, PostDetailsDto.class)); assertEquals(HttpStatus.NOT_FOUND, exception.getStatus()); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); }}In this test, we use Mockito to mock all dependent beans(PostRepository and CommentRepository) in the PostController. To mock beans in the test context, Micronaut provides a MockBean to produce a mocked instance to replace the real beans.Similar to Spring’s RestTemplate or WebClient, Micronaut provides a HttpClient to send request to a certain URI, by default it uses the ReactiveStreams compatible API, If you are stick on the traditional blocking API, call the toBlocking() method to switch to use it.The exchange method will return a HTTP response object, and the retrieve method returns the response body directly.Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code, it will throws a HttpClientResponseException instead. In contrast, in ReactiveStreams APIs, it will emit the exception to error channel.Exception HandlingIn the above PostController, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real world application, we can use an exception to envelope the exception case. Like Spring WebMVC, Micronaut also provides exception handling mechanism.For example, create an PostNotFoundException to stand for the case post was not found by id.Create a PostNotFoundException class.public class PostNotFoundException extends RuntimeException { public PostNotFoundException(UUID id) { super(&amp;quot;Post[id=&amp;quot; + id + &amp;quot;] was not found&amp;quot;); }}In the PostController, throw the exception.@Get(uri = &amp;quot;/{id}&amp;quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&amp;lt;?&amp;gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&amp;gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) .orElseThrow(() -&amp;gt; new PostNotFoundException(id));}Add a PostNotFoundExceptionHandler to handle PostNotFoundException.@Produces@Singleton@Requires(classes = { PostNotFoundException.class})@RequiredArgsConstructorpublic class PostNotFoundExceptionHandler implements ExceptionHandler&amp;lt;PostNotFoundException, HttpResponse&amp;lt;?&amp;gt;&amp;gt; { private final ErrorResponseProcessor&amp;lt;?&amp;gt; errorResponseProcessor; @Override public HttpResponse&amp;lt;?&amp;gt; handle(HttpRequest request, PostNotFoundException exception) { return errorResponseProcessor.processResponse( ErrorContext.builder(request) .cause(exception) .errorMessage(exception.getMessage()) .build(), HttpResponse.notFound() ); }}Open your terminal, use curl to test the /posts/{id} endpoint with an none-existing id.# curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf -v&amp;gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1&amp;gt; Host: localhost:8080&amp;gt; User-Agent: curl/7.55.1&amp;gt; Accept: */*&amp;gt;&amp;lt; HTTP/1.1 404 Not Found&amp;lt; Content-Type: application/json&amp;lt; date: Mon, 25 Oct 2021 07:02:01 GMT&amp;lt; content-length: 301&amp;lt; connection: keep-alive&amp;lt;{ &amp;quot;message&amp;quot; : &amp;quot;Not Found&amp;quot;, &amp;quot;_links&amp;quot; : { &amp;quot;self&amp;quot; : { &amp;quot;href&amp;quot; : &amp;quot;/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&amp;quot;, &amp;quot;templated&amp;quot; : false } }, &amp;quot;_embedded&amp;quot; : { &amp;quot;errors&amp;quot; : [ { &amp;quot;message&amp;quot; : &amp;quot;Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found&amp;quot; } ] }}PaginationSimilar to Spring Data, Micronaut Data provides pagination for long query result, the findAll accepts a Pageable parameter, and returns a Page result. Micronaut Data also includes a Specification to adopt JPA Criteria APIs for type safe query.Change PostRepository , add JpaSpecificationExecutor&amp;lt;Post&amp;gt; to extends list.@Repositorypublic interface PostRepository extends JpaRepository&amp;lt;Post, UUID&amp;gt;, JpaSpecificationExecutor&amp;lt;Post&amp;gt; {}Create a specific PostSpecifications to group all specifications for querying posts. Currently only add one for query by keyword and status.public class PostSpecifications { private PostSpecifications(){ // forbid to instantiate } public static Specification&amp;lt;Post&amp;gt; filterByKeywordAndStatus( final String keyword, final Status status ) { return (Root&amp;lt;Post&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder cb) -&amp;gt; { List&amp;lt;Predicate&amp;gt; predicates = new ArrayList&amp;lt;&amp;gt;(); if (StringUtils.hasText(keyword)) { predicates.add( cb.or( cb.like(root.get(Post_.title), &amp;quot;%&amp;quot; + keyword + &amp;quot;%&amp;quot;), cb.like(root.get(Post_.content), &amp;quot;%&amp;quot; + keyword + &amp;quot;%&amp;quot;) ) ); } if (status != null) { predicates.add(cb.equal(root.get(Post_.status), status)); } return cb.and(predicates.toArray(new Predicate[0])); }; }}Change the getAll method of PostController to the following.@Get(uri = &amp;quot;/&amp;quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&amp;lt;Page&amp;lt;PostSummaryDto&amp;gt;&amp;gt; getAll(@QueryValue(defaultValue = &amp;quot;&amp;quot;) String q, @QueryValue(defaultValue = &amp;quot;&amp;quot;) String status, @QueryValue(defaultValue = &amp;quot;0&amp;quot;) int page, @QueryValue(defaultValue = &amp;quot;10&amp;quot;) int size) { var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(&amp;quot;createdAt&amp;quot;))); var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null; var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable); var body = data.map(p -&amp;gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())); return ok(body);}All the query parameters are optional.Let’s use curl to test the /posts endpiont.# curl http://localhost:8080/posts{ &amp;quot;content&amp;quot; : [ { &amp;quot;id&amp;quot; : &amp;quot;c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:35:03.732951&amp;quot; }, { &amp;quot;id&amp;quot; : &amp;quot;0a79185c-5981-4301-86d1-c266b26b4980&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut: part 2&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:35:03.732951&amp;quot; } ], &amp;quot;pageable&amp;quot; : { &amp;quot;number&amp;quot; : 0, &amp;quot;sort&amp;quot; : { &amp;quot;orderBy&amp;quot; : [ { &amp;quot;property&amp;quot; : &amp;quot;createdAt&amp;quot;, &amp;quot;direction&amp;quot; : &amp;quot;DESC&amp;quot;, &amp;quot;ignoreCase&amp;quot; : false, &amp;quot;ascending&amp;quot; : false } ], &amp;quot;sorted&amp;quot; : true }, &amp;quot;size&amp;quot; : 10, &amp;quot;offset&amp;quot; : 0, &amp;quot;sorted&amp;quot; : true, &amp;quot;unpaged&amp;quot; : false }, &amp;quot;totalSize&amp;quot; : 2, &amp;quot;totalPages&amp;quot; : 1, &amp;quot;empty&amp;quot; : false, &amp;quot;size&amp;quot; : 10, &amp;quot;offset&amp;quot; : 0, &amp;quot;numberOfElements&amp;quot; : 2, &amp;quot;pageNumber&amp;quot; : 0}Customizing JsonSerializerThe Page object rendered result is a little tedious, most of case, we do not need all these fields, we can customize it via Jackson JsonSerializer.@Singletonpublic class PageJsonSerializer extends JsonSerializer&amp;lt;Page&amp;lt;?&amp;gt;&amp;gt; { @Override public void serialize(Page&amp;lt;?&amp;gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeStartObject(); gen.writeNumberField(&amp;quot;pageNumber&amp;quot;, value.getPageNumber()); if (value.getNumberOfElements() != value.getSize()) { //only display it in the last page when number of elements is not equal to page size. gen.writeNumberField(&amp;quot;numberOfElements&amp;quot;, value.getNumberOfElements()); } gen.writeNumberField(&amp;quot;size&amp;quot;, value.getSize()); gen.writeNumberField(&amp;quot;totalPages&amp;quot;, value.getTotalPages()); gen.writeNumberField(&amp;quot;totalSize&amp;quot;, value.getTotalSize()); gen.writeObjectField(&amp;quot;content&amp;quot;, value.getContent()); gen.writeEndObject(); }}Run the application again, and hint /posts endpoint.# curl http://localhost:8080/posts{ &amp;quot;pageNumber&amp;quot; : 0, &amp;quot;numberOfElements&amp;quot; : 2, &amp;quot;size&amp;quot; : 10, &amp;quot;totalPages&amp;quot; : 1, &amp;quot;totalSize&amp;quot; : 2, &amp;quot;content&amp;quot; : [ { &amp;quot;id&amp;quot; : &amp;quot;53fb77d5-4159-4a80-bab9-c76d9a535b36&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:47:05.545594&amp;quot; }, { &amp;quot;id&amp;quot; : &amp;quot;aa02fd49-0c24-4f12-b204-2e48213c7a1e&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;Getting started wit Micronaut: part 2&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T16:47:05.545594&amp;quot; } ]}Modify the testing codes to verify changes.class PostControllerTest{ //... @Test @DisplayName(&amp;quot;test GET &amp;#39;/posts&amp;#39; endpoint&amp;quot;) public void testGetAllPosts() throws Exception { var content = List.of(Post.builder().id(UUID.randomUUID()).title(&amp;quot;test title&amp;quot;).content(&amp;quot;test content&amp;quot;).build()); when(this.posts.findAll(isA(Specification.class), isA(Pageable.class))).thenReturn( Page.of(content, Pageable.from(0, 20), 1) ); var request = HttpRequest.GET(&amp;quot;/posts&amp;quot;); var response = client.toBlocking().exchange(request, String.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(JsonPath.from(body).getInt(&amp;quot;totalSize&amp;quot;)).isEqualTo(1); assertThat(JsonPath.from(body).getString(&amp;quot;content[0].title&amp;quot;)).isEqualTo(&amp;quot;test title&amp;quot;); verify(this.posts, times(1)).findAll(isA(Specification.class), isA(Pageable.class)); verifyNoMoreInteractions(this.posts); }}Creating PostsWe have discussed how to query posts by key word and get single post by id, in this section, we will focus on creating a new post.According the REST convention, we will use a POST HTTP method to send a request on endpoint /posts and accept JSON data as request body.@io.micronaut.http.annotation.Post(uri = &amp;quot;/&amp;quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&amp;lt;Void&amp;gt; create(@Body CreatePostCommand dto) { var data = Post.builder().title(dto.title()).content(dto.content()).build(); var saved = this.posts.save(data); return HttpResponse.created(URI.create(&amp;quot;/posts/&amp;quot; + saved.getId()));}The request body is deserialized as a POJO by built-in Jackson JsonDesearilizers, it is annotated with a @Body annotation to indicate which target class it will be desearilized to. After the post data is saved, set the response header Location to the URI of accessing the new post.Run the application, and try to add a post via curl, and then access the newly created post.# curl -X POST -v -H &amp;quot;Content-Type:application/json&amp;quot; http://localhost:8080/posts -d &amp;quot;{\&amp;quot;title\&amp;quot;:\&amp;quot;test title\&amp;quot;,\&amp;quot;content\&amp;quot;:\&amp;quot;test content\&amp;quot;}&amp;quot;&amp;gt; POST /posts HTTP/1.1&amp;gt; Host: localhost:8080&amp;gt; User-Agent: curl/7.55.1&amp;gt; Accept: */*&amp;gt; Content-Type:application/json&amp;gt; Content-Length: 47&amp;gt;* upload completely sent off: 47 out of 47 bytes&amp;lt; HTTP/1.1 201 Created&amp;lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&amp;lt; date: Mon, 25 Oct 2021 09:07:40 GMT&amp;lt; connection: keep-alive&amp;lt; transfer-encoding: chunked&amp;lt;# curl http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6{ &amp;quot;id&amp;quot; : &amp;quot;7db15639-62e3-4d3e-9cf4-f54413502ea6&amp;quot;, &amp;quot;title&amp;quot; : &amp;quot;test title&amp;quot;, &amp;quot;content&amp;quot; : &amp;quot;test content&amp;quot;, &amp;quot;status&amp;quot; : &amp;quot;DRAFT&amp;quot;, &amp;quot;createdAt&amp;quot; : &amp;quot;2021-10-25T17:07:40.87621&amp;quot;}Data ValidationGenerally, in a real application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support.In the above CreatPostCommand class, add Bean Validation annotations on the fields.@Introspectedpublic record CreatePostCommand(@NotBlank String title, @NotBlank String content) {}You have to add @Introspected annotation to let micronaut plugin to preprocess bean validation annotations at compile time, and let Bean Validation works without any reflections APIs at runtime time.In the PostController, add a @Validated on the class and a @Valid on the method argument.@Validatedpublic class PostController { public HttpResponse&amp;lt;Void&amp;gt; create(@Body @Valid CreatePostCommand dto) {...} //...}Let’s try to create a post. Note, set the content field empty.curl -X POST -v -H &amp;quot;Content-Type:application/json&amp;quot; http://localhost:8080/posts -d &amp;quot;{\&amp;quot;title\&amp;quot;:\&amp;quot;test title\&amp;quot;,\&amp;quot;content\&amp;quot;:\&amp;quot;\&amp;quot;}&amp;quot;&amp;gt; POST /posts HTTP/1.1&amp;gt; Host: localhost:8080&amp;gt; User-Agent: curl/7.55.1&amp;gt; Accept: */*&amp;gt; Content-Type:application/json&amp;gt; Content-Length: 35&amp;gt;* upload completely sent off: 35 out of 35 bytes&amp;lt; HTTP/1.1 400 Bad Request&amp;lt; Content-Type: application/json&amp;lt; date: Mon, 25 Oct 2021 09:23:22 GMT&amp;lt; content-length: 237&amp;lt; connection: keep-alive&amp;lt;{ &amp;quot;message&amp;quot; : &amp;quot;Bad Request&amp;quot;, &amp;quot;_embedded&amp;quot; : { &amp;quot;errors&amp;quot; : [ { &amp;quot;message&amp;quot; : &amp;quot;dto.content: must not be blank&amp;quot; } ] }, &amp;quot;_links&amp;quot; : { &amp;quot;self&amp;quot; : { &amp;quot;href&amp;quot; : &amp;quot;/posts&amp;quot;, &amp;quot;templated&amp;quot; : false } }}Deleting a PostAccording to REST convention, to delete a single post, send a DELETE request on /posts/{id}, if it is successful, returns a 204 status. If the id is not existed, returns a 404 instead.Add the following codes to the PostController.@Delete(uri = &amp;quot;/{id}&amp;quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&amp;lt;?&amp;gt; deleteById(@PathVariable UUID id) { return posts.findById(id) .map(p -&amp;gt; { this.posts.delete(p); return HttpResponse.noContent(); }) .orElseThrow(() -&amp;gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);}Processing SubresourcesIn our application, the a Comment resource, it should be a subresource of Post resource when adding comments or fetching comments of a specific post, we can design comments resource like this.POST /posts/{id}/comments , add a Comment resource to a specific Post.GET /posts/{id}/comments, get all comments of a certain Post which id value is the path variable id.// nested comments endpoints@Get(uri = &amp;quot;/{id}/comments&amp;quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&amp;lt;?&amp;gt; getCommentsByPostId(@PathVariable UUID id) { return posts.findById(id) .map(post -&amp;gt; { var comments = this.comments.findByPost(post); return ok(comments.stream().map(c -&amp;gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt()))); }) .orElseThrow(() -&amp;gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);}@io.micronaut.http.annotation.Post(uri = &amp;quot;/{id}/comments&amp;quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&amp;lt;?&amp;gt; create(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) { return posts.findById(id) .map(post -&amp;gt; { var data = Comment.builder().content(dto.content()).post(post).build(); post.getComments().add(data); var saved = this.comments.save(data); return HttpResponse.created(URI.create(&amp;quot;/comments/&amp;quot; + saved.getId())); }) .orElseThrow(() -&amp;gt; new PostNotFoundException(id)); // .orElseGet(HttpResponse::notFound);}Integration TestsThe following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server.@MicronautTest@Slf4jclass IntegrationTests { @Inject @Client(&amp;quot;/&amp;quot;) HttpClient client; @Inject EmbeddedApplication&amp;lt;?&amp;gt; application; @Test void testItWorks() { Assertions.assertTrue(application.isRunning()); } @Test void testGetAllPosts() { var response = client.exchange(HttpRequest.GET(&amp;quot;/posts&amp;quot;), String.class); var bodyFlux = Flux.from(response).map(HttpResponse::body); StepVerifier.create(bodyFlux) .consumeNextWith(posts -&amp;gt; assertThat(JsonPath.from(posts).getInt(&amp;quot;totalSize&amp;quot;)).isGreaterThanOrEqualTo(2)) .verifyComplete(); } @Test public void testCrudFlow() { //create a new post var request = HttpRequest.POST(&amp;quot;/posts&amp;quot;, new CreatePostCommand(&amp;quot;test title&amp;quot;, &amp;quot;test content&amp;quot;)); var blockingHttpClient = client.toBlocking(); var response = blockingHttpClient.exchange(request); assertThat(response.status().getCode()).isEqualTo(201); var savedUrl = response.getHeaders().get(&amp;quot;Location&amp;quot;); assertThat(savedUrl).isNotNull(); log.debug(&amp;quot;saved post url: {}&amp;quot;, savedUrl); //get by id var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class); assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200); // add comments var addCommentRequest = HttpRequest.POST(savedUrl + &amp;quot;/comments&amp;quot;, new CreateCommentCommand(&amp;quot;test content&amp;quot;)); var addCommentResponse = blockingHttpClient.exchange(addCommentRequest); assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201); var savedCommentUrl = addCommentResponse.getHeaders().get(&amp;quot;Location&amp;quot;); assertThat(savedCommentUrl).isNotNull(); // get all comments var getAllCommentsRequest = HttpRequest.GET(savedUrl + &amp;quot;/comments&amp;quot;); var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class)); assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200); assertThat(getAllCommentsResponse.body().size()).isEqualTo(1); //delete by id var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl)); assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204); //get by id again(404) var e = Assertions.assertThrows(HttpClientResponseException.class, () -&amp;gt; blockingHttpClient.exchange(HttpRequest.GET(savedUrl))); var getPostResponse2 = e.getResponse(); assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404); }}In the testGetAllPosts test, we try to use reactive HttpClient APIs and use reactor-test&amp;#39;s StepVerifier to assert the data in a reactive data stream.The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post.In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using RestAssured and Java 11 new HttpClient, check the source codes and explore them yourself.The example codes are hosted on my GitHub, check hantsy/micronaut-sandbox#post-service.Building Restful APIs with Micronaut was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Integrating Hibernate Reactive with Spring</title><link href="/blog/2021/integrating-hibernate-reactive-with-spring/" rel="alternate" type="text/html" title="Integrating Hibernate Reactive with Spring" /><published>2021-08-27T00:00:00+00:00</published><updated>2021-08-27T00:00:00+00:00</updated><id>/blog/2021/integrating-hibernate-reactive-with-spring</id><content type="html" xml:base="/blog/2021/integrating-hibernate-reactive-with-spring/">&lt;p&gt;Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*n4q8pWVkhuvNGMID3AOKHw.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@qriusv?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Vivek Kumar&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;In the former post &lt;a href=&quot;https://itnext.io/integrating-vertx-application-with-spring-framework-fb8fca81a357&quot;&gt;Integrating Vertx with Spring framework&lt;/a&gt; and &lt;a href=&quot;https://itnext.io/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive-5cf10b57983a&quot;&gt;the further post&lt;/a&gt; , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead.&lt;/p&gt;&lt;p&gt;Open your browser and navigate to &lt;a href=&quot;https://start.spring.io&quot;&gt;https://start.spring.io&lt;/a&gt;, and generate a Spring project skeleton with the following dependencies,&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;em&gt;WebFlux&lt;/em&gt;&lt;/li&gt;&lt;li&gt;&lt;em&gt;Lombok&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Extract the downloaded files into disc, and import the project into your IDE.&lt;/p&gt;&lt;p&gt;Open the project &lt;em&gt;pom.xml&lt;/em&gt; file, add the following dependencies.&lt;/p&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;    &amp;lt;groupId&amp;gt;io.vertx&amp;lt;/groupId&amp;gt;&lt;br&gt;    &amp;lt;artifactId&amp;gt;vertx-pg-client&amp;lt;/artifactId&amp;gt;&lt;br&gt;    &amp;lt;version&amp;gt;${vertx-pg-client.version}&amp;lt;/version&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/pre&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;    &amp;lt;groupId&amp;gt;org.hibernate.reactive&amp;lt;/groupId&amp;gt;&lt;br&gt;    &amp;lt;artifactId&amp;gt;hibernate-reactive-core&amp;lt;/artifactId&amp;gt;&lt;br&gt;    &amp;lt;version&amp;gt;${hibernate-reactive.version}&amp;lt;/version&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/pre&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;    &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;&lt;br&gt;    &amp;lt;artifactId&amp;gt;hibernate-jpamodelgen&amp;lt;/artifactId&amp;gt;&lt;br&gt;    &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/pre&gt;&lt;p&gt;In the above the codes:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.&lt;/li&gt;&lt;li&gt;The hibernate-reactive-core is the core dependency of Hibernate Reactive.&lt;/li&gt;&lt;li&gt;Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Add a &lt;em&gt;persistence.xml&lt;/em&gt; to &lt;em&gt;src/main/resources/META-INF&lt;/em&gt; folder.&lt;/p&gt;&lt;pre&gt;&amp;lt;persistence xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/persistence&amp;quot;&lt;br&gt;             xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;&lt;br&gt;             xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&amp;quot;&lt;br&gt;             version=&amp;quot;2.2&amp;quot;&amp;gt;&lt;/pre&gt;&lt;pre&gt;    &amp;lt;persistence-unit name=&amp;quot;blogPU&amp;quot;&amp;gt;&lt;br&gt;        &amp;lt;provider&amp;gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&amp;lt;/provider&amp;gt;&lt;/pre&gt;&lt;pre&gt;        &amp;lt;class&amp;gt;com.example.demo.Post&amp;lt;/class&amp;gt;&lt;/pre&gt;&lt;pre&gt;        &amp;lt;properties&amp;gt;&lt;/pre&gt;&lt;pre&gt;            &amp;lt;!-- PostgreSQL --&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.url&amp;quot;&lt;br&gt;                      value=&amp;quot;jdbc:postgresql://localhost:5432/blogdb&amp;quot;/&amp;gt;&lt;/pre&gt;&lt;pre&gt;            &amp;lt;!-- Credentials --&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.user&amp;quot;&lt;br&gt;                      value=&amp;quot;user&amp;quot;/&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;javax.persistence.jdbc.password&amp;quot;&lt;br&gt;                      value=&amp;quot;password&amp;quot;/&amp;gt;&lt;/pre&gt;&lt;pre&gt;            &amp;lt;!-- The Vert.x SQL Client connection pool size --&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;hibernate.connection.pool_size&amp;quot;&lt;br&gt;                      value=&amp;quot;10&amp;quot;/&amp;gt;&lt;/pre&gt;&lt;pre&gt;            &amp;lt;!-- Automatic schema export --&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;javax.persistence.schema-generation.database.action&amp;quot;&lt;br&gt;                      value=&amp;quot;drop-and-create&amp;quot;/&amp;gt;&lt;/pre&gt;&lt;pre&gt;            &amp;lt;!-- SQL statement logging --&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;hibernate.show_sql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;hibernate.format_sql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&lt;br&gt;            &amp;lt;property name=&amp;quot;hibernate.highlight_sql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;&lt;/pre&gt;&lt;pre&gt;        &amp;lt;/properties&amp;gt;&lt;/pre&gt;&lt;pre&gt;    &amp;lt;/persistence-unit&amp;gt;&lt;/pre&gt;&lt;pre&gt;&amp;lt;/persistence&amp;gt;&lt;/pre&gt;&lt;p&gt;Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this &lt;em&gt;persistence.xml&lt;/em&gt; file.&lt;/p&gt;&lt;p&gt;Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the &lt;em&gt;persistence.xml&lt;/em&gt; file.&lt;/p&gt;&lt;pre&gt;@Bean&lt;br&gt;public Mutiny.SessionFactory sessionFactory() {&lt;br&gt;    return Persistence.createEntityManagerFactory(&amp;quot;blogPU&amp;quot;)&lt;br&gt;        .unwrap(Mutiny.SessionFactory.class);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Create a sample entity class.&lt;/p&gt;&lt;pre&gt;@Data&lt;br&gt;@NoArgsConstructor&lt;br&gt;@AllArgsConstructor(staticName = &amp;quot;of&amp;quot;)&lt;br&gt;@Builder&lt;br&gt;@Entity&lt;br&gt;@Table(name = &amp;quot;posts&amp;quot;)&lt;br&gt;public class Post {&lt;/pre&gt;&lt;pre&gt;    @Id&lt;br&gt;    @GeneratedValue(generator = &amp;quot;uuid&amp;quot;)&lt;br&gt;    @GenericGenerator(name = &amp;quot;uuid&amp;quot;, strategy = &amp;quot;uuid2&amp;quot;)&lt;br&gt;    UUID id;&lt;br&gt;    String title;&lt;br&gt;    String content;&lt;/pre&gt;&lt;pre&gt;    @Builder.Default&lt;br&gt;    @Column(name = &amp;quot;created_at&amp;quot;)&lt;br&gt;    @CreationTimestamp&lt;br&gt;    LocalDateTime createdAt = LocalDateTime.now();&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;And then create a Repository class for it.&lt;/p&gt;&lt;pre&gt;@Component&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;public class PostRepository {&lt;br&gt;    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());&lt;/pre&gt;&lt;pre&gt;    private final Mutiny.SessionFactory sessionFactory;&lt;/pre&gt;&lt;pre&gt;    public Uni&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; findAll() {&lt;br&gt;        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();&lt;br&gt;        // create query&lt;br&gt;        CriteriaQuery&amp;lt;Post&amp;gt; query = cb.createQuery(Post.class);&lt;br&gt;        // set the root class&lt;br&gt;        Root&amp;lt;Post&amp;gt; root = query.from(Post.class);&lt;br&gt;        return this.sessionFactory.withSession(session -&amp;gt; session.createQuery(query).getResultList());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Uni&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; findByKeyword(String q, int offset, int limit) {&lt;/pre&gt;&lt;pre&gt;        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();&lt;br&gt;        // create query&lt;br&gt;        CriteriaQuery&amp;lt;Post&amp;gt; query = cb.createQuery(Post.class);&lt;br&gt;        // set the root class&lt;br&gt;        Root&amp;lt;Post&amp;gt; root = query.from(Post.class);&lt;/pre&gt;&lt;pre&gt;        // if keyword is provided&lt;br&gt;        if (q != null &amp;amp;&amp;amp; !q.trim().isEmpty()) {&lt;br&gt;            query.where(&lt;br&gt;                cb.or(&lt;br&gt;                    cb.like(root.get(Post_.title), &amp;quot;%&amp;quot; + q + &amp;quot;%&amp;quot;),&lt;br&gt;                    cb.like(root.get(Post_.content), &amp;quot;%&amp;quot; + q + &amp;quot;%&amp;quot;)&lt;br&gt;                )&lt;br&gt;            );&lt;br&gt;        }&lt;br&gt;        //perform query&lt;br&gt;        return this.sessionFactory.withSession(session -&amp;gt; session.createQuery(query)&lt;br&gt;            .setFirstResult(offset)&lt;br&gt;            .setMaxResults(limit)&lt;br&gt;            .getResultList());&lt;br&gt;    }&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    public Uni&amp;lt;Post&amp;gt; findById(UUID id) {&lt;br&gt;        Objects.requireNonNull(id, &amp;quot;id can not be null&amp;quot;);&lt;br&gt;        return this.sessionFactory.withSession(session -&amp;gt; session.find(Post.class, id))&lt;br&gt;            .onItem().ifNull().failWith(() -&amp;gt; new PostNotFoundException(id));&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Uni&amp;lt;Post&amp;gt; save(Post post) {&lt;br&gt;        if (post.getId() == null) {&lt;br&gt;            return this.sessionFactory.withSession(session -&amp;gt;&lt;br&gt;                session.persist(post)&lt;br&gt;                    .chain(session::flush)&lt;br&gt;                    .replaceWith(post)&lt;br&gt;            );&lt;br&gt;        } else {&lt;br&gt;            return this.sessionFactory.withSession(session -&amp;gt; session.merge(post).onItem().call(session::flush));&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Uni&amp;lt;Integer&amp;gt; deleteById(UUID id) {&lt;br&gt;        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();&lt;br&gt;        // create delete&lt;br&gt;        CriteriaDelete&amp;lt;Post&amp;gt; delete = cb.createCriteriaDelete(Post.class);&lt;br&gt;        // set the root class&lt;br&gt;        Root&amp;lt;Post&amp;gt; root = delete.from(Post.class);&lt;br&gt;        // set where clause&lt;br&gt;        delete.where(cb.equal(root.get(Post_.id), id));&lt;br&gt;        // perform update&lt;br&gt;        return this.sessionFactory.withTransaction((session, tx) -&amp;gt;&lt;br&gt;            session.createQuery(delete).executeUpdate()&lt;br&gt;        );&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Uni&amp;lt;Integer&amp;gt; deleteAll() {&lt;br&gt;        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();&lt;br&gt;        // create delete&lt;br&gt;        CriteriaDelete&amp;lt;Post&amp;gt; delete = cb.createCriteriaDelete(Post.class);&lt;br&gt;        // set the root class&lt;br&gt;        Root&amp;lt;Post&amp;gt; root = delete.from(Post.class);&lt;br&gt;        // perform update&lt;br&gt;        return this.sessionFactory.withTransaction((session, tx) -&amp;gt;&lt;br&gt;            session.createQuery(delete).executeUpdate()&lt;br&gt;        );&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&amp;#39;s begin to build the web handling part.&lt;/p&gt;&lt;p&gt;There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on &lt;a href=&quot;https://smallrye.io/smallrye-mutiny&quot;&gt;Smallrye Munity project&lt;/a&gt;. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post.&lt;/p&gt;&lt;p&gt;But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc.&lt;/p&gt;&lt;p&gt;There are some possible solutions that we can use to overcome this barrier.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.&lt;/li&gt;&lt;li&gt;Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Let’s explore them one by one.&lt;/p&gt;&lt;p&gt;Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request.&lt;/p&gt;&lt;p&gt;Add the following dependency to the project &lt;em&gt;pom.xml&lt;/em&gt; file.&lt;/p&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;    &amp;lt;groupId&amp;gt;io.smallrye.reactive&amp;lt;/groupId&amp;gt;&lt;br&gt;    &amp;lt;artifactId&amp;gt;mutiny-reactor&amp;lt;/artifactId&amp;gt;&lt;br&gt;    &amp;lt;version&amp;gt;${mutiny-reactor.version}&amp;lt;/version&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/pre&gt;&lt;p&gt;The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor.&lt;/p&gt;&lt;p&gt;The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs.&lt;/p&gt;&lt;pre&gt;@Component&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;class PostsHandler {&lt;/pre&gt;&lt;pre&gt;    private final PostRepository posts;&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;ServerResponse&amp;gt; all(ServerRequest req) {&lt;br&gt;        return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;ServerResponse&amp;gt; create(ServerRequest req) {&lt;br&gt;        return req.bodyToMono(CreatePostCommand.class)&lt;br&gt;            .flatMap(post -&amp;gt; this.posts.save(&lt;br&gt;                        Post.builder()&lt;br&gt;                            .title(post.getTitle())&lt;br&gt;                            .content(post.getContent())&lt;br&gt;                            .build()&lt;br&gt;                    )&lt;br&gt;                    .convert().with(toMono())&lt;br&gt;            )&lt;br&gt;            .flatMap(p -&amp;gt; ServerResponse.created(URI.create(&amp;quot;/posts/&amp;quot; + p.getId())).build());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;ServerResponse&amp;gt; get(ServerRequest req) {&lt;br&gt;        var id = UUID.fromString(req.pathVariable(&amp;quot;id&amp;quot;));&lt;br&gt;        return this.posts.findById(id).convert().with(toMono())&lt;br&gt;            .flatMap(post -&amp;gt; ServerResponse.ok().body(Mono.just(post), Post.class))&lt;br&gt;            .switchIfEmpty(ServerResponse.notFound().build());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;ServerResponse&amp;gt; update(ServerRequest req) {&lt;/pre&gt;&lt;pre&gt;        var id = UUID.fromString(req.pathVariable(&amp;quot;id&amp;quot;));&lt;br&gt;        return Mono.zip((data) -&amp;gt; {&lt;br&gt;                    Post p = (Post) data[0];&lt;br&gt;                    UpdatePostCommand p2 = (UpdatePostCommand) data[1];&lt;br&gt;                    p.setTitle(p2.getTitle());&lt;br&gt;                    p.setContent(p2.getContent());&lt;br&gt;                    return p;&lt;br&gt;                },&lt;br&gt;                this.posts.findById(id).convert().with(toMono()),&lt;br&gt;                req.bodyToMono(UpdatePostCommand.class)&lt;br&gt;            )&lt;br&gt;            //.cast(Post.class)&lt;br&gt;            .flatMap(post -&amp;gt; this.posts.save(post).convert().with(toMono()))&lt;br&gt;            .flatMap(post -&amp;gt; ServerResponse.noContent().build());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    public Mono&amp;lt;ServerResponse&amp;gt; delete(ServerRequest req) {&lt;br&gt;        var id = UUID.fromString(req.pathVariable(&amp;quot;id&amp;quot;));&lt;br&gt;        return this.posts.deleteById(id).convert().with(toMono())&lt;br&gt;            .flatMap(d -&amp;gt; ServerResponse.noContent().build());&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Then assemble the web handlers in a RouterFunction bean.&lt;/p&gt;&lt;pre&gt;@Bean&lt;br&gt;public RouterFunction&amp;lt;ServerResponse&amp;gt; routes(PostsHandler handler) {&lt;br&gt;    return route(GET(&amp;quot;/posts&amp;quot;), handler::all)&lt;br&gt;        .andRoute(POST(&amp;quot;/posts&amp;quot;), handler::create)&lt;br&gt;        .andRoute(GET(&amp;quot;/posts/{id}&amp;quot;), handler::get)&lt;br&gt;        .andRoute(PUT(&amp;quot;/posts/{id}&amp;quot;), handler::update)&lt;br&gt;        .andRoute(DELETE(&amp;quot;/posts/{id}&amp;quot;), handler::delete);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Add a DataInitializer bean to initialize some sample data when starting up the application.&lt;/p&gt;&lt;pre&gt;@Component&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;public class DataInitializer implements ApplicationRunner {&lt;/pre&gt;&lt;pre&gt;    private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());&lt;/pre&gt;&lt;pre&gt;    private final Mutiny.SessionFactory sessionFactory;&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public void run(ApplicationArguments args) throws Exception {&lt;br&gt;        LOGGER.info(&amp;quot;Data initialization is starting...&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        Post first = Post.of(null, &amp;quot;Hello Spring&amp;quot;, &amp;quot;My first post of Spring&amp;quot;, null);&lt;br&gt;        Post second = Post.of(null, &amp;quot;Hello Hibernate Reactive&amp;quot;, &amp;quot;My second Hibernate Reactive&amp;quot;, null);&lt;/pre&gt;&lt;pre&gt;        sessionFactory&lt;br&gt;            .withTransaction(&lt;br&gt;                (conn, tx) -&amp;gt; conn.createQuery(&amp;quot;DELETE FROM Post&amp;quot;).executeUpdate()&lt;br&gt;                    .flatMap(r -&amp;gt; conn.persistAll(first, second))&lt;br&gt;                    .chain(conn::flush)&lt;br&gt;                    .flatMap(r -&amp;gt; conn.createQuery(&amp;quot;SELECT p from Post p&amp;quot;, Post.class).getResultList())&lt;br&gt;            )&lt;br&gt;            .subscribe()&lt;br&gt;            .with(&lt;br&gt;                data -&amp;gt; LOGGER.log(Level.INFO, &amp;quot;saved data:{0}&amp;quot;, data),&lt;br&gt;                throwable -&amp;gt; LOGGER.warning(&amp;quot;Data initialization is failed:&amp;quot; + throwable.getMessage())&lt;br&gt;            );&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Start up a Postgres database. There is a &lt;a href=&quot;https://github.com/hantsy/spring-puzzles/blob/master/hibernate-reactive/docker-compose.yml&quot;&gt;&lt;em&gt;docker-compose.yml&lt;/em&gt;&lt;/a&gt; file available to start a Postgres instance in Docker container.&lt;/p&gt;&lt;p&gt;Then run the application via Spring Boot Maven plugin.&lt;/p&gt;&lt;pre&gt;// start postgres database&lt;br&gt;docker compose up &lt;/pre&gt;&lt;pre&gt;// run the application&lt;br&gt;mvn clean spring-root:run&lt;/pre&gt;&lt;p&gt;When the application is running successfully, open your terminal, and try to test &lt;a href=&quot;http://localhost:8080/posts&quot;&gt;http://localhost:8080/posts&lt;/a&gt; endpoints with curl command.&lt;/p&gt;&lt;pre&gt;# curl http://localhost:8080/posts&lt;br&gt;[{&amp;quot;id&amp;quot;:&amp;quot;0998578e-0553-480b-bbb7-e96fd402455f&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Hello Spring&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;My first post of Spring&amp;quot;,&amp;quot;createdAt&amp;quot;:&amp;quot;2021-08-26T22:37:02.076284&amp;quot;},{&amp;quot;id&amp;quot;:&amp;quot;e09ffa71-905f-4241-9449-0860977de666&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Hello Hibernate Reactive&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;My second Hibernate Reactive&amp;quot;,&amp;quot;createdAt&amp;quot;:&amp;quot;2021-08-26T22:37:02.116677&amp;quot;}]&lt;/pre&gt;&lt;pre&gt;# curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f&lt;br&gt;{&amp;quot;id&amp;quot;:&amp;quot;0998578e-0553-480b-bbb7-e96fd402455f&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Hello Spring&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;My first post of Spring&amp;quot;,&amp;quot;createdAt&amp;quot;:&amp;quot;2021-08-26T22:37:02.076284&amp;quot;}&lt;/pre&gt;&lt;p&gt;Then let’s discuss the second solution.&lt;/p&gt;&lt;p&gt;Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&amp;#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework.&lt;/p&gt;&lt;p&gt;We’ll create a new adapter to register Mutiny APIs as expected.&lt;/p&gt;&lt;pre&gt;@Component&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;@Slf4j&lt;br&gt;public class MutinyAdapter {&lt;br&gt;    private final ReactiveAdapterRegistry registry;&lt;/pre&gt;&lt;pre&gt;    @PostConstruct&lt;br&gt;    public void registerAdapters(){&lt;br&gt;        log.debug(&amp;quot;registering MutinyAdapter&amp;quot;);&lt;br&gt;        registry.registerReactiveType(&lt;br&gt;            ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&amp;gt; Uni.createFrom().nothing()),&lt;br&gt;            uni -&amp;gt;((Uni&amp;lt;?&amp;gt;)uni).convert().toPublisher(),&lt;br&gt;            publisher -&amp;gt;  Uni.createFrom().publisher(publisher)&lt;br&gt;        );&lt;/pre&gt;&lt;pre&gt;        registry.registerReactiveType(&lt;br&gt;            ReactiveTypeDescriptor.multiValue(Multi.class, ()-&amp;gt; Multi.createFrom().empty()),&lt;br&gt;            multi -&amp;gt; (Multi&amp;lt;?&amp;gt;) multi,&lt;br&gt;            publisher-&amp;gt; Multi.createFrom().publisher(publisher));&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&amp;lt;ResponseEntity&amp;gt; type directly, no need explicit conversion work there.&lt;/p&gt;&lt;pre&gt;@RestController&lt;br&gt;@RequestMapping(&amp;quot;/posts&amp;quot;)&lt;br&gt;@RequiredArgsConstructor&lt;br&gt;class PostController {&lt;/pre&gt;&lt;pre&gt;    private final PostRepository posts;&lt;/pre&gt;&lt;pre&gt;    @GetMapping(value = &amp;quot;&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE)&lt;br&gt;    public ResponseEntity&amp;lt;?&amp;gt; all() {&lt;br&gt;        return ok().body(this.posts.findAll());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @PostMapping(value = &amp;quot;&amp;quot;, consumes = MediaType.APPLICATION_JSON_VALUE)&lt;br&gt;    public Uni&amp;lt;ResponseEntity&amp;lt;?&amp;gt;&amp;gt; create(@RequestBody CreatePostCommand data) {&lt;br&gt;        return this.posts.save(&lt;br&gt;                Post.builder()&lt;br&gt;                    .title(data.getTitle())&lt;br&gt;                    .content(data.getContent())&lt;br&gt;                    .build()&lt;br&gt;            )&lt;br&gt;            .map(p -&amp;gt; created(URI.create(&amp;quot;/posts/&amp;quot; + p.getId())).build());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @GetMapping(value = &amp;quot;{id}&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE)&lt;br&gt;    public Uni&amp;lt;ResponseEntity&amp;lt;Post&amp;gt;&amp;gt; get(@PathVariable UUID id) {&lt;br&gt;        return this.posts.findById(id)&lt;br&gt;            .map(post -&amp;gt; ok().body(post));&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @PutMapping(value = &amp;quot;{id}&amp;quot;, consumes = MediaType.APPLICATION_JSON_VALUE)&lt;br&gt;    public Uni&amp;lt;ResponseEntity&amp;lt;?&amp;gt;&amp;gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) {&lt;/pre&gt;&lt;pre&gt;        return Uni.combine().all()&lt;br&gt;            .unis(&lt;br&gt;                this.posts.findById(id),&lt;br&gt;                Uni.createFrom().item(data)&lt;br&gt;            )&lt;br&gt;            .combinedWith((p, d) -&amp;gt; {&lt;br&gt;                p.setTitle(d.getTitle());&lt;br&gt;                p.setContent(d.getContent());&lt;br&gt;                return p;&lt;br&gt;            })&lt;br&gt;            .flatMap(this.posts::save)&lt;br&gt;            .map(post -&amp;gt; noContent().build());&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @DeleteMapping(&amp;quot;{id}&amp;quot;)&lt;br&gt;    public Uni&amp;lt;ResponseEntity&amp;lt;?&amp;gt;&amp;gt; delete(@PathVariable UUID id) {&lt;br&gt;        return this.posts.deleteById(id).map(d -&amp;gt; noContent().build());&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Run this application again, you will get the same result as the former solution.&lt;/p&gt;&lt;h4&gt;Get the source codes of this post from my GitHub, they are available in two separate projects, &lt;a href=&quot;https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive&quot;&gt;hibernate-reactive&lt;/a&gt; and &lt;a href=&quot;https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive-mutiny&quot;&gt;hibernate-reactive-mutiny&lt;/a&gt;.&lt;/h4&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5427440607fe&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/integrating-hibernate-reactive-with-spring-5427440607fe&quot;&gt;Integrating Hibernate Reactive with Spring&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework.Photo by Vivek Kumar on UnsplashIn the former post Integrating Vertx with Spring framework and the further post , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead.Open your browser and navigate to https://start.spring.io, and generate a Spring project skeleton with the following dependencies,WebFluxLombokExtract the downloaded files into disc, and import the project into your IDE.Open the project pom.xml file, add the following dependencies.&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.vertx&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;vertx-pg-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${vertx-pg-client.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate.reactive&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-reactive-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${hibernate-reactive.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-jpamodelgen&amp;lt;/artifactId&amp;gt; &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&amp;lt;/dependency&amp;gt;In the above the codes:The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.The hibernate-reactive-core is the core dependency of Hibernate Reactive.Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes.Add a persistence.xml to src/main/resources/META-INF folder.&amp;lt;persistence xmlns=&amp;quot;http://xmlns.jcp.org/xml/ns/persistence&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&amp;quot; version=&amp;quot;2.2&amp;quot;&amp;gt; &amp;lt;persistence-unit name=&amp;quot;blogPU&amp;quot;&amp;gt; &amp;lt;provider&amp;gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&amp;lt;/provider&amp;gt; &amp;lt;class&amp;gt;com.example.demo.Post&amp;lt;/class&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;!-- PostgreSQL --&amp;gt; &amp;lt;property name=&amp;quot;javax.persistence.jdbc.url&amp;quot; value=&amp;quot;jdbc:postgresql://localhost:5432/blogdb&amp;quot;/&amp;gt; &amp;lt;!-- Credentials --&amp;gt; &amp;lt;property name=&amp;quot;javax.persistence.jdbc.user&amp;quot; value=&amp;quot;user&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;javax.persistence.jdbc.password&amp;quot; value=&amp;quot;password&amp;quot;/&amp;gt; &amp;lt;!-- The Vert.x SQL Client connection pool size --&amp;gt; &amp;lt;property name=&amp;quot;hibernate.connection.pool_size&amp;quot; value=&amp;quot;10&amp;quot;/&amp;gt; &amp;lt;!-- Automatic schema export --&amp;gt; &amp;lt;property name=&amp;quot;javax.persistence.schema-generation.database.action&amp;quot; value=&amp;quot;drop-and-create&amp;quot;/&amp;gt; &amp;lt;!-- SQL statement logging --&amp;gt; &amp;lt;property name=&amp;quot;hibernate.show_sql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;hibernate.format_sql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;hibernate.highlight_sql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/persistence-unit&amp;gt;&amp;lt;/persistence&amp;gt;Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this persistence.xml file.Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the persistence.xml file.@Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&amp;quot;blogPU&amp;quot;) .unwrap(Mutiny.SessionFactory.class);}Create a sample entity class.@Data@NoArgsConstructor@AllArgsConstructor(staticName = &amp;quot;of&amp;quot;)@Builder@Entity@Table(name = &amp;quot;posts&amp;quot;)public class Post { @Id @GeneratedValue(generator = &amp;quot;uuid&amp;quot;) @GenericGenerator(name = &amp;quot;uuid&amp;quot;, strategy = &amp;quot;uuid2&amp;quot;) UUID id; String title; String content; @Builder.Default @Column(name = &amp;quot;created_at&amp;quot;) @CreationTimestamp LocalDateTime createdAt = LocalDateTime.now();}And then create a Repository class for it.@Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&amp;lt;Post&amp;gt; query = cb.createQuery(Post.class); // set the root class Root&amp;lt;Post&amp;gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&amp;gt; session.createQuery(query).getResultList()); } public Uni&amp;lt;List&amp;lt;Post&amp;gt;&amp;gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&amp;lt;Post&amp;gt; query = cb.createQuery(Post.class); // set the root class Root&amp;lt;Post&amp;gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;amp;&amp;amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &amp;quot;%&amp;quot; + q + &amp;quot;%&amp;quot;), cb.like(root.get(Post_.content), &amp;quot;%&amp;quot; + q + &amp;quot;%&amp;quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&amp;gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&amp;lt;Post&amp;gt; findById(UUID id) { Objects.requireNonNull(id, &amp;quot;id can not be null&amp;quot;); return this.sessionFactory.withSession(session -&amp;gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&amp;gt; new PostNotFoundException(id)); } public Uni&amp;lt;Post&amp;gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&amp;gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&amp;gt; session.merge(post).onItem().call(session::flush)); } } public Uni&amp;lt;Integer&amp;gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&amp;lt;Post&amp;gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&amp;lt;Post&amp;gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&amp;gt; session.createQuery(delete).executeUpdate() ); } public Uni&amp;lt;Integer&amp;gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&amp;lt;Post&amp;gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&amp;lt;Post&amp;gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&amp;gt; session.createQuery(delete).executeUpdate() ); }}Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&amp;#39;s begin to build the web handling part.There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on Smallrye Munity project. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post.But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc.There are some possible solutions that we can use to overcome this barrier.Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor.Let’s explore them one by one.Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request.Add the following dependency to the project pom.xml file.&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.smallrye.reactive&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mutiny-reactor&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${mutiny-reactor.version}&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor.The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs.@Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; public Mono&amp;lt;ServerResponse&amp;gt; all(ServerRequest req) { return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class); } public Mono&amp;lt;ServerResponse&amp;gt; create(ServerRequest req) { return req.bodyToMono(CreatePostCommand.class) .flatMap(post -&amp;gt; this.posts.save( Post.builder() .title(post.getTitle()) .content(post.getContent()) .build() ) .convert().with(toMono()) ) .flatMap(p -&amp;gt; ServerResponse.created(URI.create(&amp;quot;/posts/&amp;quot; + p.getId())).build()); } public Mono&amp;lt;ServerResponse&amp;gt; get(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&amp;quot;id&amp;quot;)); return this.posts.findById(id).convert().with(toMono()) .flatMap(post -&amp;gt; ServerResponse.ok().body(Mono.just(post), Post.class)) .switchIfEmpty(ServerResponse.notFound().build()); } public Mono&amp;lt;ServerResponse&amp;gt; update(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&amp;quot;id&amp;quot;)); return Mono.zip((data) -&amp;gt; { Post p = (Post) data[0]; UpdatePostCommand p2 = (UpdatePostCommand) data[1]; p.setTitle(p2.getTitle()); p.setContent(p2.getContent()); return p; }, this.posts.findById(id).convert().with(toMono()), req.bodyToMono(UpdatePostCommand.class) ) //.cast(Post.class) .flatMap(post -&amp;gt; this.posts.save(post).convert().with(toMono())) .flatMap(post -&amp;gt; ServerResponse.noContent().build()); } public Mono&amp;lt;ServerResponse&amp;gt; delete(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&amp;quot;id&amp;quot;)); return this.posts.deleteById(id).convert().with(toMono()) .flatMap(d -&amp;gt; ServerResponse.noContent().build()); }}Then assemble the web handlers in a RouterFunction bean.@Beanpublic RouterFunction&amp;lt;ServerResponse&amp;gt; routes(PostsHandler handler) { return route(GET(&amp;quot;/posts&amp;quot;), handler::all) .andRoute(POST(&amp;quot;/posts&amp;quot;), handler::create) .andRoute(GET(&amp;quot;/posts/{id}&amp;quot;), handler::get) .andRoute(PUT(&amp;quot;/posts/{id}&amp;quot;), handler::update) .andRoute(DELETE(&amp;quot;/posts/{id}&amp;quot;), handler::delete);}Add a DataInitializer bean to initialize some sample data when starting up the application.@Component@RequiredArgsConstructorpublic class DataInitializer implements ApplicationRunner { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private final Mutiny.SessionFactory sessionFactory; @Override public void run(ApplicationArguments args) throws Exception { LOGGER.info(&amp;quot;Data initialization is starting...&amp;quot;); Post first = Post.of(null, &amp;quot;Hello Spring&amp;quot;, &amp;quot;My first post of Spring&amp;quot;, null); Post second = Post.of(null, &amp;quot;Hello Hibernate Reactive&amp;quot;, &amp;quot;My second Hibernate Reactive&amp;quot;, null); sessionFactory .withTransaction( (conn, tx) -&amp;gt; conn.createQuery(&amp;quot;DELETE FROM Post&amp;quot;).executeUpdate() .flatMap(r -&amp;gt; conn.persistAll(first, second)) .chain(conn::flush) .flatMap(r -&amp;gt; conn.createQuery(&amp;quot;SELECT p from Post p&amp;quot;, Post.class).getResultList()) ) .subscribe() .with( data -&amp;gt; LOGGER.log(Level.INFO, &amp;quot;saved data:{0}&amp;quot;, data), throwable -&amp;gt; LOGGER.warning(&amp;quot;Data initialization is failed:&amp;quot; + throwable.getMessage()) ); }}Start up a Postgres database. There is a docker-compose.yml file available to start a Postgres instance in Docker container.Then run the application via Spring Boot Maven plugin.// start postgres databasedocker compose up // run the applicationmvn clean spring-root:runWhen the application is running successfully, open your terminal, and try to test http://localhost:8080/posts endpoints with curl command.# curl http://localhost:8080/posts[{&amp;quot;id&amp;quot;:&amp;quot;0998578e-0553-480b-bbb7-e96fd402455f&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Hello Spring&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;My first post of Spring&amp;quot;,&amp;quot;createdAt&amp;quot;:&amp;quot;2021-08-26T22:37:02.076284&amp;quot;},{&amp;quot;id&amp;quot;:&amp;quot;e09ffa71-905f-4241-9449-0860977de666&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Hello Hibernate Reactive&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;My second Hibernate Reactive&amp;quot;,&amp;quot;createdAt&amp;quot;:&amp;quot;2021-08-26T22:37:02.116677&amp;quot;}]# curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f{&amp;quot;id&amp;quot;:&amp;quot;0998578e-0553-480b-bbb7-e96fd402455f&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Hello Spring&amp;quot;,&amp;quot;content&amp;quot;:&amp;quot;My first post of Spring&amp;quot;,&amp;quot;createdAt&amp;quot;:&amp;quot;2021-08-26T22:37:02.076284&amp;quot;}Then let’s discuss the second solution.Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&amp;#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework.We’ll create a new adapter to register Mutiny APIs as expected.@Component@RequiredArgsConstructor@Slf4jpublic class MutinyAdapter { private final ReactiveAdapterRegistry registry; @PostConstruct public void registerAdapters(){ log.debug(&amp;quot;registering MutinyAdapter&amp;quot;); registry.registerReactiveType( ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&amp;gt; Uni.createFrom().nothing()), uni -&amp;gt;((Uni&amp;lt;?&amp;gt;)uni).convert().toPublisher(), publisher -&amp;gt; Uni.createFrom().publisher(publisher) ); registry.registerReactiveType( ReactiveTypeDescriptor.multiValue(Multi.class, ()-&amp;gt; Multi.createFrom().empty()), multi -&amp;gt; (Multi&amp;lt;?&amp;gt;) multi, publisher-&amp;gt; Multi.createFrom().publisher(publisher)); }}Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&amp;lt;ResponseEntity&amp;gt; type directly, no need explicit conversion work there.@RestController@RequestMapping(&amp;quot;/posts&amp;quot;)@RequiredArgsConstructorclass PostController { private final PostRepository posts; @GetMapping(value = &amp;quot;&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&amp;lt;?&amp;gt; all() { return ok().body(this.posts.findAll()); } @PostMapping(value = &amp;quot;&amp;quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&amp;lt;ResponseEntity&amp;lt;?&amp;gt;&amp;gt; create(@RequestBody CreatePostCommand data) { return this.posts.save( Post.builder() .title(data.getTitle()) .content(data.getContent()) .build() ) .map(p -&amp;gt; created(URI.create(&amp;quot;/posts/&amp;quot; + p.getId())).build()); } @GetMapping(value = &amp;quot;{id}&amp;quot;, produces = MediaType.APPLICATION_JSON_VALUE) public Uni&amp;lt;ResponseEntity&amp;lt;Post&amp;gt;&amp;gt; get(@PathVariable UUID id) { return this.posts.findById(id) .map(post -&amp;gt; ok().body(post)); } @PutMapping(value = &amp;quot;{id}&amp;quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&amp;lt;ResponseEntity&amp;lt;?&amp;gt;&amp;gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) { return Uni.combine().all() .unis( this.posts.findById(id), Uni.createFrom().item(data) ) .combinedWith((p, d) -&amp;gt; { p.setTitle(d.getTitle()); p.setContent(d.getContent()); return p; }) .flatMap(this.posts::save) .map(post -&amp;gt; noContent().build()); } @DeleteMapping(&amp;quot;{id}&amp;quot;) public Uni&amp;lt;ResponseEntity&amp;lt;?&amp;gt;&amp;gt; delete(@PathVariable UUID id) { return this.posts.deleteById(id).map(d -&amp;gt; noContent().build()); }}Run this application again, you will get the same result as the former solution.Get the source codes of this post from my GitHub, they are available in two separate projects, hibernate-reactive and hibernate-reactive-mutiny.Integrating Hibernate Reactive with Spring was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building GraphQL APIs with Eclipse Vertx</title><link href="/blog/2021/building-graphql-apis-with-eclipse-vertx/" rel="alternate" type="text/html" title="Building GraphQL APIs with Eclipse Vertx" /><published>2021-07-24T00:00:00+00:00</published><updated>2021-07-24T00:00:00+00:00</updated><id>/blog/2021/building-graphql-apis-with-eclipse-vertx</id><content type="html" xml:base="/blog/2021/building-graphql-apis-with-eclipse-vertx/">&lt;p&gt;We have discussed GraphQL in a former &lt;a href=&quot;https://itnext.io/building-graphql-apis-with-quarkus-dbbf23f897df&quot;&gt;Quarkus GraphQL post&lt;/a&gt;. In this post, we will explore the GraphQL support in Eclipse Vertx.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*m_nulmhV7cbLfrp0iAmbcg.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@yangshuo?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Yang Shuo&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;em&gt;Quarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;Follow the steps in the &lt;a href=&quot;https://itnext.io/building-restful-apis-with-eclipse-vertx-4ce89d8eeb74&quot;&gt;Building RESTful APIs with Eclipse Vertx&lt;/a&gt; and create a new Eclipse Vertx project, do not forget to add &lt;em&gt;GraphQL&lt;/em&gt; into &lt;strong&gt;Dependencies&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;Or add the following dependency into the existing &lt;em&gt;pom.xml&lt;/em&gt; file directly.&lt;/p&gt;&lt;pre&gt;&amp;lt;dependency&amp;gt;&lt;br&gt;     &amp;lt;groupId&amp;gt;io.vertx&amp;lt;/groupId&amp;gt;&lt;br&gt;     &amp;lt;artifactId&amp;gt;vertx-web-graphql&amp;lt;/artifactId&amp;gt;&lt;br&gt;&amp;lt;/dependency&amp;gt;&lt;/pre&gt;&lt;h4&gt;Checkout the &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/tree/master/graphql&quot;&gt;complete sample codes from my Github&lt;/a&gt;.&lt;/h4&gt;&lt;p&gt;Vertx provides a specific GraphQLHandler to handle GraphQL request from client.&lt;/p&gt;&lt;p&gt;Fill the MainVerticle with the following content.&lt;/p&gt;&lt;pre&gt;@Slf4j&lt;br&gt;public class MainVerticle extends AbstractVerticle {&lt;/pre&gt;&lt;pre&gt;    static {&lt;br&gt;        log.info(&amp;quot;Customizing the built-in jackson ObjectMapper...&amp;quot;);&lt;br&gt;        var objectMapper = DatabindCodec.mapper();&lt;br&gt;        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);&lt;br&gt;        objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);&lt;br&gt;        objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);&lt;/pre&gt;&lt;pre&gt;        JavaTimeModule module = new JavaTimeModule();&lt;br&gt;        objectMapper.registerModule(module);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public void start(Promise&amp;lt;Void&amp;gt; startPromise) throws Exception {&lt;br&gt;        log.info(&amp;quot;Starting HTTP server...&amp;quot;);&lt;br&gt;        //setupLogging();&lt;/pre&gt;&lt;pre&gt;        //Create a PgPool instance&lt;br&gt;        var pgPool = pgPool();&lt;/pre&gt;&lt;pre&gt;        // instantiate repos&lt;br&gt;        var postRepository = new PostRepository(pgPool);&lt;br&gt;        var commentRepository = new CommentRepository(pgPool);&lt;br&gt;        var authorRepository = new AuthorRepository(pgPool);&lt;/pre&gt;&lt;pre&gt;        // Initializing the sample data&lt;br&gt;        var initializer = new DataInitializer(postRepository, commentRepository, authorRepository);&lt;br&gt;        initializer.run();&lt;/pre&gt;&lt;pre&gt;        //assemble PostService&lt;br&gt;        var postService = new PostService(postRepository, commentRepository, authorRepository);&lt;br&gt;        var authorService = new AuthorService(authorRepository);&lt;/pre&gt;&lt;pre&gt;        // assemble DataLoaders&lt;br&gt;        var dataLoaders = new DataLoaders(authorService, postService);&lt;/pre&gt;&lt;pre&gt;        //assemble DataFetcher&lt;br&gt;        var dataFetchers = new DataFetchers(postService);&lt;/pre&gt;&lt;pre&gt;        // setup GraphQL&lt;br&gt;        GraphQL graphQL = setupGraphQLJava(dataFetchers);&lt;/pre&gt;&lt;pre&gt;        // Configure routes&lt;br&gt;        var router = setupRoutes(graphQL, dataLoaders);&lt;/pre&gt;&lt;pre&gt;        // enable GraphQL Websocket Protocol&lt;br&gt;        HttpServerOptions httpServerOptions = new HttpServerOptions()&lt;br&gt;            .addWebSocketSubProtocol(&amp;quot;graphql-ws&amp;quot;);&lt;br&gt;        // Create the HTTP server&lt;br&gt;        vertx.createHttpServer(httpServerOptions)&lt;br&gt;            // Handle every request using the router&lt;br&gt;            .requestHandler(router)&lt;br&gt;            // Start listening&lt;br&gt;            .listen(8080)&lt;br&gt;            // Print the port&lt;br&gt;            .onSuccess(server -&amp;gt; {&lt;br&gt;                startPromise.complete();&lt;br&gt;                log.info(&amp;quot;HTTP server started on port &amp;quot; + server.actualPort());&lt;br&gt;            })&lt;br&gt;            .onFailure(event -&amp;gt; {&lt;br&gt;                startPromise.fail(event);&lt;br&gt;                log.info(&amp;quot;Failed to start HTTP server:&amp;quot; + event.getMessage());&lt;br&gt;            })&lt;br&gt;        ;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    //create routes&lt;br&gt;    private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) {&lt;/pre&gt;&lt;pre&gt;        // Create a Router&lt;br&gt;        Router router = Router.router(vertx);&lt;/pre&gt;&lt;pre&gt;        // register BodyHandler globally.&lt;br&gt;        router.route().handler(BodyHandler.create());&lt;/pre&gt;&lt;pre&gt;        // register GraphQL Subscription websocket handler.&lt;br&gt;        ApolloWSOptions apolloWSOptions = new ApolloWSOptions();&lt;br&gt;        router.route(&amp;quot;/graphql&amp;quot;).handler(&lt;br&gt;            ApolloWSHandler.create(graphQL, apolloWSOptions)&lt;br&gt;                .connectionInitHandler(connectionInitEvent -&amp;gt; {&lt;br&gt;                    JsonObject payload = connectionInitEvent.message().content().getJsonObject(&amp;quot;payload&amp;quot;);&lt;br&gt;                    log.info(&amp;quot;connection init event: {}&amp;quot;, payload);&lt;br&gt;                    if (payload != null &amp;amp;&amp;amp; payload.containsKey(&amp;quot;rejectMessage&amp;quot;)) {&lt;br&gt;                        connectionInitEvent.fail(payload.getString(&amp;quot;rejectMessage&amp;quot;));&lt;br&gt;                        return;&lt;br&gt;                    }&lt;br&gt;                    connectionInitEvent.complete(payload);&lt;br&gt;                })&lt;br&gt;                //.connectionHandler(event -&amp;gt; log.info(&amp;quot;connection event: {}&amp;quot;, event))&lt;br&gt;                //.messageHandler(msg -&amp;gt; log.info(&amp;quot;websocket message: {}&amp;quot;, msg.content().toString()))&lt;br&gt;                //.endHandler(event -&amp;gt; log.info(&amp;quot;end event: {}&amp;quot;, event))&lt;br&gt;        );&lt;/pre&gt;&lt;pre&gt;        GraphQLHandlerOptions options = new GraphQLHandlerOptions()&lt;br&gt;            // enable multipart for file upload.&lt;br&gt;            .setRequestMultipartEnabled(true)&lt;br&gt;            .setRequestBatchingEnabled(true);&lt;br&gt;        // register `/graphql` for GraphQL handler&lt;br&gt;        // alternatively, use `router.route()` to enable GET and POST http methods&lt;br&gt;        router.post(&amp;quot;/graphql&amp;quot;)&lt;br&gt;            .handler(&lt;br&gt;                GraphQLHandler.create(graphQL, options)&lt;br&gt;                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))&lt;br&gt;                //.locale()&lt;br&gt;                //.queryContext()&lt;br&gt;            );&lt;/pre&gt;&lt;pre&gt;        // register `/graphiql` endpoint for the GraphiQL UI&lt;br&gt;        GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions()&lt;br&gt;            .setEnabled(true);&lt;br&gt;        router.get(&amp;quot;/graphiql/*&amp;quot;).handler(GraphiQLHandler.create(graphiqlOptions));&lt;/pre&gt;&lt;pre&gt;        router.get(&amp;quot;/hello&amp;quot;).handler(rc -&amp;gt; rc.response().end(&amp;quot;Hello from my route&amp;quot;));&lt;/pre&gt;&lt;pre&gt;        return router;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private Function&amp;lt;RoutingContext, DataLoaderRegistry&amp;gt; buildDataLoaderRegistry(DataLoaders dataLoaders) {&lt;br&gt;        DataLoaderRegistry registry = new DataLoaderRegistry();&lt;br&gt;        registry.register(&amp;quot;commentsLoader&amp;quot;, dataLoaders.commentsLoader());&lt;br&gt;        registry.register(&amp;quot;authorsLoader&amp;quot;, dataLoaders.authorsLoader());&lt;br&gt;        return rc -&amp;gt; registry;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @SneakyThrows&lt;br&gt;    private GraphQL setupGraphQLJava(DataFetchers dataFetchers) {&lt;br&gt;        TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry();&lt;br&gt;        RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers);&lt;br&gt;        GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring);&lt;br&gt;        return buildGraphQL(graphQLSchema);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) {&lt;br&gt;        return GraphQL.newGraphQL(graphQLSchema)&lt;br&gt;            .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler())&lt;br&gt;            //.queryExecutionStrategy()&lt;br&gt;            //.mutationExecutionStrategy()&lt;br&gt;            //.subscriptionExecutionStrategy()&lt;br&gt;            //.instrumentation()&lt;br&gt;            .build();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) {&lt;br&gt;        SchemaGenerator schemaGenerator = new SchemaGenerator();&lt;br&gt;        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);&lt;br&gt;        return graphQLSchema;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException {&lt;br&gt;        var schema = Files.readString(Paths.get(getClass().getResource(&amp;quot;/schema/schema.graphql&amp;quot;).toURI()));&lt;br&gt;        //String schema = vertx.fileSystem().readFileBlocking(&amp;quot;/schema/schema.graphql&amp;quot;).toString();&lt;/pre&gt;&lt;pre&gt;        SchemaParser schemaParser = new SchemaParser();&lt;br&gt;        TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema);&lt;br&gt;        return typeDefinitionRegistry;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) {&lt;br&gt;        return newRuntimeWiring()&lt;br&gt;            // the following codes are moved to CodeRegistry, the central place to configure the execution codes.&lt;br&gt;            /*&lt;br&gt;            .wiringFactory(new WiringFactory() {&lt;br&gt;                @Override&lt;br&gt;                public DataFetcher&amp;lt;Object&amp;gt; getDefaultDataFetcher(FieldWiringEnvironment environment) {&lt;br&gt;                    return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());&lt;br&gt;                }&lt;br&gt;            })&lt;br&gt;            .type(&amp;quot;Query&amp;quot;, builder -&amp;gt; builder&lt;br&gt;                .dataFetcher(&amp;quot;postById&amp;quot;, dataFetchers.getPostById())&lt;br&gt;                .dataFetcher(&amp;quot;allPosts&amp;quot;, dataFetchers.getAllPosts())&lt;br&gt;            )&lt;br&gt;            .type(&amp;quot;Mutation&amp;quot;, builder -&amp;gt; builder.dataFetcher(&amp;quot;createPost&amp;quot;, dataFetchers.createPost()))&lt;br&gt;            .type(&amp;quot;Post&amp;quot;, builder -&amp;gt; builder&lt;br&gt;                .dataFetcher(&amp;quot;author&amp;quot;, dataFetchers.authorOfPost())&lt;br&gt;                .dataFetcher(&amp;quot;comments&amp;quot;, dataFetchers.commentsOfPost())&lt;br&gt;            )&lt;br&gt;            */&lt;br&gt;            .codeRegistry(buildCodeRegistry(dataFetchers))&lt;br&gt;            .scalar(Scalars.localDateTimeType())&lt;br&gt;            .scalar(Scalars.uuidType())&lt;br&gt;            .scalar(UploadScalar.build())// handling `Upload` scalar&lt;br&gt;            .directive(&amp;quot;uppercase&amp;quot;, new UpperCaseDirectiveWiring())&lt;br&gt;            .build();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) {&lt;br&gt;        return GraphQLCodeRegistry.newCodeRegistry()&lt;br&gt;            .dataFetchers(&amp;quot;Query&amp;quot;, Map.of(&lt;br&gt;                &amp;quot;postById&amp;quot;, dataFetchers.getPostById(),&lt;br&gt;                &amp;quot;allPosts&amp;quot;, dataFetchers.getAllPosts()&lt;br&gt;            ))&lt;br&gt;            .dataFetchers(&amp;quot;Mutation&amp;quot;, Map.of(&lt;br&gt;                &amp;quot;createPost&amp;quot;, dataFetchers.createPost(),&lt;br&gt;                &amp;quot;upload&amp;quot;, dataFetchers.upload(),&lt;br&gt;                &amp;quot;addComment&amp;quot;, dataFetchers.addComment()&lt;br&gt;            ))&lt;br&gt;            .dataFetchers(&amp;quot;Subscription&amp;quot;, Map.of(&lt;br&gt;                &amp;quot;commentAdded&amp;quot;, dataFetchers.commentAdded()&lt;br&gt;            ))&lt;br&gt;            .dataFetchers(&amp;quot;Post&amp;quot;, Map.of(&lt;br&gt;                &amp;quot;author&amp;quot;, dataFetchers.authorOfPost(),&lt;br&gt;                &amp;quot;comments&amp;quot;, dataFetchers.commentsOfPost()&lt;br&gt;            ))&lt;br&gt;            //.typeResolver()&lt;br&gt;            //.fieldVisibility()&lt;br&gt;            .defaultDataFetcher(environment -&amp;gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()))&lt;br&gt;            .build();&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private PgPool pgPool() {&lt;br&gt;        PgConnectOptions connectOptions = new PgConnectOptions()&lt;br&gt;            .setPort(5432)&lt;br&gt;            .setHost(&amp;quot;localhost&amp;quot;)&lt;br&gt;            .setDatabase(&amp;quot;blogdb&amp;quot;)&lt;br&gt;            .setUser(&amp;quot;user&amp;quot;)&lt;br&gt;            .setPassword(&amp;quot;password&amp;quot;);&lt;/pre&gt;&lt;pre&gt;        // Pool Options&lt;br&gt;        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);&lt;/pre&gt;&lt;pre&gt;        // Create the pool from the data object&lt;br&gt;        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);&lt;/pre&gt;&lt;pre&gt;        return pool;&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;The start method is similar to the one in the previous posts, but here it enabled &lt;em&gt;graphql-ws&lt;/em&gt; WebSocket sub protocol to activate GraphQL &lt;em&gt;Subscription&lt;/em&gt; support.&lt;/p&gt;&lt;p&gt;In the &lt;em&gt;setupRoutes&lt;/em&gt; method, it adds the route &lt;em&gt;/graphql&lt;/em&gt; to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via &lt;em&gt;/graphql&lt;/em&gt; endpoint, also adds route &lt;em&gt;/graphiql&lt;/em&gt; to activate GraphiQL interactive Web UI.&lt;/p&gt;&lt;p&gt;As you see, the following is used to create a GraphQLHandler instance.&lt;/p&gt;&lt;pre&gt;GraphQLHandler.create(graphQL, options)&lt;br&gt;                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))&lt;/pre&gt;&lt;p&gt;It requires a GraphQL instance and optional options to initialize a GraphQL instance.&lt;/p&gt;&lt;p&gt;To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.&lt;/li&gt;&lt;li&gt;A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance.&lt;/p&gt;&lt;p&gt;Let’s have a look at the graphql schema file under the &lt;em&gt;main/resources/schema/schema.graphql&lt;/em&gt; folder.&lt;/p&gt;&lt;pre&gt;directive @uppercase on FIELD_DEFINITION&lt;/pre&gt;&lt;pre&gt;scalar LocalDateTime&lt;br&gt;scalar UUID&lt;br&gt;scalar Upload&lt;/pre&gt;&lt;pre&gt;type Post {&lt;br&gt;    id: ID!&lt;br&gt;    title: String! @uppercase&lt;br&gt;    content: String&lt;br&gt;    comments: [Comment]&lt;br&gt;    status: PostStatus&lt;br&gt;    createdAt: LocalDateTime&lt;br&gt;    authorId: String&lt;br&gt;    author: Author&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;type Author {&lt;br&gt;    id: ID!&lt;br&gt;    name: String!&lt;br&gt;    email: String!&lt;br&gt;    createdAt: LocalDateTime&lt;br&gt;    posts: [Post]&lt;br&gt;}&lt;br&gt;type Comment {&lt;br&gt;    id: ID!&lt;br&gt;    content: String!&lt;br&gt;    createdAt: LocalDateTime&lt;br&gt;    postId: String!&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;input CreatePostInput {&lt;br&gt;    title: String!&lt;br&gt;    content: String!&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;input CommentInput {&lt;br&gt;    postId: String!&lt;br&gt;    content: String!&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;type Query {&lt;br&gt;    allPosts: [Post!]!&lt;br&gt;    postById(postId: String!): Post&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;type Mutation {&lt;br&gt;    createPost(createPostInput: CreatePostInput!): UUID!&lt;br&gt;    upload(file: Upload!): Boolean&lt;br&gt;    addComment(commentInput: CommentInput!): UUID!&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;type Subscription{&lt;br&gt;    commentAdded: Comment!&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;enum PostStatus {&lt;br&gt;    DRAFT&lt;br&gt;    PENDING_MODERATION&lt;br&gt;    PUBLISHED&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In this schema file, we declare 3 top level types: &lt;em&gt;Query&lt;/em&gt;, &lt;em&gt;Mutation&lt;/em&gt; and &lt;em&gt;Subscription&lt;/em&gt; which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The &lt;em&gt;scalar&lt;/em&gt; keyword defines custom scalar types. The &lt;em&gt;directive&lt;/em&gt; defines custom directive &lt;em&gt;@uppercase&lt;/em&gt; applied on field.&lt;/p&gt;&lt;p&gt;In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions.&lt;/p&gt;&lt;p&gt;For example, when performing a &lt;em&gt;Query&lt;/em&gt;: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method.&lt;/p&gt;&lt;pre&gt;.dataFetchers(&amp;quot;Query&amp;quot;, Map.of(&lt;br&gt;                &amp;quot;postById&amp;quot;, dataFetchers.getPostById(),&lt;br&gt;    ...&lt;/pre&gt;&lt;p&gt;Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc.&lt;/p&gt;&lt;p&gt;The following is an example of custom Scalar type.&lt;/p&gt;&lt;pre&gt;// LocalDateTimeScalar&lt;br&gt;public class LocalDateTimeScalar implements Coercing&amp;lt;LocalDateTime, String&amp;gt; {&lt;br&gt;    @Override&lt;br&gt;    public String serialize(Object dataFetcherResult) throws CoercingSerializeException {&lt;br&gt;        if (dataFetcherResult instanceof LocalDateTime) {&lt;br&gt;            return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME);&lt;br&gt;        } else {&lt;br&gt;            throw new CoercingSerializeException(&amp;quot;Not a valid DateTime&amp;quot;);&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public LocalDateTime parseValue(Object input) throws CoercingParseValueException {&lt;br&gt;        return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Override&lt;br&gt;    public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException {&lt;br&gt;        if (input instanceof StringValue) {&lt;br&gt;            return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME);&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        throw new CoercingParseLiteralException(&amp;quot;Value is not a valid ISO date time&amp;quot;);&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;//Scalars&lt;br&gt;public class Scalars {&lt;/pre&gt;&lt;pre&gt;    public static GraphQLScalarType localDateTimeType() {&lt;br&gt;        return GraphQLScalarType.newScalar()&lt;br&gt;                .name(&amp;quot;LocalDateTime&amp;quot;)&lt;br&gt;                .description(&amp;quot;LocalDateTime type&amp;quot;)&lt;br&gt;                .coercing(new LocalDateTimeScalar())&lt;br&gt;                .build();&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;//register custom scalar type in the MainVertcle buildRuntimeWiring&lt;br&gt;newRuntimeWiring()&lt;br&gt;    ...&lt;br&gt;    .scalar(Scalars.localDateTimeType())&lt;/pre&gt;&lt;p&gt;Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself.&lt;/p&gt;&lt;p&gt;Similarly register a custom &lt;em&gt;Directive&lt;/em&gt; in the buildRuntimeWiring, eg. the @uppercase directive.&lt;/p&gt;&lt;pre&gt;//UpperCaseDirectiveWiring&lt;br&gt;public class UpperCaseDirectiveWiring implements SchemaDirectiveWiring {&lt;br&gt;    @Override&lt;br&gt;    public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&amp;lt;GraphQLFieldDefinition&amp;gt; env) {&lt;/pre&gt;&lt;pre&gt;        var field = env.getElement();&lt;br&gt;        var parentType = env.getFieldsContainer();&lt;/pre&gt;&lt;pre&gt;        var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field);&lt;br&gt;        var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher,&lt;br&gt;                (dataFetchingEnvironment, value) -&amp;gt; {&lt;br&gt;                    if (value instanceof String s) {&lt;br&gt;                        return s.toUpperCase();&lt;br&gt;                    }&lt;br&gt;                    return value;&lt;br&gt;                }&lt;br&gt;        );&lt;/pre&gt;&lt;pre&gt;        env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher);&lt;br&gt;        return field;&lt;br&gt;    }&lt;br&gt;}&lt;br&gt;//register custom scalar directive in the MainVertcle buildRuntimeWiring&lt;br&gt;newRuntimeWiring()&lt;br&gt;    ...&lt;br&gt;    .directive(&amp;quot;uppercase&amp;quot;, new UpperCaseDirectiveWiring())&lt;/pre&gt;&lt;p&gt;Let’s move on to the data fetchers which are responsible for resolving the type values at runtime.&lt;/p&gt;&lt;p&gt;For example, in the GraphiQL UI page, try to send a predefined query like this.&lt;/p&gt;&lt;pre&gt;query {&lt;br&gt;    allPosts{&lt;br&gt;        id&lt;br&gt;        title&lt;br&gt;        content&lt;br&gt;        author{ name }&lt;br&gt;        comments{ content }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;It means, it will perform an allPosts &lt;em&gt;Query&lt;/em&gt;, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field.&lt;/p&gt;&lt;p&gt;When the GraphQL request is sent, GraphQLHandler will handle it.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Validate the GraphQL request and ensure it follows schema type definitions.&lt;/li&gt;&lt;li&gt;Locate the data fetchers via type coordinates, &lt;em&gt;Query&lt;/em&gt; and &lt;em&gt;allPosts&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;Assemble the returned values according to the request format.&lt;/li&gt;&lt;li&gt;When resolving author field, it will try to locate &lt;em&gt;Post&lt;/em&gt; and &lt;em&gt;author&lt;/em&gt; to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles &lt;em&gt;comments&lt;/em&gt; via dataFetchers.commentsOfPost().&lt;/li&gt;&lt;li&gt;Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it.&lt;/p&gt;&lt;p&gt;The file uploading is defined by &lt;a href=&quot;https://github.com/jaydenseric/graphql-multipart-request-spec&quot;&gt;GraphQL multipart request specification&lt;/a&gt;, not part of the standard GraphQL spec.&lt;/p&gt;&lt;p&gt;The following is the data fetcher to handle the file uploading.&lt;/p&gt;&lt;pre&gt;public DataFetcher&amp;lt;Boolean&amp;gt; upload() {&lt;br&gt;    return (DataFetchingEnvironment dfe) -&amp;gt; {&lt;/pre&gt;&lt;pre&gt;        FileUpload upload = dfe.getArgument(&amp;quot;file&amp;quot;);&lt;br&gt;        log.info(&amp;quot;name: {}&amp;quot;, upload.name());&lt;br&gt;        log.info(&amp;quot;file name: {}&amp;quot;, upload.fileName());&lt;br&gt;        log.info(&amp;quot;uploaded file name: {}&amp;quot;, upload.uploadedFileName());&lt;br&gt;        log.info(&amp;quot;content type: {}&amp;quot;, upload.contentType());&lt;br&gt;        log.info(&amp;quot;charset: {}&amp;quot;, upload.charSet());&lt;br&gt;        log.info(&amp;quot;size: {}&amp;quot;, upload.size());&lt;br&gt;        //            String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString();&lt;br&gt;        //            log.info(&amp;quot;file content: {}&amp;quot;, fileContent);&lt;br&gt;        return true;&lt;br&gt;    };&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system.&lt;/p&gt;&lt;p&gt;For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type.&lt;/p&gt;&lt;p&gt;The following is an example of sending notification when a comment is added.&lt;/p&gt;&lt;pre&gt;public VertxDataFetcher&amp;lt;UUID&amp;gt; addComment() {&lt;br&gt;    return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&amp;gt; {&lt;br&gt;        var commentInputArg = dfe.getArgument(&amp;quot;commentInput&amp;quot;);&lt;br&gt;        var jacksonMapper = DatabindCodec.mapper();&lt;br&gt;        var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class);&lt;br&gt;        return this.posts.addComment(input)&lt;br&gt;            .onSuccess(id -&amp;gt; this.posts.getCommentById(id.toString())&lt;br&gt;                       .onSuccess(c -&amp;gt; subject.onNext(c)));&lt;br&gt;    });&lt;br&gt;}&lt;/pre&gt;&lt;pre&gt;private ReplaySubject&amp;lt;Comment&amp;gt; subject = ReplaySubject.create(1);&lt;/pre&gt;&lt;pre&gt;public DataFetcher&amp;lt;Publisher&amp;lt;Comment&amp;gt;&amp;gt; commentAdded() {&lt;br&gt;    return (DataFetchingEnvironment dfe) -&amp;gt; {&lt;br&gt;        ApolloWSMessage message = dfe.getContext();&lt;br&gt;        log.info(&amp;quot;msg: {}, connectionParams: {}&amp;quot;, message.content(), message.connectionParams());&lt;br&gt;        ConnectableObservable&amp;lt;Comment&amp;gt; connectableObservable = subject.share().publish();&lt;br&gt;        connectableObservable.connect();&lt;br&gt;        log.info(&amp;quot;connect to `commentAdded`&amp;quot;);&lt;br&gt;        return connectableObservable.toFlowable(BackpressureStrategy.BUFFER);&lt;br&gt;    };&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints.&lt;/p&gt;&lt;p&gt;Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/tree/master/graphql&quot;&gt;complete sample codes from my Github&lt;/a&gt; and explore it yourself.&lt;/p&gt;&lt;p&gt;Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java.&lt;/p&gt;&lt;p&gt;To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about &lt;a href=&quot;https://graphql.org/learn/serving-over-http/&quot;&gt;GraphQL over HTTP specification&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The following is an example of testing &lt;em&gt;allPosts&lt;/em&gt; query and &lt;em&gt;createPost&lt;/em&gt; mutation using Vertx HttpClient.&lt;/p&gt;&lt;pre&gt;@ExtendWith(VertxExtension.class)&lt;br&gt;@Slf4j&lt;br&gt;public class TestMainVerticle {&lt;/pre&gt;&lt;pre&gt;    HttpClient client;&lt;/pre&gt;&lt;pre&gt;    @BeforeEach&lt;br&gt;    void setup(Vertx vertx, VertxTestContext testContext) {&lt;br&gt;        vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&amp;gt; testContext.completeNow()));&lt;br&gt;        var options = new HttpClientOptions()&lt;br&gt;            .setDefaultHost(&amp;quot;localhost&amp;quot;)&lt;br&gt;            .setDefaultPort(8080);&lt;br&gt;        client = vertx.createHttpClient(options);&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable {&lt;br&gt;        var query = &amp;quot;&amp;quot;&amp;quot;&lt;br&gt;            query {&lt;br&gt;                allPosts{&lt;br&gt;                    id&lt;br&gt;                    title&lt;br&gt;                    content&lt;br&gt;                    author{ name }&lt;br&gt;                    comments{ content }&lt;br&gt;                }&lt;br&gt;            }&amp;quot;&amp;quot;&amp;quot;;&lt;br&gt;        client.request(HttpMethod.POST, &amp;quot;/graphql&amp;quot;)&lt;br&gt;            .flatMap(req -&amp;gt; req.putHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)&lt;br&gt;                .putHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;)&lt;br&gt;                .send(Json.encode(Map.of(&amp;quot;query&amp;quot;, query)))//have to use Json.encode to convert objects to json string.&lt;br&gt;                .flatMap(HttpClientResponse::body)&lt;br&gt;            )&lt;br&gt;            .onComplete(&lt;br&gt;                testContext.succeeding(&lt;br&gt;                    buffer -&amp;gt; testContext.verify(&lt;br&gt;                        () -&amp;gt; {&lt;br&gt;                            log.info(&amp;quot;buf: {}&amp;quot;, buffer.toString());&lt;br&gt;                            JsonArray array = buffer.toJsonObject()&lt;br&gt;                                .getJsonObject(&amp;quot;data&amp;quot;)&lt;br&gt;                                .getJsonArray(&amp;quot;allPosts&amp;quot;);&lt;br&gt;                            assertThat(array.size()).isGreaterThan(0);&lt;/pre&gt;&lt;pre&gt;                            var titles = array.getList().stream().map(o -&amp;gt; ((Map&amp;lt;String, Object&amp;gt;) o).get(&amp;quot;title&amp;quot;)).toList();&lt;br&gt;                            assertThat(titles).allMatch(s -&amp;gt; ((String) s).startsWith(&amp;quot;DGS POST&amp;quot;));&lt;br&gt;                            testContext.completeNow();&lt;br&gt;                        }&lt;br&gt;                    )&lt;br&gt;                )&lt;br&gt;            );&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    @Test&lt;br&gt;    void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable {&lt;br&gt;        String TITLE = &amp;quot;My post created by Vertx HttpClient&amp;quot;;&lt;br&gt;        //var creatPostQuery = &amp;quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&amp;quot;;&lt;br&gt;        var creatPostQuery = &amp;quot;&amp;quot;&amp;quot;&lt;br&gt;            mutation newPost($input:CreatePostInput!){&lt;br&gt;                createPost(createPostInput:$input)&lt;br&gt;            }&amp;quot;&amp;quot;&amp;quot;;&lt;br&gt;        client.request(HttpMethod.POST, &amp;quot;/graphql&amp;quot;)&lt;br&gt;            .flatMap(req -&amp;gt; {&lt;br&gt;                    String encodedJson = Json.encode(Map.of(&lt;br&gt;                        &amp;quot;query&amp;quot;, creatPostQuery,&lt;br&gt;                        &amp;quot;variables&amp;quot;, Map.of(&lt;br&gt;                            &amp;quot;input&amp;quot;, Map.of(&lt;br&gt;                                &amp;quot;title&amp;quot;, TITLE,&lt;br&gt;                                &amp;quot;content&amp;quot;, &amp;quot;content of my post&amp;quot;&lt;br&gt;                            )&lt;br&gt;                        )&lt;br&gt;                    ));&lt;br&gt;                    log.info(&amp;quot;sending encoded json: {}&amp;quot;, encodedJson);&lt;br&gt;                    return req.putHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)&lt;br&gt;                        .putHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;)&lt;br&gt;                        .send(encodedJson)//have to use Json.encode to convert objects to json string.&lt;br&gt;                        .flatMap(HttpClientResponse::body);&lt;br&gt;                }&lt;br&gt;            )&lt;br&gt;            .flatMap(buf -&amp;gt; {&lt;br&gt;                Object id = buf.toJsonObject().getJsonObject(&amp;quot;data&amp;quot;).getValue(&amp;quot;createPost&amp;quot;);&lt;/pre&gt;&lt;pre&gt;                log.info(&amp;quot;created post: {}&amp;quot;, id);&lt;br&gt;                assertThat(id).isNotNull();&lt;/pre&gt;&lt;pre&gt;                var postById = &amp;quot;&amp;quot;&amp;quot;&lt;br&gt;                    query post($id:String!) {&lt;br&gt;                        postById(postId:$id){id title content}&lt;br&gt;                    }&amp;quot;&amp;quot;&amp;quot;;&lt;/pre&gt;&lt;pre&gt;                return client.request(HttpMethod.POST, &amp;quot;/graphql&amp;quot;)&lt;br&gt;                    .flatMap(req -&amp;gt; req.putHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)&lt;br&gt;                        .putHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;)&lt;br&gt;                        .send(Json.encode(Map.of(&lt;br&gt;                            &amp;quot;query&amp;quot;, postById,&lt;br&gt;                            &amp;quot;variables&amp;quot;, Map.of(&amp;quot;id&amp;quot;, id.toString())&lt;br&gt;                        )))//have to use Json.encode to convert objects to json string.&lt;br&gt;                        .flatMap(HttpClientResponse::body)&lt;br&gt;                    );&lt;br&gt;            })&lt;br&gt;            .onComplete(&lt;br&gt;                testContext.succeeding(&lt;br&gt;                    buffer -&amp;gt; testContext.verify(&lt;br&gt;                        () -&amp;gt; {&lt;br&gt;                            log.info(&amp;quot;buf: {}&amp;quot;, buffer.toString());&lt;br&gt;                            String title = buffer.toJsonObject()&lt;br&gt;                                .getJsonObject(&amp;quot;data&amp;quot;)&lt;br&gt;                                .getJsonObject(&amp;quot;postById&amp;quot;)&lt;br&gt;                                .getString(&amp;quot;title&amp;quot;);&lt;br&gt;                            assertThat(title).isEqualTo(TITLE.toUpperCase());&lt;br&gt;                            testContext.completeNow();&lt;br&gt;                        }&lt;br&gt;                    )&lt;br&gt;                )&lt;br&gt;            );&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Get the &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/tree/master/graphql&quot;&gt;sample codes from my Github&lt;/a&gt;.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=2f3a4e584370&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/building-graphql-apis-with-eclipse-vertx-2f3a4e584370&quot;&gt;Building GraphQL APIs with Eclipse Vertx&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">We have discussed GraphQL in a former Quarkus GraphQL post. In this post, we will explore the GraphQL support in Eclipse Vertx.Photo by Yang Shuo on UnsplashQuarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature.Follow the steps in the Building RESTful APIs with Eclipse Vertx and create a new Eclipse Vertx project, do not forget to add GraphQL into Dependencies.Or add the following dependency into the existing pom.xml file directly.&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.vertx&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;vertx-web-graphql&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt;Checkout the complete sample codes from my Github.Vertx provides a specific GraphQLHandler to handle GraphQL request from client.Fill the MainVerticle with the following content.@Slf4jpublic class MainVerticle extends AbstractVerticle { static { log.info(&amp;quot;Customizing the built-in jackson ObjectMapper...&amp;quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public void start(Promise&amp;lt;Void&amp;gt; startPromise) throws Exception { log.info(&amp;quot;Starting HTTP server...&amp;quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); // instantiate repos var postRepository = new PostRepository(pgPool); var commentRepository = new CommentRepository(pgPool); var authorRepository = new AuthorRepository(pgPool); // Initializing the sample data var initializer = new DataInitializer(postRepository, commentRepository, authorRepository); initializer.run(); //assemble PostService var postService = new PostService(postRepository, commentRepository, authorRepository); var authorService = new AuthorService(authorRepository); // assemble DataLoaders var dataLoaders = new DataLoaders(authorService, postService); //assemble DataFetcher var dataFetchers = new DataFetchers(postService); // setup GraphQL GraphQL graphQL = setupGraphQLJava(dataFetchers); // Configure routes var router = setupRoutes(graphQL, dataLoaders); // enable GraphQL Websocket Protocol HttpServerOptions httpServerOptions = new HttpServerOptions() .addWebSocketSubProtocol(&amp;quot;graphql-ws&amp;quot;); // Create the HTTP server vertx.createHttpServer(httpServerOptions) // Handle every request using the router .requestHandler(router) // Start listening .listen(8080) // Print the port .onSuccess(server -&amp;gt; { startPromise.complete(); log.info(&amp;quot;HTTP server started on port &amp;quot; + server.actualPort()); }) .onFailure(event -&amp;gt; { startPromise.fail(event); log.info(&amp;quot;Failed to start HTTP server:&amp;quot; + event.getMessage()); }) ; } //create routes private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. router.route().handler(BodyHandler.create()); // register GraphQL Subscription websocket handler. ApolloWSOptions apolloWSOptions = new ApolloWSOptions(); router.route(&amp;quot;/graphql&amp;quot;).handler( ApolloWSHandler.create(graphQL, apolloWSOptions) .connectionInitHandler(connectionInitEvent -&amp;gt; { JsonObject payload = connectionInitEvent.message().content().getJsonObject(&amp;quot;payload&amp;quot;); log.info(&amp;quot;connection init event: {}&amp;quot;, payload); if (payload != null &amp;amp;&amp;amp; payload.containsKey(&amp;quot;rejectMessage&amp;quot;)) { connectionInitEvent.fail(payload.getString(&amp;quot;rejectMessage&amp;quot;)); return; } connectionInitEvent.complete(payload); }) //.connectionHandler(event -&amp;gt; log.info(&amp;quot;connection event: {}&amp;quot;, event)) //.messageHandler(msg -&amp;gt; log.info(&amp;quot;websocket message: {}&amp;quot;, msg.content().toString())) //.endHandler(event -&amp;gt; log.info(&amp;quot;end event: {}&amp;quot;, event)) ); GraphQLHandlerOptions options = new GraphQLHandlerOptions() // enable multipart for file upload. .setRequestMultipartEnabled(true) .setRequestBatchingEnabled(true); // register `/graphql` for GraphQL handler // alternatively, use `router.route()` to enable GET and POST http methods router.post(&amp;quot;/graphql&amp;quot;) .handler( GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) //.locale() //.queryContext() ); // register `/graphiql` endpoint for the GraphiQL UI GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions() .setEnabled(true); router.get(&amp;quot;/graphiql/*&amp;quot;).handler(GraphiQLHandler.create(graphiqlOptions)); router.get(&amp;quot;/hello&amp;quot;).handler(rc -&amp;gt; rc.response().end(&amp;quot;Hello from my route&amp;quot;)); return router; } private Function&amp;lt;RoutingContext, DataLoaderRegistry&amp;gt; buildDataLoaderRegistry(DataLoaders dataLoaders) { DataLoaderRegistry registry = new DataLoaderRegistry(); registry.register(&amp;quot;commentsLoader&amp;quot;, dataLoaders.commentsLoader()); registry.register(&amp;quot;authorsLoader&amp;quot;, dataLoaders.authorsLoader()); return rc -&amp;gt; registry; } @SneakyThrows private GraphQL setupGraphQLJava(DataFetchers dataFetchers) { TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry(); RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers); GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring); return buildGraphQL(graphQLSchema); } private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) { return GraphQL.newGraphQL(graphQLSchema) .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler()) //.queryExecutionStrategy() //.mutationExecutionStrategy() //.subscriptionExecutionStrategy() //.instrumentation() .build(); } private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) { SchemaGenerator schemaGenerator = new SchemaGenerator(); GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring); return graphQLSchema; } private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException { var schema = Files.readString(Paths.get(getClass().getResource(&amp;quot;/schema/schema.graphql&amp;quot;).toURI())); //String schema = vertx.fileSystem().readFileBlocking(&amp;quot;/schema/schema.graphql&amp;quot;).toString(); SchemaParser schemaParser = new SchemaParser(); TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema); return typeDefinitionRegistry; } private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) { return newRuntimeWiring() // the following codes are moved to CodeRegistry, the central place to configure the execution codes. /* .wiringFactory(new WiringFactory() { @Override public DataFetcher&amp;lt;Object&amp;gt; getDefaultDataFetcher(FieldWiringEnvironment environment) { return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()); } }) .type(&amp;quot;Query&amp;quot;, builder -&amp;gt; builder .dataFetcher(&amp;quot;postById&amp;quot;, dataFetchers.getPostById()) .dataFetcher(&amp;quot;allPosts&amp;quot;, dataFetchers.getAllPosts()) ) .type(&amp;quot;Mutation&amp;quot;, builder -&amp;gt; builder.dataFetcher(&amp;quot;createPost&amp;quot;, dataFetchers.createPost())) .type(&amp;quot;Post&amp;quot;, builder -&amp;gt; builder .dataFetcher(&amp;quot;author&amp;quot;, dataFetchers.authorOfPost()) .dataFetcher(&amp;quot;comments&amp;quot;, dataFetchers.commentsOfPost()) ) */ .codeRegistry(buildCodeRegistry(dataFetchers)) .scalar(Scalars.localDateTimeType()) .scalar(Scalars.uuidType()) .scalar(UploadScalar.build())// handling `Upload` scalar .directive(&amp;quot;uppercase&amp;quot;, new UpperCaseDirectiveWiring()) .build(); } private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) { return GraphQLCodeRegistry.newCodeRegistry() .dataFetchers(&amp;quot;Query&amp;quot;, Map.of( &amp;quot;postById&amp;quot;, dataFetchers.getPostById(), &amp;quot;allPosts&amp;quot;, dataFetchers.getAllPosts() )) .dataFetchers(&amp;quot;Mutation&amp;quot;, Map.of( &amp;quot;createPost&amp;quot;, dataFetchers.createPost(), &amp;quot;upload&amp;quot;, dataFetchers.upload(), &amp;quot;addComment&amp;quot;, dataFetchers.addComment() )) .dataFetchers(&amp;quot;Subscription&amp;quot;, Map.of( &amp;quot;commentAdded&amp;quot;, dataFetchers.commentAdded() )) .dataFetchers(&amp;quot;Post&amp;quot;, Map.of( &amp;quot;author&amp;quot;, dataFetchers.authorOfPost(), &amp;quot;comments&amp;quot;, dataFetchers.commentsOfPost() )) //.typeResolver() //.fieldVisibility() .defaultDataFetcher(environment -&amp;gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName())) .build(); } private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&amp;quot;localhost&amp;quot;) .setDatabase(&amp;quot;blogdb&amp;quot;) .setUser(&amp;quot;user&amp;quot;) .setPassword(&amp;quot;password&amp;quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; }}The start method is similar to the one in the previous posts, but here it enabled graphql-ws WebSocket sub protocol to activate GraphQL Subscription support.In the setupRoutes method, it adds the route /graphql to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via /graphql endpoint, also adds route /graphiql to activate GraphiQL interactive Web UI.As you see, the following is used to create a GraphQLHandler instance.GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))It requires a GraphQL instance and optional options to initialize a GraphQL instance.To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects:A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method.In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance.Let’s have a look at the graphql schema file under the main/resources/schema/schema.graphql folder.directive @uppercase on FIELD_DEFINITIONscalar LocalDateTimescalar UUIDscalar Uploadtype Post { id: ID! title: String! @uppercase content: String comments: [Comment] status: PostStatus createdAt: LocalDateTime authorId: String author: Author}type Author { id: ID! name: String! email: String! createdAt: LocalDateTime posts: [Post]}type Comment { id: ID! content: String! createdAt: LocalDateTime postId: String!}input CreatePostInput { title: String! content: String!}input CommentInput { postId: String! content: String!}type Query { allPosts: [Post!]! postById(postId: String!): Post}type Mutation { createPost(createPostInput: CreatePostInput!): UUID! upload(file: Upload!): Boolean addComment(commentInput: CommentInput!): UUID!}type Subscription{ commentAdded: Comment!}enum PostStatus { DRAFT PENDING_MODERATION PUBLISHED}In this schema file, we declare 3 top level types: Query, Mutation and Subscription which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The scalar keyword defines custom scalar types. The directive defines custom directive @uppercase applied on field.In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions.For example, when performing a Query: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method..dataFetchers(&amp;quot;Query&amp;quot;, Map.of( &amp;quot;postById&amp;quot;, dataFetchers.getPostById(), ...Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc.The following is an example of custom Scalar type.// LocalDateTimeScalarpublic class LocalDateTimeScalar implements Coercing&amp;lt;LocalDateTime, String&amp;gt; { @Override public String serialize(Object dataFetcherResult) throws CoercingSerializeException { if (dataFetcherResult instanceof LocalDateTime) { return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME); } else { throw new CoercingSerializeException(&amp;quot;Not a valid DateTime&amp;quot;); } } @Override public LocalDateTime parseValue(Object input) throws CoercingParseValueException { return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME); } @Override public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException { if (input instanceof StringValue) { return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME); } throw new CoercingParseLiteralException(&amp;quot;Value is not a valid ISO date time&amp;quot;); }}//Scalarspublic class Scalars { public static GraphQLScalarType localDateTimeType() { return GraphQLScalarType.newScalar() .name(&amp;quot;LocalDateTime&amp;quot;) .description(&amp;quot;LocalDateTime type&amp;quot;) .coercing(new LocalDateTimeScalar()) .build(); }}//register custom scalar type in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .scalar(Scalars.localDateTimeType())Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself.Similarly register a custom Directive in the buildRuntimeWiring, eg. the @uppercase directive.//UpperCaseDirectiveWiringpublic class UpperCaseDirectiveWiring implements SchemaDirectiveWiring { @Override public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&amp;lt;GraphQLFieldDefinition&amp;gt; env) { var field = env.getElement(); var parentType = env.getFieldsContainer(); var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field); var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher, (dataFetchingEnvironment, value) -&amp;gt; { if (value instanceof String s) { return s.toUpperCase(); } return value; } ); env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher); return field; }}//register custom scalar directive in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .directive(&amp;quot;uppercase&amp;quot;, new UpperCaseDirectiveWiring())Let’s move on to the data fetchers which are responsible for resolving the type values at runtime.For example, in the GraphiQL UI page, try to send a predefined query like this.query { allPosts{ id title content author{ name } comments{ content } }}It means, it will perform an allPosts Query, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field.When the GraphQL request is sent, GraphQLHandler will handle it.Validate the GraphQL request and ensure it follows schema type definitions.Locate the data fetchers via type coordinates, Query and allPosts.Assemble the returned values according to the request format.When resolving author field, it will try to locate Post and author to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles comments via dataFetchers.commentsOfPost().Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly.The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it.The file uploading is defined by GraphQL multipart request specification, not part of the standard GraphQL spec.The following is the data fetcher to handle the file uploading.public DataFetcher&amp;lt;Boolean&amp;gt; upload() { return (DataFetchingEnvironment dfe) -&amp;gt; { FileUpload upload = dfe.getArgument(&amp;quot;file&amp;quot;); log.info(&amp;quot;name: {}&amp;quot;, upload.name()); log.info(&amp;quot;file name: {}&amp;quot;, upload.fileName()); log.info(&amp;quot;uploaded file name: {}&amp;quot;, upload.uploadedFileName()); log.info(&amp;quot;content type: {}&amp;quot;, upload.contentType()); log.info(&amp;quot;charset: {}&amp;quot;, upload.charSet()); log.info(&amp;quot;size: {}&amp;quot;, upload.size()); // String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString(); // log.info(&amp;quot;file content: {}&amp;quot;, fileContent); return true; };}Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system.For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type.The following is an example of sending notification when a comment is added.public VertxDataFetcher&amp;lt;UUID&amp;gt; addComment() { return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&amp;gt; { var commentInputArg = dfe.getArgument(&amp;quot;commentInput&amp;quot;); var jacksonMapper = DatabindCodec.mapper(); var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class); return this.posts.addComment(input) .onSuccess(id -&amp;gt; this.posts.getCommentById(id.toString()) .onSuccess(c -&amp;gt; subject.onNext(c))); });}private ReplaySubject&amp;lt;Comment&amp;gt; subject = ReplaySubject.create(1);public DataFetcher&amp;lt;Publisher&amp;lt;Comment&amp;gt;&amp;gt; commentAdded() { return (DataFetchingEnvironment dfe) -&amp;gt; { ApolloWSMessage message = dfe.getContext(); log.info(&amp;quot;msg: {}, connectionParams: {}&amp;quot;, message.content(), message.connectionParams()); ConnectableObservable&amp;lt;Comment&amp;gt; connectableObservable = subject.share().publish(); connectableObservable.connect(); log.info(&amp;quot;connect to `commentAdded`&amp;quot;); return connectableObservable.toFlowable(BackpressureStrategy.BUFFER); };}The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints.Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the complete sample codes from my Github and explore it yourself.Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java.To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about GraphQL over HTTP specification.The following is an example of testing allPosts query and createPost mutation using Vertx HttpClient.@ExtendWith(VertxExtension.class)@Slf4jpublic class TestMainVerticle { HttpClient client; @BeforeEach void setup(Vertx vertx, VertxTestContext testContext) { vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&amp;gt; testContext.completeNow())); var options = new HttpClientOptions() .setDefaultHost(&amp;quot;localhost&amp;quot;) .setDefaultPort(8080); client = vertx.createHttpClient(options); } @Test void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable { var query = &amp;quot;&amp;quot;&amp;quot; query { allPosts{ id title content author{ name } comments{ content } } }&amp;quot;&amp;quot;&amp;quot;; client.request(HttpMethod.POST, &amp;quot;/graphql&amp;quot;) .flatMap(req -&amp;gt; req.putHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;) .putHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;) .send(Json.encode(Map.of(&amp;quot;query&amp;quot;, query)))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ) .onComplete( testContext.succeeding( buffer -&amp;gt; testContext.verify( () -&amp;gt; { log.info(&amp;quot;buf: {}&amp;quot;, buffer.toString()); JsonArray array = buffer.toJsonObject() .getJsonObject(&amp;quot;data&amp;quot;) .getJsonArray(&amp;quot;allPosts&amp;quot;); assertThat(array.size()).isGreaterThan(0); var titles = array.getList().stream().map(o -&amp;gt; ((Map&amp;lt;String, Object&amp;gt;) o).get(&amp;quot;title&amp;quot;)).toList(); assertThat(titles).allMatch(s -&amp;gt; ((String) s).startsWith(&amp;quot;DGS POST&amp;quot;)); testContext.completeNow(); } ) ) ); } @Test void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable { String TITLE = &amp;quot;My post created by Vertx HttpClient&amp;quot;; //var creatPostQuery = &amp;quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&amp;quot;; var creatPostQuery = &amp;quot;&amp;quot;&amp;quot; mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input) }&amp;quot;&amp;quot;&amp;quot;; client.request(HttpMethod.POST, &amp;quot;/graphql&amp;quot;) .flatMap(req -&amp;gt; { String encodedJson = Json.encode(Map.of( &amp;quot;query&amp;quot;, creatPostQuery, &amp;quot;variables&amp;quot;, Map.of( &amp;quot;input&amp;quot;, Map.of( &amp;quot;title&amp;quot;, TITLE, &amp;quot;content&amp;quot;, &amp;quot;content of my post&amp;quot; ) ) )); log.info(&amp;quot;sending encoded json: {}&amp;quot;, encodedJson); return req.putHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;) .putHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;) .send(encodedJson)//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body); } ) .flatMap(buf -&amp;gt; { Object id = buf.toJsonObject().getJsonObject(&amp;quot;data&amp;quot;).getValue(&amp;quot;createPost&amp;quot;); log.info(&amp;quot;created post: {}&amp;quot;, id); assertThat(id).isNotNull(); var postById = &amp;quot;&amp;quot;&amp;quot; query post($id:String!) { postById(postId:$id){id title content} }&amp;quot;&amp;quot;&amp;quot;; return client.request(HttpMethod.POST, &amp;quot;/graphql&amp;quot;) .flatMap(req -&amp;gt; req.putHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;) .putHeader(&amp;quot;Accept&amp;quot;, &amp;quot;application/json&amp;quot;) .send(Json.encode(Map.of( &amp;quot;query&amp;quot;, postById, &amp;quot;variables&amp;quot;, Map.of(&amp;quot;id&amp;quot;, id.toString()) )))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ); }) .onComplete( testContext.succeeding( buffer -&amp;gt; testContext.verify( () -&amp;gt; { log.info(&amp;quot;buf: {}&amp;quot;, buffer.toString()); String title = buffer.toJsonObject() .getJsonObject(&amp;quot;data&amp;quot;) .getJsonObject(&amp;quot;postById&amp;quot;) .getString(&amp;quot;title&amp;quot;); assertThat(title).isEqualTo(TITLE.toUpperCase()); testContext.completeNow(); } ) ) ); }}Get the sample codes from my Github.Building GraphQL APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Consuming GraphQL APIs with Vertx HttpClient/WebClient</title><link href="/blog/2021/consuming-graphql-apis-with-vertx-httpclient-webclient/" rel="alternate" type="text/html" title="Consuming GraphQL APIs with Vertx HttpClient/WebClient" /><published>2021-07-24T00:00:00+00:00</published><updated>2021-07-24T00:00:00+00:00</updated><id>/blog/2021/consuming-graphql-apis-with-vertx-httpclient-webclient</id><content type="html" xml:base="/blog/2021/consuming-graphql-apis-with-vertx-httpclient-webclient/">&lt;p&gt;In &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/blob/master/docs/client&quot;&gt;a previous post&lt;/a&gt;, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/blob/master/docs/graphql.md&quot;&gt;the last post&lt;/a&gt;.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*jVl9u3hRpyj1g8ySAxcD3w.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@sambalye?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Sam Balye&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Firstly, let’s review the difference between the HttpClient and WebClient.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.&lt;/li&gt;&lt;li&gt;The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient.&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Checkout the &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient&quot;&gt;complete sample codes from my Github&lt;/a&gt;.&lt;/h4&gt;&lt;p&gt;Assume you have read the &lt;a href=&quot;https://graphql.org/learn/serving-over-http/&quot;&gt;GraphQL over HTTP specification&lt;/a&gt; and &lt;a href=&quot;https://github.com/jaydenseric/graphql-multipart-request-spec&quot;&gt;GraphQL multipart request specification&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Create a Eclipse Vertx project through the &lt;a href=&quot;https://start.vertx.io&quot;&gt;Eclipse Vertx Starter&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;In the start method of the MainVerticle class, create a WebClient object firstly.&lt;/p&gt;&lt;pre&gt;var options = new WebClientOptions()&lt;br&gt;    .setUserAgent(WebClientOptions.loadUserAgent())&lt;br&gt;    .setDefaultHost(&amp;quot;localhost&amp;quot;)&lt;br&gt;    .setDefaultPort(8080);&lt;/pre&gt;&lt;pre&gt;var client = WebClient.create(vertx, options);&lt;/pre&gt;&lt;p&gt;The following is an example sending a GraphQL request to retrieve all posts.&lt;/p&gt;&lt;pre&gt;client.post(&amp;quot;/graphql&amp;quot;)&lt;br&gt;     .sendJson(Map.of(&lt;br&gt;         &amp;quot;query&amp;quot;, &amp;quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&amp;quot;,&lt;br&gt;         &amp;quot;variables&amp;quot;, Map.of()&lt;br&gt;     ))&lt;br&gt;     .onSuccess(&lt;br&gt;         data -&amp;gt; log.info(&amp;quot;data of allPosts: {}&amp;quot;, data.bodyAsString())&lt;br&gt;     )&lt;br&gt;     .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));&lt;/pre&gt;&lt;p&gt;The request body format is like the following.&lt;/p&gt;&lt;pre&gt;{&lt;br&gt;  &amp;quot;query&amp;quot;: &amp;quot;...&amp;quot;,&lt;br&gt;  &amp;quot;operationName&amp;quot;: &amp;quot;...&amp;quot;,&lt;br&gt;  &amp;quot;variables&amp;quot;: { &amp;quot;myVariable&amp;quot;: &amp;quot;someValue&amp;quot;, ... }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;The query is accepting a &lt;em&gt;Schema Definition Language&lt;/em&gt; in string. The &lt;em&gt;operationName&lt;/em&gt; and &lt;em&gt;variables&lt;/em&gt; are optional.&lt;/p&gt;&lt;p&gt;And the response body is like.&lt;/p&gt;&lt;pre&gt;{&lt;br&gt;  &amp;quot;data&amp;quot;: &amp;quot;...&amp;quot;,&lt;br&gt;  &amp;quot;errors&amp;quot;: &amp;quot;...&amp;quot;&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;When an error occurs, data is empty, and errors will contains the error details to describe the error or exception.&lt;/p&gt;&lt;blockquote&gt;&lt;em&gt;Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200.&lt;/em&gt;&lt;/blockquote&gt;&lt;p&gt;The following example is to demonstrate how to create a post and then retrieve the newly created post by id.&lt;/p&gt;&lt;pre&gt;client.post(&amp;quot;/graphql&amp;quot;)&lt;br&gt;     .sendJson(Map.of(&lt;br&gt;         &amp;quot;query&amp;quot;, &amp;quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&amp;quot;,&lt;br&gt;         &amp;quot;variables&amp;quot;, Map.of(&lt;br&gt;             &amp;quot;input&amp;quot;, Map.of(&amp;quot;title&amp;quot;, &amp;quot;create post from WebClient&amp;quot;, &amp;quot;content&amp;quot;, &amp;quot;content of the new post&amp;quot;)&lt;br&gt;         )&lt;br&gt;     ))&lt;br&gt;     .onSuccess(&lt;br&gt;         data -&amp;gt; {&lt;br&gt;             log.info(&amp;quot;data of createPost: {}&amp;quot;, data.bodyAsString());&lt;br&gt;             var createdId = data.bodyAsJsonObject().getJsonObject(&amp;quot;data&amp;quot;).getString(&amp;quot;createPost&amp;quot;);&lt;br&gt;             // get the created post.&lt;br&gt;             getPostById(client, createdId);&lt;br&gt;             // add comment.&lt;br&gt;             addComment(client, createdId);&lt;br&gt;         }&lt;br&gt;     )&lt;br&gt;     .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));&lt;/pre&gt;&lt;pre&gt;//getPostById&lt;br&gt;private void getPostById(WebClient client, String id) {&lt;br&gt;        client.post(&amp;quot;/graphql&amp;quot;)&lt;br&gt;            .sendJson(Map.of(&lt;br&gt;                &amp;quot;query&amp;quot;, &amp;quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&amp;quot;,&lt;br&gt;                &amp;quot;variables&amp;quot;, Map.of(&lt;br&gt;                    &amp;quot;id&amp;quot;, id&lt;br&gt;                )&lt;br&gt;            ))&lt;br&gt;            .onSuccess(&lt;br&gt;                data -&amp;gt; log.info(&amp;quot;data of postByID: {}&amp;quot;, data.bodyAsString())&lt;br&gt;            )&lt;br&gt;            .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));&lt;br&gt;    }&lt;/pre&gt;&lt;p&gt;Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (&lt;em&gt;Subscription&lt;/em&gt;).&lt;/p&gt;&lt;pre&gt;private void addComment(WebClient client, String id) {&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    // switch to HttpClient to handle WebSocket&lt;br&gt;    var options = new HttpClientOptions()&lt;br&gt;        .setWebSocketClosingTimeout(7200)&lt;br&gt;        .setDefaultHost(&amp;quot;localhost&amp;quot;)&lt;br&gt;        .setDefaultPort(8080);&lt;/pre&gt;&lt;pre&gt;    // see: &lt;a href=&quot;https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java&quot;&gt;https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java&lt;/a&gt;&lt;br&gt;    var httpClient = vertx.createHttpClient(options);&lt;br&gt;    httpClient.webSocket(&amp;quot;/graphql&amp;quot;)&lt;br&gt;        .onSuccess(ws -&amp;gt; {&lt;br&gt;            ws.closeHandler(v -&amp;gt; log.info(&amp;quot;websocket is being closed&amp;quot;));&lt;br&gt;            ws.endHandler(v -&amp;gt; log.info(&amp;quot;websocket is being ended&amp;quot;));&lt;br&gt;            ws.exceptionHandler(e -&amp;gt; log.info(&amp;quot;catching websocket exception: {}&amp;quot;, e.getMessage()));&lt;/pre&gt;&lt;pre&gt;            ws.textMessageHandler(text -&amp;gt; {&lt;br&gt;                //log.info(&amp;quot;websocket message handler:{}&amp;quot;, text);&lt;br&gt;                JsonObject obj = new JsonObject(text);&lt;br&gt;                ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&amp;quot;type&amp;quot;));&lt;br&gt;                if (type.equals(CONNECTION_KEEP_ALIVE)) {&lt;br&gt;                    return;// do nothing when ka.&lt;br&gt;                } else if (type.equals(DATA)) {&lt;br&gt;                    // handle the subscription `commentAdded` data.&lt;br&gt;                    log.info(&amp;quot;subscription commentAdded data: {}&amp;quot;, obj.getJsonObject(&amp;quot;payload&amp;quot;).getJsonObject(&amp;quot;data&amp;quot;).getJsonObject(&amp;quot;commentAdded&amp;quot;));&lt;br&gt;                }&lt;br&gt;            });&lt;/pre&gt;&lt;pre&gt;            JsonObject messageInit = new JsonObject()&lt;br&gt;                .put(&amp;quot;type&amp;quot;, &amp;quot;connection_init&amp;quot;)//this is required to initialize a connection.&lt;br&gt;                .put(&amp;quot;id&amp;quot;, &amp;quot;1&amp;quot;);&lt;/pre&gt;&lt;pre&gt;            JsonObject message = new JsonObject()&lt;br&gt;                .put(&amp;quot;payload&amp;quot;, new JsonObject()&lt;br&gt;                     .put(&amp;quot;query&amp;quot;, &amp;quot;subscription onCommentAdded { commentAdded { id content } }&amp;quot;))&lt;br&gt;                .put(&amp;quot;type&amp;quot;, &amp;quot;start&amp;quot;)&lt;br&gt;                .put(&amp;quot;id&amp;quot;, &amp;quot;1&amp;quot;);&lt;/pre&gt;&lt;pre&gt;            ws.write(messageInit.toBuffer());&lt;br&gt;            ws.write(message.toBuffer());&lt;br&gt;        })&lt;br&gt;        .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));&lt;/pre&gt;&lt;pre&gt;    addCommentToPost(client, id);&lt;br&gt;    addCommentToPost(client, id);&lt;br&gt;    addCommentToPost(client, id);&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In the above addComment method, we have switch to use HttpClient to handle WebSocket request.&lt;/p&gt;&lt;p&gt;Firstly it opens a WebSocket connection to &lt;em&gt;/graphql&lt;/em&gt; WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side.&lt;/p&gt;&lt;p&gt;Let’s have a look at the file uploads.&lt;/p&gt;&lt;pre&gt;private void uploadFile(WebClient client) {&lt;br&gt;    Buffer fileBuf = vertx.fileSystem().readFileBlocking(&amp;quot;test.txt&amp;quot;);&lt;br&gt;    MultipartForm form = MultipartForm.create();&lt;br&gt;    String query = &amp;quot;&amp;quot;&amp;quot;&lt;br&gt;        mutation upload($file:Upload!){&lt;br&gt;        upload(file:$file)&lt;br&gt;    }&lt;br&gt;    &amp;quot;&amp;quot;&amp;quot;;&lt;br&gt;        var variables = new HashMap&amp;lt;String, Object&amp;gt;();&lt;br&gt;    variables.put(&amp;quot;file&amp;quot;, null);&lt;br&gt;    form.attribute(&amp;quot;operations&amp;quot;, Json.encode(Map.of(&amp;quot;query&amp;quot;, query, &amp;quot;variables&amp;quot;, variables)));&lt;br&gt;    form.attribute(&amp;quot;map&amp;quot;, Json.encode(Map.of(&amp;quot;file0&amp;quot;, List.of(&amp;quot;variables.file&amp;quot;))));&lt;br&gt;    form.textFileUpload(&amp;quot;file0&amp;quot;, &amp;quot;test.txt&amp;quot;, fileBuf, &amp;quot;text/plain&amp;quot;);&lt;/pre&gt;&lt;pre&gt;    client.post(&amp;quot;/graphql&amp;quot;)&lt;br&gt;        .sendMultipartForm(form)&lt;br&gt;        .onSuccess(&lt;br&gt;        data -&amp;gt; log.info(&amp;quot;data of upload: {}&amp;quot;, data.bodyAsString())&lt;br&gt;    )&lt;br&gt;    .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API.&lt;/p&gt;&lt;p&gt;Get the &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient&quot;&gt;sample codes from my Github&lt;/a&gt;.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=db410c410aa2&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://itnext.io/consuming-graphql-apis-with-vertx-httpclient-webclient-db410c410aa2&quot;&gt;Consuming GraphQL APIs with Vertx HttpClient/WebClient&lt;/a&gt; was originally published in &lt;a href=&quot;https://itnext.io&quot;&gt;ITNEXT&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">In a previous post, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in the last post.Photo by Sam Balye on UnsplashFirstly, let’s review the difference between the HttpClient and WebClient.The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient.Checkout the complete sample codes from my Github.Assume you have read the GraphQL over HTTP specification and GraphQL multipart request specification.Create a Eclipse Vertx project through the Eclipse Vertx Starter.In the start method of the MainVerticle class, create a WebClient object firstly.var options = new WebClientOptions() .setUserAgent(WebClientOptions.loadUserAgent()) .setDefaultHost(&amp;quot;localhost&amp;quot;) .setDefaultPort(8080);var client = WebClient.create(vertx, options);The following is an example sending a GraphQL request to retrieve all posts.client.post(&amp;quot;/graphql&amp;quot;) .sendJson(Map.of( &amp;quot;query&amp;quot;, &amp;quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&amp;quot;, &amp;quot;variables&amp;quot;, Map.of() )) .onSuccess( data -&amp;gt; log.info(&amp;quot;data of allPosts: {}&amp;quot;, data.bodyAsString()) ) .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));The request body format is like the following.{ &amp;quot;query&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;operationName&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;variables&amp;quot;: { &amp;quot;myVariable&amp;quot;: &amp;quot;someValue&amp;quot;, ... }}The query is accepting a Schema Definition Language in string. The operationName and variables are optional.And the response body is like.{ &amp;quot;data&amp;quot;: &amp;quot;...&amp;quot;, &amp;quot;errors&amp;quot;: &amp;quot;...&amp;quot;}When an error occurs, data is empty, and errors will contains the error details to describe the error or exception.Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200.The following example is to demonstrate how to create a post and then retrieve the newly created post by id.client.post(&amp;quot;/graphql&amp;quot;) .sendJson(Map.of( &amp;quot;query&amp;quot;, &amp;quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&amp;quot;, &amp;quot;variables&amp;quot;, Map.of( &amp;quot;input&amp;quot;, Map.of(&amp;quot;title&amp;quot;, &amp;quot;create post from WebClient&amp;quot;, &amp;quot;content&amp;quot;, &amp;quot;content of the new post&amp;quot;) ) )) .onSuccess( data -&amp;gt; { log.info(&amp;quot;data of createPost: {}&amp;quot;, data.bodyAsString()); var createdId = data.bodyAsJsonObject().getJsonObject(&amp;quot;data&amp;quot;).getString(&amp;quot;createPost&amp;quot;); // get the created post. getPostById(client, createdId); // add comment. addComment(client, createdId); } ) .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));//getPostByIdprivate void getPostById(WebClient client, String id) { client.post(&amp;quot;/graphql&amp;quot;) .sendJson(Map.of( &amp;quot;query&amp;quot;, &amp;quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&amp;quot;, &amp;quot;variables&amp;quot;, Map.of( &amp;quot;id&amp;quot;, id ) )) .onSuccess( data -&amp;gt; log.info(&amp;quot;data of postByID: {}&amp;quot;, data.bodyAsString()) ) .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e)); }Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (Subscription).private void addComment(WebClient client, String id) { // switch to HttpClient to handle WebSocket var options = new HttpClientOptions() .setWebSocketClosingTimeout(7200) .setDefaultHost(&amp;quot;localhost&amp;quot;) .setDefaultPort(8080); // see: https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java var httpClient = vertx.createHttpClient(options); httpClient.webSocket(&amp;quot;/graphql&amp;quot;) .onSuccess(ws -&amp;gt; { ws.closeHandler(v -&amp;gt; log.info(&amp;quot;websocket is being closed&amp;quot;)); ws.endHandler(v -&amp;gt; log.info(&amp;quot;websocket is being ended&amp;quot;)); ws.exceptionHandler(e -&amp;gt; log.info(&amp;quot;catching websocket exception: {}&amp;quot;, e.getMessage())); ws.textMessageHandler(text -&amp;gt; { //log.info(&amp;quot;websocket message handler:{}&amp;quot;, text); JsonObject obj = new JsonObject(text); ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&amp;quot;type&amp;quot;)); if (type.equals(CONNECTION_KEEP_ALIVE)) { return;// do nothing when ka. } else if (type.equals(DATA)) { // handle the subscription `commentAdded` data. log.info(&amp;quot;subscription commentAdded data: {}&amp;quot;, obj.getJsonObject(&amp;quot;payload&amp;quot;).getJsonObject(&amp;quot;data&amp;quot;).getJsonObject(&amp;quot;commentAdded&amp;quot;)); } }); JsonObject messageInit = new JsonObject() .put(&amp;quot;type&amp;quot;, &amp;quot;connection_init&amp;quot;)//this is required to initialize a connection. .put(&amp;quot;id&amp;quot;, &amp;quot;1&amp;quot;); JsonObject message = new JsonObject() .put(&amp;quot;payload&amp;quot;, new JsonObject() .put(&amp;quot;query&amp;quot;, &amp;quot;subscription onCommentAdded { commentAdded { id content } }&amp;quot;)) .put(&amp;quot;type&amp;quot;, &amp;quot;start&amp;quot;) .put(&amp;quot;id&amp;quot;, &amp;quot;1&amp;quot;); ws.write(messageInit.toBuffer()); ws.write(message.toBuffer()); }) .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e)); addCommentToPost(client, id); addCommentToPost(client, id); addCommentToPost(client, id);}In the above addComment method, we have switch to use HttpClient to handle WebSocket request.Firstly it opens a WebSocket connection to /graphql WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side.Let’s have a look at the file uploads.private void uploadFile(WebClient client) { Buffer fileBuf = vertx.fileSystem().readFileBlocking(&amp;quot;test.txt&amp;quot;); MultipartForm form = MultipartForm.create(); String query = &amp;quot;&amp;quot;&amp;quot; mutation upload($file:Upload!){ upload(file:$file) } &amp;quot;&amp;quot;&amp;quot;; var variables = new HashMap&amp;lt;String, Object&amp;gt;(); variables.put(&amp;quot;file&amp;quot;, null); form.attribute(&amp;quot;operations&amp;quot;, Json.encode(Map.of(&amp;quot;query&amp;quot;, query, &amp;quot;variables&amp;quot;, variables))); form.attribute(&amp;quot;map&amp;quot;, Json.encode(Map.of(&amp;quot;file0&amp;quot;, List.of(&amp;quot;variables.file&amp;quot;)))); form.textFileUpload(&amp;quot;file0&amp;quot;, &amp;quot;test.txt&amp;quot;, fileBuf, &amp;quot;text/plain&amp;quot;); client.post(&amp;quot;/graphql&amp;quot;) .sendMultipartForm(form) .onSuccess( data -&amp;gt; log.info(&amp;quot;data of upload: {}&amp;quot;, data.bodyAsString()) ) .onFailure(e -&amp;gt; log.error(&amp;quot;error: {}&amp;quot;, e));}As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API.Get the sample codes from my Github.Consuming GraphQL APIs with Vertx HttpClient/WebClient was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry><entry><title type="html">Building a Vertx application with Kotlin Coroutines</title><link href="/blog/2021/building-a-vertx-application-with-kotlin-coroutines/" rel="alternate" type="text/html" title="Building a Vertx application with Kotlin Coroutines" /><published>2021-07-23T00:00:00+00:00</published><updated>2021-07-23T00:00:00+00:00</updated><id>/blog/2021/building-a-vertx-application-with-kotlin-coroutines</id><content type="html" xml:base="/blog/2021/building-a-vertx-application-with-kotlin-coroutines/">&lt;p&gt;In &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/blob/master/docs/kotlin.md&quot;&gt;the last post&lt;/a&gt;, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines.&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;&quot; src=&quot;https://cdn-images-1.medium.com/max/1024/1*zi-wSXYA9KsoR2ALXGWNwg.jpeg&quot; /&gt;&lt;figcaption&gt;Photo by &lt;a href=&quot;https://unsplash.com/@yuzkiwww?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Yuzki Wang&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Follow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines.&lt;/p&gt;&lt;p&gt;Firstly let’s have a look at the PostRepository.&lt;/p&gt;&lt;pre&gt;class PostRepository(private val client: PgPool) {&lt;/pre&gt;&lt;pre&gt;    suspend fun findAll() = client.query(&amp;quot;SELECT * FROM posts ORDER BY id ASC&amp;quot;)&lt;br&gt;        .execute()&lt;br&gt;        .map { rs: RowSet&amp;lt;Row?&amp;gt; -&amp;gt;&lt;br&gt;            StreamSupport.stream(rs.spliterator(), false)&lt;br&gt;                .map { mapFun(it!!) }&lt;br&gt;                .toList()&lt;br&gt;        }.await()&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    suspend fun findById(id: UUID): Post? = client.preparedQuery(&amp;quot;SELECT * FROM posts WHERE id=$1&amp;quot;)&lt;br&gt;        .execute(Tuple.of(id))&lt;br&gt;        .map { it.iterator() }&lt;br&gt;        .map { if (it.hasNext()) mapFun(it.next()) else null }&lt;br&gt;        .await()&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    suspend fun save(data: Post) =&lt;br&gt;        client.preparedQuery(&amp;quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&amp;quot;)&lt;br&gt;            .execute(Tuple.of(data.title, data.content))&lt;br&gt;            .map { it.iterator().next().getUUID(&amp;quot;id&amp;quot;) }&lt;br&gt;            .await()&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    suspend fun saveAll(data: List&amp;lt;Post&amp;gt;): Int? {&lt;br&gt;        val tuples = data.map { Tuple.of(it.title, it.content) }&lt;/pre&gt;&lt;pre&gt;        return client.preparedQuery(&amp;quot;INSERT INTO posts (title, content) VALUES ($1, $2)&amp;quot;)&lt;br&gt;            .executeBatch(tuples)&lt;br&gt;            .map { it.rowCount() }&lt;br&gt;            .await()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    suspend fun update(data: Post) = client.preparedQuery(&amp;quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&amp;quot;)&lt;br&gt;        .execute(Tuple.of(data.title, data.content, data.id))&lt;br&gt;        .map { it.rowCount() }&lt;br&gt;        .await()&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    suspend fun deleteAll() = client.query(&amp;quot;DELETE FROM posts&amp;quot;).execute()&lt;br&gt;        .map { it.rowCount() }&lt;br&gt;        .await()&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;    suspend fun deleteById(id: UUID) = client.preparedQuery(&amp;quot;DELETE FROM posts WHERE id=$1&amp;quot;).execute(Tuple.of(id))&lt;br&gt;        .map { it.rowCount() }&lt;br&gt;        .await()&lt;/pre&gt;&lt;pre&gt;    companion object {&lt;br&gt;        private val LOGGER = Logger.getLogger(PostRepository::class.java.name)&lt;br&gt;        val mapFun: (Row) -&amp;gt; Post = { row: Row -&amp;gt;&lt;br&gt;            Post(&lt;br&gt;                row.getUUID(&amp;quot;id&amp;quot;),&lt;br&gt;                row.getString(&amp;quot;title&amp;quot;),&lt;br&gt;                row.getString(&amp;quot;content&amp;quot;),&lt;br&gt;                row.getLocalDateTime(&amp;quot;created_at&amp;quot;)&lt;br&gt;            )&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a &lt;em&gt;suspended&lt;/em&gt; result.&lt;/p&gt;&lt;p&gt;Let’s move to PostHandlers.&lt;/p&gt;&lt;pre&gt;class PostsHandler(val posts: PostRepository) {&lt;br&gt;    suspend fun all(rc: RoutingContext) {&lt;br&gt;//        var params = rc.queryParams();&lt;br&gt;//        var q = params.get(&amp;quot;q&amp;quot;);&lt;br&gt;//        var limit = params.get(&amp;quot;limit&amp;quot;) == null ? 10 : Integer.parseInt(params.get(&amp;quot;q&amp;quot;));&lt;br&gt;//        var offset = params.get(&amp;quot;offset&amp;quot;) == null ? 0 : Integer.parseInt(params.get(&amp;quot;offset&amp;quot;));&lt;br&gt;//        LOGGER.log(Level.INFO, &amp;quot; find by keyword: q={0}, limit={1}, offset={2}&amp;quot;, new Object[]{q, limit, offset});&lt;br&gt;        val data = posts.findAll()&lt;br&gt;        rc.response().end(Json.encode(data)).await()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    suspend fun getById(rc: RoutingContext) {&lt;br&gt;        val params = rc.pathParams()&lt;br&gt;        val id = params[&amp;quot;id&amp;quot;]&lt;br&gt;        val uuid = UUID.fromString(id)&lt;br&gt;        val data = posts.findById(uuid)&lt;br&gt;        if (data != null) {&lt;br&gt;            rc.response().end(Json.encode(data)).await()&lt;br&gt;        } else {&lt;br&gt;            rc.fail(404, PostNotFoundException(uuid))&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    suspend fun save(rc: RoutingContext) {&lt;br&gt;        //rc.getBodyAsJson().mapTo(PostForm.class)&lt;br&gt;        val body = rc.bodyAsJson&lt;br&gt;        LOGGER.log(Level.INFO, &amp;quot;request body: {0}&amp;quot;, body)&lt;br&gt;        val (title, content) = body.mapTo(CreatePostCommand::class.java)&lt;br&gt;        val savedId = posts.save(Post(title = title, content = content))&lt;br&gt;        rc.response()&lt;br&gt;            .putHeader(&amp;quot;Location&amp;quot;, &amp;quot;/posts/$savedId&amp;quot;)&lt;br&gt;            .setStatusCode(201)&lt;br&gt;            .end()&lt;br&gt;            .await()&lt;/pre&gt;&lt;pre&gt;    }&lt;/pre&gt;&lt;pre&gt;    suspend fun update(rc: RoutingContext) {&lt;br&gt;        val params = rc.pathParams()&lt;br&gt;        val id = params[&amp;quot;id&amp;quot;]&lt;br&gt;        val uuid = UUID.fromString(id)&lt;br&gt;        val body = rc.bodyAsJson&lt;br&gt;        LOGGER.log(Level.INFO, &amp;quot;\npath param id: {0}\nrequest body: {1}&amp;quot;, arrayOf(id, body))&lt;br&gt;        var (title, content) = body.mapTo(CreatePostCommand::class.java)&lt;/pre&gt;&lt;pre&gt;        var existing: Post? = posts.findById(uuid)&lt;br&gt;        if (existing != null) {&lt;br&gt;            val data: Post = existing.apply {&lt;br&gt;                title = title&lt;br&gt;                content = content&lt;br&gt;            }&lt;br&gt;            posts.update(data)&lt;br&gt;            rc.response().setStatusCode(204).end().await()&lt;br&gt;        } else {&lt;br&gt;            rc.fail(404, PostNotFoundException(uuid))&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    suspend fun delete(rc: RoutingContext) {&lt;br&gt;        val params = rc.pathParams()&lt;br&gt;        val id = params[&amp;quot;id&amp;quot;]&lt;br&gt;        val uuid = UUID.fromString(id)&lt;br&gt;        val existing = posts.findById(uuid)&lt;br&gt;        if (existing != null) {&lt;br&gt;            rc.response().setStatusCode(204).end().await()&lt;br&gt;        } else {&lt;br&gt;            rc.fail(404, PostNotFoundException(uuid))&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    companion object {&lt;br&gt;        private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName)&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;In the above codes, it uses sequential statements instead of Future with chained functionalities&lt;/p&gt;&lt;p&gt;Eclipse Vertx Kotlin bindings provides a CooutineVerticle.&lt;/p&gt;&lt;pre&gt;class MainVerticle : CoroutineVerticle() {&lt;br&gt;    companion object {&lt;br&gt;        private val LOGGER = Logger.getLogger(MainVerticle::class.java.name)&lt;/pre&gt;&lt;pre&gt;        /**&lt;br&gt;         * Configure logging from logging.properties file.&lt;br&gt;         * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties&lt;br&gt;         * or set java.util.logging.config.file system property to locate the properties file.&lt;br&gt;         */&lt;br&gt;        @Throws(IOException::class)&lt;br&gt;        private fun setupLogging() {&lt;br&gt;            MainVerticle::class.java.getResourceAsStream(&amp;quot;/logging.properties&amp;quot;)&lt;br&gt;                .use { f -&amp;gt; LogManager.getLogManager().readConfiguration(f) }&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        init {&lt;br&gt;            LOGGER.info(&amp;quot;Customizing the built-in jackson ObjectMapper...&amp;quot;)&lt;br&gt;            val objectMapper = DatabindCodec.mapper()&lt;br&gt;            objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)&lt;br&gt;            objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)&lt;br&gt;            objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)&lt;br&gt;            val module = JavaTimeModule()&lt;br&gt;            objectMapper.registerModule(module)&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    override suspend fun start() {&lt;br&gt;        LOGGER.log(Level.INFO, &amp;quot;Starting HTTP server...&amp;quot;)&lt;br&gt;        //setupLogging();&lt;/pre&gt;&lt;pre&gt;        //Create a PgPool instance&lt;br&gt;        val pgPool = pgPool()&lt;/pre&gt;&lt;pre&gt;        //Creating PostRepository&lt;br&gt;        val postRepository = PostRepository(pgPool)&lt;/pre&gt;&lt;pre&gt;        //Creating PostHandler&lt;br&gt;        val postHandlers = PostsHandler(postRepository)&lt;/pre&gt;&lt;pre&gt;        // Initializing the sample data&lt;br&gt;        val initializer = DataInitializer(pgPool)&lt;br&gt;        initializer.run()&lt;/pre&gt;&lt;pre&gt;        // Configure routes&lt;br&gt;        val router = routes(postHandlers)&lt;/pre&gt;&lt;pre&gt;        // Create the HTTP server&lt;br&gt;        val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true)&lt;br&gt;        vertx.createHttpServer(options) // Handle every request using the router&lt;br&gt;            .requestHandler(router) // Start listening&lt;br&gt;            .listen(8888) // Print the port&lt;br&gt;            .onComplete { println(&amp;quot;HttpSever started at ${it.result().actualPort()}&amp;quot;) }&lt;br&gt;            .await()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    override suspend fun stop() {&lt;br&gt;        super.stop()&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    //create routes&lt;br&gt;    private fun routes(handlers: PostsHandler): Router {&lt;/pre&gt;&lt;pre&gt;        // Create a Router&lt;br&gt;        val router = Router.router(vertx)&lt;br&gt;        // register BodyHandler globally.&lt;br&gt;        //router.route().handler(BodyHandler.create());&lt;/pre&gt;&lt;pre&gt;        router.get(&amp;quot;/posts&amp;quot;)&lt;br&gt;            .produces(&amp;quot;application/json&amp;quot;)&lt;br&gt;            .coroutineHandler {&lt;br&gt;                handlers.all(it)&lt;br&gt;            }&lt;/pre&gt;&lt;pre&gt;        router.post(&amp;quot;/posts&amp;quot;)&lt;br&gt;            .consumes(&amp;quot;application/json&amp;quot;)&lt;br&gt;            .handler(BodyHandler.create())&lt;br&gt;            .coroutineHandler {&lt;br&gt;                handlers.save(it)&lt;br&gt;            }&lt;/pre&gt;&lt;pre&gt;        router.get(&amp;quot;/posts/:id&amp;quot;)&lt;br&gt;            .produces(&amp;quot;application/json&amp;quot;)&lt;br&gt;            .coroutineHandler {&lt;br&gt;                handlers.getById(it)&lt;br&gt;            }&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;        router.put(&amp;quot;/posts/:id&amp;quot;)&lt;br&gt;            .consumes(&amp;quot;application/json&amp;quot;)&lt;br&gt;            .handler(BodyHandler.create())&lt;br&gt;            .coroutineHandler {&lt;br&gt;                handlers.update(it)&lt;br&gt;            }&lt;/pre&gt;&lt;pre&gt;        router.delete(&amp;quot;/posts/:id&amp;quot;)&lt;br&gt;            .coroutineHandler {&lt;br&gt;                handlers.delete(it)&lt;br&gt;            }&lt;/pre&gt;&lt;pre&gt;        router.route().failureHandler {&lt;br&gt;            if (it.failure() is PostNotFoundException) {&lt;br&gt;                it.response()&lt;br&gt;                    .setStatusCode(404)&lt;br&gt;                    .end(&lt;br&gt;                        json {// an example using JSON DSL&lt;br&gt;                            obj(&lt;br&gt;                                &amp;quot;message&amp;quot; to &amp;quot;${it.failure().message}&amp;quot;,&lt;br&gt;                                &amp;quot;code&amp;quot; to &amp;quot;not_found&amp;quot;&lt;br&gt;                            )&lt;br&gt;                        }.toString()&lt;br&gt;                    )&lt;br&gt;            }&lt;br&gt;        }&lt;/pre&gt;&lt;pre&gt;        router.get(&amp;quot;/hello&amp;quot;).handler { it.response().end(&amp;quot;Hello from my route&amp;quot;) }&lt;/pre&gt;&lt;pre&gt;        return router&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private fun pgPool(): PgPool {&lt;br&gt;        val connectOptions = PgConnectOptions()&lt;br&gt;            .setPort(5432)&lt;br&gt;            .setHost(&amp;quot;localhost&amp;quot;)&lt;br&gt;            .setDatabase(&amp;quot;blogdb&amp;quot;)&lt;br&gt;            .setUser(&amp;quot;user&amp;quot;)&lt;br&gt;            .setPassword(&amp;quot;password&amp;quot;)&lt;/pre&gt;&lt;pre&gt;        // Pool Options&lt;br&gt;        val poolOptions = PoolOptions().setMaxSize(5)&lt;/pre&gt;&lt;pre&gt;        // Create the pool from the data object&lt;br&gt;        return PgPool.pool(vertx, connectOptions, poolOptions)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&amp;gt; Unit) = handler {&lt;br&gt;        launch(it.vertx().dispatcher()) {&lt;br&gt;            try {&lt;br&gt;                fn(it)&lt;br&gt;            } catch (e: Exception) {&lt;br&gt;                it.fail(e)&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;}&lt;/pre&gt;&lt;p&gt;Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue &lt;a href=&quot;https://github.com/vert-x3/vertx-lang-kotlin/issues/194&quot;&gt;vert-x3/vertx-lang-kotlin #194&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Let’s convert the DataIntializer to use Kotlin Coroutines.&lt;/p&gt;&lt;pre&gt;class DataInitializer(private val client: PgPool) {&lt;/pre&gt;&lt;pre&gt;    suspend fun run() {&lt;br&gt;        LOGGER.info(&amp;quot;Data initialization is starting...&amp;quot;)&lt;br&gt;        val first = Tuple.of(&amp;quot;Hello Quarkus&amp;quot;, &amp;quot;My first post of Quarkus&amp;quot;)&lt;br&gt;        val second = Tuple.of(&amp;quot;Hello Again, Quarkus&amp;quot;, &amp;quot;My second post of Quarkus&amp;quot;)&lt;br&gt;&lt;/pre&gt;&lt;pre&gt;        val result = client&lt;br&gt;            .withTransaction { conn: SqlConnection -&amp;gt;&lt;br&gt;                conn.query(&amp;quot;DELETE FROM posts&amp;quot;)&lt;br&gt;                    .execute()&lt;br&gt;                    .flatMap {&lt;br&gt;                        conn.preparedQuery(&amp;quot;INSERT INTO posts (title, content) VALUES ($1, $2)&amp;quot;)&lt;br&gt;                            .executeBatch(listOf(first, second))&lt;br&gt;                    }&lt;br&gt;                    .flatMap {&lt;br&gt;                        conn.query(&amp;quot;SELECT * FROM posts&amp;quot;)&lt;br&gt;                            .execute()&lt;br&gt;                    }&lt;/pre&gt;&lt;pre&gt;            }.await()&lt;/pre&gt;&lt;pre&gt;        result.forEach { println(it.toJson()) }&lt;br&gt;        LOGGER.info(&amp;quot;Data initialization is done...&amp;quot;)&lt;br&gt;    }&lt;/pre&gt;&lt;pre&gt;    companion object {&lt;br&gt;        private val LOGGER = Logger.getLogger(DataInitializer::class.java.name)&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;Get &lt;a href=&quot;https://github.com/hantsy/vertx-sandbox/tree/master/kotlin&quot;&gt;the example codes&lt;/a&gt; from my Github.&lt;/p&gt;&lt;img src=&quot;https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=6c7dbb7ad893&quot; width=&quot;1&quot; height=&quot;1&quot; alt=&quot;&quot;&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/nerd-for-tech/building-a-vertx-application-with-kotlin-coroutines-6c7dbb7ad893&quot;&gt;Building a Vertx application with Kotlin Coroutines&lt;/a&gt; was originally published in &lt;a href=&quot;https://medium.com/nerd-for-tech&quot;&gt;Nerd For Tech&lt;/a&gt; on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</content><author><name></name></author><summary type="html">In the last post, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines.Photo by Yuzki Wang on UnsplashFollow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines.Firstly let’s have a look at the PostRepository.class PostRepository(private val client: PgPool) { suspend fun findAll() = client.query(&amp;quot;SELECT * FROM posts ORDER BY id ASC&amp;quot;) .execute() .map { rs: RowSet&amp;lt;Row?&amp;gt; -&amp;gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() }.await() suspend fun findById(id: UUID): Post? = client.preparedQuery(&amp;quot;SELECT * FROM posts WHERE id=$1&amp;quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()) else null } .await() suspend fun save(data: Post) = client.preparedQuery(&amp;quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&amp;quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&amp;quot;id&amp;quot;) } .await() suspend fun saveAll(data: List&amp;lt;Post&amp;gt;): Int? { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&amp;quot;INSERT INTO posts (title, content) VALUES ($1, $2)&amp;quot;) .executeBatch(tuples) .map { it.rowCount() } .await() } suspend fun update(data: Post) = client.preparedQuery(&amp;quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&amp;quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } .await() suspend fun deleteAll() = client.query(&amp;quot;DELETE FROM posts&amp;quot;).execute() .map { it.rowCount() } .await() suspend fun deleteById(id: UUID) = client.preparedQuery(&amp;quot;DELETE FROM posts WHERE id=$1&amp;quot;).execute(Tuple.of(id)) .map { it.rowCount() } .await() companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&amp;gt; Post = { row: Row -&amp;gt; Post( row.getUUID(&amp;quot;id&amp;quot;), row.getString(&amp;quot;title&amp;quot;), row.getString(&amp;quot;content&amp;quot;), row.getLocalDateTime(&amp;quot;created_at&amp;quot;) ) } }}As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a suspended result.Let’s move to PostHandlers.class PostsHandler(val posts: PostRepository) { suspend fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&amp;quot;q&amp;quot;);// var limit = params.get(&amp;quot;limit&amp;quot;) == null ? 10 : Integer.parseInt(params.get(&amp;quot;q&amp;quot;));// var offset = params.get(&amp;quot;offset&amp;quot;) == null ? 0 : Integer.parseInt(params.get(&amp;quot;offset&amp;quot;));// LOGGER.log(Level.INFO, &amp;quot; find by keyword: q={0}, limit={1}, offset={2}&amp;quot;, new Object[]{q, limit, offset}); val data = posts.findAll() rc.response().end(Json.encode(data)).await() } suspend fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&amp;quot;id&amp;quot;] val uuid = UUID.fromString(id) val data = posts.findById(uuid) if (data != null) { rc.response().end(Json.encode(data)).await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &amp;quot;request body: {0}&amp;quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) val savedId = posts.save(Post(title = title, content = content)) rc.response() .putHeader(&amp;quot;Location&amp;quot;, &amp;quot;/posts/$savedId&amp;quot;) .setStatusCode(201) .end() .await() } suspend fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&amp;quot;id&amp;quot;] val uuid = UUID.fromString(id) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &amp;quot;\npath param id: {0}\nrequest body: {1}&amp;quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) var existing: Post? = posts.findById(uuid) if (existing != null) { val data: Post = existing.apply { title = title content = content } posts.update(data) rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&amp;quot;id&amp;quot;] val uuid = UUID.fromString(id) val existing = posts.findById(uuid) if (existing != null) { rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }}In the above codes, it uses sequential statements instead of Future with chained functionalitiesEclipse Vertx Kotlin bindings provides a CooutineVerticle.class MainVerticle : CoroutineVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&amp;quot;/logging.properties&amp;quot;) .use { f -&amp;gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&amp;quot;Customizing the built-in jackson ObjectMapper...&amp;quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } override suspend fun start() { LOGGER.log(Level.INFO, &amp;quot;Starting HTTP server...&amp;quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true) vertx.createHttpServer(options) // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onComplete { println(&amp;quot;HttpSever started at ${it.result().actualPort()}&amp;quot;) } .await() } override suspend fun stop() { super.stop() } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&amp;quot;/posts&amp;quot;) .produces(&amp;quot;application/json&amp;quot;) .coroutineHandler { handlers.all(it) } router.post(&amp;quot;/posts&amp;quot;) .consumes(&amp;quot;application/json&amp;quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.save(it) } router.get(&amp;quot;/posts/:id&amp;quot;) .produces(&amp;quot;application/json&amp;quot;) .coroutineHandler { handlers.getById(it) } router.put(&amp;quot;/posts/:id&amp;quot;) .consumes(&amp;quot;application/json&amp;quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.update(it) } router.delete(&amp;quot;/posts/:id&amp;quot;) .coroutineHandler { handlers.delete(it) } router.route().failureHandler { if (it.failure() is PostNotFoundException) { it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &amp;quot;message&amp;quot; to &amp;quot;${it.failure().message}&amp;quot;, &amp;quot;code&amp;quot; to &amp;quot;not_found&amp;quot; ) }.toString() ) } } router.get(&amp;quot;/hello&amp;quot;).handler { it.response().end(&amp;quot;Hello from my route&amp;quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&amp;quot;localhost&amp;quot;) .setDatabase(&amp;quot;blogdb&amp;quot;) .setUser(&amp;quot;user&amp;quot;) .setPassword(&amp;quot;password&amp;quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) } private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&amp;gt; Unit) = handler { launch(it.vertx().dispatcher()) { try { fn(it) } catch (e: Exception) { it.fail(e) } } }}Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue vert-x3/vertx-lang-kotlin #194.Let’s convert the DataIntializer to use Kotlin Coroutines.class DataInitializer(private val client: PgPool) { suspend fun run() { LOGGER.info(&amp;quot;Data initialization is starting...&amp;quot;) val first = Tuple.of(&amp;quot;Hello Quarkus&amp;quot;, &amp;quot;My first post of Quarkus&amp;quot;) val second = Tuple.of(&amp;quot;Hello Again, Quarkus&amp;quot;, &amp;quot;My second post of Quarkus&amp;quot;) val result = client .withTransaction { conn: SqlConnection -&amp;gt; conn.query(&amp;quot;DELETE FROM posts&amp;quot;) .execute() .flatMap { conn.preparedQuery(&amp;quot;INSERT INTO posts (title, content) VALUES ($1, $2)&amp;quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&amp;quot;SELECT * FROM posts&amp;quot;) .execute() } }.await() result.forEach { println(it.toJson()) } LOGGER.info(&amp;quot;Data initialization is done...&amp;quot;) } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }}Get the example codes from my Github.Building a Vertx application with Kotlin Coroutines was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.</summary></entry></feed>