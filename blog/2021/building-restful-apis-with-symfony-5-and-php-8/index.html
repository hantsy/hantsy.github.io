<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building Restful APIs with Symfony 5 and PHP 8
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-restful-apis-with-symfony-5-and-php-8/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building Restful APIs with Symfony 5 and PHP 8" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Symfony is a full-featured modularized PHP framework that is used for building all kinds of applications, from traditional web applications to small Microservice components. Photo by te chan on Unsplash Get your feet wet Install PHP 8 and PHP Composer tools. # choco php composer Install [Symfony CLI](symfony check:requirements), check the system requirements. # symfony check:requirements Symfony Requirements Checker~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &gt; PHP is using the following php.ini file:C:\tools\php80\php.ini &gt; Checking Symfony requirements: ....................WWW......... [OK] Your system is ready to run Symfony projects Optional recommendations to improve your setup~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * intl extension should be available &gt; Install and enable the intl extension (used for validators). * a PHP accelerator should be installed &gt; Install and/or enable a PHP accelerator (highly recommended). * realpath_cache_size should be at least 5M in php.ini &gt; Setting &quot;realpath_cache_size&quot; to e.g. &quot;5242880&quot; or &quot;5M&quot; in &gt; php.ini* may improve performance on Windows significantly in some &gt; cases. Note The command console can use a different php.ini file~~~~ than the one used by your web server. Please check that both the console and the web server are using the same PHP version and configuration. According to the recommendations info, adjust your PHP configuration in the php.ini. And we will use Postgres as database in the sample application, make sure pdo_pgsql and pgsql modules are enabled. Finally, you can confirm the enabled modules by the following command. # php -m Create a new Symfony project. # symfony new rest-sample // a classic website application# symfony new web-sample --full By default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application. Alternatively, you can create it using Composer. # composer create-project symfony/skeleton rest-sample //start a classic website application# composer create-project symfony/website-skeleton web-sample Enter the generated project root folder, start the application. # symfony server:start [WARNING] run &quot;symfony.exe server:ca:install&quot; first if you want to run the web server with TLS support, or use &quot;--no- tls&quot; to avoid this warning Tailing PHP-CGI log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)Tailing Web Server log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158.log) [OK] Web server listening The Web server is using PHP CGI 8.0.10 http://127.0.0.1:8000 [Web Server ] Oct 4 13:33:01 |DEBUG | PHP Reloading PHP versions[Web Server ] Oct 4 13:33:01 |DEBUG | PHP Using PHP version 8.0.10 (from default version in $PATH)[Web Server ] Oct 4 13:33:01 |INFO | PHP listening path=&quot;C:\\tools\\php80\\php-cgi.exe&quot; php=&quot;8.0.10&quot; port=61738 Hello , Symfony Create a simple class to a resource entity in the HTTP response. class Post{ private ?string $id = null; private string $title; private string $content; //getters and setters.} And use a factory to create a new Post instance. class PostFactory{ public static function create(string $title, string $content): Post { $post = new Post(); $post-&gt;setTitle($title); $post-&gt;setContent($content); return $post; }} Let’s create a simple Controller class. To use the newest PHP 8 attributes to configure the routing rules, apply the following changes in the project configurations. Open config/packages/doctrine.yaml, remove doctrine/orm/mapping/App/type or change its value to attributeOpen composer.json, change PHP version to &gt;=8.0.0. To render the response body into a JSON string, use a JsonReponse to wrap the response. #[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]class PostController{ #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(): Response { $post1 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;); $post1-&gt;setId(&quot;1&quot;); $post2 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;); $post2-&gt;setId(&quot;2&quot;); $data = [$post1-&gt;asArray(), $post2-&gt;asArray()]; return new JsonResponse($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); //return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); }} The first parameter of JsonReponse accepts an array as data, so add a function in the Post class to archive this purpose. class Post{ //... public function asArray(): array { return [ &#39;id&#39; =&gt; $this-&gt;id, &#39;title&#39; =&gt; $this-&gt;title, &#39;content&#39; =&gt; $this-&gt;content ]; }} Run the application, use curl to test the /posts endpoint. # curl http://localhost:8000/posts Symfony provides a simple AbstractController which includes several functions to simplfy the response and adopt the container and dependency injection management. In the above controller, extends from AbstractController, simply call $this-&gt;json to render the response in JSON format, no need to transform the data to an array before rendering response. class PostController extends AbstractController{ function all(): Response { //... return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); }} Connecting to Database Doctrine is a popular ORM framework , it is highly inspired by the existing Java ORM tooling, such as JPA spec and Hibernate framework. There are two core components in Doctrine, doctrine/dbal and doctrine/orm, the former is a low level APIs for database operations, if you know Java development, consider it as the Jdbc layer. The later is the advanced ORM framework, the public APIs are similar to JPA/Hibernate. Install Doctrine into the project. # composer require symfony/orm-pack# composer require --dev symfony/maker-bundle The pack is a virtual Symfony package, it will install a series of packages and basic configurations. Open the .env file in the project root folder, edit the DATABASE_URL value, setup the database name, username, password to connect. DATABASE_URL=&quot;postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;charset=utf8&quot; Use the following command to generate a docker compose file template. # php bin/console make:docker:database We change it to the following to start up a Postgres database in development. version: &quot;3.5&quot; # specify docker-compose version, v3.5 is compatible with docker 17.12.0+ # Define the services/containers to be runservices: postgres: image: postgres:${POSTGRES_VERSION:-13}-alpine ports: - &quot;5432:5432&quot; environment: POSTGRES_DB: ${POSTGRES_DB:-blogdb} # You should definitely change the password in production POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password} POSTGRES_USER: ${POSTGRES_USER:-user} volumes: - ./data/blogdb:/var/lib/postgresql/data:rw - ./pg-initdb.d:/docker-entrypoint-initdb.d We will use UUID as data type of the primary key, add a script to enable uuid-ossp extension in Postgres when it is starting up. -- file: pg-initdb.d/ini.sqlSET search_path TO public;DROP EXTENSION IF EXISTS &quot;uuid-ossp&quot;;CREATE EXTENSION &quot;uuid-ossp&quot; SCHEMA public; Open config/packages/test/doctrine.yaml, comment out dbname_suffix line. We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production. Now startup the application and make sure there is no exception in the console, that means the database connection is successful. symfony server:start Before starting the application, make sure the database is running. Run the following command to start up the Postgres in Docker. # docker compose up postgres# docker ps -a # to list all containers and make the postgres is running Building Data Models Now we will build the Entities that will be used in the next sections. We are modeling a simple blog system, it includes the following concepts. A Post presents an article post in the blog system.A Comment presents the comments under a specific post.The common Tag can be applied on different posts, which categorizes posts by topic, categories , etc. You can draft your model relations in mind or through some graphic data modeling tools. Post and comments is a one-to-many relationPost and tag is a many-to-many relation It is easy to convert the idea to real codes via Doctrine Entity. Run the following command to create Post, Comment and Tag entities. In the Doctrine ORM 2.10.x and Dbal 3.x, the UUID type ID generator is deprecated. We will switch to the Uuid form symfony\uid. Install symfony\uid firstly. # composer require symfony/uid Simply, you can use the following command to create entities quickly. # php bin/console make:entity # following the interactive steps to create them one by one. Finally we got three entities in the src/Entity folder. Modify them as you expected. // src/Entity/Post.php#[Entity(repositoryClass: PostRepository::class)]class Post{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;) //#[Column(type: &quot;string&quot;, unique: true)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private string $title; #[Column(type: &quot;string&quot;, length: 255)] private string $content; #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $createdAt = null; #[Column(name: &quot;published_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $publishedAt = null; #[OneToMany(mappedBy: &quot;post&quot;, targetEntity: Comment::class, cascade: [&#39;persist&#39;, &#39;merge&#39;, &quot;remove&quot;], fetch: &#39;LAZY&#39;, orphanRemoval: true)] private Collection $comments; #[ManyToMany(targetEntity: Tag::class, mappedBy: &quot;posts&quot;, cascade: [&#39;persist&#39;, &#39;merge&#39;], fetch: &#39;EAGER&#39;)] private Collection $tags; public function __construct() { $this-&gt;createdAt = new DateTime(); $this-&gt;comments = new ArrayCollection(); $this-&gt;tags = new ArrayCollection(); } //other getters and setters} // src/Entity/Comment.php#[Entity(repositoryClass: CommentRepository::class)]class Comment{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private string $content; #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $createdAt = null; #[ManyToOne(targetEntity: &quot;Post&quot;, inversedBy: &quot;comments&quot;)] #[JoinColumn(name: &quot;post_id&quot;, referencedColumnName: &quot;id&quot;)] private Post $post; public function __construct() { $this-&gt;createdAt = new DateTime(); } //other getters and setters} //src/Entity/Tag.php#[Entity(repositoryClass: TagRepository::class)]class Tag{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;) //#[Column(type: &quot;string&quot;, unique: true)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private ?string $name; #[ManyToMany(targetEntity: Post::class, inversedBy: &quot;tags&quot;)] private Collection $posts; public function __construct() { $this-&gt;posts = new ArrayCollection(); }} At the same time, it generated three Repository classes for these entities. // src/Repository/PostRepsoitory.phpclass PostRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Post::class); }} // src/Repository/CommentRepsoitory.phpclass CommentRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Comment::class); }} //src/Repository/TagRepository.phpclass TagRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Tag::class); }} You can use Doctrine migration to generate a Migration file to maintain database schema in a production environment. Run the following command to generate a Migration file. # php bin/console make:migration After it is executed, a Migration file is generated in the migrations folder, its naming is like Version20211104031420. It is a simple class extended AbstractMigration, the up function is use for upgrade to this version and down function is use for downgrade to the previous version. To apply Migrations on database automaticially. # php bin/console doctrine:migrations:migrate # return to prev version# php bin/console doctrine:migrations:migrate prev # migrate to next# php bin/console doctrine:migrations:migrate next # These alias are defined : first, latest, prev, current and next # certain version fully qualified class name# php bin/console doctrine:migrations:migrate FQCN Doctrine bundle also includes some command to maintain database and schema. eg. # php bin/console doctrine:database:create# php bin/console doctrine:database:drop // schema create, drop, update and validate# php bin/console doctrine:schema:create# php bin/console doctrine:schema:drop# php bin/console doctrine:schema:update# php bin/console doctrine:schema:validate Adding Sample Data Create a custom command to load some sample data. # php bin/console make:command add-post It will generate a AddPostCommand under src/Command folder. #[AsCommand( name: &#39;app:add-post&#39;, description: &#39;Add a short description for your command&#39;,)]class AddPostCommand extends Command{ public function __construct(private EntityManagerInterface $manager) { parent::__construct(); } protected function configure(): void { $this -&gt;addArgument(&#39;title&#39;, InputArgument::REQUIRED, &#39;Title of a post&#39;) -&gt;addArgument(&#39;content&#39;, InputArgument::REQUIRED, &#39;Content of a post&#39;) //-&gt;addOption(&#39;option1&#39;, null, InputOption::VALUE_NONE, &#39;Option description&#39;) ; } protected function execute(InputInterface $input, OutputInterface $output): int { $io = new SymfonyStyle($input, $output); $title = $input-&gt;getArgument(&#39;title&#39;); if ($title) { $io-&gt;note(sprintf(&#39;Title: %s&#39;, $title)); } $content = $input-&gt;getArgument(&#39;content&#39;); if ($content) { $io-&gt;note(sprintf(&#39;Content: %s&#39;, $content)); } $entity = PostFactory::create($title, $content); $this -&gt;manager-&gt;persist($entity); $this -&gt;manager-&gt;flush(); // if ($input-&gt;getOption(&#39;option1&#39;)) {// // ...// } $io-&gt;success(&#39;Post is saved: &#39;.$entity); return Command::SUCCESS; }} The Doctrine EntityManagerInterface is managed by Symfony Service Container, and use for data persistence operations. Run the following command to add a post into the database. # php bin/console app:add-post &quot;test title&quot; &quot;test content&quot; ! [NOTE] Title: test title ! [NOTE] Content: test content [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=] Testing Repository PHPUnit is the most popular testing framework in PHP world, Symfony integrates PHPUnit tightly. Run the following command to install PHPUnit and Symfony test-pack. The test-pack will install all essential packages for testing Symfony components and add PHPUnit configuration, such as phpunit.xml.dist. # composer require --dev phpunit/phpunit symfony/test-pack An simple test example written in pure PHPUnit. class PostTest extends TestCase{ public function testPost() { $p = PostFactory::create(&quot;tests title&quot;, &quot;tests content&quot;); $this-&gt;assertEquals(&quot;tests title&quot;, $p-&gt;getTitle()); $this-&gt;assertEquals(&quot;tests content&quot;, $p-&gt;getContent()); $this-&gt;assertNotNull( $p-&gt;getCreatedAt()); }} Symfony provides some specific base classes(KernelTestCase, WebTestCase, etc.) to simplfy the testing work in a Symfony project. The following is an example of testing a Repository - PostRepository. The KernelTestCase contains facilities to bootstrap application kernel and provides service container. class PostRepositoryTest extends KernelTestCase{ private EntityManagerInterface $entityManager; private PostRepository $postRepository; protected function setUp(): void { //(1) boot the Symfony kernel $kernel = self::bootKernel(); $this-&gt;assertSame(&#39;test&#39;, $kernel-&gt;getEnvironment()); $this-&gt;entityManager = $kernel-&gt;getContainer() -&gt;get(&#39;doctrine&#39;) -&gt;getManager(); //(2) use static::getContainer() to access the service container $container = static::getContainer(); //(3) get PostRepository from container. $this-&gt;postRepository = $container-&gt;get(PostRepository::class); } protected function tearDown(): void { parent::tearDown(); $this-&gt;entityManager-&gt;close(); } public function testCreatePost(): void { $entity = PostFactory::create(&quot;test post&quot;, &quot;test content&quot;); $this-&gt;entityManager-&gt;persist($entity); $this-&gt;entityManager-&gt;flush(); $this-&gt;assertNotNull($entity-&gt;getId()); $byId = $this-&gt;postRepository-&gt;findOneBy([&quot;id&quot; =&gt; $entity-&gt;getId()]); $this-&gt;assertEquals(&quot;test post&quot;, $byId-&gt;getTitle()); $this-&gt;assertEquals(&quot;test content&quot;, $byId-&gt;getContent()); } } In the above codes, in the setUp function, boot up the application kernel, after it is booted, a test scoped Service Container is available. Then get EntityManagerInterface and PostRepository from service container. In the testCreatePost function, persists a Post entity, and find this post by id and verify the title and content fields. Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes are similar to the legacy JUnit 4 code style. Creating PostController: Exposing your first Rest API Similar to other MVC framework, we can expose RESTful APIs via Symfony Controller component. Follow the REST convention, we are planning to create the following APIs to a blog system. GET /posts Get all posts.GET /posts/{id} Get a single post by ID, if not found, return status 404POST /posts Create a new post from request body, add the new post URI to response header Location, and return status 201DELETE /posts/{id} Delete a single post by ID, return status 204. If the post was not found, return status 404 instead.… Run the following command to create a Controller skeleton. Follow the interactive guide to create a controller named PostController. # php bin/console make:constroller Open src/Controller/PostController.php in IDE. Add Route attribute on class level and two functions: one for fetching all posts and another for getting single post by ID. #[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]class PostController extends AbstractController{ public function __construct(private PostRepository $posts) { } #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(): Response { $data = $this-&gt;posts-&gt;findAll(); return $this-&gt;json($data); } } Start up the application, and try to access the http://localhost:8000/posts, it will throw a circular dependencies exception when rendering the models in JSON view directly. There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view. Add a Ignore attribute on Comment.post and Tag.posts. //src/Entity/Comment.phpclass Comment{ #[Ignore] private Post $post;} //src/Entity/Tag.phpclass Tag{ #[Ignore] private Collection $posts;} Testing Controller As described in the previous sections, to test Controller/API, create a test class to extend WebTestCase, which provides a plenty of facilities to handle request and assert response. Run the following command to create a test skeleton. # php bin/console make:test Follow the interactive steps to create a test base on WebTestCase. class PostControllerTest extends WebTestCase{ public function testGetAllPosts(): void { $client = static::createClient(); $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts&#39;); $this-&gt;assertResponseIsSuccessful(); // $response = $client-&gt;getResponse(); $data = $response-&gt;getContent(); //dump($data); $this-&gt;assertStringContainsString(&quot;Symfony and PHP&quot;, $data); } } If you try to run the test, it will fail. At the moment, there is no any data for testing. Preparing Data for Testing Purpose The doctrine/doctrine-fixtures-bundle is use for populate sample data for testing purpose, and dama/doctrine-test-bundle ensures the data is restored before evey test is running. Install doctrine/doctrine-fixtures-bundle and dama/doctrine-test-bundle. composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundle Create a new Fixture. # php bin/console make:fixtures In the load fucntion, persist some data for tests. class AppFixtures extends Fixture{ public function load(ObjectManager $manager): void { $data = PostFactory::create(&quot;Building Restful APIs with Symfony and PHP 8&quot;, &quot;test content&quot;); $data-&gt;addTag(Tag::of( &quot;Symfony&quot;)) -&gt;addTag( Tag::of(&quot;PHP 8&quot;)) -&gt;addComment(Comment::of(&quot;test comment 1&quot;)) -&gt;addComment(Comment::of(&quot;test comment 2&quot;)); $manager-&gt;persist($data); $manager-&gt;flush(); }} Run the command to load the sample data into database manually. # php bin/console doctrine:fixtures:load Add the following extension configuration into the phpunit.xml.dist, thus the data will be purged and recreated for every test running. &lt;extensions&gt; &lt;extension class=&quot;DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension&quot;/&gt;&lt;/extensions&gt; Run the following command to execute PostControllerTest.php . # php .\vendor\bin\phpunit .\tests\Controller\PostControllerTest.php Paginating Result There are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a keyword provided by request to match Post title or content fields, a offset to set the offset position of the pagination, and a limit to set the limited size of the elements per page. Create a function in the PostRepository, accepts a keyword, offset and limit as arguments. public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page{ $query = $this-&gt;createQueryBuilder(&quot;p&quot;) -&gt;andWhere(&quot;p.title like :q or p.content like :q&quot;) -&gt;setParameter(&#39;q&#39;, &quot;%&quot; . $q . &quot;%&quot;) -&gt;orderBy(&#39;p.createdAt&#39;, &#39;DESC&#39;) -&gt;setMaxResults($limit) -&gt;setFirstResult($offset) -&gt;getQuery(); $paginator = new Paginator($query, $fetchJoinCollection = false); $c = count($paginator); $content = new ArrayCollection(); foreach ($paginator as $post) { $content-&gt;add(PostSummaryDto::of($post-&gt;getId(), $post-&gt;getTitle())); } return Page::of ($content, $c, $offset, $limit);} Firstly, create a dynamic query using createQueryBuilder , then create a Doctrine Paginator instance to execute the query. The Paginator implements Countable interface, use count to get the count of total elements. Finally, we use a custom Page object to wrap the result. class Page{ private Collection $content; private int $totalElements; private int $offset; private int $limit; #[Pure] public function __construct() { $this-&gt;content = new ArrayCollection(); } public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page { $page = new Page(); $page-&gt;setContent($content) -&gt;setTotalElements($totalElements) -&gt;setOffset($offset) -&gt;setLimit($limit); return $page; } // //getters } Customzing ArgumentResolver In the PostController , let&#39;s improve the the function which serves the route /posts, make it accept query parameters like /posts?q=Symfony&amp;offset=0&amp;limit=10, and ensure the parameters are optional. #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(Request $req): Response { $keyword = $req-&gt;query-&gt;get(&#39;q&#39;)??&#39;&#39;; $offset = $req-&gt;query-&gt;get(&#39;offset&#39;)??0; $limit = $req-&gt;query-&gt;get(&#39;limit&#39;)??10; $data = $this-&gt;posts-&gt;findByKeyword($keyword, $offset, $limit); return $this-&gt;json($data); } It works but the query parameters handling looks a little ugly. It is great if they can be handled as the route path parameters. We can create a custom ArgumentResolver to resolve the bound query arguments. Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this ArgumentResolver. #[Attribute(Attribute::TARGET_PARAMETER)]final class QueryParam{ private null|string $name; private bool $required; /** * @param string|null $name * @param bool $required */ public function __construct(?string $name = null, bool $required = false) { $this-&gt;name = $name; $this-&gt;required = $required; } //getters and setters } Create a custom ArgumentResolver implements the built-in ArgugmentResolverInterface. class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct() { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $argumentName = $argument-&gt;getName(); $this-&gt;logger-&gt;info(&quot;Found [QueryParam] annotation/attribute on argument &#39;&quot; . $argumentName . &quot;&#39;, applying [QueryParamValueResolver]&quot;); $type = $argument-&gt;getType(); $nullable = $argument-&gt;isNullable(); $this-&gt;logger-&gt;debug(&quot;The method argument type: &#39;&quot; . $type . &quot;&#39; and nullable: &#39;&quot; . $nullable . &quot;&#39;&quot;); //read name property from QueryParam $attr = $argument-&gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable $this-&gt;logger-&gt;debug(&quot;QueryParam:&quot; . $attr); //if name property is not set in `QueryParam`, use the argument name instead. $name = $attr-&gt;getName() ?? $argumentName; $required = $attr-&gt;isRequired() ?? false; $this-&gt;logger-&gt;debug(&quot;Polished QueryParam values: name=&#39;&quot; . $name . &quot;&#39;, required=&#39;&quot; . $required . &quot;&#39;&quot;); //fetch query name from request $value = $request-&gt;query-&gt;get($name); $this-&gt;logger-&gt;debug(&quot;The request query parameter value: &#39;&quot; . $value . &quot;&#39;&quot;); //if default value is set and query param value is not set, use default value instead. if (!$value &amp;&amp; $argument-&gt;hasDefaultValue()) { $value = $argument-&gt;getDefaultValue(); $this-&gt;logger-&gt;debug(&quot;After set default value: &#39;&quot; . $value . &quot;&#39;&quot;); } if ($required &amp;&amp; !$value) { throw new \InvalidArgumentException(&quot;Request query parameter &#39;&quot; . $name . &quot;&#39; is required, but not set.&quot;); } $this-&gt;logger-&gt;debug(&quot;final resolved value: &#39;&quot; . $value . &quot;&#39;&quot;); //must return a `yield` clause yield match ($type) { &#39;int&#39; =&gt; $value ? (int)$value : 0, &#39;float&#39; =&gt; $value ? (float)$value : .0, &#39;bool&#39; =&gt; (bool)$value, &#39;string&#39; =&gt; $value ? (string)$value : ($nullable ? null : &#39;&#39;), null =&gt; null }; } public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&gt;getAttributes(QueryParam::class); return count($attrs) &gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; }} At runtime, it calls the supports function to check it the current request satisfy the requirement, if it is ok, then invoke the resovle funtion. In the supports function, we check if the argument is annotated with a QueryParam, if it is existed, then resolved the argument from request query string. Now change the function that serves /posts endpoint to the following. #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]function all(#[QueryParam] $keyword, #[QueryParam] int $offset = 0, #[QueryParam] int $limit = 20): Response { $data = $this-&gt;posts-&gt;findByKeyword($keyword || &#39;&#39;, $offset, $limit); return $this-&gt;json($data); } Run the application and test the /posts using curl. # curl http://localhost:8000/posts{ &quot;content&quot;:[ { &quot;id&quot;:&quot;1ec3e1e0-17b3-6ed2-a01c-edecc112b436&quot;, &quot;title&quot;:&quot;Building Restful APIs with Symfony and PHP 8&quot; } ], &quot;totalElements&quot;:1, &quot;offset&quot;:0, &quot;limit&quot;:20} Get Post by ID Follow the design in the previous section, add another function to PostController to map route /posts/{id} . class PostController extends AbstractController{ //other functions... #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])] function getById(Uuid $id): Response { $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]); if ($data) { return $this-&gt;json($data); } else { return $this-&gt;json([&quot;error&quot; =&gt; &quot;Post was not found by id:&quot; . $id], 404); } }} Run the application, and try to access http://localhost:8000/posts/{id}, it will throw an exception like this. App\Controller\PostController::getById(): Argument #1 ($id) must be of type Symfony\Component\Uid\Uuid, string given, called in D:\hantsylabs\symfony5-sample\rest-sample\vendor\symfony\http-kernel\HttpKernel.php on line 156 The id in the URI is a string, can not be used as Uuid directly. Symfony provides ParamConverter to convert the request attributes to the target type. We can create a custom ParamConverter to archive the purpose. Customizing ParamConverter Create a new class UuidParamCovnerter under src/Request/ folder. class UuidParamConverter implements ParamConverterInterface{ public function __construct(private LoggerInterface $logger) { } /** * @inheritDoc */ public function apply(Request $request, ParamConverter $configuration): bool { $param = $configuration-&gt;getName(); if (!$request-&gt;attributes-&gt;has($param)) { return false; } $value = $request-&gt;attributes-&gt;get($param); $this-&gt;logger-&gt;info(&quot;parameter value:&quot; . $value); if (!$value &amp;&amp; $configuration-&gt;isOptional()) { $request-&gt;attributes-&gt;set($param, null); return true; } $data = Uuid::fromString($value); $request-&gt;attributes-&gt;set($param, $data); return true; } /** * @inheritDoc */ public function supports(ParamConverter $configuration): bool { $className = $configuration-&gt;getClass(); $this-&gt;logger-&gt;info(&quot;converting to UUID :{c}&quot;, [&quot;c&quot; =&gt; $className]); return $className &amp;&amp; $className == Uuid::class; }} In the above codes, The supports function to check the execution environment if matching the requirementsThe apply function to perform the conversion. if supports returns false, this conversion step will be skipped. Creating a Post Follow the REST convention, define the following rule to serve an endpoint to handle the request. Request matches Http verbs/HTTP Method: POSTRequest matches route endpoint: /postsSet request header Content-Type value to application/json, and use request body to hold request data as JSON formatIf successful, return a CREATED(201) Http Status code, and set the response header Location value to the URI of the new created post. #[Route(path: &quot;&quot;, name: &quot;create&quot;, methods: [&quot;POST&quot;])]public function create(Request $request): Response{ $data = $this-&gt;serializer-&gt;deserialize($request-&gt;getContent(), CreatePostDto::class, &#39;json&#39;); $entity = PostFactory::create($data-&gt;getTitle(), $data-&gt;getContent()); $this-&gt;posts-&gt;getEntityManager()-&gt;persist($entity); return $this-&gt;json([], 201, [&quot;Location&quot; =&gt; &quot;/posts/&quot; . $entity-&gt;getId()]);} The posts-&gt;getEntityManager() overrides parent methods to get a EntityManager from parent class, you can also inject ObjectManager or EntityManagerInterface in the PostController directly to do the persistence work. The Doctrine Repository is mainly designated to build query criteria and execute custom queries. Create a test function to verify in the PostControllerTest file. public function testCreatePost(): void{ $client = static::createClient(); $data = CreatePostDto::of(&quot;test title&quot;, &quot;test content&quot;); $crawler = $client-&gt;request( &#39;POST&#39;, &#39;/posts&#39;, [], [], [], $this-&gt;getContainer()-&gt;get(&#39;serializer&#39;)-&gt;serialize($data, &#39;json&#39;) ); $this-&gt;assertResponseIsSuccessful(); $response = $client-&gt;getResponse(); $url = $response-&gt;headers-&gt;get(&#39;Location&#39;); //dump($data); $this-&gt;assertNotNull($url); $this-&gt;assertStringStartsWith(&quot;/posts/&quot;, $url);} Converting Request Body We can also use an Annotation/Attribute to erase the raw codes of handling Request object through introducing a custom ArgumentResolver. Create a Body Attribute. #[Attribute(Attribute::TARGET_PARAMETER)]final class Body{} Then create a BodyValueResolver. class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct(private SerializerInterface $serializer) { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $type = $argument-&gt;getType(); $this-&gt;logger-&gt;debug(&quot;The argument type:&#39;&quot; . $type . &quot;&#39;&quot;); $format = $request-&gt;getContentType() ?? &#39;json&#39;; $this-&gt;logger-&gt;debug(&quot;The request format:&#39;&quot; . $format . &quot;&#39;&quot;); //read request body $content = $request-&gt;getContent(); $data = $this-&gt;serializer-&gt;deserialize($content, $type, $format); // $this-&gt;logger-&gt;debug(&quot;deserialized data:{0}&quot;, [$data]); yield $data; } /** * @inheritDoc */ public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&gt;getAttributes(Body::class); return count($attrs) &gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; } In the supports method, it simply detects if the method argument annotated with a Body attribute, then apply resolve method to deserialize the request body content to a typed object. Run the application and test the endpoint through /posts. curl -v http://localhost:8000/posts -H &quot;Content-Type:application/json&quot; -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;test content\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8000&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 47&gt;&lt; HTTP/1.1 201 Created&lt; Cache-Control: no-cache, private&lt; Content-Type: application/json&lt; Date: Sun, 21 Nov 2021 08:42:49 GMT&lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e&lt; X-Powered-By: PHP/8.0.10&lt; X-Robots-Tag: noindex&lt; Content-Length: 2&lt;[] Exception Handling Symfony kernel provides a event machoism to raise an Exception in Controller class and handle them in your custom EventListener or EventSubscriber . For example, create a PostNotFoundException. class PostNotFoundException extends \RuntimeException{ public function __construct(Uuid $uuid) { parent::__construct(&quot;Post #&quot; . $uuid . &quot; was not found&quot;); } } Create a EventListener to catch this exception, and handle the exception as expected. class ExceptionListener implements LoggerAwareInterface{ private LoggerInterface $logger; public function __construct() { } public function onKernelException(ExceptionEvent $event) { // You get the exception object from the received event $exception = $event-&gt;getThrowable(); $data = [&quot;error&quot; =&gt; $exception-&gt;getMessage()]; // Customize your response object to display the exception details $response = new JsonResponse($data); // HttpExceptionInterface is a special type of exception that // holds status code and header details if ($exception instanceof PostNotFoundException) { $response-&gt;setStatusCode(Response::HTTP_NOT_FOUND); } else if ($exception instanceof HttpExceptionInterface) { $response-&gt;setStatusCode($exception-&gt;getStatusCode()); $response-&gt;headers-&gt;replace($exception-&gt;getHeaders()); } else { $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR); } // sends the modified response object to the event $event-&gt;setResponse($response); } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; }} Register this ExceptionListener in config/service.yml file. App\EventListener\ExceptionListener: tags: - { name: kernel.event_listener, event: kernel.exception, priority: 50 } It indicates it binds event.exception event to ExceptionListener, and set priority to set the order at execution time. Run the following command to show all registered EventListener/EventSubscribers on event kernel.exception. php bin/console debug:event-subscriber kernel.exception Change the getById function to the following. #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])]function getById(Uuid $id): Response{ $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]); if ($data) { return $this-&gt;json($data); } else { throw new PostNotFoundException($id); }} Add a test to verify if the post is not found and get a 404 status code. public function testGetANoneExistingPost(): void{ $client = static::createClient(); $id = Uuid::v4(); $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts/&#39; . $id); // $response = $client-&gt;getResponse(); $this-&gt;assertResponseStatusCodeSame(404); $data = $response-&gt;getContent(); $this-&gt;assertStringContainsString(&quot;Post #&quot; . $id . &quot; was not found&quot;, $data);} Run the application again, and try to access a single Post through a none existing id. curl http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 -H &quot;Accept: application/json&quot; -v&gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1&gt; Host: localhost:8000&gt; User-Agent: curl/7.55.1&gt; Accept: application/json&gt;&lt; HTTP/1.1 404 Not Found&lt; Cache-Control: no-cache, private&lt; Content-Type: application/json&lt; Date: Mon, 22 Nov 2021 03:57:51 GMT&lt; X-Powered-By: PHP/8.0.10&lt; X-Robots-Tag: noindex&lt; Content-Length: 69&lt;{&quot;error&quot;:&quot;Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.&quot;} Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Restful APIs with Symfony 5 and PHP 8 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Symfony is a full-featured modularized PHP framework that is used for building all kinds of applications, from traditional web applications to small Microservice components. Photo by te chan on Unsplash Get your feet wet Install PHP 8 and PHP Composer tools. # choco php composer Install [Symfony CLI](symfony check:requirements), check the system requirements. # symfony check:requirements Symfony Requirements Checker~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &gt; PHP is using the following php.ini file:C:\tools\php80\php.ini &gt; Checking Symfony requirements: ....................WWW......... [OK] Your system is ready to run Symfony projects Optional recommendations to improve your setup~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * intl extension should be available &gt; Install and enable the intl extension (used for validators). * a PHP accelerator should be installed &gt; Install and/or enable a PHP accelerator (highly recommended). * realpath_cache_size should be at least 5M in php.ini &gt; Setting &quot;realpath_cache_size&quot; to e.g. &quot;5242880&quot; or &quot;5M&quot; in &gt; php.ini* may improve performance on Windows significantly in some &gt; cases. Note The command console can use a different php.ini file~~~~ than the one used by your web server. Please check that both the console and the web server are using the same PHP version and configuration. According to the recommendations info, adjust your PHP configuration in the php.ini. And we will use Postgres as database in the sample application, make sure pdo_pgsql and pgsql modules are enabled. Finally, you can confirm the enabled modules by the following command. # php -m Create a new Symfony project. # symfony new rest-sample // a classic website application# symfony new web-sample --full By default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application. Alternatively, you can create it using Composer. # composer create-project symfony/skeleton rest-sample //start a classic website application# composer create-project symfony/website-skeleton web-sample Enter the generated project root folder, start the application. # symfony server:start [WARNING] run &quot;symfony.exe server:ca:install&quot; first if you want to run the web server with TLS support, or use &quot;--no- tls&quot; to avoid this warning Tailing PHP-CGI log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)Tailing Web Server log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158.log) [OK] Web server listening The Web server is using PHP CGI 8.0.10 http://127.0.0.1:8000 [Web Server ] Oct 4 13:33:01 |DEBUG | PHP Reloading PHP versions[Web Server ] Oct 4 13:33:01 |DEBUG | PHP Using PHP version 8.0.10 (from default version in $PATH)[Web Server ] Oct 4 13:33:01 |INFO | PHP listening path=&quot;C:\\tools\\php80\\php-cgi.exe&quot; php=&quot;8.0.10&quot; port=61738 Hello , Symfony Create a simple class to a resource entity in the HTTP response. class Post{ private ?string $id = null; private string $title; private string $content; //getters and setters.} And use a factory to create a new Post instance. class PostFactory{ public static function create(string $title, string $content): Post { $post = new Post(); $post-&gt;setTitle($title); $post-&gt;setContent($content); return $post; }} Let’s create a simple Controller class. To use the newest PHP 8 attributes to configure the routing rules, apply the following changes in the project configurations. Open config/packages/doctrine.yaml, remove doctrine/orm/mapping/App/type or change its value to attributeOpen composer.json, change PHP version to &gt;=8.0.0. To render the response body into a JSON string, use a JsonReponse to wrap the response. #[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]class PostController{ #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(): Response { $post1 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;); $post1-&gt;setId(&quot;1&quot;); $post2 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;); $post2-&gt;setId(&quot;2&quot;); $data = [$post1-&gt;asArray(), $post2-&gt;asArray()]; return new JsonResponse($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); //return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); }} The first parameter of JsonReponse accepts an array as data, so add a function in the Post class to archive this purpose. class Post{ //... public function asArray(): array { return [ &#39;id&#39; =&gt; $this-&gt;id, &#39;title&#39; =&gt; $this-&gt;title, &#39;content&#39; =&gt; $this-&gt;content ]; }} Run the application, use curl to test the /posts endpoint. # curl http://localhost:8000/posts Symfony provides a simple AbstractController which includes several functions to simplfy the response and adopt the container and dependency injection management. In the above controller, extends from AbstractController, simply call $this-&gt;json to render the response in JSON format, no need to transform the data to an array before rendering response. class PostController extends AbstractController{ function all(): Response { //... return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); }} Connecting to Database Doctrine is a popular ORM framework , it is highly inspired by the existing Java ORM tooling, such as JPA spec and Hibernate framework. There are two core components in Doctrine, doctrine/dbal and doctrine/orm, the former is a low level APIs for database operations, if you know Java development, consider it as the Jdbc layer. The later is the advanced ORM framework, the public APIs are similar to JPA/Hibernate. Install Doctrine into the project. # composer require symfony/orm-pack# composer require --dev symfony/maker-bundle The pack is a virtual Symfony package, it will install a series of packages and basic configurations. Open the .env file in the project root folder, edit the DATABASE_URL value, setup the database name, username, password to connect. DATABASE_URL=&quot;postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;charset=utf8&quot; Use the following command to generate a docker compose file template. # php bin/console make:docker:database We change it to the following to start up a Postgres database in development. version: &quot;3.5&quot; # specify docker-compose version, v3.5 is compatible with docker 17.12.0+ # Define the services/containers to be runservices: postgres: image: postgres:${POSTGRES_VERSION:-13}-alpine ports: - &quot;5432:5432&quot; environment: POSTGRES_DB: ${POSTGRES_DB:-blogdb} # You should definitely change the password in production POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password} POSTGRES_USER: ${POSTGRES_USER:-user} volumes: - ./data/blogdb:/var/lib/postgresql/data:rw - ./pg-initdb.d:/docker-entrypoint-initdb.d We will use UUID as data type of the primary key, add a script to enable uuid-ossp extension in Postgres when it is starting up. -- file: pg-initdb.d/ini.sqlSET search_path TO public;DROP EXTENSION IF EXISTS &quot;uuid-ossp&quot;;CREATE EXTENSION &quot;uuid-ossp&quot; SCHEMA public; Open config/packages/test/doctrine.yaml, comment out dbname_suffix line. We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production. Now startup the application and make sure there is no exception in the console, that means the database connection is successful. symfony server:start Before starting the application, make sure the database is running. Run the following command to start up the Postgres in Docker. # docker compose up postgres# docker ps -a # to list all containers and make the postgres is running Building Data Models Now we will build the Entities that will be used in the next sections. We are modeling a simple blog system, it includes the following concepts. A Post presents an article post in the blog system.A Comment presents the comments under a specific post.The common Tag can be applied on different posts, which categorizes posts by topic, categories , etc. You can draft your model relations in mind or through some graphic data modeling tools. Post and comments is a one-to-many relationPost and tag is a many-to-many relation It is easy to convert the idea to real codes via Doctrine Entity. Run the following command to create Post, Comment and Tag entities. In the Doctrine ORM 2.10.x and Dbal 3.x, the UUID type ID generator is deprecated. We will switch to the Uuid form symfony\uid. Install symfony\uid firstly. # composer require symfony/uid Simply, you can use the following command to create entities quickly. # php bin/console make:entity # following the interactive steps to create them one by one. Finally we got three entities in the src/Entity folder. Modify them as you expected. // src/Entity/Post.php#[Entity(repositoryClass: PostRepository::class)]class Post{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;) //#[Column(type: &quot;string&quot;, unique: true)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private string $title; #[Column(type: &quot;string&quot;, length: 255)] private string $content; #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $createdAt = null; #[Column(name: &quot;published_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $publishedAt = null; #[OneToMany(mappedBy: &quot;post&quot;, targetEntity: Comment::class, cascade: [&#39;persist&#39;, &#39;merge&#39;, &quot;remove&quot;], fetch: &#39;LAZY&#39;, orphanRemoval: true)] private Collection $comments; #[ManyToMany(targetEntity: Tag::class, mappedBy: &quot;posts&quot;, cascade: [&#39;persist&#39;, &#39;merge&#39;], fetch: &#39;EAGER&#39;)] private Collection $tags; public function __construct() { $this-&gt;createdAt = new DateTime(); $this-&gt;comments = new ArrayCollection(); $this-&gt;tags = new ArrayCollection(); } //other getters and setters} // src/Entity/Comment.php#[Entity(repositoryClass: CommentRepository::class)]class Comment{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private string $content; #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $createdAt = null; #[ManyToOne(targetEntity: &quot;Post&quot;, inversedBy: &quot;comments&quot;)] #[JoinColumn(name: &quot;post_id&quot;, referencedColumnName: &quot;id&quot;)] private Post $post; public function __construct() { $this-&gt;createdAt = new DateTime(); } //other getters and setters} //src/Entity/Tag.php#[Entity(repositoryClass: TagRepository::class)]class Tag{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;) //#[Column(type: &quot;string&quot;, unique: true)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private ?string $name; #[ManyToMany(targetEntity: Post::class, inversedBy: &quot;tags&quot;)] private Collection $posts; public function __construct() { $this-&gt;posts = new ArrayCollection(); }} At the same time, it generated three Repository classes for these entities. // src/Repository/PostRepsoitory.phpclass PostRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Post::class); }} // src/Repository/CommentRepsoitory.phpclass CommentRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Comment::class); }} //src/Repository/TagRepository.phpclass TagRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Tag::class); }} You can use Doctrine migration to generate a Migration file to maintain database schema in a production environment. Run the following command to generate a Migration file. # php bin/console make:migration After it is executed, a Migration file is generated in the migrations folder, its naming is like Version20211104031420. It is a simple class extended AbstractMigration, the up function is use for upgrade to this version and down function is use for downgrade to the previous version. To apply Migrations on database automaticially. # php bin/console doctrine:migrations:migrate # return to prev version# php bin/console doctrine:migrations:migrate prev # migrate to next# php bin/console doctrine:migrations:migrate next # These alias are defined : first, latest, prev, current and next # certain version fully qualified class name# php bin/console doctrine:migrations:migrate FQCN Doctrine bundle also includes some command to maintain database and schema. eg. # php bin/console doctrine:database:create# php bin/console doctrine:database:drop // schema create, drop, update and validate# php bin/console doctrine:schema:create# php bin/console doctrine:schema:drop# php bin/console doctrine:schema:update# php bin/console doctrine:schema:validate Adding Sample Data Create a custom command to load some sample data. # php bin/console make:command add-post It will generate a AddPostCommand under src/Command folder. #[AsCommand( name: &#39;app:add-post&#39;, description: &#39;Add a short description for your command&#39;,)]class AddPostCommand extends Command{ public function __construct(private EntityManagerInterface $manager) { parent::__construct(); } protected function configure(): void { $this -&gt;addArgument(&#39;title&#39;, InputArgument::REQUIRED, &#39;Title of a post&#39;) -&gt;addArgument(&#39;content&#39;, InputArgument::REQUIRED, &#39;Content of a post&#39;) //-&gt;addOption(&#39;option1&#39;, null, InputOption::VALUE_NONE, &#39;Option description&#39;) ; } protected function execute(InputInterface $input, OutputInterface $output): int { $io = new SymfonyStyle($input, $output); $title = $input-&gt;getArgument(&#39;title&#39;); if ($title) { $io-&gt;note(sprintf(&#39;Title: %s&#39;, $title)); } $content = $input-&gt;getArgument(&#39;content&#39;); if ($content) { $io-&gt;note(sprintf(&#39;Content: %s&#39;, $content)); } $entity = PostFactory::create($title, $content); $this -&gt;manager-&gt;persist($entity); $this -&gt;manager-&gt;flush(); // if ($input-&gt;getOption(&#39;option1&#39;)) {// // ...// } $io-&gt;success(&#39;Post is saved: &#39;.$entity); return Command::SUCCESS; }} The Doctrine EntityManagerInterface is managed by Symfony Service Container, and use for data persistence operations. Run the following command to add a post into the database. # php bin/console app:add-post &quot;test title&quot; &quot;test content&quot; ! [NOTE] Title: test title ! [NOTE] Content: test content [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=] Testing Repository PHPUnit is the most popular testing framework in PHP world, Symfony integrates PHPUnit tightly. Run the following command to install PHPUnit and Symfony test-pack. The test-pack will install all essential packages for testing Symfony components and add PHPUnit configuration, such as phpunit.xml.dist. # composer require --dev phpunit/phpunit symfony/test-pack An simple test example written in pure PHPUnit. class PostTest extends TestCase{ public function testPost() { $p = PostFactory::create(&quot;tests title&quot;, &quot;tests content&quot;); $this-&gt;assertEquals(&quot;tests title&quot;, $p-&gt;getTitle()); $this-&gt;assertEquals(&quot;tests content&quot;, $p-&gt;getContent()); $this-&gt;assertNotNull( $p-&gt;getCreatedAt()); }} Symfony provides some specific base classes(KernelTestCase, WebTestCase, etc.) to simplfy the testing work in a Symfony project. The following is an example of testing a Repository - PostRepository. The KernelTestCase contains facilities to bootstrap application kernel and provides service container. class PostRepositoryTest extends KernelTestCase{ private EntityManagerInterface $entityManager; private PostRepository $postRepository; protected function setUp(): void { //(1) boot the Symfony kernel $kernel = self::bootKernel(); $this-&gt;assertSame(&#39;test&#39;, $kernel-&gt;getEnvironment()); $this-&gt;entityManager = $kernel-&gt;getContainer() -&gt;get(&#39;doctrine&#39;) -&gt;getManager(); //(2) use static::getContainer() to access the service container $container = static::getContainer(); //(3) get PostRepository from container. $this-&gt;postRepository = $container-&gt;get(PostRepository::class); } protected function tearDown(): void { parent::tearDown(); $this-&gt;entityManager-&gt;close(); } public function testCreatePost(): void { $entity = PostFactory::create(&quot;test post&quot;, &quot;test content&quot;); $this-&gt;entityManager-&gt;persist($entity); $this-&gt;entityManager-&gt;flush(); $this-&gt;assertNotNull($entity-&gt;getId()); $byId = $this-&gt;postRepository-&gt;findOneBy([&quot;id&quot; =&gt; $entity-&gt;getId()]); $this-&gt;assertEquals(&quot;test post&quot;, $byId-&gt;getTitle()); $this-&gt;assertEquals(&quot;test content&quot;, $byId-&gt;getContent()); } } In the above codes, in the setUp function, boot up the application kernel, after it is booted, a test scoped Service Container is available. Then get EntityManagerInterface and PostRepository from service container. In the testCreatePost function, persists a Post entity, and find this post by id and verify the title and content fields. Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes are similar to the legacy JUnit 4 code style. Creating PostController: Exposing your first Rest API Similar to other MVC framework, we can expose RESTful APIs via Symfony Controller component. Follow the REST convention, we are planning to create the following APIs to a blog system. GET /posts Get all posts.GET /posts/{id} Get a single post by ID, if not found, return status 404POST /posts Create a new post from request body, add the new post URI to response header Location, and return status 201DELETE /posts/{id} Delete a single post by ID, return status 204. If the post was not found, return status 404 instead.… Run the following command to create a Controller skeleton. Follow the interactive guide to create a controller named PostController. # php bin/console make:constroller Open src/Controller/PostController.php in IDE. Add Route attribute on class level and two functions: one for fetching all posts and another for getting single post by ID. #[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]class PostController extends AbstractController{ public function __construct(private PostRepository $posts) { } #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(): Response { $data = $this-&gt;posts-&gt;findAll(); return $this-&gt;json($data); } } Start up the application, and try to access the http://localhost:8000/posts, it will throw a circular dependencies exception when rendering the models in JSON view directly. There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view. Add a Ignore attribute on Comment.post and Tag.posts. //src/Entity/Comment.phpclass Comment{ #[Ignore] private Post $post;} //src/Entity/Tag.phpclass Tag{ #[Ignore] private Collection $posts;} Testing Controller As described in the previous sections, to test Controller/API, create a test class to extend WebTestCase, which provides a plenty of facilities to handle request and assert response. Run the following command to create a test skeleton. # php bin/console make:test Follow the interactive steps to create a test base on WebTestCase. class PostControllerTest extends WebTestCase{ public function testGetAllPosts(): void { $client = static::createClient(); $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts&#39;); $this-&gt;assertResponseIsSuccessful(); // $response = $client-&gt;getResponse(); $data = $response-&gt;getContent(); //dump($data); $this-&gt;assertStringContainsString(&quot;Symfony and PHP&quot;, $data); } } If you try to run the test, it will fail. At the moment, there is no any data for testing. Preparing Data for Testing Purpose The doctrine/doctrine-fixtures-bundle is use for populate sample data for testing purpose, and dama/doctrine-test-bundle ensures the data is restored before evey test is running. Install doctrine/doctrine-fixtures-bundle and dama/doctrine-test-bundle. composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundle Create a new Fixture. # php bin/console make:fixtures In the load fucntion, persist some data for tests. class AppFixtures extends Fixture{ public function load(ObjectManager $manager): void { $data = PostFactory::create(&quot;Building Restful APIs with Symfony and PHP 8&quot;, &quot;test content&quot;); $data-&gt;addTag(Tag::of( &quot;Symfony&quot;)) -&gt;addTag( Tag::of(&quot;PHP 8&quot;)) -&gt;addComment(Comment::of(&quot;test comment 1&quot;)) -&gt;addComment(Comment::of(&quot;test comment 2&quot;)); $manager-&gt;persist($data); $manager-&gt;flush(); }} Run the command to load the sample data into database manually. # php bin/console doctrine:fixtures:load Add the following extension configuration into the phpunit.xml.dist, thus the data will be purged and recreated for every test running. &lt;extensions&gt; &lt;extension class=&quot;DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension&quot;/&gt;&lt;/extensions&gt; Run the following command to execute PostControllerTest.php . # php .\vendor\bin\phpunit .\tests\Controller\PostControllerTest.php Paginating Result There are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a keyword provided by request to match Post title or content fields, a offset to set the offset position of the pagination, and a limit to set the limited size of the elements per page. Create a function in the PostRepository, accepts a keyword, offset and limit as arguments. public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page{ $query = $this-&gt;createQueryBuilder(&quot;p&quot;) -&gt;andWhere(&quot;p.title like :q or p.content like :q&quot;) -&gt;setParameter(&#39;q&#39;, &quot;%&quot; . $q . &quot;%&quot;) -&gt;orderBy(&#39;p.createdAt&#39;, &#39;DESC&#39;) -&gt;setMaxResults($limit) -&gt;setFirstResult($offset) -&gt;getQuery(); $paginator = new Paginator($query, $fetchJoinCollection = false); $c = count($paginator); $content = new ArrayCollection(); foreach ($paginator as $post) { $content-&gt;add(PostSummaryDto::of($post-&gt;getId(), $post-&gt;getTitle())); } return Page::of ($content, $c, $offset, $limit);} Firstly, create a dynamic query using createQueryBuilder , then create a Doctrine Paginator instance to execute the query. The Paginator implements Countable interface, use count to get the count of total elements. Finally, we use a custom Page object to wrap the result. class Page{ private Collection $content; private int $totalElements; private int $offset; private int $limit; #[Pure] public function __construct() { $this-&gt;content = new ArrayCollection(); } public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page { $page = new Page(); $page-&gt;setContent($content) -&gt;setTotalElements($totalElements) -&gt;setOffset($offset) -&gt;setLimit($limit); return $page; } // //getters } Customzing ArgumentResolver In the PostController , let&#39;s improve the the function which serves the route /posts, make it accept query parameters like /posts?q=Symfony&amp;offset=0&amp;limit=10, and ensure the parameters are optional. #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(Request $req): Response { $keyword = $req-&gt;query-&gt;get(&#39;q&#39;)??&#39;&#39;; $offset = $req-&gt;query-&gt;get(&#39;offset&#39;)??0; $limit = $req-&gt;query-&gt;get(&#39;limit&#39;)??10; $data = $this-&gt;posts-&gt;findByKeyword($keyword, $offset, $limit); return $this-&gt;json($data); } It works but the query parameters handling looks a little ugly. It is great if they can be handled as the route path parameters. We can create a custom ArgumentResolver to resolve the bound query arguments. Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this ArgumentResolver. #[Attribute(Attribute::TARGET_PARAMETER)]final class QueryParam{ private null|string $name; private bool $required; /** * @param string|null $name * @param bool $required */ public function __construct(?string $name = null, bool $required = false) { $this-&gt;name = $name; $this-&gt;required = $required; } //getters and setters } Create a custom ArgumentResolver implements the built-in ArgugmentResolverInterface. class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct() { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $argumentName = $argument-&gt;getName(); $this-&gt;logger-&gt;info(&quot;Found [QueryParam] annotation/attribute on argument &#39;&quot; . $argumentName . &quot;&#39;, applying [QueryParamValueResolver]&quot;); $type = $argument-&gt;getType(); $nullable = $argument-&gt;isNullable(); $this-&gt;logger-&gt;debug(&quot;The method argument type: &#39;&quot; . $type . &quot;&#39; and nullable: &#39;&quot; . $nullable . &quot;&#39;&quot;); //read name property from QueryParam $attr = $argument-&gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable $this-&gt;logger-&gt;debug(&quot;QueryParam:&quot; . $attr); //if name property is not set in `QueryParam`, use the argument name instead. $name = $attr-&gt;getName() ?? $argumentName; $required = $attr-&gt;isRequired() ?? false; $this-&gt;logger-&gt;debug(&quot;Polished QueryParam values: name=&#39;&quot; . $name . &quot;&#39;, required=&#39;&quot; . $required . &quot;&#39;&quot;); //fetch query name from request $value = $request-&gt;query-&gt;get($name); $this-&gt;logger-&gt;debug(&quot;The request query parameter value: &#39;&quot; . $value . &quot;&#39;&quot;); //if default value is set and query param value is not set, use default value instead. if (!$value &amp;&amp; $argument-&gt;hasDefaultValue()) { $value = $argument-&gt;getDefaultValue(); $this-&gt;logger-&gt;debug(&quot;After set default value: &#39;&quot; . $value . &quot;&#39;&quot;); } if ($required &amp;&amp; !$value) { throw new \InvalidArgumentException(&quot;Request query parameter &#39;&quot; . $name . &quot;&#39; is required, but not set.&quot;); } $this-&gt;logger-&gt;debug(&quot;final resolved value: &#39;&quot; . $value . &quot;&#39;&quot;); //must return a `yield` clause yield match ($type) { &#39;int&#39; =&gt; $value ? (int)$value : 0, &#39;float&#39; =&gt; $value ? (float)$value : .0, &#39;bool&#39; =&gt; (bool)$value, &#39;string&#39; =&gt; $value ? (string)$value : ($nullable ? null : &#39;&#39;), null =&gt; null }; } public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&gt;getAttributes(QueryParam::class); return count($attrs) &gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; }} At runtime, it calls the supports function to check it the current request satisfy the requirement, if it is ok, then invoke the resovle funtion. In the supports function, we check if the argument is annotated with a QueryParam, if it is existed, then resolved the argument from request query string. Now change the function that serves /posts endpoint to the following. #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]function all(#[QueryParam] $keyword, #[QueryParam] int $offset = 0, #[QueryParam] int $limit = 20): Response { $data = $this-&gt;posts-&gt;findByKeyword($keyword || &#39;&#39;, $offset, $limit); return $this-&gt;json($data); } Run the application and test the /posts using curl. # curl http://localhost:8000/posts{ &quot;content&quot;:[ { &quot;id&quot;:&quot;1ec3e1e0-17b3-6ed2-a01c-edecc112b436&quot;, &quot;title&quot;:&quot;Building Restful APIs with Symfony and PHP 8&quot; } ], &quot;totalElements&quot;:1, &quot;offset&quot;:0, &quot;limit&quot;:20} Get Post by ID Follow the design in the previous section, add another function to PostController to map route /posts/{id} . class PostController extends AbstractController{ //other functions... #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])] function getById(Uuid $id): Response { $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]); if ($data) { return $this-&gt;json($data); } else { return $this-&gt;json([&quot;error&quot; =&gt; &quot;Post was not found by id:&quot; . $id], 404); } }} Run the application, and try to access http://localhost:8000/posts/{id}, it will throw an exception like this. App\Controller\PostController::getById(): Argument #1 ($id) must be of type Symfony\Component\Uid\Uuid, string given, called in D:\hantsylabs\symfony5-sample\rest-sample\vendor\symfony\http-kernel\HttpKernel.php on line 156 The id in the URI is a string, can not be used as Uuid directly. Symfony provides ParamConverter to convert the request attributes to the target type. We can create a custom ParamConverter to archive the purpose. Customizing ParamConverter Create a new class UuidParamCovnerter under src/Request/ folder. class UuidParamConverter implements ParamConverterInterface{ public function __construct(private LoggerInterface $logger) { } /** * @inheritDoc */ public function apply(Request $request, ParamConverter $configuration): bool { $param = $configuration-&gt;getName(); if (!$request-&gt;attributes-&gt;has($param)) { return false; } $value = $request-&gt;attributes-&gt;get($param); $this-&gt;logger-&gt;info(&quot;parameter value:&quot; . $value); if (!$value &amp;&amp; $configuration-&gt;isOptional()) { $request-&gt;attributes-&gt;set($param, null); return true; } $data = Uuid::fromString($value); $request-&gt;attributes-&gt;set($param, $data); return true; } /** * @inheritDoc */ public function supports(ParamConverter $configuration): bool { $className = $configuration-&gt;getClass(); $this-&gt;logger-&gt;info(&quot;converting to UUID :{c}&quot;, [&quot;c&quot; =&gt; $className]); return $className &amp;&amp; $className == Uuid::class; }} In the above codes, The supports function to check the execution environment if matching the requirementsThe apply function to perform the conversion. if supports returns false, this conversion step will be skipped. Creating a Post Follow the REST convention, define the following rule to serve an endpoint to handle the request. Request matches Http verbs/HTTP Method: POSTRequest matches route endpoint: /postsSet request header Content-Type value to application/json, and use request body to hold request data as JSON formatIf successful, return a CREATED(201) Http Status code, and set the response header Location value to the URI of the new created post. #[Route(path: &quot;&quot;, name: &quot;create&quot;, methods: [&quot;POST&quot;])]public function create(Request $request): Response{ $data = $this-&gt;serializer-&gt;deserialize($request-&gt;getContent(), CreatePostDto::class, &#39;json&#39;); $entity = PostFactory::create($data-&gt;getTitle(), $data-&gt;getContent()); $this-&gt;posts-&gt;getEntityManager()-&gt;persist($entity); return $this-&gt;json([], 201, [&quot;Location&quot; =&gt; &quot;/posts/&quot; . $entity-&gt;getId()]);} The posts-&gt;getEntityManager() overrides parent methods to get a EntityManager from parent class, you can also inject ObjectManager or EntityManagerInterface in the PostController directly to do the persistence work. The Doctrine Repository is mainly designated to build query criteria and execute custom queries. Create a test function to verify in the PostControllerTest file. public function testCreatePost(): void{ $client = static::createClient(); $data = CreatePostDto::of(&quot;test title&quot;, &quot;test content&quot;); $crawler = $client-&gt;request( &#39;POST&#39;, &#39;/posts&#39;, [], [], [], $this-&gt;getContainer()-&gt;get(&#39;serializer&#39;)-&gt;serialize($data, &#39;json&#39;) ); $this-&gt;assertResponseIsSuccessful(); $response = $client-&gt;getResponse(); $url = $response-&gt;headers-&gt;get(&#39;Location&#39;); //dump($data); $this-&gt;assertNotNull($url); $this-&gt;assertStringStartsWith(&quot;/posts/&quot;, $url);} Converting Request Body We can also use an Annotation/Attribute to erase the raw codes of handling Request object through introducing a custom ArgumentResolver. Create a Body Attribute. #[Attribute(Attribute::TARGET_PARAMETER)]final class Body{} Then create a BodyValueResolver. class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct(private SerializerInterface $serializer) { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $type = $argument-&gt;getType(); $this-&gt;logger-&gt;debug(&quot;The argument type:&#39;&quot; . $type . &quot;&#39;&quot;); $format = $request-&gt;getContentType() ?? &#39;json&#39;; $this-&gt;logger-&gt;debug(&quot;The request format:&#39;&quot; . $format . &quot;&#39;&quot;); //read request body $content = $request-&gt;getContent(); $data = $this-&gt;serializer-&gt;deserialize($content, $type, $format); // $this-&gt;logger-&gt;debug(&quot;deserialized data:{0}&quot;, [$data]); yield $data; } /** * @inheritDoc */ public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&gt;getAttributes(Body::class); return count($attrs) &gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; } In the supports method, it simply detects if the method argument annotated with a Body attribute, then apply resolve method to deserialize the request body content to a typed object. Run the application and test the endpoint through /posts. curl -v http://localhost:8000/posts -H &quot;Content-Type:application/json&quot; -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;test content\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8000&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 47&gt;&lt; HTTP/1.1 201 Created&lt; Cache-Control: no-cache, private&lt; Content-Type: application/json&lt; Date: Sun, 21 Nov 2021 08:42:49 GMT&lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e&lt; X-Powered-By: PHP/8.0.10&lt; X-Robots-Tag: noindex&lt; Content-Length: 2&lt;[] Exception Handling Symfony kernel provides a event machoism to raise an Exception in Controller class and handle them in your custom EventListener or EventSubscriber . For example, create a PostNotFoundException. class PostNotFoundException extends \RuntimeException{ public function __construct(Uuid $uuid) { parent::__construct(&quot;Post #&quot; . $uuid . &quot; was not found&quot;); } } Create a EventListener to catch this exception, and handle the exception as expected. class ExceptionListener implements LoggerAwareInterface{ private LoggerInterface $logger; public function __construct() { } public function onKernelException(ExceptionEvent $event) { // You get the exception object from the received event $exception = $event-&gt;getThrowable(); $data = [&quot;error&quot; =&gt; $exception-&gt;getMessage()]; // Customize your response object to display the exception details $response = new JsonResponse($data); // HttpExceptionInterface is a special type of exception that // holds status code and header details if ($exception instanceof PostNotFoundException) { $response-&gt;setStatusCode(Response::HTTP_NOT_FOUND); } else if ($exception instanceof HttpExceptionInterface) { $response-&gt;setStatusCode($exception-&gt;getStatusCode()); $response-&gt;headers-&gt;replace($exception-&gt;getHeaders()); } else { $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR); } // sends the modified response object to the event $event-&gt;setResponse($response); } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; }} Register this ExceptionListener in config/service.yml file. App\EventListener\ExceptionListener: tags: - { name: kernel.event_listener, event: kernel.exception, priority: 50 } It indicates it binds event.exception event to ExceptionListener, and set priority to set the order at execution time. Run the following command to show all registered EventListener/EventSubscribers on event kernel.exception. php bin/console debug:event-subscriber kernel.exception Change the getById function to the following. #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])]function getById(Uuid $id): Response{ $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]); if ($data) { return $this-&gt;json($data); } else { throw new PostNotFoundException($id); }} Add a test to verify if the post is not found and get a 404 status code. public function testGetANoneExistingPost(): void{ $client = static::createClient(); $id = Uuid::v4(); $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts/&#39; . $id); // $response = $client-&gt;getResponse(); $this-&gt;assertResponseStatusCodeSame(404); $data = $response-&gt;getContent(); $this-&gt;assertStringContainsString(&quot;Post #&quot; . $id . &quot; was not found&quot;, $data);} Run the application again, and try to access a single Post through a none existing id. curl http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 -H &quot;Accept: application/json&quot; -v&gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1&gt; Host: localhost:8000&gt; User-Agent: curl/7.55.1&gt; Accept: application/json&gt;&lt; HTTP/1.1 404 Not Found&lt; Cache-Control: no-cache, private&lt; Content-Type: application/json&lt; Date: Mon, 22 Nov 2021 03:57:51 GMT&lt; X-Powered-By: PHP/8.0.10&lt; X-Robots-Tag: noindex&lt; Content-Length: 69&lt;{&quot;error&quot;:&quot;Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.&quot;} Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Restful APIs with Symfony 5 and PHP 8 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-11-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building Restful APIs with Symfony 5 and PHP 8" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-11-22T00:00:00+00:00","datePublished":"2021-11-22T00:00:00+00:00","description":"Symfony is a full-featured modularized PHP framework that is used for building all kinds of applications, from traditional web applications to small Microservice components. Photo by te chan on Unsplash Get your feet wet Install PHP 8 and PHP Composer tools. # choco php composer Install [Symfony CLI](symfony check:requirements), check the system requirements. # symfony check:requirements Symfony Requirements Checker~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &gt; PHP is using the following php.ini file:C:\\tools\\php80\\php.ini &gt; Checking Symfony requirements: ....................WWW......... [OK] Your system is ready to run Symfony projects Optional recommendations to improve your setup~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * intl extension should be available &gt; Install and enable the intl extension (used for validators). * a PHP accelerator should be installed &gt; Install and/or enable a PHP accelerator (highly recommended). * realpath_cache_size should be at least 5M in php.ini &gt; Setting &quot;realpath_cache_size&quot; to e.g. &quot;5242880&quot; or &quot;5M&quot; in &gt; php.ini* may improve performance on Windows significantly in some &gt; cases. Note The command console can use a different php.ini file~~~~ than the one used by your web server. Please check that both the console and the web server are using the same PHP version and configuration. According to the recommendations info, adjust your PHP configuration in the php.ini. And we will use Postgres as database in the sample application, make sure pdo_pgsql and pgsql modules are enabled. Finally, you can confirm the enabled modules by the following command. # php -m Create a new Symfony project. # symfony new rest-sample // a classic website application# symfony new web-sample --full By default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application. Alternatively, you can create it using Composer. # composer create-project symfony/skeleton rest-sample //start a classic website application# composer create-project symfony/website-skeleton web-sample Enter the generated project root folder, start the application. # symfony server:start [WARNING] run &quot;symfony.exe server:ca:install&quot; first if you want to run the web server with TLS support, or use &quot;--no- tls&quot; to avoid this warning Tailing PHP-CGI log file (C:\\Users\\hantsy\\.symfony\\log\\499d60b14521d4842ba7ebfce0861130efe66158\\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)Tailing Web Server log file (C:\\Users\\hantsy\\.symfony\\log\\499d60b14521d4842ba7ebfce0861130efe66158.log) [OK] Web server listening The Web server is using PHP CGI 8.0.10 http://127.0.0.1:8000 [Web Server ] Oct 4 13:33:01 |DEBUG | PHP Reloading PHP versions[Web Server ] Oct 4 13:33:01 |DEBUG | PHP Using PHP version 8.0.10 (from default version in $PATH)[Web Server ] Oct 4 13:33:01 |INFO | PHP listening path=&quot;C:\\\\tools\\\\php80\\\\php-cgi.exe&quot; php=&quot;8.0.10&quot; port=61738 Hello , Symfony Create a simple class to a resource entity in the HTTP response. class Post{ private ?string $id = null; private string $title; private string $content; //getters and setters.} And use a factory to create a new Post instance. class PostFactory{ public static function create(string $title, string $content): Post { $post = new Post(); $post-&gt;setTitle($title); $post-&gt;setContent($content); return $post; }} Let’s create a simple Controller class. To use the newest PHP 8 attributes to configure the routing rules, apply the following changes in the project configurations. Open config/packages/doctrine.yaml, remove doctrine/orm/mapping/App/type or change its value to attributeOpen composer.json, change PHP version to &gt;=8.0.0. To render the response body into a JSON string, use a JsonReponse to wrap the response. #[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]class PostController{ #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(): Response { $post1 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;); $post1-&gt;setId(&quot;1&quot;); $post2 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;); $post2-&gt;setId(&quot;2&quot;); $data = [$post1-&gt;asArray(), $post2-&gt;asArray()]; return new JsonResponse($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); //return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); }} The first parameter of JsonReponse accepts an array as data, so add a function in the Post class to archive this purpose. class Post{ //... public function asArray(): array { return [ &#39;id&#39; =&gt; $this-&gt;id, &#39;title&#39; =&gt; $this-&gt;title, &#39;content&#39; =&gt; $this-&gt;content ]; }} Run the application, use curl to test the /posts endpoint. # curl http://localhost:8000/posts Symfony provides a simple AbstractController which includes several functions to simplfy the response and adopt the container and dependency injection management. In the above controller, extends from AbstractController, simply call $this-&gt;json to render the response in JSON format, no need to transform the data to an array before rendering response. class PostController extends AbstractController{ function all(): Response { //... return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]); }} Connecting to Database Doctrine is a popular ORM framework , it is highly inspired by the existing Java ORM tooling, such as JPA spec and Hibernate framework. There are two core components in Doctrine, doctrine/dbal and doctrine/orm, the former is a low level APIs for database operations, if you know Java development, consider it as the Jdbc layer. The later is the advanced ORM framework, the public APIs are similar to JPA/Hibernate. Install Doctrine into the project. # composer require symfony/orm-pack# composer require --dev symfony/maker-bundle The pack is a virtual Symfony package, it will install a series of packages and basic configurations. Open the .env file in the project root folder, edit the DATABASE_URL value, setup the database name, username, password to connect. DATABASE_URL=&quot;postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;charset=utf8&quot; Use the following command to generate a docker compose file template. # php bin/console make:docker:database We change it to the following to start up a Postgres database in development. version: &quot;3.5&quot; # specify docker-compose version, v3.5 is compatible with docker 17.12.0+ # Define the services/containers to be runservices: postgres: image: postgres:${POSTGRES_VERSION:-13}-alpine ports: - &quot;5432:5432&quot; environment: POSTGRES_DB: ${POSTGRES_DB:-blogdb} # You should definitely change the password in production POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password} POSTGRES_USER: ${POSTGRES_USER:-user} volumes: - ./data/blogdb:/var/lib/postgresql/data:rw - ./pg-initdb.d:/docker-entrypoint-initdb.d We will use UUID as data type of the primary key, add a script to enable uuid-ossp extension in Postgres when it is starting up. -- file: pg-initdb.d/ini.sqlSET search_path TO public;DROP EXTENSION IF EXISTS &quot;uuid-ossp&quot;;CREATE EXTENSION &quot;uuid-ossp&quot; SCHEMA public; Open config/packages/test/doctrine.yaml, comment out dbname_suffix line. We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production. Now startup the application and make sure there is no exception in the console, that means the database connection is successful. symfony server:start Before starting the application, make sure the database is running. Run the following command to start up the Postgres in Docker. # docker compose up postgres# docker ps -a # to list all containers and make the postgres is running Building Data Models Now we will build the Entities that will be used in the next sections. We are modeling a simple blog system, it includes the following concepts. A Post presents an article post in the blog system.A Comment presents the comments under a specific post.The common Tag can be applied on different posts, which categorizes posts by topic, categories , etc. You can draft your model relations in mind or through some graphic data modeling tools. Post and comments is a one-to-many relationPost and tag is a many-to-many relation It is easy to convert the idea to real codes via Doctrine Entity. Run the following command to create Post, Comment and Tag entities. In the Doctrine ORM 2.10.x and Dbal 3.x, the UUID type ID generator is deprecated. We will switch to the Uuid form symfony\\uid. Install symfony\\uid firstly. # composer require symfony/uid Simply, you can use the following command to create entities quickly. # php bin/console make:entity # following the interactive steps to create them one by one. Finally we got three entities in the src/Entity folder. Modify them as you expected. // src/Entity/Post.php#[Entity(repositoryClass: PostRepository::class)]class Post{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;) //#[Column(type: &quot;string&quot;, unique: true)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private string $title; #[Column(type: &quot;string&quot;, length: 255)] private string $content; #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $createdAt = null; #[Column(name: &quot;published_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $publishedAt = null; #[OneToMany(mappedBy: &quot;post&quot;, targetEntity: Comment::class, cascade: [&#39;persist&#39;, &#39;merge&#39;, &quot;remove&quot;], fetch: &#39;LAZY&#39;, orphanRemoval: true)] private Collection $comments; #[ManyToMany(targetEntity: Tag::class, mappedBy: &quot;posts&quot;, cascade: [&#39;persist&#39;, &#39;merge&#39;], fetch: &#39;EAGER&#39;)] private Collection $tags; public function __construct() { $this-&gt;createdAt = new DateTime(); $this-&gt;comments = new ArrayCollection(); $this-&gt;tags = new ArrayCollection(); } //other getters and setters} // src/Entity/Comment.php#[Entity(repositoryClass: CommentRepository::class)]class Comment{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private string $content; #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)] private DateTime|null $createdAt = null; #[ManyToOne(targetEntity: &quot;Post&quot;, inversedBy: &quot;comments&quot;)] #[JoinColumn(name: &quot;post_id&quot;, referencedColumnName: &quot;id&quot;)] private Post $post; public function __construct() { $this-&gt;createdAt = new DateTime(); } //other getters and setters} //src/Entity/Tag.php#[Entity(repositoryClass: TagRepository::class)]class Tag{ #[Id] //#[GeneratedValue(strategy: &quot;UUID&quot;) //#[Column(type: &quot;string&quot;, unique: true)] #[Column(type: &quot;uuid&quot;, unique: true)] #[GeneratedValue(strategy: &quot;CUSTOM&quot;)] #[CustomIdGenerator(class: UuidGenerator::class)] private ?Uuid $id = null; #[Column(type: &quot;string&quot;, length: 255)] private ?string $name; #[ManyToMany(targetEntity: Post::class, inversedBy: &quot;tags&quot;)] private Collection $posts; public function __construct() { $this-&gt;posts = new ArrayCollection(); }} At the same time, it generated three Repository classes for these entities. // src/Repository/PostRepsoitory.phpclass PostRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Post::class); }} // src/Repository/CommentRepsoitory.phpclass CommentRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Comment::class); }} //src/Repository/TagRepository.phpclass TagRepository extends ServiceEntityRepository{ public function __construct(ManagerRegistry $registry) { parent::__construct($registry, Tag::class); }} You can use Doctrine migration to generate a Migration file to maintain database schema in a production environment. Run the following command to generate a Migration file. # php bin/console make:migration After it is executed, a Migration file is generated in the migrations folder, its naming is like Version20211104031420. It is a simple class extended AbstractMigration, the up function is use for upgrade to this version and down function is use for downgrade to the previous version. To apply Migrations on database automaticially. # php bin/console doctrine:migrations:migrate # return to prev version# php bin/console doctrine:migrations:migrate prev # migrate to next# php bin/console doctrine:migrations:migrate next # These alias are defined : first, latest, prev, current and next # certain version fully qualified class name# php bin/console doctrine:migrations:migrate FQCN Doctrine bundle also includes some command to maintain database and schema. eg. # php bin/console doctrine:database:create# php bin/console doctrine:database:drop // schema create, drop, update and validate# php bin/console doctrine:schema:create# php bin/console doctrine:schema:drop# php bin/console doctrine:schema:update# php bin/console doctrine:schema:validate Adding Sample Data Create a custom command to load some sample data. # php bin/console make:command add-post It will generate a AddPostCommand under src/Command folder. #[AsCommand( name: &#39;app:add-post&#39;, description: &#39;Add a short description for your command&#39;,)]class AddPostCommand extends Command{ public function __construct(private EntityManagerInterface $manager) { parent::__construct(); } protected function configure(): void { $this -&gt;addArgument(&#39;title&#39;, InputArgument::REQUIRED, &#39;Title of a post&#39;) -&gt;addArgument(&#39;content&#39;, InputArgument::REQUIRED, &#39;Content of a post&#39;) //-&gt;addOption(&#39;option1&#39;, null, InputOption::VALUE_NONE, &#39;Option description&#39;) ; } protected function execute(InputInterface $input, OutputInterface $output): int { $io = new SymfonyStyle($input, $output); $title = $input-&gt;getArgument(&#39;title&#39;); if ($title) { $io-&gt;note(sprintf(&#39;Title: %s&#39;, $title)); } $content = $input-&gt;getArgument(&#39;content&#39;); if ($content) { $io-&gt;note(sprintf(&#39;Content: %s&#39;, $content)); } $entity = PostFactory::create($title, $content); $this -&gt;manager-&gt;persist($entity); $this -&gt;manager-&gt;flush(); // if ($input-&gt;getOption(&#39;option1&#39;)) {// // ...// } $io-&gt;success(&#39;Post is saved: &#39;.$entity); return Command::SUCCESS; }} The Doctrine EntityManagerInterface is managed by Symfony Service Container, and use for data persistence operations. Run the following command to add a post into the database. # php bin/console app:add-post &quot;test title&quot; &quot;test content&quot; ! [NOTE] Title: test title ! [NOTE] Content: test content [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=] Testing Repository PHPUnit is the most popular testing framework in PHP world, Symfony integrates PHPUnit tightly. Run the following command to install PHPUnit and Symfony test-pack. The test-pack will install all essential packages for testing Symfony components and add PHPUnit configuration, such as phpunit.xml.dist. # composer require --dev phpunit/phpunit symfony/test-pack An simple test example written in pure PHPUnit. class PostTest extends TestCase{ public function testPost() { $p = PostFactory::create(&quot;tests title&quot;, &quot;tests content&quot;); $this-&gt;assertEquals(&quot;tests title&quot;, $p-&gt;getTitle()); $this-&gt;assertEquals(&quot;tests content&quot;, $p-&gt;getContent()); $this-&gt;assertNotNull( $p-&gt;getCreatedAt()); }} Symfony provides some specific base classes(KernelTestCase, WebTestCase, etc.) to simplfy the testing work in a Symfony project. The following is an example of testing a Repository - PostRepository. The KernelTestCase contains facilities to bootstrap application kernel and provides service container. class PostRepositoryTest extends KernelTestCase{ private EntityManagerInterface $entityManager; private PostRepository $postRepository; protected function setUp(): void { //(1) boot the Symfony kernel $kernel = self::bootKernel(); $this-&gt;assertSame(&#39;test&#39;, $kernel-&gt;getEnvironment()); $this-&gt;entityManager = $kernel-&gt;getContainer() -&gt;get(&#39;doctrine&#39;) -&gt;getManager(); //(2) use static::getContainer() to access the service container $container = static::getContainer(); //(3) get PostRepository from container. $this-&gt;postRepository = $container-&gt;get(PostRepository::class); } protected function tearDown(): void { parent::tearDown(); $this-&gt;entityManager-&gt;close(); } public function testCreatePost(): void { $entity = PostFactory::create(&quot;test post&quot;, &quot;test content&quot;); $this-&gt;entityManager-&gt;persist($entity); $this-&gt;entityManager-&gt;flush(); $this-&gt;assertNotNull($entity-&gt;getId()); $byId = $this-&gt;postRepository-&gt;findOneBy([&quot;id&quot; =&gt; $entity-&gt;getId()]); $this-&gt;assertEquals(&quot;test post&quot;, $byId-&gt;getTitle()); $this-&gt;assertEquals(&quot;test content&quot;, $byId-&gt;getContent()); } } In the above codes, in the setUp function, boot up the application kernel, after it is booted, a test scoped Service Container is available. Then get EntityManagerInterface and PostRepository from service container. In the testCreatePost function, persists a Post entity, and find this post by id and verify the title and content fields. Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes are similar to the legacy JUnit 4 code style. Creating PostController: Exposing your first Rest API Similar to other MVC framework, we can expose RESTful APIs via Symfony Controller component. Follow the REST convention, we are planning to create the following APIs to a blog system. GET /posts Get all posts.GET /posts/{id} Get a single post by ID, if not found, return status 404POST /posts Create a new post from request body, add the new post URI to response header Location, and return status 201DELETE /posts/{id} Delete a single post by ID, return status 204. If the post was not found, return status 404 instead.… Run the following command to create a Controller skeleton. Follow the interactive guide to create a controller named PostController. # php bin/console make:constroller Open src/Controller/PostController.php in IDE. Add Route attribute on class level and two functions: one for fetching all posts and another for getting single post by ID. #[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]class PostController extends AbstractController{ public function __construct(private PostRepository $posts) { } #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(): Response { $data = $this-&gt;posts-&gt;findAll(); return $this-&gt;json($data); } } Start up the application, and try to access the http://localhost:8000/posts, it will throw a circular dependencies exception when rendering the models in JSON view directly. There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view. Add a Ignore attribute on Comment.post and Tag.posts. //src/Entity/Comment.phpclass Comment{ #[Ignore] private Post $post;} //src/Entity/Tag.phpclass Tag{ #[Ignore] private Collection $posts;} Testing Controller As described in the previous sections, to test Controller/API, create a test class to extend WebTestCase, which provides a plenty of facilities to handle request and assert response. Run the following command to create a test skeleton. # php bin/console make:test Follow the interactive steps to create a test base on WebTestCase. class PostControllerTest extends WebTestCase{ public function testGetAllPosts(): void { $client = static::createClient(); $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts&#39;); $this-&gt;assertResponseIsSuccessful(); // $response = $client-&gt;getResponse(); $data = $response-&gt;getContent(); //dump($data); $this-&gt;assertStringContainsString(&quot;Symfony and PHP&quot;, $data); } } If you try to run the test, it will fail. At the moment, there is no any data for testing. Preparing Data for Testing Purpose The doctrine/doctrine-fixtures-bundle is use for populate sample data for testing purpose, and dama/doctrine-test-bundle ensures the data is restored before evey test is running. Install doctrine/doctrine-fixtures-bundle and dama/doctrine-test-bundle. composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundle Create a new Fixture. # php bin/console make:fixtures In the load fucntion, persist some data for tests. class AppFixtures extends Fixture{ public function load(ObjectManager $manager): void { $data = PostFactory::create(&quot;Building Restful APIs with Symfony and PHP 8&quot;, &quot;test content&quot;); $data-&gt;addTag(Tag::of( &quot;Symfony&quot;)) -&gt;addTag( Tag::of(&quot;PHP 8&quot;)) -&gt;addComment(Comment::of(&quot;test comment 1&quot;)) -&gt;addComment(Comment::of(&quot;test comment 2&quot;)); $manager-&gt;persist($data); $manager-&gt;flush(); }} Run the command to load the sample data into database manually. # php bin/console doctrine:fixtures:load Add the following extension configuration into the phpunit.xml.dist, thus the data will be purged and recreated for every test running. &lt;extensions&gt; &lt;extension class=&quot;DAMA\\DoctrineTestBundle\\PHPUnit\\PHPUnitExtension&quot;/&gt;&lt;/extensions&gt; Run the following command to execute PostControllerTest.php . # php .\\vendor\\bin\\phpunit .\\tests\\Controller\\PostControllerTest.php Paginating Result There are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a keyword provided by request to match Post title or content fields, a offset to set the offset position of the pagination, and a limit to set the limited size of the elements per page. Create a function in the PostRepository, accepts a keyword, offset and limit as arguments. public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page{ $query = $this-&gt;createQueryBuilder(&quot;p&quot;) -&gt;andWhere(&quot;p.title like :q or p.content like :q&quot;) -&gt;setParameter(&#39;q&#39;, &quot;%&quot; . $q . &quot;%&quot;) -&gt;orderBy(&#39;p.createdAt&#39;, &#39;DESC&#39;) -&gt;setMaxResults($limit) -&gt;setFirstResult($offset) -&gt;getQuery(); $paginator = new Paginator($query, $fetchJoinCollection = false); $c = count($paginator); $content = new ArrayCollection(); foreach ($paginator as $post) { $content-&gt;add(PostSummaryDto::of($post-&gt;getId(), $post-&gt;getTitle())); } return Page::of ($content, $c, $offset, $limit);} Firstly, create a dynamic query using createQueryBuilder , then create a Doctrine Paginator instance to execute the query. The Paginator implements Countable interface, use count to get the count of total elements. Finally, we use a custom Page object to wrap the result. class Page{ private Collection $content; private int $totalElements; private int $offset; private int $limit; #[Pure] public function __construct() { $this-&gt;content = new ArrayCollection(); } public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page { $page = new Page(); $page-&gt;setContent($content) -&gt;setTotalElements($totalElements) -&gt;setOffset($offset) -&gt;setLimit($limit); return $page; } // //getters } Customzing ArgumentResolver In the PostController , let&#39;s improve the the function which serves the route /posts, make it accept query parameters like /posts?q=Symfony&amp;offset=0&amp;limit=10, and ensure the parameters are optional. #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])] function all(Request $req): Response { $keyword = $req-&gt;query-&gt;get(&#39;q&#39;)??&#39;&#39;; $offset = $req-&gt;query-&gt;get(&#39;offset&#39;)??0; $limit = $req-&gt;query-&gt;get(&#39;limit&#39;)??10; $data = $this-&gt;posts-&gt;findByKeyword($keyword, $offset, $limit); return $this-&gt;json($data); } It works but the query parameters handling looks a little ugly. It is great if they can be handled as the route path parameters. We can create a custom ArgumentResolver to resolve the bound query arguments. Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this ArgumentResolver. #[Attribute(Attribute::TARGET_PARAMETER)]final class QueryParam{ private null|string $name; private bool $required; /** * @param string|null $name * @param bool $required */ public function __construct(?string $name = null, bool $required = false) { $this-&gt;name = $name; $this-&gt;required = $required; } //getters and setters } Create a custom ArgumentResolver implements the built-in ArgugmentResolverInterface. class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct() { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $argumentName = $argument-&gt;getName(); $this-&gt;logger-&gt;info(&quot;Found [QueryParam] annotation/attribute on argument &#39;&quot; . $argumentName . &quot;&#39;, applying [QueryParamValueResolver]&quot;); $type = $argument-&gt;getType(); $nullable = $argument-&gt;isNullable(); $this-&gt;logger-&gt;debug(&quot;The method argument type: &#39;&quot; . $type . &quot;&#39; and nullable: &#39;&quot; . $nullable . &quot;&#39;&quot;); //read name property from QueryParam $attr = $argument-&gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable $this-&gt;logger-&gt;debug(&quot;QueryParam:&quot; . $attr); //if name property is not set in `QueryParam`, use the argument name instead. $name = $attr-&gt;getName() ?? $argumentName; $required = $attr-&gt;isRequired() ?? false; $this-&gt;logger-&gt;debug(&quot;Polished QueryParam values: name=&#39;&quot; . $name . &quot;&#39;, required=&#39;&quot; . $required . &quot;&#39;&quot;); //fetch query name from request $value = $request-&gt;query-&gt;get($name); $this-&gt;logger-&gt;debug(&quot;The request query parameter value: &#39;&quot; . $value . &quot;&#39;&quot;); //if default value is set and query param value is not set, use default value instead. if (!$value &amp;&amp; $argument-&gt;hasDefaultValue()) { $value = $argument-&gt;getDefaultValue(); $this-&gt;logger-&gt;debug(&quot;After set default value: &#39;&quot; . $value . &quot;&#39;&quot;); } if ($required &amp;&amp; !$value) { throw new \\InvalidArgumentException(&quot;Request query parameter &#39;&quot; . $name . &quot;&#39; is required, but not set.&quot;); } $this-&gt;logger-&gt;debug(&quot;final resolved value: &#39;&quot; . $value . &quot;&#39;&quot;); //must return a `yield` clause yield match ($type) { &#39;int&#39; =&gt; $value ? (int)$value : 0, &#39;float&#39; =&gt; $value ? (float)$value : .0, &#39;bool&#39; =&gt; (bool)$value, &#39;string&#39; =&gt; $value ? (string)$value : ($nullable ? null : &#39;&#39;), null =&gt; null }; } public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&gt;getAttributes(QueryParam::class); return count($attrs) &gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; }} At runtime, it calls the supports function to check it the current request satisfy the requirement, if it is ok, then invoke the resovle funtion. In the supports function, we check if the argument is annotated with a QueryParam, if it is existed, then resolved the argument from request query string. Now change the function that serves /posts endpoint to the following. #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]function all(#[QueryParam] $keyword, #[QueryParam] int $offset = 0, #[QueryParam] int $limit = 20): Response { $data = $this-&gt;posts-&gt;findByKeyword($keyword || &#39;&#39;, $offset, $limit); return $this-&gt;json($data); } Run the application and test the /posts using curl. # curl http://localhost:8000/posts{ &quot;content&quot;:[ { &quot;id&quot;:&quot;1ec3e1e0-17b3-6ed2-a01c-edecc112b436&quot;, &quot;title&quot;:&quot;Building Restful APIs with Symfony and PHP 8&quot; } ], &quot;totalElements&quot;:1, &quot;offset&quot;:0, &quot;limit&quot;:20} Get Post by ID Follow the design in the previous section, add another function to PostController to map route /posts/{id} . class PostController extends AbstractController{ //other functions... #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])] function getById(Uuid $id): Response { $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]); if ($data) { return $this-&gt;json($data); } else { return $this-&gt;json([&quot;error&quot; =&gt; &quot;Post was not found by id:&quot; . $id], 404); } }} Run the application, and try to access http://localhost:8000/posts/{id}, it will throw an exception like this. App\\Controller\\PostController::getById(): Argument #1 ($id) must be of type Symfony\\Component\\Uid\\Uuid, string given, called in D:\\hantsylabs\\symfony5-sample\\rest-sample\\vendor\\symfony\\http-kernel\\HttpKernel.php on line 156 The id in the URI is a string, can not be used as Uuid directly. Symfony provides ParamConverter to convert the request attributes to the target type. We can create a custom ParamConverter to archive the purpose. Customizing ParamConverter Create a new class UuidParamCovnerter under src/Request/ folder. class UuidParamConverter implements ParamConverterInterface{ public function __construct(private LoggerInterface $logger) { } /** * @inheritDoc */ public function apply(Request $request, ParamConverter $configuration): bool { $param = $configuration-&gt;getName(); if (!$request-&gt;attributes-&gt;has($param)) { return false; } $value = $request-&gt;attributes-&gt;get($param); $this-&gt;logger-&gt;info(&quot;parameter value:&quot; . $value); if (!$value &amp;&amp; $configuration-&gt;isOptional()) { $request-&gt;attributes-&gt;set($param, null); return true; } $data = Uuid::fromString($value); $request-&gt;attributes-&gt;set($param, $data); return true; } /** * @inheritDoc */ public function supports(ParamConverter $configuration): bool { $className = $configuration-&gt;getClass(); $this-&gt;logger-&gt;info(&quot;converting to UUID :{c}&quot;, [&quot;c&quot; =&gt; $className]); return $className &amp;&amp; $className == Uuid::class; }} In the above codes, The supports function to check the execution environment if matching the requirementsThe apply function to perform the conversion. if supports returns false, this conversion step will be skipped. Creating a Post Follow the REST convention, define the following rule to serve an endpoint to handle the request. Request matches Http verbs/HTTP Method: POSTRequest matches route endpoint: /postsSet request header Content-Type value to application/json, and use request body to hold request data as JSON formatIf successful, return a CREATED(201) Http Status code, and set the response header Location value to the URI of the new created post. #[Route(path: &quot;&quot;, name: &quot;create&quot;, methods: [&quot;POST&quot;])]public function create(Request $request): Response{ $data = $this-&gt;serializer-&gt;deserialize($request-&gt;getContent(), CreatePostDto::class, &#39;json&#39;); $entity = PostFactory::create($data-&gt;getTitle(), $data-&gt;getContent()); $this-&gt;posts-&gt;getEntityManager()-&gt;persist($entity); return $this-&gt;json([], 201, [&quot;Location&quot; =&gt; &quot;/posts/&quot; . $entity-&gt;getId()]);} The posts-&gt;getEntityManager() overrides parent methods to get a EntityManager from parent class, you can also inject ObjectManager or EntityManagerInterface in the PostController directly to do the persistence work. The Doctrine Repository is mainly designated to build query criteria and execute custom queries. Create a test function to verify in the PostControllerTest file. public function testCreatePost(): void{ $client = static::createClient(); $data = CreatePostDto::of(&quot;test title&quot;, &quot;test content&quot;); $crawler = $client-&gt;request( &#39;POST&#39;, &#39;/posts&#39;, [], [], [], $this-&gt;getContainer()-&gt;get(&#39;serializer&#39;)-&gt;serialize($data, &#39;json&#39;) ); $this-&gt;assertResponseIsSuccessful(); $response = $client-&gt;getResponse(); $url = $response-&gt;headers-&gt;get(&#39;Location&#39;); //dump($data); $this-&gt;assertNotNull($url); $this-&gt;assertStringStartsWith(&quot;/posts/&quot;, $url);} Converting Request Body We can also use an Annotation/Attribute to erase the raw codes of handling Request object through introducing a custom ArgumentResolver. Create a Body Attribute. #[Attribute(Attribute::TARGET_PARAMETER)]final class Body{} Then create a BodyValueResolver. class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface{ public function __construct(private SerializerInterface $serializer) { } private LoggerInterface $logger; /** * @inheritDoc */ public function resolve(Request $request, ArgumentMetadata $argument) { $type = $argument-&gt;getType(); $this-&gt;logger-&gt;debug(&quot;The argument type:&#39;&quot; . $type . &quot;&#39;&quot;); $format = $request-&gt;getContentType() ?? &#39;json&#39;; $this-&gt;logger-&gt;debug(&quot;The request format:&#39;&quot; . $format . &quot;&#39;&quot;); //read request body $content = $request-&gt;getContent(); $data = $this-&gt;serializer-&gt;deserialize($content, $type, $format); // $this-&gt;logger-&gt;debug(&quot;deserialized data:{0}&quot;, [$data]); yield $data; } /** * @inheritDoc */ public function supports(Request $request, ArgumentMetadata $argument): bool { $attrs = $argument-&gt;getAttributes(Body::class); return count($attrs) &gt; 0; } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; } In the supports method, it simply detects if the method argument annotated with a Body attribute, then apply resolve method to deserialize the request body content to a typed object. Run the application and test the endpoint through /posts. curl -v http://localhost:8000/posts -H &quot;Content-Type:application/json&quot; -d &quot;{\\&quot;title\\&quot;:\\&quot;test title\\&quot;,\\&quot;content\\&quot;:\\&quot;test content\\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8000&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 47&gt;&lt; HTTP/1.1 201 Created&lt; Cache-Control: no-cache, private&lt; Content-Type: application/json&lt; Date: Sun, 21 Nov 2021 08:42:49 GMT&lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e&lt; X-Powered-By: PHP/8.0.10&lt; X-Robots-Tag: noindex&lt; Content-Length: 2&lt;[] Exception Handling Symfony kernel provides a event machoism to raise an Exception in Controller class and handle them in your custom EventListener or EventSubscriber . For example, create a PostNotFoundException. class PostNotFoundException extends \\RuntimeException{ public function __construct(Uuid $uuid) { parent::__construct(&quot;Post #&quot; . $uuid . &quot; was not found&quot;); } } Create a EventListener to catch this exception, and handle the exception as expected. class ExceptionListener implements LoggerAwareInterface{ private LoggerInterface $logger; public function __construct() { } public function onKernelException(ExceptionEvent $event) { // You get the exception object from the received event $exception = $event-&gt;getThrowable(); $data = [&quot;error&quot; =&gt; $exception-&gt;getMessage()]; // Customize your response object to display the exception details $response = new JsonResponse($data); // HttpExceptionInterface is a special type of exception that // holds status code and header details if ($exception instanceof PostNotFoundException) { $response-&gt;setStatusCode(Response::HTTP_NOT_FOUND); } else if ($exception instanceof HttpExceptionInterface) { $response-&gt;setStatusCode($exception-&gt;getStatusCode()); $response-&gt;headers-&gt;replace($exception-&gt;getHeaders()); } else { $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR); } // sends the modified response object to the event $event-&gt;setResponse($response); } public function setLogger(LoggerInterface $logger) { $this-&gt;logger = $logger; }} Register this ExceptionListener in config/service.yml file. App\\EventListener\\ExceptionListener: tags: - { name: kernel.event_listener, event: kernel.exception, priority: 50 } It indicates it binds event.exception event to ExceptionListener, and set priority to set the order at execution time. Run the following command to show all registered EventListener/EventSubscribers on event kernel.exception. php bin/console debug:event-subscriber kernel.exception Change the getById function to the following. #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])]function getById(Uuid $id): Response{ $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]); if ($data) { return $this-&gt;json($data); } else { throw new PostNotFoundException($id); }} Add a test to verify if the post is not found and get a 404 status code. public function testGetANoneExistingPost(): void{ $client = static::createClient(); $id = Uuid::v4(); $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts/&#39; . $id); // $response = $client-&gt;getResponse(); $this-&gt;assertResponseStatusCodeSame(404); $data = $response-&gt;getContent(); $this-&gt;assertStringContainsString(&quot;Post #&quot; . $id . &quot; was not found&quot;, $data);} Run the application again, and try to access a single Post through a none existing id. curl http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 -H &quot;Accept: application/json&quot; -v&gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1&gt; Host: localhost:8000&gt; User-Agent: curl/7.55.1&gt; Accept: application/json&gt;&lt; HTTP/1.1 404 Not Found&lt; Cache-Control: no-cache, private&lt; Content-Type: application/json&lt; Date: Mon, 22 Nov 2021 03:57:51 GMT&lt; X-Powered-By: PHP/8.0.10&lt; X-Robots-Tag: noindex&lt; Content-Length: 69&lt;{&quot;error&quot;:&quot;Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.&quot;} Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Restful APIs with Symfony 5 and PHP 8 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building Restful APIs with Symfony 5 and PHP 8","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-restful-apis-with-symfony-5-and-php-8/"},"url":"/blog/2021/building-restful-apis-with-symfony-5-and-php-8/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building Restful APIs with Symfony 5 and PHP 8</h1>
    <p class="post-meta">November 22, 2021</p>
  </header>

  <article class="post-content">
    <p>Symfony is a full-featured modularized PHP framework that is used for building all kinds of applications, from traditional web applications to small Microservice components.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7zVWP_mRMsd2gPIrKrxrNA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@kakachen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">te chan</a> on <a href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h3>Get your feet wet</h3><p>Install PHP 8 and PHP Composer tools.</p><pre># choco php composer</pre><p>Install [Symfony CLI](symfony check:requirements), check the system requirements.</p><pre># symfony check:requirements</pre><pre>Symfony Requirements Checker<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~</pre><pre>&gt; PHP is using the following php.ini file:<br>C:\tools\php80\php.ini</pre><pre>&gt; Checking Symfony requirements:</pre><pre>....................WWW.........</pre><pre>                                              <br> [OK]                                         <br> Your system is ready to run Symfony projects <br>                                              </pre><pre>Optional recommendations to improve your setup<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</pre><pre> * intl extension should be available<br>   &gt; Install and enable the intl extension (used for validators).</pre><pre> * a PHP accelerator should be installed<br>   &gt; Install and/or enable a PHP accelerator (highly recommended).</pre><pre> * realpath_cache_size should be at least 5M in php.ini<br>   &gt; Setting &quot;realpath_cache_size&quot; to e.g. &quot;5242880&quot; or &quot;5M&quot; in<br>   &gt; php.ini* may improve performance on Windows significantly in some<br>   &gt; cases.<br></pre><pre>Note  The command console can use a different php.ini file<br>~~~~  than the one used by your web server.<br>      Please check that both the console and the web server<br>      are using the same PHP version and configuration.</pre><p>According to the <em>recommendations</em> info, adjust your PHP configuration in the <em>php.ini</em>. And we will use Postgres as database in the sample application, make sure pdo_pgsql and pgsql modules are enabled.</p><p>Finally, you can confirm the enabled modules by the following command.</p><pre># php -m</pre><p>Create a new Symfony project.</p><pre># symfony new rest-sample</pre><pre>// a classic website application<br># symfony new web-sample --full</pre><p>By default, it will create a simple Symfony skeleton project only with core kernel configuration, which is good to start a lightweight Restful API application.</p><p>Alternatively, you can create it using Composer.</p><pre># composer create-project symfony/skeleton rest-sample</pre><pre>//start a classic website application<br># composer create-project symfony/website-skeleton web-sample</pre><p>Enter the generated project root folder, start the application.</p><pre># symfony server:start</pre><pre> [WARNING] run &quot;symfony.exe server:ca:install&quot; first if you want to run the web server with TLS support, or use &quot;--no-  <br> tls&quot; to avoid this warning                                                                                             <br>                                                                                                                       <br>Tailing PHP-CGI log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158\79ca75f9e90b4126a5955a33ea6a41ec5e854698.log)<br>Tailing Web Server log file (C:\Users\hantsy\.symfony\log\499d60b14521d4842ba7ebfce0861130efe66158.log)<br>                                                                                                                        <br> [OK] Web server listening                                                                                              <br>      The Web server is using PHP CGI 8.0.10                                                                            <br>      <a href="http://127.0.0.1:8000">http://127.0.0.1:8000</a>                                                                                             <br>                                                                                                                        </pre><pre>[Web Server ] Oct  4 13:33:01 |DEBUG  | PHP    Reloading PHP versions<br>[Web Server ] Oct  4 13:33:01 |DEBUG  | PHP    Using PHP version 8.0.10 (from default version in $PATH)<br>[Web Server ] Oct  4 13:33:01 |INFO   | PHP    listening path=&quot;C:\\tools\\php80\\php-cgi.exe&quot; php=&quot;8.0.10&quot; port=61738</pre><h3>Hello , Symfony</h3><p>Create a simple class to a resource entity in the HTTP response.</p><pre>class Post<br>{<br>    private ?string $id = null;</pre><pre>    private string $title;</pre><pre>    private string $content;<br>    <br>    //getters and setters.<br>}</pre><p>And use a factory to create a new Post instance.</p><pre>class PostFactory<br>{<br>    public static function create(string $title, string $content): Post<br>    {<br>        $post = new Post();<br>        $post-&gt;setTitle($title);<br>        $post-&gt;setContent($content);<br>        return $post;<br>    }<br>}</pre><p>Let’s create a simple Controller class.</p><p>To use the newest PHP 8 attributes to configure the routing rules, apply the following changes in the project configurations.</p><ul><li>Open <em>config/packages/doctrine.yaml</em>, remove doctrine/orm/mapping/App/type or change its value to attribute</li><li>Open <em>composer.json</em>, change PHP version to &gt;=8.0.0.</li></ul><p>To render the response body into a JSON string, use a JsonReponse to wrap the response.</p><pre>#[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]<br>class PostController<br>{</pre><pre>    #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]<br>    function all(): Response<br>    {<br>        $post1 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;);<br>        $post1-&gt;setId(&quot;1&quot;);</pre><pre>        $post2 = PostFactory::create(&quot;test title&quot;, &quot;test content&quot;);<br>        $post2-&gt;setId(&quot;2&quot;);<br>        $data = [$post1-&gt;asArray(), $post2-&gt;asArray()];<br>        return new JsonResponse($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]);<br>        //return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]);<br>    }<br>}</pre><p>The first parameter of JsonReponse accepts an array as data, so add a function in the Post class to archive this purpose.</p><pre>class Post{<br>    //...<br>    public function asArray(): array<br>    {<br>        return [<br>            &#39;id&#39; =&gt; $this-&gt;id,<br>            &#39;title&#39; =&gt; $this-&gt;title,<br>            &#39;content&#39; =&gt; $this-&gt;content<br>        ];<br>    }<br>}</pre><p>Run the application, use curl to test the /posts endpoint.</p><pre># curl <a href="http://localhost:8000/posts">http://localhost:8000/posts</a></pre><p>Symfony provides a simple AbstractController which includes several functions to simplfy the response and adopt the container and dependency injection management.</p><p>In the above controller, extends from AbstractController, simply call $this-&gt;json to render the response in JSON format, no need to transform the data to an array before rendering response.</p><pre>class PostController extends AbstractController<br>{</pre><pre>    function all(): Response<br>    {<br>        //...<br>        return $this-&gt;json($data, 200, [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;]);<br>    }<br>}</pre><h3>Connecting to Database</h3><p>Doctrine is a popular ORM framework , it is highly inspired by the existing Java ORM tooling, such as JPA spec and Hibernate framework. There are two core components in Doctrine, doctrine/dbal and doctrine/orm, the former is a low level APIs for database operations, if you know Java development, consider it as the <em>Jdbc</em> layer. The later is the advanced ORM framework, the public APIs are similar to JPA/Hibernate.</p><p>Install Doctrine into the project.</p><pre># composer require symfony/orm-pack<br># composer require --dev symfony/maker-bundle</pre><p>The <strong>pack</strong> is a virtual Symfony package, it will install a series of packages and basic configurations.</p><p>Open the .env file in the project root folder, edit the DATABASE_URL value, setup the database name, username, password to connect.</p><pre>DATABASE_URL=&quot;postgresql://user:password@127.0.0.1:5432/blogdb?serverVersion=13&amp;charset=utf8&quot;</pre><p>Use the following command to generate a docker compose file template.</p><pre># php bin/console make:docker:database</pre><p>We change it to the following to start up a Postgres database in development.</p><pre>version: &quot;3.5&quot; # specify docker-compose version, v3.5 is compatible with docker 17.12.0+</pre><pre># Define the services/containers to be run<br>services:</pre><pre>  postgres:<br>    image: postgres:${POSTGRES_VERSION:-13}-alpine<br>    ports:<br>      - &quot;5432:5432&quot;<br>    environment:<br>      POSTGRES_DB: ${POSTGRES_DB:-blogdb}<br>      # You should definitely change the password in production<br>      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-password}<br>      POSTGRES_USER: ${POSTGRES_USER:-user}<br>    volumes:<br>      - ./data/blogdb:/var/lib/postgresql/data:rw<br>      - ./pg-initdb.d:/docker-entrypoint-initdb.d</pre><p>We will use UUID as data type of the primary key, add a script to enable uuid-ossp extension in Postgres when it is starting up.</p><pre>-- file: pg-initdb.d/ini.sql<br>SET search_path TO public;<br>DROP EXTENSION IF EXISTS &quot;uuid-ossp&quot;;<br>CREATE EXTENSION &quot;uuid-ossp&quot; SCHEMA public;</pre><p>Open <em>config/packages/test/doctrine.yaml</em>, comment out dbname_suffix line. We use Docker container to bootstrap a database to ensure the application behaviors are same between the development and production.</p><p>Now startup the application and make sure there is no exception in the console, that means the database connection is successful.</p><pre>symfony server:start</pre><p>Before starting the application, make sure the database is running. Run the following command to start up the Postgres in Docker.</p><pre># docker compose up postgres<br># docker ps -a # to list all containers and make the postgres is running</pre><h3>Building Data Models</h3><p>Now we will build the Entities that will be used in the next sections. We are modeling a simple blog system, it includes the following concepts.</p><ul><li>A Post presents an article post in the blog system.</li><li>A Comment presents the comments under a specific post.</li><li>The common Tag can be applied on different posts, which categorizes posts by topic, categories , etc.</li></ul><p>You can draft your model relations in mind or through some graphic data modeling tools.</p><ul><li>Post and comments is a one-to-many relation</li><li>Post and tag is a many-to-many relation</li></ul><p>It is easy to convert the idea to real codes via Doctrine Entity. Run the following command to create Post, Comment and Tag entities.</p><p>In the Doctrine ORM 2.10.x and Dbal 3.x, the UUID type ID generator is deprecated. We will switch to the Uuid form symfony\uid.</p><p>Install symfony\uid firstly.</p><pre># composer require symfony/uid</pre><p>Simply, you can use the following command to create entities quickly.</p><pre># php bin/console make:entity  # following the interactive steps to create them one by one.</pre><p>Finally we got three entities in the <em>src/Entity</em> folder. Modify them as you expected.</p><pre>// src/Entity/Post.php<br>#[Entity(repositoryClass: PostRepository::class)]<br>class Post<br>{<br>    #[Id]<br>    //#[GeneratedValue(strategy: &quot;UUID&quot;)<br>    //#[Column(type: &quot;string&quot;, unique: true)]<br>    #[Column(type: &quot;uuid&quot;, unique: true)]<br>    #[GeneratedValue(strategy: &quot;CUSTOM&quot;)]<br>    #[CustomIdGenerator(class: UuidGenerator::class)]<br>    private ?Uuid $id = null;</pre><pre>    #[Column(type: &quot;string&quot;, length: 255)]<br>    private string $title;</pre><pre>    #[Column(type: &quot;string&quot;, length: 255)]<br>    private string $content;</pre><pre>    #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)]<br>    private DateTime|null $createdAt = null;</pre><pre>    #[Column(name: &quot;published_at&quot;, type: &quot;datetime&quot;, nullable: true)]<br>    private DateTime|null $publishedAt = null;</pre><pre>    #[OneToMany(mappedBy: &quot;post&quot;, targetEntity: Comment::class, cascade: [&#39;persist&#39;, &#39;merge&#39;, &quot;remove&quot;], fetch: &#39;LAZY&#39;, orphanRemoval: true)]<br>    private Collection $comments;</pre><pre>    #[ManyToMany(targetEntity: Tag::class, mappedBy: &quot;posts&quot;, cascade: [&#39;persist&#39;, &#39;merge&#39;], fetch: &#39;EAGER&#39;)]<br>    private Collection $tags;</pre><pre>    public function __construct()<br>    {<br>        $this-&gt;createdAt = new DateTime();<br>        $this-&gt;comments = new ArrayCollection();<br>        $this-&gt;tags = new ArrayCollection();<br>    }<br>    //other getters and setters<br>}</pre><pre>// src/Entity/Comment.php<br>#[Entity(repositoryClass: CommentRepository::class)]<br>class Comment<br>{<br>    #[Id]<br>    //#[GeneratedValue(strategy: &quot;UUID&quot;)]<br>    #[Column(type: &quot;uuid&quot;, unique: true)]<br>    #[GeneratedValue(strategy: &quot;CUSTOM&quot;)]<br>    #[CustomIdGenerator(class: UuidGenerator::class)]<br>    private ?Uuid $id = null;</pre><pre>    #[Column(type: &quot;string&quot;, length: 255)]<br>    private string $content;</pre><pre>    #[Column(name: &quot;created_at&quot;, type: &quot;datetime&quot;, nullable: true)]<br>    private DateTime|null $createdAt = null;</pre><pre>    #[ManyToOne(targetEntity: &quot;Post&quot;, inversedBy: &quot;comments&quot;)]<br>    #[JoinColumn(name: &quot;post_id&quot;, referencedColumnName: &quot;id&quot;)]<br>    private Post $post;</pre><pre>    public function __construct()<br>    {<br>        $this-&gt;createdAt = new DateTime();<br>    }<br>    //other getters and setters<br>}</pre><pre>//src/Entity/Tag.php<br>#[Entity(repositoryClass: TagRepository::class)]<br>class Tag<br>{<br>    #[Id]<br>    //#[GeneratedValue(strategy: &quot;UUID&quot;)<br>    //#[Column(type: &quot;string&quot;, unique: true)]<br>    #[Column(type: &quot;uuid&quot;, unique: true)]<br>    #[GeneratedValue(strategy: &quot;CUSTOM&quot;)]<br>    #[CustomIdGenerator(class: UuidGenerator::class)]<br>    private ?Uuid $id = null;</pre><pre>    #[Column(type: &quot;string&quot;, length: 255)]<br>    private ?string $name;</pre><pre>    #[ManyToMany(targetEntity: Post::class, inversedBy: &quot;tags&quot;)]<br>    private Collection $posts;</pre><pre>    public function __construct()<br>    {<br>        $this-&gt;posts = new ArrayCollection();<br>    }<br>}</pre><p>At the same time, it generated three Repository classes for these entities.</p><pre>// src/Repository/PostRepsoitory.php<br>class PostRepository extends ServiceEntityRepository<br>{<br>    public function __construct(ManagerRegistry $registry)<br>    {<br>        parent::__construct($registry, Post::class);<br>    }<br>}</pre><pre>// src/Repository/CommentRepsoitory.php<br>class CommentRepository extends ServiceEntityRepository<br>{<br>    public function __construct(ManagerRegistry $registry)<br>    {<br>        parent::__construct($registry, Comment::class);<br>    }<br>}</pre><pre>//src/Repository/TagRepository.php<br>class TagRepository extends ServiceEntityRepository<br>{<br>    public function __construct(ManagerRegistry $registry)<br>    {<br>        parent::__construct($registry, Tag::class);<br>    }<br>}</pre><p>You can use Doctrine migration to generate a <em>Migration</em> file to maintain database schema in a production environment.</p><p>Run the following command to generate a <em>Migration</em> file.</p><pre># php bin/console make:migration</pre><p>After it is executed, a Migration file is generated in the <em>migrations</em> folder, its naming is like Version20211104031420. It is a simple class extended AbstractMigration, the up function is use for upgrade to this version and down function is use for downgrade to the previous version.</p><p>To apply Migrations on database automaticially.</p><pre># php bin/console doctrine:migrations:migrate</pre><pre># return to prev version<br># php bin/console doctrine:migrations:migrate prev</pre><pre># migrate to next<br># php bin/console doctrine:migrations:migrate next</pre><pre># These alias are defined : first, latest, prev, current and next</pre><pre># certain version fully qualified class name<br># php bin/console doctrine:migrations:migrate FQCN</pre><p>Doctrine bundle also includes some command to maintain database and schema. eg.</p><pre># php bin/console doctrine:database:create<br># php bin/console doctrine:database:drop</pre><pre>// schema create, drop, update and validate<br># php bin/console doctrine:schema:create<br># php bin/console doctrine:schema:drop<br># php bin/console doctrine:schema:update<br># php bin/console doctrine:schema:validate</pre><h3>Adding Sample Data</h3><p>Create a custom command to load some sample data.</p><pre># php bin/console make:command add-post</pre><p>It will generate a AddPostCommand under <em>src/Command</em> folder.</p><pre>#[AsCommand(<br>    name: &#39;app:add-post&#39;,<br>    description: &#39;Add a short description for your command&#39;,<br>)]<br>class AddPostCommand extends Command<br>{<br></pre><pre>    public function __construct(private EntityManagerInterface $manager)<br>    {<br>        parent::__construct();<br>    }</pre><pre>    protected function configure(): void<br>    {<br>        $this<br>            -&gt;addArgument(&#39;title&#39;, InputArgument::REQUIRED, &#39;Title of a post&#39;)<br>            -&gt;addArgument(&#39;content&#39;, InputArgument::REQUIRED, &#39;Content of a post&#39;)<br>            //-&gt;addOption(&#39;option1&#39;, null, InputOption::VALUE_NONE, &#39;Option description&#39;)<br>        ;<br>    }</pre><pre>    protected function execute(InputInterface $input, OutputInterface $output): int<br>    {<br>        $io = new SymfonyStyle($input, $output);<br>        $title = $input-&gt;getArgument(&#39;title&#39;);</pre><pre>        if ($title) {<br>            $io-&gt;note(sprintf(&#39;Title: %s&#39;, $title));<br>        }</pre><pre>        $content = $input-&gt;getArgument(&#39;content&#39;);</pre><pre>        if ($content) {<br>            $io-&gt;note(sprintf(&#39;Content: %s&#39;, $content));<br>        }</pre><pre>        $entity = PostFactory::create($title, $content);<br>        $this -&gt;manager-&gt;persist($entity);<br>        $this -&gt;manager-&gt;flush();</pre><pre>//        if ($input-&gt;getOption(&#39;option1&#39;)) {<br>//            // ...<br>//        }</pre><pre>        $io-&gt;success(&#39;Post is saved: &#39;.$entity);</pre><pre>        return Command::SUCCESS;<br>    }<br>}</pre><p>The Doctrine EntityManagerInterface is managed by Symfony <em>Service Container</em>, and use for data persistence operations.</p><p>Run the following command to add a post into the database.</p><pre># php bin/console app:add-post &quot;test title&quot; &quot;test content&quot;<br> ! [NOTE] Title: test title                                               <br> ! [NOTE] Content: test content                                                             <br> [OK] Post is saved: Post: [ id =1ec3d3ec-895d-685a-b712-955865f6c134, title=test title, content=test content, createdAt=1636010040, blishedAt=]</pre><h3>Testing Repository</h3><p><a href="https://phpunit.de">PHPUnit</a> is the most popular testing framework in PHP world, Symfony integrates PHPUnit tightly.</p><p>Run the following command to install PHPUnit and Symfony <strong>test-pack</strong>. The <strong>test-pack</strong> will install all essential packages for testing Symfony components and add PHPUnit configuration, such as <em>phpunit.xml.dist</em>.</p><pre># composer require --dev phpunit/phpunit symfony/test-pack</pre><p>An simple test example written in pure PHPUnit.</p><pre>class PostTest extends TestCase<br>{</pre><pre>    public function testPost()<br>    {<br>        $p = PostFactory::create(&quot;tests title&quot;, &quot;tests content&quot;);</pre><pre>        $this-&gt;assertEquals(&quot;tests title&quot;, $p-&gt;getTitle());<br>        $this-&gt;assertEquals(&quot;tests content&quot;, $p-&gt;getContent());<br>        $this-&gt;assertNotNull( $p-&gt;getCreatedAt());<br>    }<br>}</pre><p>Symfony provides some specific base classes(KernelTestCase, WebTestCase, etc.) to simplfy the testing work in a Symfony project.</p><p>The following is an example of testing a Repository - PostRepository. The KernelTestCase contains facilities to bootstrap application kernel and provides service container.</p><pre>class PostRepositoryTest extends KernelTestCase<br>{</pre><pre>    private EntityManagerInterface $entityManager;</pre><pre>    private PostRepository $postRepository;</pre><pre>    protected function setUp(): void<br>    {<br>        //(1) boot the Symfony kernel<br>        $kernel = self::bootKernel();<br>        $this-&gt;assertSame(&#39;test&#39;, $kernel-&gt;getEnvironment());<br>        $this-&gt;entityManager = $kernel-&gt;getContainer()<br>            -&gt;get(&#39;doctrine&#39;)<br>            -&gt;getManager();</pre><pre>        //(2) use static::getContainer() to access the service container<br>        $container = static::getContainer();</pre><pre>        //(3) get PostRepository from container.<br>        $this-&gt;postRepository = $container-&gt;get(PostRepository::class);<br>    }</pre><pre>    protected function tearDown(): void<br>    {<br>        parent::tearDown();<br>        $this-&gt;entityManager-&gt;close();<br>    }</pre><pre>    public function testCreatePost(): void<br>    {<br>        $entity = PostFactory::create(&quot;test post&quot;, &quot;test content&quot;);<br>        $this-&gt;entityManager-&gt;persist($entity);<br>        $this-&gt;entityManager-&gt;flush();<br>        $this-&gt;assertNotNull($entity-&gt;getId());</pre><pre>        $byId = $this-&gt;postRepository-&gt;findOneBy([&quot;id&quot; =&gt; $entity-&gt;getId()]);<br>        $this-&gt;assertEquals(&quot;test post&quot;, $byId-&gt;getTitle());<br>        $this-&gt;assertEquals(&quot;test content&quot;, $byId-&gt;getContent());<br>    }</pre><pre>}</pre><p>In the above codes, in the setUp function, boot up the application kernel, after it is booted, a test scoped <em>Service Container</em> is available. Then get EntityManagerInterface and PostRepository from service container.</p><p>In the testCreatePost function, persists a Post entity, and find this post by id and verify the <em>title</em> and <em>content</em> fields.</p><blockquote><em>Currently, PHPUnit does not include PHP 8 Attribute support, the testing codes are similar to the legacy JUnit 4 code style.</em></blockquote><h3>Creating PostController: Exposing your first Rest API</h3><p>Similar to other MVC framework, we can expose RESTful APIs via Symfony Controller component. Follow the REST convention, we are planning to create the following APIs to a blog system.</p><ul><li>GET /posts Get all posts.</li><li>GET /posts/{id} Get a single post by ID, if not found, return status 404</li><li>POST /posts Create a new post from request body, add the new post URI to response header Location, and return status 201</li><li>DELETE /posts/{id} Delete a single post by ID, return status 204. If the post was not found, return status 404 instead.</li><li>…</li></ul><p>Run the following command to create a Controller skeleton. Follow the interactive guide to create a controller named PostController.</p><pre># php bin/console make:constroller</pre><p>Open <em>src/Controller/PostController.php</em> in IDE.</p><p>Add Route attribute on class level and two functions: one for fetching all posts and another for getting single post by ID.</p><pre>#[Route(path: &quot;/posts&quot;, name: &quot;posts_&quot;)]<br>class PostController extends AbstractController<br>{<br>    public function __construct(private PostRepository      $posts)<br>    {<br>    }</pre><pre>    #[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]<br>    function all(): Response<br>    {<br>        $data = $this-&gt;posts-&gt;findAll();<br>        return $this-&gt;json($data);<br>    }<br>    <br>}</pre><p>Start up the application, and try to access the <a href="http://localhost:8000/posts"><em>http://localhost:8000/posts</em></a>, it will throw a circular dependencies exception when rendering the models in JSON view directly. There are some solutions to avoid this, the simplest is break the bi-direction relations before rendering the JSON view. Add a Ignore attribute on Comment.post and Tag.posts.</p><pre>//src/Entity/Comment.php<br>class Comment<br>{<br>    #[Ignore]<br>    private Post $post;<br>}</pre><pre>//src/Entity/Tag.php<br>class Tag<br>{<br>    #[Ignore]<br>    private Collection $posts;<br>}</pre><h3>Testing Controller</h3><p>As described in the previous sections, to test Controller/API, create a test class to extend WebTestCase, which provides a plenty of facilities to handle request and assert response.</p><p>Run the following command to create a test skeleton.</p><pre># php bin/console make:test</pre><p>Follow the interactive steps to create a test base on WebTestCase.</p><pre>class PostControllerTest extends WebTestCase<br>{<br>    public function testGetAllPosts(): void<br>    {<br>        $client = static::createClient();<br>        $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts&#39;);</pre><pre>        $this-&gt;assertResponseIsSuccessful();</pre><pre>        //<br>        $response = $client-&gt;getResponse();<br>        $data = $response-&gt;getContent();<br>        //dump($data);<br>        $this-&gt;assertStringContainsString(&quot;Symfony and PHP&quot;, $data);<br>    }</pre><pre>}</pre><p>If you try to run the test, it will fail. At the moment, there is no any data for testing.</p><h3>Preparing Data for Testing Purpose</h3><p>The doctrine/doctrine-fixtures-bundle is use for populate sample data for testing purpose, and dama/doctrine-test-bundle ensures the data is restored before evey test is running.</p><p>Install doctrine/doctrine-fixtures-bundle and dama/doctrine-test-bundle.</p><pre>composer require --dev doctrine/doctrine-fixtures-bundle dama/doctrine-test-bundle</pre><p>Create a new Fixture.</p><pre># php bin/console make:fixtures</pre><p>In the load fucntion, persist some data for tests.</p><pre>class AppFixtures extends Fixture<br>{<br>    public function load(ObjectManager $manager): void<br>    {<br>        $data = PostFactory::create(&quot;Building Restful APIs with Symfony and PHP 8&quot;, &quot;test content&quot;);<br>        $data-&gt;addTag(Tag::of( &quot;Symfony&quot;))<br>            -&gt;addTag( Tag::of(&quot;PHP 8&quot;))<br>            -&gt;addComment(Comment::of(&quot;test comment 1&quot;))<br>            -&gt;addComment(Comment::of(&quot;test comment 2&quot;));</pre><pre>        $manager-&gt;persist($data);<br>        $manager-&gt;flush();<br>    }<br>}</pre><p>Run the command to load the sample data into database manually.</p><pre># php bin/console doctrine:fixtures:load</pre><p>Add the following extension configuration into the phpunit.xml.dist, thus the data will be purged and recreated for every test running.</p><pre>&lt;extensions&gt;<br>    &lt;extension class=&quot;DAMA\DoctrineTestBundle\PHPUnit\PHPUnitExtension&quot;/&gt;<br>&lt;/extensions&gt;</pre><p>Run the following command to execute PostControllerTest.php .</p><pre># php .\vendor\bin\phpunit .\tests\Controller\PostControllerTest.php</pre><h3>Paginating Result</h3><p>There are a lot of web applications which provide a input field for typing keyword and paginating the search results. Assume there is a <em>keyword</em> provided by request to match Post <em>title</em> or <em>content</em> fields, a <em>offset</em> to set the offset position of the pagination, and a <em>limit</em> to set the limited size of the elements per page. Create a function in the PostRepository, accepts a <em>keyword</em>, <em>offset</em> and <em>limit</em> as arguments.</p><pre>public function findByKeyword(string $q, int $offset = 0, int $limit = 20): Page<br>{<br>    $query = $this-&gt;createQueryBuilder(&quot;p&quot;)<br>        -&gt;andWhere(&quot;p.title like :q or p.content like :q&quot;)<br>        -&gt;setParameter(&#39;q&#39;, &quot;%&quot; . $q . &quot;%&quot;)<br>        -&gt;orderBy(&#39;p.createdAt&#39;, &#39;DESC&#39;)<br>        -&gt;setMaxResults($limit)<br>        -&gt;setFirstResult($offset)<br>        -&gt;getQuery();</pre><pre>    $paginator = new Paginator($query, $fetchJoinCollection = false);<br>    $c = count($paginator);<br>    $content = new ArrayCollection();<br>    foreach ($paginator as $post) {<br>        $content-&gt;add(PostSummaryDto::of($post-&gt;getId(), $post-&gt;getTitle()));<br>    }<br>    return Page::of ($content, $c, $offset, $limit);<br>}</pre><p>Firstly, create a dynamic query using createQueryBuilder , then create a Doctrine Paginator instance to execute the query. The Paginator implements Countable interface, use count to get the count of total elements. Finally, we use a custom Page object to wrap the result.</p><pre>class Page<br>{<br>    private Collection $content;<br>    private int $totalElements;<br>    private int $offset;<br>    private int $limit;</pre><pre>    #[Pure] public function __construct()<br>    {<br>        $this-&gt;content = new ArrayCollection();<br>    }<br></pre><pre>    public static function of(Collection $content, int $totalElements, int $offset = 0, int $limit = 20): Page<br>    {<br>        $page = new Page();<br>        $page-&gt;setContent($content)<br>            -&gt;setTotalElements($totalElements)<br>            -&gt;setOffset($offset)<br>            -&gt;setLimit($limit);</pre><pre>        return $page;<br>    }<br>    <br>    //<br>    //getters</pre><pre>}</pre><h3>Customzing ArgumentResolver</h3><p>In the PostController , let&#39;s improve the the function which serves the route /posts, make it accept query parameters like <em>/posts?q=Symfony&amp;offset=0&amp;limit=10</em>, and ensure the parameters are optional.</p><pre>#[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]<br>    function all(Request $req): Response<br>    {<br>        $keyword = $req-&gt;query-&gt;get(&#39;q&#39;)??&#39;&#39;;<br>        $offset = $req-&gt;query-&gt;get(&#39;offset&#39;)??0;<br>        $limit = $req-&gt;query-&gt;get(&#39;limit&#39;)??10;<br>        <br>        $data = $this-&gt;posts-&gt;findByKeyword($keyword, $offset, $limit);<br>        return $this-&gt;json($data);<br>    }</pre><p>It works but the query parameters handling looks a little ugly. It is great if they can be handled as the route path parameters.</p><p>We can create a custom ArgumentResolver to resolve the bound query arguments.</p><p>Firstly create an Annotation/Attribute class to identify a query parameter that need to be resolved by this ArgumentResolver.</p><pre>#[Attribute(Attribute::TARGET_PARAMETER)]<br>final class QueryParam<br>{<br>    private null|string $name;<br>    private bool $required;</pre><pre>    /**<br>     * @param string|null $name<br>     * @param bool $required<br>     */<br>    public function __construct(?string $name = null, bool $required = false)<br>    {<br>        $this-&gt;name = $name;<br>        $this-&gt;required = $required;<br>    }<br>    <br>    //getters and setters<br>    <br>}</pre><p>Create a custom ArgumentResolver implements the built-in ArgugmentResolverInterface.</p><pre>class QueryParamValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface<br>{<br>    public function __construct()<br>    {<br>    }</pre><pre>    private LoggerInterface $logger;</pre><pre>    /**<br>     * @inheritDoc<br>     */<br>    public function resolve(Request $request, ArgumentMetadata $argument)<br>    {<br>        $argumentName = $argument-&gt;getName();<br>        $this-&gt;logger-&gt;info(&quot;Found [QueryParam] annotation/attribute on argument &#39;&quot; . $argumentName . &quot;&#39;, applying [QueryParamValueResolver]&quot;);<br>        $type = $argument-&gt;getType();<br>        $nullable = $argument-&gt;isNullable();<br>        $this-&gt;logger-&gt;debug(&quot;The method argument type: &#39;&quot; . $type . &quot;&#39; and nullable: &#39;&quot; . $nullable . &quot;&#39;&quot;);</pre><pre>        //read name property from QueryParam<br>        $attr = $argument-&gt;getAttributes(QueryParam::class)[0];// `QueryParam` is not repeatable<br>        $this-&gt;logger-&gt;debug(&quot;QueryParam:&quot; . $attr);<br>        //if name property is not set in `QueryParam`, use the argument name instead.<br>        $name = $attr-&gt;getName() ?? $argumentName;<br>        $required = $attr-&gt;isRequired() ?? false;<br>        $this-&gt;logger-&gt;debug(&quot;Polished QueryParam values: name=&#39;&quot; . $name . &quot;&#39;, required=&#39;&quot; . $required . &quot;&#39;&quot;);</pre><pre>        //fetch query name from request<br>        $value = $request-&gt;query-&gt;get($name);<br>        $this-&gt;logger-&gt;debug(&quot;The request query parameter value: &#39;&quot; . $value . &quot;&#39;&quot;);</pre><pre>        //if default value is set and query param value is not set, use default value instead.<br>        if (!$value &amp;&amp; $argument-&gt;hasDefaultValue()) {<br>            $value = $argument-&gt;getDefaultValue();<br>            $this-&gt;logger-&gt;debug(&quot;After set default value: &#39;&quot; . $value . &quot;&#39;&quot;);<br>        }</pre><pre>        if ($required &amp;&amp; !$value) {<br>            throw new \InvalidArgumentException(&quot;Request query parameter &#39;&quot; . $name . &quot;&#39; is required, but not set.&quot;);<br>        }</pre><pre>        $this-&gt;logger-&gt;debug(&quot;final resolved value: &#39;&quot; . $value . &quot;&#39;&quot;);<br>        <br>        //must return  a `yield` clause<br>        yield match ($type) {<br>            &#39;int&#39; =&gt; $value ? (int)$value : 0,<br>            &#39;float&#39; =&gt; $value ? (float)$value : .0,<br>            &#39;bool&#39; =&gt; (bool)$value,<br>            &#39;string&#39; =&gt; $value ? (string)$value : ($nullable ? null : &#39;&#39;),<br>            null =&gt; null<br>        };<br>    }</pre><pre>    public function supports(Request $request, ArgumentMetadata $argument): bool<br>    {<br>        $attrs = $argument-&gt;getAttributes(QueryParam::class);<br>        return count($attrs) &gt; 0;<br>    }</pre><pre>    public function setLogger(LoggerInterface $logger)<br>    {<br>        $this-&gt;logger = $logger;<br>    }<br>}</pre><p>At runtime, it calls the supports function to check it the current request satisfy the requirement, if it is ok, then invoke the resovle funtion.</p><p>In the supports function, we check if the argument is annotated with a QueryParam, if it is existed, then resolved the argument from request query string.</p><p>Now change the function that serves <em>/posts</em> endpoint to the following.</p><pre>#[Route(path: &quot;&quot;, name: &quot;all&quot;, methods: [&quot;GET&quot;])]<br>function all(#[QueryParam] $keyword,<br>    #[QueryParam] int $offset = 0,<br>    #[QueryParam] int $limit = 20): Response<br>    {<br>        $data = $this-&gt;posts-&gt;findByKeyword($keyword || &#39;&#39;, $offset, $limit);<br>        return $this-&gt;json($data);<br>    }</pre><p>Run the application and test the <em>/posts</em> using curl.</p><pre># curl <a href="http://localhost:8000/posts">http://localhost:8000/posts</a><br>{<br>    &quot;content&quot;:[<br>    	{<br>            &quot;id&quot;:&quot;1ec3e1e0-17b3-6ed2-a01c-edecc112b436&quot;,<br>            &quot;title&quot;:&quot;Building Restful APIs with Symfony and PHP 8&quot;<br>        }<br>    ],<br>    &quot;totalElements&quot;:1,<br>    &quot;offset&quot;:0,<br>    &quot;limit&quot;:20<br>}</pre><h3>Get Post by ID</h3><p>Follow the design in the previous section, add another function to PostController to map route /posts/{id} .</p><pre>class PostController extends AbstractController<br>{<br>	//other functions...</pre><pre>    #[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])]<br>    function getById(Uuid $id): Response<br>    {<br>        $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]);<br>        if ($data) {<br>            return $this-&gt;json($data);<br>        } else {<br>            return $this-&gt;json([&quot;error&quot; =&gt; &quot;Post was not found by id:&quot; . $id], 404);<br>        }<br>    }<br>}</pre><p>Run the application, and try to access <a href="http://localhost:8000/posts/%7Bid%7D"><em>http://localhost:8000/posts/{id}</em></a>, it will throw an exception like this.</p><pre>App\Controller\PostController::getById(): Argument #1 ($id) must be of type Symfony\Component\Uid\Uuid, string given, cal<br>led in D:\hantsylabs\symfony5-sample\rest-sample\vendor\symfony\http-kernel\HttpKernel.php on line 156</pre><p>The id in the URI is a string, can not be used as Uuid directly.</p><p>Symfony provides ParamConverter to convert the request attributes to the target type. We can create a custom ParamConverter to archive the purpose.</p><h3>Customizing ParamConverter</h3><p>Create a new class UuidParamCovnerter under <em>src/Request/</em> folder.</p><pre>class UuidParamConverter implements ParamConverterInterface<br>{<br>    public function __construct(private LoggerInterface $logger)<br>    {<br>    }<br></pre><pre>    /**<br>     * @inheritDoc<br>     */<br>    public function apply(Request $request, ParamConverter $configuration): bool<br>    {</pre><pre>        $param = $configuration-&gt;getName();</pre><pre>        if (!$request-&gt;attributes-&gt;has($param)) {<br>            return false;<br>        }</pre><pre>        $value = $request-&gt;attributes-&gt;get($param);<br>        $this-&gt;logger-&gt;info(&quot;parameter value:&quot; . $value);<br>        if (!$value &amp;&amp; $configuration-&gt;isOptional()) {<br>            $request-&gt;attributes-&gt;set($param, null);</pre><pre>            return true;<br>        }</pre><pre>        $data = Uuid::fromString($value);<br>        $request-&gt;attributes-&gt;set($param, $data);</pre><pre>        return true;<br>    }</pre><pre>    /**<br>     * @inheritDoc<br>     */<br>    public function supports(ParamConverter $configuration): bool<br>    {<br>        $className = $configuration-&gt;getClass();<br>        $this-&gt;logger-&gt;info(&quot;converting to UUID :{c}&quot;, [&quot;c&quot; =&gt; $className]);<br>        return $className &amp;&amp; $className == Uuid::class;<br>    }<br>}</pre><p>In the above codes,</p><ul><li>The supports function to check the execution environment if matching the requirements</li><li>The apply function to perform the conversion. if supports returns false, this conversion step will be skipped.</li></ul><h3>Creating a Post</h3><p>Follow the REST convention, define the following rule to serve an endpoint to handle the request.</p><ul><li>Request matches Http verbs/HTTP Method: POST</li><li>Request matches route endpoint: <em>/posts</em></li><li>Set request header Content-Type value to <em>application/json</em>, and use request body to hold request data as JSON format</li><li>If successful, return a CREATED(201) Http Status code, and set the response header <em>Location</em> value to the URI of the new created post.</li></ul><pre>#[Route(path: &quot;&quot;, name: &quot;create&quot;, methods: [&quot;POST&quot;])]<br>public function create(Request $request): Response<br>{<br>    $data = $this-&gt;serializer-&gt;deserialize($request-&gt;getContent(), CreatePostDto::class, &#39;json&#39;);<br>    $entity = PostFactory::create($data-&gt;getTitle(), $data-&gt;getContent());<br>    $this-&gt;posts-&gt;getEntityManager()-&gt;persist($entity);</pre><pre>    return $this-&gt;json([], 201, [&quot;Location&quot; =&gt; &quot;/posts/&quot; . $entity-&gt;getId()]);<br>}</pre><p>The posts-&gt;getEntityManager() overrides parent methods to get a EntityManager from parent class, you can also inject ObjectManager or EntityManagerInterface in the PostController directly to do the persistence work. The Doctrine Repository is mainly designated to build query criteria and execute custom queries.</p><p>Create a test function to verify in the PostControllerTest file.</p><pre>public function testCreatePost(): void<br>{<br>    $client = static::createClient();<br>    $data = CreatePostDto::of(&quot;test title&quot;, &quot;test content&quot;);<br>    $crawler = $client-&gt;request(<br>        &#39;POST&#39;,<br>        &#39;/posts&#39;,<br>        [],<br>        [],<br>        [],<br>        $this-&gt;getContainer()-&gt;get(&#39;serializer&#39;)-&gt;serialize($data, &#39;json&#39;)<br>    );</pre><pre>    $this-&gt;assertResponseIsSuccessful();</pre><pre>    $response = $client-&gt;getResponse();<br>    $url = $response-&gt;headers-&gt;get(&#39;Location&#39;);<br>    //dump($data);<br>    $this-&gt;assertNotNull($url);<br>    $this-&gt;assertStringStartsWith(&quot;/posts/&quot;, $url);<br>}</pre><h3>Converting Request Body</h3><p>We can also use an Annotation/Attribute to erase the raw codes of handling Request object through introducing a custom ArgumentResolver.</p><p>Create a Body <em>Attribute</em>.</p><pre>#[Attribute(Attribute::TARGET_PARAMETER)]<br>final class Body<br>{<br>}</pre><p>Then create a BodyValueResolver.</p><pre>class BodyValueResolver implements ArgumentValueResolverInterface, LoggerAwareInterface<br>{<br>    public function __construct(private SerializerInterface $serializer)<br>    {<br>    }</pre><pre>    private LoggerInterface $logger;</pre><pre>    /**<br>     * @inheritDoc<br>     */<br>    public function resolve(Request $request, ArgumentMetadata $argument)<br>    {<br>        $type = $argument-&gt;getType();<br>        $this-&gt;logger-&gt;debug(&quot;The argument type:&#39;&quot; . $type . &quot;&#39;&quot;);<br>        $format = $request-&gt;getContentType() ?? &#39;json&#39;;<br>        $this-&gt;logger-&gt;debug(&quot;The request format:&#39;&quot; . $format . &quot;&#39;&quot;);</pre><pre>        //read request body<br>        $content = $request-&gt;getContent();<br>        $data = $this-&gt;serializer-&gt;deserialize($content, $type, $format);<br>       // $this-&gt;logger-&gt;debug(&quot;deserialized data:{0}&quot;, [$data]);<br>        yield $data;<br>    }</pre><pre>    /**<br>     * @inheritDoc<br>     */<br>    public function supports(Request $request, ArgumentMetadata $argument): bool<br>    {<br>        $attrs = $argument-&gt;getAttributes(Body::class);<br>        return count($attrs) &gt; 0;<br>    }</pre><pre>    public function setLogger(LoggerInterface $logger)<br>    {<br>        $this-&gt;logger = $logger;<br>    }</pre><p>In the supports method, it simply detects if the method argument annotated with a Body attribute, then apply resolve method to deserialize the request body content to a typed object.</p><p>Run the application and test the endpoint through <em>/posts</em>.</p><pre>curl -v <a href="http://localhost:8000/posts">http://localhost:8000/posts</a> -H &quot;Content-Type:application/json&quot; -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;test content\&quot;}&quot;<br>&gt; POST /posts HTTP/1.1<br>&gt; Host: localhost:8000<br>&gt; User-Agent: curl/7.55.1<br>&gt; Accept: */*<br>&gt; Content-Type:application/json<br>&gt; Content-Length: 47<br>&gt;<br>&lt; HTTP/1.1 201 Created<br>&lt; Cache-Control: no-cache, private<br>&lt; Content-Type: application/json<br>&lt; Date: Sun, 21 Nov 2021 08:42:49 GMT<br>&lt; Location: /posts/1ec4aa70-1b21-6bce-93f8-b39330fe328e<br>&lt; X-Powered-By: PHP/8.0.10<br>&lt; X-Robots-Tag: noindex<br>&lt; Content-Length: 2<br>&lt;<br>[]</pre><h3>Exception Handling</h3><p>Symfony kernel provides a event machoism to raise an Exception in Controller class and handle them in your custom EventListener or EventSubscriber .</p><p>For example, create a PostNotFoundException.</p><pre>class PostNotFoundException extends \RuntimeException<br>{</pre><pre>    public function __construct(Uuid $uuid)<br>    {<br>        parent::__construct(&quot;Post #&quot; . $uuid . &quot; was not found&quot;);<br>    }</pre><pre>}</pre><p>Create a EventListener to catch this exception, and handle the exception as expected.</p><pre>class ExceptionListener implements LoggerAwareInterface<br>{<br>    private LoggerInterface $logger;</pre><pre>    public function __construct()<br>    {<br>    }</pre><pre>    public function onKernelException(ExceptionEvent $event)<br>    {<br>        // You get the exception object from the received event<br>        $exception = $event-&gt;getThrowable();<br>        $data = [&quot;error&quot; =&gt; $exception-&gt;getMessage()];</pre><pre>        // Customize your response object to display the exception details<br>        $response = new JsonResponse($data);</pre><pre>        // HttpExceptionInterface is a special type of exception that<br>        // holds status code and header details</pre><pre>        if ($exception instanceof PostNotFoundException) {<br>            $response-&gt;setStatusCode(Response::HTTP_NOT_FOUND);<br>        } else if ($exception instanceof HttpExceptionInterface) {<br>            $response-&gt;setStatusCode($exception-&gt;getStatusCode());<br>            $response-&gt;headers-&gt;replace($exception-&gt;getHeaders());<br>        } else {<br>            $response-&gt;setStatusCode(Response::HTTP_INTERNAL_SERVER_ERROR);<br>        }</pre><pre>        // sends the modified response object to the event<br>        $event-&gt;setResponse($response);<br>    }</pre><pre>    public function setLogger(LoggerInterface $logger)<br>    {<br>        $this-&gt;logger = $logger;<br>    }<br>}</pre><p>Register this ExceptionListener in <em>config/service.yml</em> file.</p><pre>App\EventListener\ExceptionListener:<br>    tags:<br>      - { name: kernel.event_listener, event: kernel.exception, priority: 50 }</pre><p>It indicates it binds event.exception event to ExceptionListener, and set priority to set the order at execution time.</p><p>Run the following command to show all registered EventListener/EventSubscribers on event <em>kernel.exception</em>.</p><pre>php bin/console debug:event-subscriber kernel.exception</pre><p>Change the getById function to the following.</p><pre>#[Route(path: &quot;/{id}&quot;, name: &quot;byId&quot;, methods: [&quot;GET&quot;])]<br>function getById(Uuid $id): Response<br>{<br>    $data = $this-&gt;posts-&gt;findOneBy([&quot;id&quot; =&gt; $id]);<br>    if ($data) {<br>   		return $this-&gt;json($data);<br>    } else {<br>    	throw new PostNotFoundException($id);<br>    }<br>}</pre><p>Add a test to verify if the post is not found and get a 404 status code.</p><pre>public function testGetANoneExistingPost(): void<br>{<br>    $client = static::createClient();<br>    $id = Uuid::v4();<br>    $crawler = $client-&gt;request(&#39;GET&#39;, &#39;/posts/&#39; . $id);</pre><pre>    //<br>    $response = $client-&gt;getResponse();<br>    $this-&gt;assertResponseStatusCodeSame(404);<br>    $data = $response-&gt;getContent();<br>    $this-&gt;assertStringContainsString(&quot;Post #&quot; . $id . &quot; was not found&quot;, $data);<br>}</pre><p>Run the application again, and try to access a single Post through a none existing id.</p><pre>curl <a href="http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438">http://localhost:8000/posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438</a> -H &quot;Accept: application/json&quot; -v<br>&gt; GET /posts/1ec3e1e0-17b3-6ed2-a01c-edecc112b438 HTTP/1.1<br>&gt; Host: localhost:8000<br>&gt; User-Agent: curl/7.55.1<br>&gt; Accept: application/json<br>&gt;<br>&lt; HTTP/1.1 404 Not Found<br>&lt; Cache-Control: no-cache, private<br>&lt; Content-Type: application/json<br>&lt; Date: Mon, 22 Nov 2021 03:57:51 GMT<br>&lt; X-Powered-By: PHP/8.0.10<br>&lt; X-Robots-Tag: noindex<br>&lt; Content-Length: 69<br>&lt;<br>{&quot;error&quot;:&quot;Post #1ec3e1e0-17b3-6ed2-a01c-edecc112b438 was not found.&quot;}</pre><h4>Get the <a href="https://github.com/hantsy/symfony5-sample/tree/master/rest-sample">complete source codes</a> from my Github.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=35368a6246ad" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-restful-apis-with-symfony-5-and-php-8-35368a6246ad">Building Restful APIs with Symfony 5 and PHP 8</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
