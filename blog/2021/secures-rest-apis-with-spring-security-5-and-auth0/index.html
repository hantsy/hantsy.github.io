<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Secures REST APIs with Spring Security 5 and Auth0
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/secures-rest-apis-with-spring-security-5-and-auth0/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Secures REST APIs with Spring Security 5 and Auth0" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Spring Security 5 deprecated the original Spring Security OAuth module and rewrote the OAuth2/Oidc implementation, make it available as part of the core modules. The image is from https://unsplash.com/photos/SwbsW4uf1Qs OAuth protocol defines 4 roles, including Resource Owner, Client, Authorization server and Resource server. Imagine you are using an app in your mobile, you(Resource owner) authorizes the app(presents a Client role itself) to perform an authorization flow to get access token from the authorization server, then utilizes this token to interact with the protected resources(from Resource server). Oidc is an additional supplement to enrich OAuth2 protocol. In Spring Security 5, it does not differentiate them explicitly in the API level and configuration. And nowadays most OAuth2 compatible provider supports the Oidc protocol. If you are new to OAuth2 and OIDC, please check the official OAuth 2 docs and explore OpenId Connect related specs. For impatient users, this introductory article from DigitalOcean is a good start point. With Spring Security 5, it is easy to set up OAuth2 Client and Resource server roles in your applications. And there is another incubator project which allow you to serve a custom Authorization server. In a real world application, I think it is a smart choice that choosing a mature IDP service to simplify the integration work of multiple authentication services and advanced features, for example, you want to integrate Google accounts, Facebook, Twitter and custom username/password authentication, and enable two-phases authentication in your applications. Auth0 and Okta are the leading IDP services in this area, they provide excellent administrative UI and rich SDK of all use case in your applications. In the open source world, Keycloak is widely used to host a custom authentication server. From the official Okta blog, Auth0 has joined the Okta family. I am a little afraid Auth0 will be disappeared like Stormpath. But the Okta guys declared that Auth0 will operate as a standalone brand. In this post, we will use Auth0 as the authentication server role to simplify our development progress. To demonstrate the OAuth2 flow, firstly we will create a RESTful API application that acts as Resource server. In the further post, we will create an Angular SPA client app to interact with this API backend. There are plenty of tutorials provided on the official auth0 docs page. Usually you can find the use cases matched your applications in these docs, go to the Backend API doc to go through the tutorial, esp. there is a great tutorial for Spring Security 5. Firstly register an Auth0 account if you don’t have one before. Or login using a social network account directly. After logged in, you will find Auth0 has created a development-purpose domain for you, it categories all resources for your new application. In the dashboard UI, expand the Applications/APIs in the left pane, let’s create a new API application(Resource server role in the OAuth2 protocol). Click the Create API button to start the progress.Fill the essential fields, the audience field is used to identify this API, it is recommended to fill a URL like value. For example. Here I created a new API application named Backend API, and set the audience to https://hantsy.github.io/api. Auth0 also provides an Auth0 Management API for you to access the Auth0 APIs, and for test purpose, Auth0 also created a Machine to Machine application automatically which allow you to interact with your own APIs. Next let’s create our Backend API application. Go to https://start.spring.io, fill the required fields, and select Maven as build tools and Java as language, then add the following dependencies, Web StarterValidationData JPASpring SecurityLombok Hit the Generate button to generate the project skeleton into an archive, download it and extract the files into your disk. Import the project into your IDEA, open the pom.xml file, add spring security oauth2 related dependencies. &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;&lt;/dependency&gt; In this post, we are going to integrate Auth0 with Spring Security to protect the RESTful APIs, and we will focus on the security configuration for an API application. To simplify the development work, I copied the existing codes from hantsy/spring-webmvc-functional-sample, which is used to produce RESTful APIs for a simple blog application. For the introduction of Spring WebMvc functional programming, check my post published on Medium. Declares a SecurityFilterChain bean to configure the details of Spring Security. @BeanSecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception { return http .httpBasic(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable) .sessionManagement(c -&gt; c.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeRequests(c -&gt; c .antMatchers(&quot;/&quot;, &quot;/info&quot;).permitAll() .antMatchers(HttpMethod.GET, &quot;/posts/**&quot;).permitAll()//.hasAuthority(&quot;SCOPE_read:posts&quot;) .antMatchers(HttpMethod.POST, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;) .antMatchers(HttpMethod.PUT, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;) .antMatchers(HttpMethod.DELETE, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_delete:posts&quot;) .anyRequest().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt) .build();} The oauth2ResourceServer indicates this application will work as a Resource server role, and it uses a JWT token to validate the incoming request.The authorizeRequests section defines the security rules againt HTTP URI and verbs, eg. requires a write:posts permission when creating new posts. Unlike the opaque token, a JWT token can be simply validated by a local public key or JWK set uri prvided by the authorization server. In Spring Security 5, a JWT token can be decoded from a configured issurer_uri if the auth provider implements OpenId Configuration spec, and exposes the whole OAuth2/Oidc configuration metadata such as token url, authorization server url, jwk set uri, user info uri etc. through a single url .well-known/openid-configuration. Add the following configuration in the application.properties. spring: ... security: oauth2: resourceserver: jwt: # Replace with the domain of your Auth0 tenant. # Note the trailing slash is important! issuer-uri: https://dev-ese8241b.us.auth0.com/ To check if the audience is set and included in the access token, add a custom audience validator. @RequiredArgsConstructor(staticName = &quot;of&quot;)public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; { private final String audience; public OAuth2TokenValidatorResult validate(Jwt jwt) { OAuth2Error error = new OAuth2Error(&quot;invalid_token&quot;, &quot;The required audience is missing&quot;, null); if (jwt.getAudience().contains(audience)) { return OAuth2TokenValidatorResult.success(); } return OAuth2TokenValidatorResult.failure(error); }} And add this validator in the JwtDecoder bean. @BeanJwtDecoder jwtDecoder(OAuth2ResourceServerProperties properties, @Value(&quot;${auth0.audience}&quot;) String audience) { /* By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is indeed intended for our app. Adding our own validator is easy to do: */ String issuerUri = properties.getJwt().getIssuerUri(); NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri); OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = AudienceValidator.of(audience); OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri); OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator); jwtDecoder.setJwtValidator(withAudience); return jwtDecoder;} Next, let’s add some permissions configuration in the Auth0 administration dashboard. Go to the Settings page of Backend API, and click the Permissions tab, add the following permissions. read:posts — Read postswrite:posts — Create and update Postsdelete:posts — Delete posts Switch to Machine to Machine applications tab, make sure the Test application is enabled, and expand the configuration of this application, make sure all permissions are checked on, the hit the Update button to apply the changes. Now switch to the Test tab, there is a guide for testing your API application with token, it is available in different scripts. Just copy the cURL command, and open a Unix/bash like terminal, and paste and execute it. $ curl --request POST \&gt; --url https://dev-ese8241b.us.auth0.com/oauth/token \&gt; --header &#39;content-type: application/json&#39; \&gt; --data &#39;{&quot;client_id&quot;:&quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1&quot;,&quot;client_secret&quot;:&quot;OknFJUkFpBe_tpFPAP2hL10NliMbCGxMRiFH_DkTxylBnZ5WjP9aq6zQOtL2L7ea&quot;,&quot;audience&quot;:&quot;https://hantsy.github.io/api&quot;,&quot;grant_type&quot;:&quot;client_credentials&quot;}&#39;{&quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgzMjAsImV4cCI6MTYyMDYzNDcyMCwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.UCdmcIb8xREC_rQp3EVBx8EALzhPcpJL1Mh1n6UX-Sf2cHkSsiUFISkHHM-qa5qZ34aNxJwKfvKPnZsfcIH9xwaGMeZjHub22PwAyVscQpZBq2mPRe_28GiwMP9jtFmSPhuGQec6-K7f0410tZTEKggnX3qFDdsJBWEhnu4zeFSwn865--Lbgk52owdncMd8jp2O5olKdnkeieChGQaYsLQ_vM8JTDN-eu5hm1DEL8WcfCd_foIG6klcm_gzgHpAru6zJQb48OmWIxlL6VGQl7RqIQIfds2NBBG7xYVr_38M2cltx8EUyIcXedR-d4YG_Dfp-NJbFkpZcSs9PPTagw&quot;,&quot;scope&quot;:&quot;read:posts write:posts delete:posts&quot;,&quot;expires_in&quot;:86400,&quot;token_type&quot;:&quot;Bearer&quot;} Copy to the access_token, open https://jwt.io page, and paste the token in the Encode box, you can see the decoded result. Now let’s use this token to access the protected APIs in our Backend API application. Firstly start up a Postgres server. Simply run the following docker command. $ docker compose up postgres Then run the application. $ mvn clean spring-boot:run// or $ mvn clean package$ java -jar ./target/xxx.jar Try to create a new post. $ curl --request POST \ --url http://localhost:8080/posts \ --header &#39;authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgwNzEsImV4cCI6MTYyMDYzNDQ3MSwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.Rg6UqIb2kjrPg39QRLOLsvI54TUsQM4B7j_6Eb4hlxFkzHWglD-V0b5kXfgSMIcBQ-fq5oLt7Fj8etgqMMpstyx-2Ob20rbCBd-msZ1o-xGQidkQsyEM6lL6GMX7d79Vw0H9eZN8D8j8_mVoqd-wENhWsBiSp3xq8Jz6KSdslrxGnMaQKbQ2IL7dgw8Y1kJBz8FgBcUUF5k-dhMB-DDLkaLsurwcb380Qk3gMD2JW97fxQWM_mi38ufcoopSWxznDE118ng7hQXT18vFB9N_RCNaPHslsKZsE6ytiwx6kiSYvGFN5RMWIa3Dyp6Rt4UjfTLx1WO9JDtxNc4NMSPQ-g&#39; \ --header &#39;Content-Type: application/json&#39; \ --data &#39;{&quot;title&quot;: &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot;: &quot;Content of this post, TBD&quot;}&#39; Then list all posts and check if the post is created as expected. $ curl http://localhost:8080/posts[ { &quot;id&quot; : 1, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;, &quot;title&quot; : &quot;Post one&quot;, &quot;content&quot; : &quot;content of Post one&quot;}, { &quot;id&quot; : 2, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;, &quot;title&quot; : &quot;Post two&quot;, &quot;content&quot; : &quot;content of Post two&quot;}, { &quot;id&quot; : 3, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;, &quot;createdBy&quot; : { &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot; }, &quot;lastModifiedBy&quot; : { &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot; }, &quot;title&quot; : &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot; : &quot;Content of this post, TBD&quot;} ] The Backend API is ready for being accessed by client applications. Now let’s explore the testing facilities provided in the Spring Security Test module to test the APIs protected by a JWT token. Spring Security provides a simple SecurityMockMvcRequestPostProcessors.jwt to mock JWT processing and bypass the JWT decoding in a Spring MockMvc environment. @Testpublic void testSave() throws Exception { given(this.posts.save(any(Post.class))) .willReturn(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()); this.mockMvc .perform( post(&quot;/posts&quot;) .with(jwt().jwt(jwtBuilder().claim(&quot;scope&quot;, &quot;write:posts&quot;).build())) .content(this.objectMapper.writeValueAsBytes(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())) .contentType(MediaType.APPLICATION_JSON) ) .andExpect(status().isCreated()); verify(this.posts, times(1)).save(any(Post.class)); verifyNoMoreInteractions(this.posts);} private Jwt.Builder jwtBuilder() { return Jwt.withTokenValue(&quot;token&quot;).header(&quot;alg&quot;, &quot;none&quot;).audience(List.of(audience));} In an integration test, you can use the same access token generated from the Test application to interact with the Backend API. Adding the token into the HTTP header to access the APIs, the following testing codes are written with Rest Assured. @SpringBootTest(webEnvironment = RANDOM_PORT)@Slf4jpublic class IntegrationTests { @LocalServerPort private int port; @Autowired ObjectMapper objectMapper; @Value(&quot;${auth0.audience}&quot;) private String audience; private String token = &quot;...&quot;; @BeforeEach public void setup() { RestAssured.port = this.port; } @Test public void createPostWithoutToken() throws Exception { //@formatter:off given() .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .assertThat() .statusCode(HttpStatus.SC_UNAUTHORIZED); //@formatter:on } @Test public void createPost() throws Exception { //@formatter:off given() .auth().oauth2(token) .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .assertThat() .statusCode(HttpStatus.SC_CREATED) .header(&quot;Location&quot;, notNullValue()); //@formatter:on } } Grab a copy of the source codes from my Github. &lt;hr&gt;&lt;p&gt;Secures REST APIs with Spring Security 5 and Auth0 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Spring Security 5 deprecated the original Spring Security OAuth module and rewrote the OAuth2/Oidc implementation, make it available as part of the core modules. The image is from https://unsplash.com/photos/SwbsW4uf1Qs OAuth protocol defines 4 roles, including Resource Owner, Client, Authorization server and Resource server. Imagine you are using an app in your mobile, you(Resource owner) authorizes the app(presents a Client role itself) to perform an authorization flow to get access token from the authorization server, then utilizes this token to interact with the protected resources(from Resource server). Oidc is an additional supplement to enrich OAuth2 protocol. In Spring Security 5, it does not differentiate them explicitly in the API level and configuration. And nowadays most OAuth2 compatible provider supports the Oidc protocol. If you are new to OAuth2 and OIDC, please check the official OAuth 2 docs and explore OpenId Connect related specs. For impatient users, this introductory article from DigitalOcean is a good start point. With Spring Security 5, it is easy to set up OAuth2 Client and Resource server roles in your applications. And there is another incubator project which allow you to serve a custom Authorization server. In a real world application, I think it is a smart choice that choosing a mature IDP service to simplify the integration work of multiple authentication services and advanced features, for example, you want to integrate Google accounts, Facebook, Twitter and custom username/password authentication, and enable two-phases authentication in your applications. Auth0 and Okta are the leading IDP services in this area, they provide excellent administrative UI and rich SDK of all use case in your applications. In the open source world, Keycloak is widely used to host a custom authentication server. From the official Okta blog, Auth0 has joined the Okta family. I am a little afraid Auth0 will be disappeared like Stormpath. But the Okta guys declared that Auth0 will operate as a standalone brand. In this post, we will use Auth0 as the authentication server role to simplify our development progress. To demonstrate the OAuth2 flow, firstly we will create a RESTful API application that acts as Resource server. In the further post, we will create an Angular SPA client app to interact with this API backend. There are plenty of tutorials provided on the official auth0 docs page. Usually you can find the use cases matched your applications in these docs, go to the Backend API doc to go through the tutorial, esp. there is a great tutorial for Spring Security 5. Firstly register an Auth0 account if you don’t have one before. Or login using a social network account directly. After logged in, you will find Auth0 has created a development-purpose domain for you, it categories all resources for your new application. In the dashboard UI, expand the Applications/APIs in the left pane, let’s create a new API application(Resource server role in the OAuth2 protocol). Click the Create API button to start the progress.Fill the essential fields, the audience field is used to identify this API, it is recommended to fill a URL like value. For example. Here I created a new API application named Backend API, and set the audience to https://hantsy.github.io/api. Auth0 also provides an Auth0 Management API for you to access the Auth0 APIs, and for test purpose, Auth0 also created a Machine to Machine application automatically which allow you to interact with your own APIs. Next let’s create our Backend API application. Go to https://start.spring.io, fill the required fields, and select Maven as build tools and Java as language, then add the following dependencies, Web StarterValidationData JPASpring SecurityLombok Hit the Generate button to generate the project skeleton into an archive, download it and extract the files into your disk. Import the project into your IDEA, open the pom.xml file, add spring security oauth2 related dependencies. &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;&lt;/dependency&gt; In this post, we are going to integrate Auth0 with Spring Security to protect the RESTful APIs, and we will focus on the security configuration for an API application. To simplify the development work, I copied the existing codes from hantsy/spring-webmvc-functional-sample, which is used to produce RESTful APIs for a simple blog application. For the introduction of Spring WebMvc functional programming, check my post published on Medium. Declares a SecurityFilterChain bean to configure the details of Spring Security. @BeanSecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception { return http .httpBasic(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable) .sessionManagement(c -&gt; c.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeRequests(c -&gt; c .antMatchers(&quot;/&quot;, &quot;/info&quot;).permitAll() .antMatchers(HttpMethod.GET, &quot;/posts/**&quot;).permitAll()//.hasAuthority(&quot;SCOPE_read:posts&quot;) .antMatchers(HttpMethod.POST, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;) .antMatchers(HttpMethod.PUT, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;) .antMatchers(HttpMethod.DELETE, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_delete:posts&quot;) .anyRequest().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt) .build();} The oauth2ResourceServer indicates this application will work as a Resource server role, and it uses a JWT token to validate the incoming request.The authorizeRequests section defines the security rules againt HTTP URI and verbs, eg. requires a write:posts permission when creating new posts. Unlike the opaque token, a JWT token can be simply validated by a local public key or JWK set uri prvided by the authorization server. In Spring Security 5, a JWT token can be decoded from a configured issurer_uri if the auth provider implements OpenId Configuration spec, and exposes the whole OAuth2/Oidc configuration metadata such as token url, authorization server url, jwk set uri, user info uri etc. through a single url .well-known/openid-configuration. Add the following configuration in the application.properties. spring: ... security: oauth2: resourceserver: jwt: # Replace with the domain of your Auth0 tenant. # Note the trailing slash is important! issuer-uri: https://dev-ese8241b.us.auth0.com/ To check if the audience is set and included in the access token, add a custom audience validator. @RequiredArgsConstructor(staticName = &quot;of&quot;)public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; { private final String audience; public OAuth2TokenValidatorResult validate(Jwt jwt) { OAuth2Error error = new OAuth2Error(&quot;invalid_token&quot;, &quot;The required audience is missing&quot;, null); if (jwt.getAudience().contains(audience)) { return OAuth2TokenValidatorResult.success(); } return OAuth2TokenValidatorResult.failure(error); }} And add this validator in the JwtDecoder bean. @BeanJwtDecoder jwtDecoder(OAuth2ResourceServerProperties properties, @Value(&quot;${auth0.audience}&quot;) String audience) { /* By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is indeed intended for our app. Adding our own validator is easy to do: */ String issuerUri = properties.getJwt().getIssuerUri(); NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri); OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = AudienceValidator.of(audience); OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri); OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator); jwtDecoder.setJwtValidator(withAudience); return jwtDecoder;} Next, let’s add some permissions configuration in the Auth0 administration dashboard. Go to the Settings page of Backend API, and click the Permissions tab, add the following permissions. read:posts — Read postswrite:posts — Create and update Postsdelete:posts — Delete posts Switch to Machine to Machine applications tab, make sure the Test application is enabled, and expand the configuration of this application, make sure all permissions are checked on, the hit the Update button to apply the changes. Now switch to the Test tab, there is a guide for testing your API application with token, it is available in different scripts. Just copy the cURL command, and open a Unix/bash like terminal, and paste and execute it. $ curl --request POST \&gt; --url https://dev-ese8241b.us.auth0.com/oauth/token \&gt; --header &#39;content-type: application/json&#39; \&gt; --data &#39;{&quot;client_id&quot;:&quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1&quot;,&quot;client_secret&quot;:&quot;OknFJUkFpBe_tpFPAP2hL10NliMbCGxMRiFH_DkTxylBnZ5WjP9aq6zQOtL2L7ea&quot;,&quot;audience&quot;:&quot;https://hantsy.github.io/api&quot;,&quot;grant_type&quot;:&quot;client_credentials&quot;}&#39;{&quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgzMjAsImV4cCI6MTYyMDYzNDcyMCwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.UCdmcIb8xREC_rQp3EVBx8EALzhPcpJL1Mh1n6UX-Sf2cHkSsiUFISkHHM-qa5qZ34aNxJwKfvKPnZsfcIH9xwaGMeZjHub22PwAyVscQpZBq2mPRe_28GiwMP9jtFmSPhuGQec6-K7f0410tZTEKggnX3qFDdsJBWEhnu4zeFSwn865--Lbgk52owdncMd8jp2O5olKdnkeieChGQaYsLQ_vM8JTDN-eu5hm1DEL8WcfCd_foIG6klcm_gzgHpAru6zJQb48OmWIxlL6VGQl7RqIQIfds2NBBG7xYVr_38M2cltx8EUyIcXedR-d4YG_Dfp-NJbFkpZcSs9PPTagw&quot;,&quot;scope&quot;:&quot;read:posts write:posts delete:posts&quot;,&quot;expires_in&quot;:86400,&quot;token_type&quot;:&quot;Bearer&quot;} Copy to the access_token, open https://jwt.io page, and paste the token in the Encode box, you can see the decoded result. Now let’s use this token to access the protected APIs in our Backend API application. Firstly start up a Postgres server. Simply run the following docker command. $ docker compose up postgres Then run the application. $ mvn clean spring-boot:run// or $ mvn clean package$ java -jar ./target/xxx.jar Try to create a new post. $ curl --request POST \ --url http://localhost:8080/posts \ --header &#39;authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgwNzEsImV4cCI6MTYyMDYzNDQ3MSwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.Rg6UqIb2kjrPg39QRLOLsvI54TUsQM4B7j_6Eb4hlxFkzHWglD-V0b5kXfgSMIcBQ-fq5oLt7Fj8etgqMMpstyx-2Ob20rbCBd-msZ1o-xGQidkQsyEM6lL6GMX7d79Vw0H9eZN8D8j8_mVoqd-wENhWsBiSp3xq8Jz6KSdslrxGnMaQKbQ2IL7dgw8Y1kJBz8FgBcUUF5k-dhMB-DDLkaLsurwcb380Qk3gMD2JW97fxQWM_mi38ufcoopSWxznDE118ng7hQXT18vFB9N_RCNaPHslsKZsE6ytiwx6kiSYvGFN5RMWIa3Dyp6Rt4UjfTLx1WO9JDtxNc4NMSPQ-g&#39; \ --header &#39;Content-Type: application/json&#39; \ --data &#39;{&quot;title&quot;: &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot;: &quot;Content of this post, TBD&quot;}&#39; Then list all posts and check if the post is created as expected. $ curl http://localhost:8080/posts[ { &quot;id&quot; : 1, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;, &quot;title&quot; : &quot;Post one&quot;, &quot;content&quot; : &quot;content of Post one&quot;}, { &quot;id&quot; : 2, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;, &quot;title&quot; : &quot;Post two&quot;, &quot;content&quot; : &quot;content of Post two&quot;}, { &quot;id&quot; : 3, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;, &quot;createdBy&quot; : { &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot; }, &quot;lastModifiedBy&quot; : { &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot; }, &quot;title&quot; : &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot; : &quot;Content of this post, TBD&quot;} ] The Backend API is ready for being accessed by client applications. Now let’s explore the testing facilities provided in the Spring Security Test module to test the APIs protected by a JWT token. Spring Security provides a simple SecurityMockMvcRequestPostProcessors.jwt to mock JWT processing and bypass the JWT decoding in a Spring MockMvc environment. @Testpublic void testSave() throws Exception { given(this.posts.save(any(Post.class))) .willReturn(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()); this.mockMvc .perform( post(&quot;/posts&quot;) .with(jwt().jwt(jwtBuilder().claim(&quot;scope&quot;, &quot;write:posts&quot;).build())) .content(this.objectMapper.writeValueAsBytes(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())) .contentType(MediaType.APPLICATION_JSON) ) .andExpect(status().isCreated()); verify(this.posts, times(1)).save(any(Post.class)); verifyNoMoreInteractions(this.posts);} private Jwt.Builder jwtBuilder() { return Jwt.withTokenValue(&quot;token&quot;).header(&quot;alg&quot;, &quot;none&quot;).audience(List.of(audience));} In an integration test, you can use the same access token generated from the Test application to interact with the Backend API. Adding the token into the HTTP header to access the APIs, the following testing codes are written with Rest Assured. @SpringBootTest(webEnvironment = RANDOM_PORT)@Slf4jpublic class IntegrationTests { @LocalServerPort private int port; @Autowired ObjectMapper objectMapper; @Value(&quot;${auth0.audience}&quot;) private String audience; private String token = &quot;...&quot;; @BeforeEach public void setup() { RestAssured.port = this.port; } @Test public void createPostWithoutToken() throws Exception { //@formatter:off given() .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .assertThat() .statusCode(HttpStatus.SC_UNAUTHORIZED); //@formatter:on } @Test public void createPost() throws Exception { //@formatter:off given() .auth().oauth2(token) .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .assertThat() .statusCode(HttpStatus.SC_CREATED) .header(&quot;Location&quot;, notNullValue()); //@formatter:on } } Grab a copy of the source codes from my Github. &lt;hr&gt;&lt;p&gt;Secures REST APIs with Spring Security 5 and Auth0 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-09T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Secures REST APIs with Spring Security 5 and Auth0" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-05-09T00:00:00+00:00","datePublished":"2021-05-09T00:00:00+00:00","description":"Spring Security 5 deprecated the original Spring Security OAuth module and rewrote the OAuth2/Oidc implementation, make it available as part of the core modules. The image is from https://unsplash.com/photos/SwbsW4uf1Qs OAuth protocol defines 4 roles, including Resource Owner, Client, Authorization server and Resource server. Imagine you are using an app in your mobile, you(Resource owner) authorizes the app(presents a Client role itself) to perform an authorization flow to get access token from the authorization server, then utilizes this token to interact with the protected resources(from Resource server). Oidc is an additional supplement to enrich OAuth2 protocol. In Spring Security 5, it does not differentiate them explicitly in the API level and configuration. And nowadays most OAuth2 compatible provider supports the Oidc protocol. If you are new to OAuth2 and OIDC, please check the official OAuth 2 docs and explore OpenId Connect related specs. For impatient users, this introductory article from DigitalOcean is a good start point. With Spring Security 5, it is easy to set up OAuth2 Client and Resource server roles in your applications. And there is another incubator project which allow you to serve a custom Authorization server. In a real world application, I think it is a smart choice that choosing a mature IDP service to simplify the integration work of multiple authentication services and advanced features, for example, you want to integrate Google accounts, Facebook, Twitter and custom username/password authentication, and enable two-phases authentication in your applications. Auth0 and Okta are the leading IDP services in this area, they provide excellent administrative UI and rich SDK of all use case in your applications. In the open source world, Keycloak is widely used to host a custom authentication server. From the official Okta blog, Auth0 has joined the Okta family. I am a little afraid Auth0 will be disappeared like Stormpath. But the Okta guys declared that Auth0 will operate as a standalone brand. In this post, we will use Auth0 as the authentication server role to simplify our development progress. To demonstrate the OAuth2 flow, firstly we will create a RESTful API application that acts as Resource server. In the further post, we will create an Angular SPA client app to interact with this API backend. There are plenty of tutorials provided on the official auth0 docs page. Usually you can find the use cases matched your applications in these docs, go to the Backend API doc to go through the tutorial, esp. there is a great tutorial for Spring Security 5. Firstly register an Auth0 account if you don’t have one before. Or login using a social network account directly. After logged in, you will find Auth0 has created a development-purpose domain for you, it categories all resources for your new application. In the dashboard UI, expand the Applications/APIs in the left pane, let’s create a new API application(Resource server role in the OAuth2 protocol). Click the Create API button to start the progress.Fill the essential fields, the audience field is used to identify this API, it is recommended to fill a URL like value. For example. Here I created a new API application named Backend API, and set the audience to https://hantsy.github.io/api. Auth0 also provides an Auth0 Management API for you to access the Auth0 APIs, and for test purpose, Auth0 also created a Machine to Machine application automatically which allow you to interact with your own APIs. Next let’s create our Backend API application. Go to https://start.spring.io, fill the required fields, and select Maven as build tools and Java as language, then add the following dependencies, Web StarterValidationData JPASpring SecurityLombok Hit the Generate button to generate the project skeleton into an archive, download it and extract the files into your disk. Import the project into your IDEA, open the pom.xml file, add spring security oauth2 related dependencies. &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;&lt;/dependency&gt; In this post, we are going to integrate Auth0 with Spring Security to protect the RESTful APIs, and we will focus on the security configuration for an API application. To simplify the development work, I copied the existing codes from hantsy/spring-webmvc-functional-sample, which is used to produce RESTful APIs for a simple blog application. For the introduction of Spring WebMvc functional programming, check my post published on Medium. Declares a SecurityFilterChain bean to configure the details of Spring Security. @BeanSecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception { return http .httpBasic(AbstractHttpConfigurer::disable) .csrf(AbstractHttpConfigurer::disable) .sessionManagement(c -&gt; c.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeRequests(c -&gt; c .antMatchers(&quot;/&quot;, &quot;/info&quot;).permitAll() .antMatchers(HttpMethod.GET, &quot;/posts/**&quot;).permitAll()//.hasAuthority(&quot;SCOPE_read:posts&quot;) .antMatchers(HttpMethod.POST, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;) .antMatchers(HttpMethod.PUT, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;) .antMatchers(HttpMethod.DELETE, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_delete:posts&quot;) .anyRequest().authenticated() ) .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt) .build();} The oauth2ResourceServer indicates this application will work as a Resource server role, and it uses a JWT token to validate the incoming request.The authorizeRequests section defines the security rules againt HTTP URI and verbs, eg. requires a write:posts permission when creating new posts. Unlike the opaque token, a JWT token can be simply validated by a local public key or JWK set uri prvided by the authorization server. In Spring Security 5, a JWT token can be decoded from a configured issurer_uri if the auth provider implements OpenId Configuration spec, and exposes the whole OAuth2/Oidc configuration metadata such as token url, authorization server url, jwk set uri, user info uri etc. through a single url .well-known/openid-configuration. Add the following configuration in the application.properties. spring: ... security: oauth2: resourceserver: jwt: # Replace with the domain of your Auth0 tenant. # Note the trailing slash is important! issuer-uri: https://dev-ese8241b.us.auth0.com/ To check if the audience is set and included in the access token, add a custom audience validator. @RequiredArgsConstructor(staticName = &quot;of&quot;)public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; { private final String audience; public OAuth2TokenValidatorResult validate(Jwt jwt) { OAuth2Error error = new OAuth2Error(&quot;invalid_token&quot;, &quot;The required audience is missing&quot;, null); if (jwt.getAudience().contains(audience)) { return OAuth2TokenValidatorResult.success(); } return OAuth2TokenValidatorResult.failure(error); }} And add this validator in the JwtDecoder bean. @BeanJwtDecoder jwtDecoder(OAuth2ResourceServerProperties properties, @Value(&quot;${auth0.audience}&quot;) String audience) { /* By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is indeed intended for our app. Adding our own validator is easy to do: */ String issuerUri = properties.getJwt().getIssuerUri(); NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri); OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = AudienceValidator.of(audience); OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri); OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator); jwtDecoder.setJwtValidator(withAudience); return jwtDecoder;} Next, let’s add some permissions configuration in the Auth0 administration dashboard. Go to the Settings page of Backend API, and click the Permissions tab, add the following permissions. read:posts — Read postswrite:posts — Create and update Postsdelete:posts — Delete posts Switch to Machine to Machine applications tab, make sure the Test application is enabled, and expand the configuration of this application, make sure all permissions are checked on, the hit the Update button to apply the changes. Now switch to the Test tab, there is a guide for testing your API application with token, it is available in different scripts. Just copy the cURL command, and open a Unix/bash like terminal, and paste and execute it. $ curl --request POST \\&gt; --url https://dev-ese8241b.us.auth0.com/oauth/token \\&gt; --header &#39;content-type: application/json&#39; \\&gt; --data &#39;{&quot;client_id&quot;:&quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1&quot;,&quot;client_secret&quot;:&quot;OknFJUkFpBe_tpFPAP2hL10NliMbCGxMRiFH_DkTxylBnZ5WjP9aq6zQOtL2L7ea&quot;,&quot;audience&quot;:&quot;https://hantsy.github.io/api&quot;,&quot;grant_type&quot;:&quot;client_credentials&quot;}&#39;{&quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgzMjAsImV4cCI6MTYyMDYzNDcyMCwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.UCdmcIb8xREC_rQp3EVBx8EALzhPcpJL1Mh1n6UX-Sf2cHkSsiUFISkHHM-qa5qZ34aNxJwKfvKPnZsfcIH9xwaGMeZjHub22PwAyVscQpZBq2mPRe_28GiwMP9jtFmSPhuGQec6-K7f0410tZTEKggnX3qFDdsJBWEhnu4zeFSwn865--Lbgk52owdncMd8jp2O5olKdnkeieChGQaYsLQ_vM8JTDN-eu5hm1DEL8WcfCd_foIG6klcm_gzgHpAru6zJQb48OmWIxlL6VGQl7RqIQIfds2NBBG7xYVr_38M2cltx8EUyIcXedR-d4YG_Dfp-NJbFkpZcSs9PPTagw&quot;,&quot;scope&quot;:&quot;read:posts write:posts delete:posts&quot;,&quot;expires_in&quot;:86400,&quot;token_type&quot;:&quot;Bearer&quot;} Copy to the access_token, open https://jwt.io page, and paste the token in the Encode box, you can see the decoded result. Now let’s use this token to access the protected APIs in our Backend API application. Firstly start up a Postgres server. Simply run the following docker command. $ docker compose up postgres Then run the application. $ mvn clean spring-boot:run// or $ mvn clean package$ java -jar ./target/xxx.jar Try to create a new post. $ curl --request POST \\ --url http://localhost:8080/posts \\ --header &#39;authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgwNzEsImV4cCI6MTYyMDYzNDQ3MSwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.Rg6UqIb2kjrPg39QRLOLsvI54TUsQM4B7j_6Eb4hlxFkzHWglD-V0b5kXfgSMIcBQ-fq5oLt7Fj8etgqMMpstyx-2Ob20rbCBd-msZ1o-xGQidkQsyEM6lL6GMX7d79Vw0H9eZN8D8j8_mVoqd-wENhWsBiSp3xq8Jz6KSdslrxGnMaQKbQ2IL7dgw8Y1kJBz8FgBcUUF5k-dhMB-DDLkaLsurwcb380Qk3gMD2JW97fxQWM_mi38ufcoopSWxznDE118ng7hQXT18vFB9N_RCNaPHslsKZsE6ytiwx6kiSYvGFN5RMWIa3Dyp6Rt4UjfTLx1WO9JDtxNc4NMSPQ-g&#39; \\ --header &#39;Content-Type: application/json&#39; \\ --data &#39;{&quot;title&quot;: &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot;: &quot;Content of this post, TBD&quot;}&#39; Then list all posts and check if the post is created as expected. $ curl http://localhost:8080/posts[ { &quot;id&quot; : 1, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;, &quot;title&quot; : &quot;Post one&quot;, &quot;content&quot; : &quot;content of Post one&quot;}, { &quot;id&quot; : 2, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;, &quot;title&quot; : &quot;Post two&quot;, &quot;content&quot; : &quot;content of Post two&quot;}, { &quot;id&quot; : 3, &quot;version&quot; : 0, &quot;createdDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;, &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;, &quot;createdBy&quot; : { &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot; }, &quot;lastModifiedBy&quot; : { &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot; }, &quot;title&quot; : &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot; : &quot;Content of this post, TBD&quot;} ] The Backend API is ready for being accessed by client applications. Now let’s explore the testing facilities provided in the Spring Security Test module to test the APIs protected by a JWT token. Spring Security provides a simple SecurityMockMvcRequestPostProcessors.jwt to mock JWT processing and bypass the JWT decoding in a Spring MockMvc environment. @Testpublic void testSave() throws Exception { given(this.posts.save(any(Post.class))) .willReturn(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()); this.mockMvc .perform( post(&quot;/posts&quot;) .with(jwt().jwt(jwtBuilder().claim(&quot;scope&quot;, &quot;write:posts&quot;).build())) .content(this.objectMapper.writeValueAsBytes(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())) .contentType(MediaType.APPLICATION_JSON) ) .andExpect(status().isCreated()); verify(this.posts, times(1)).save(any(Post.class)); verifyNoMoreInteractions(this.posts);} private Jwt.Builder jwtBuilder() { return Jwt.withTokenValue(&quot;token&quot;).header(&quot;alg&quot;, &quot;none&quot;).audience(List.of(audience));} In an integration test, you can use the same access token generated from the Test application to interact with the Backend API. Adding the token into the HTTP header to access the APIs, the following testing codes are written with Rest Assured. @SpringBootTest(webEnvironment = RANDOM_PORT)@Slf4jpublic class IntegrationTests { @LocalServerPort private int port; @Autowired ObjectMapper objectMapper; @Value(&quot;${auth0.audience}&quot;) private String audience; private String token = &quot;...&quot;; @BeforeEach public void setup() { RestAssured.port = this.port; } @Test public void createPostWithoutToken() throws Exception { //@formatter:off given() .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .assertThat() .statusCode(HttpStatus.SC_UNAUTHORIZED); //@formatter:on } @Test public void createPost() throws Exception { //@formatter:off given() .auth().oauth2(token) .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .assertThat() .statusCode(HttpStatus.SC_CREATED) .header(&quot;Location&quot;, notNullValue()); //@formatter:on } } Grab a copy of the source codes from my Github. &lt;hr&gt;&lt;p&gt;Secures REST APIs with Spring Security 5 and Auth0 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Secures REST APIs with Spring Security 5 and Auth0","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/secures-rest-apis-with-spring-security-5-and-auth0/"},"url":"/blog/2021/secures-rest-apis-with-spring-security-5-and-auth0/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Secures REST APIs with Spring Security 5 and Auth0</h1>
    <p class="post-meta">May 9, 2021</p>
  </header>

  <article class="post-content">
    <p>Spring Security 5 deprecated the original Spring Security OAuth module and rewrote the OAuth2/Oidc implementation, make it available as part of the core modules.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QhbQzmBZJD2sMMlR-Cacrg.jpeg" /><figcaption><a href="https://unsplash.com/photos/SwbsW4uf1Qs">The image is from https://unsplash.com/photos/SwbsW4uf1Qs</a></figcaption></figure><p>OAuth protocol defines 4 roles, including <em>Resource Owner</em>, <em>Client</em>, <em>Authorization server</em> and <em>Resource server</em>. Imagine you are using an app in your mobile, you(<em>Resource owner</em>) authorizes the app(presents a <em>Client</em> role itself) to perform an authorization flow to get access token from the authorization server, then utilizes this token to interact with the protected resources(from <em>Resource server</em>).</p><p>Oidc is an additional supplement to enrich OAuth2 protocol. In Spring Security 5, it does not differentiate them explicitly in the API level and configuration. And nowadays most OAuth2 compatible provider supports the Oidc protocol.</p><blockquote><em>If you are new to OAuth2 and OIDC, please check the official </em><a href="https://oauth.net/2/"><em>OAuth 2 docs</em></a><em> and explore </em><a href="https://openid.net/connect/"><em>OpenId Connect</em></a><em> related specs. For impatient users, </em><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2"><em>this introductory article</em></a><em> from DigitalOcean is a good start point.</em></blockquote><p>With Spring Security 5, it is easy to set up OAuth2 <em>Client</em> and <em>Resource server</em> roles in your applications. And there is <a href="https://github.com/spring-projects-experimental/spring-authorization-server">another incubator project</a> which allow you to serve a custom <em>Authorization server</em>. In a real world application, I think it is a smart choice that choosing a mature IDP service to simplify the integration work of multiple authentication services and advanced features, for example, you want to integrate Google accounts, Facebook, Twitter and custom username/password authentication, and enable two-phases authentication in your applications. <a href="https://www.auth0.com">Auth0</a> and <a href="https://www.okta.com">Okta</a> are the leading IDP services in this area, they provide excellent administrative UI and rich SDK of all use case in your applications. In the open source world, <a href="https://www.keycloak.org/">Keycloak</a> is widely used to host a custom authentication server.</p><blockquote><em>From the official Okta blog, Auth0 has joined the Okta family. I am a little afraid Auth0 will be disappeared like Stormpath. But the Okta guys declared that Auth0 will operate as a standalone brand.</em></blockquote><p>In this post, we will use Auth0 as the authentication server role to simplify our development progress.</p><p>To demonstrate the OAuth2 flow, firstly we will create a RESTful API <em>application</em> that acts as <em>Resource server</em>. In the further post, we will create an Angular SPA client app to interact with this API backend.</p><p>There are plenty of tutorials provided on the official <a href="https://auth0.com/docs/">auth0 docs page</a>. Usually you can find the use cases matched your applications in these docs, go to the <em>Backend API</em> doc to go through the tutorial, esp. there is a <a href="https://auth0.com/docs/quickstart/backend/java-spring-security5">great tutorial for Spring Security 5</a>.</p><p>Firstly register an Auth0 account if you don’t have one before. Or login using a social network account directly. After logged in, you will find Auth0 has created a development-purpose domain for you, it categories all resources for your new application.</p><p>In the dashboard UI, expand the <em>Applications/APIs</em> in the left pane, let’s create a new API application(<em>Resource server</em> role in the OAuth2 protocol).</p><ul><li>Click the <em>Create API</em> button to start the progress.</li><li>Fill the essential fields, the <em>audience</em> field is used to identify this API, it is recommended to fill a URL like value. For example. Here I created a new API application named <em>Backend API</em>, and set the audience to <a href="https://hantsy.github.io/api"><em>https://hantsy.github.io/api</em></a>.</li></ul><p>Auth0 also provides an <em>Auth0 Management API</em> for you to access the Auth0 APIs, and for test purpose, Auth0 also created a <em>Machine to Machine</em> application automatically which allow you to interact with your own APIs.</p><p>Next let’s create our <em>Backend API</em> application. Go to <a href="https://start.spring.io">https://start.spring.io</a>, fill the required fields, and select <em>Maven</em> as build tools and <em>Java</em> as language, then add the following dependencies,</p><ul><li>Web Starter</li><li>Validation</li><li>Data JPA</li><li>Spring Security</li><li>Lombok</li></ul><p>Hit the Generate button to generate the project skeleton into an archive, download it and extract the files into your disk. Import the project into your IDEA, open the <em>pom.xml</em> file, add spring security oauth2 related dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>In this post, we are going to integrate Auth0 with Spring Security to protect the RESTful APIs, and we will focus on the security configuration for an API application. To simplify the development work, I copied the existing codes from <a href="https://github.com/hantsy/spring-webmvc-functional-sample">hantsy/spring-webmvc-functional-sample</a>, which is used to produce RESTful APIs for a simple blog application.</p><blockquote><em>For the introduction of Spring WebMvc functional programming, check </em><a href="https://hantsy.medium.com/functional-programming-in-spring-mvc-20957653da1"><em>my post published on Medium</em></a><em>.</em></blockquote><p>Declares a SecurityFilterChain bean to configure the details of Spring Security.</p><pre>@Bean<br>SecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception {<br>    return http<br>        .httpBasic(AbstractHttpConfigurer::disable)<br>        .csrf(AbstractHttpConfigurer::disable)<br>        .sessionManagement(c -&gt; c.sessionCreationPolicy(SessionCreationPolicy.STATELESS))<br>        .authorizeRequests(c -&gt; c<br>                           .antMatchers(&quot;/&quot;, &quot;/info&quot;).permitAll()<br>                           .antMatchers(HttpMethod.GET, &quot;/posts/**&quot;).permitAll()//.hasAuthority(&quot;SCOPE_read:posts&quot;)<br>                           .antMatchers(HttpMethod.POST, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;)<br>                           .antMatchers(HttpMethod.PUT, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;)<br>                           .antMatchers(HttpMethod.DELETE, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_delete:posts&quot;)<br>                           .anyRequest().authenticated()<br>                          )<br>        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt)<br>        .build();<br>}</pre><ol><li>The oauth2ResourceServer indicates this application will work as a <em>Resource server</em> role, and it uses a JWT token to validate the incoming request.</li><li>The authorizeRequests section defines the security rules againt HTTP URI and verbs, eg. requires a write:posts permission when creating new posts.</li></ol><p>Unlike the <em>opaque</em> token, a JWT token can be simply validated by a local public key or JWK set uri prvided by the authorization server.</p><p>In Spring Security 5, a JWT token can be decoded from a configured <em>issurer_uri</em> if the auth provider implements OpenId Configuration spec, and exposes the whole OAuth2/Oidc configuration metadata such as token url, authorization server url, jwk set uri, user info uri etc. through a single url .well-known/openid-configuration.</p><p>Add the following configuration in the <em>application.properties</em>.</p><pre>spring:<br>  ...<br>  security:<br>    oauth2:<br>      resourceserver:<br>        jwt:<br>          # Replace with the domain of your Auth0 tenant.<br>          # Note the trailing slash is important!<br>          issuer-uri: <a href="https://dev-ese8241b.us.auth0.com/">https://dev-ese8241b.us.auth0.com/</a></pre><p>To check if the audience is set and included in the access token, add a custom audience validator.</p><pre>@RequiredArgsConstructor(staticName = &quot;of&quot;)<br>public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {<br>    private final String audience;<br>    <br>    public OAuth2TokenValidatorResult validate(Jwt jwt) {<br>        OAuth2Error error = new OAuth2Error(&quot;invalid_token&quot;, &quot;The required audience is missing&quot;, null);<br>        <br>        if (jwt.getAudience().contains(audience)) {<br>            return OAuth2TokenValidatorResult.success();<br>        }<br>        <br>        return OAuth2TokenValidatorResult.failure(error);<br>    }<br>}</pre><p>And add this validator in the JwtDecoder bean.</p><pre>@Bean<br>JwtDecoder jwtDecoder(OAuth2ResourceServerProperties properties, @Value(&quot;${auth0.audience}&quot;) String audience) {<br>    /*<br>        By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is<br>        indeed intended for our app. Adding our own validator is easy to do:<br>        */</pre><pre>    String issuerUri = properties.getJwt().getIssuerUri();<br>    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);</pre><pre>    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = AudienceValidator.of(audience);<br>    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);<br>    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);</pre><pre>    jwtDecoder.setJwtValidator(withAudience);</pre><pre>    return jwtDecoder;<br>}</pre><p>Next, let’s add some permissions configuration in the Auth0 administration dashboard.</p><p>Go to the <em>Settings</em> page of <em>Backend API</em>, and click the <em>Permissions</em> tab, add the following permissions.</p><ul><li><em>read:posts</em> — Read posts</li><li><em>write:posts</em> — Create and update Posts</li><li><em>delete:posts</em> — Delete posts</li></ul><p>Switch to <em>Machine to Machine applications</em> tab, make sure the <em>Test application</em> is enabled, and expand the configuration of this application, make sure all permissions are checked on, the hit the <strong>Update</strong> button to apply the changes.</p><p>Now switch to the <em>Test</em> tab, there is a guide for testing your API application with token, it is available in different scripts. Just copy the <strong>cURL</strong> command, and open a Unix/bash like terminal, and paste and execute it.</p><pre>$ curl --request POST \<br>&gt;   --url <a href="https://dev-ese8241b.us.auth0.com/oauth/token">https://dev-ese8241b.us.auth0.com/oauth/token</a> \<br>&gt;   --header &#39;content-type: application/json&#39; \<br>&gt;   --data &#39;{&quot;client_id&quot;:&quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1&quot;,&quot;client_secret&quot;:&quot;OknFJUkFpBe_tpFPAP2hL10NliMbCGxMRiFH_DkTxylBnZ5WjP9aq6zQOtL2L7ea&quot;,&quot;audience&quot;:&quot;https://hantsy.github.io/api&quot;,&quot;grant_type&quot;:&quot;client_credentials&quot;}&#39;<br>{&quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgzMjAsImV4cCI6MTYyMDYzNDcyMCwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.UCdmcIb8xREC_rQp3EVBx8EALzhPcpJL1Mh1n6UX-Sf2cHkSsiUFISkHHM-qa5qZ34aNxJwKfvKPnZsfcIH9xwaGMeZjHub22PwAyVscQpZBq2mPRe_28GiwMP9jtFmSPhuGQec6-K7f0410tZTEKggnX3qFDdsJBWEhnu4zeFSwn865--Lbgk52owdncMd8jp2O5olKdnkeieChGQaYsLQ_vM8JTDN-eu5hm1DEL8WcfCd_foIG6klcm_gzgHpAru6zJQb48OmWIxlL6VGQl7RqIQIfds2NBBG7xYVr_38M2cltx8EUyIcXedR-d4YG_Dfp-NJbFkpZcSs9PPTagw&quot;,&quot;scope&quot;:&quot;read:posts write:posts delete:posts&quot;,&quot;expires_in&quot;:86400,&quot;token_type&quot;:&quot;Bearer&quot;}</pre><p>Copy to the access_token, open <a href="https://jwt.io">https://jwt.io</a> page, and paste the token in the <em>Encode</em> box, you can see the decoded result.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LumBCwNgFd73at0i.png" /></figure><p>Now let’s use this token to access the protected APIs in our <em>Backend API</em> application.</p><p>Firstly start up a Postgres server. Simply run the following docker command.</p><pre>$ docker compose up postgres</pre><p>Then run the application.</p><pre>$ mvn clean spring-boot:run<br>// or <br>$ mvn clean package<br>$ java -jar ./target/xxx.jar</pre><p>Try to create a new post.</p><pre>$ curl --request POST \<br>  --url <a href="http://localhost:8080/posts">http://localhost:8080/posts</a> \<br>  --header &#39;authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgwNzEsImV4cCI6MTYyMDYzNDQ3MSwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.Rg6UqIb2kjrPg39QRLOLsvI54TUsQM4B7j_6Eb4hlxFkzHWglD-V0b5kXfgSMIcBQ-fq5oLt7Fj8etgqMMpstyx-2Ob20rbCBd-msZ1o-xGQidkQsyEM6lL6GMX7d79Vw0H9eZN8D8j8_mVoqd-wENhWsBiSp3xq8Jz6KSdslrxGnMaQKbQ2IL7dgw8Y1kJBz8FgBcUUF5k-dhMB-DDLkaLsurwcb380Qk3gMD2JW97fxQWM_mi38ufcoopSWxznDE118ng7hQXT18vFB9N_RCNaPHslsKZsE6ytiwx6kiSYvGFN5RMWIa3Dyp6Rt4UjfTLx1WO9JDtxNc4NMSPQ-g&#39; \<br>  --header &#39;Content-Type: application/json&#39; \<br>  --data &#39;{&quot;title&quot;: &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot;: &quot;Content of this post, TBD&quot;}&#39;</pre><p>Then list all posts and check if the post is created as expected.</p><pre>$ curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a><br>[ {<br>  &quot;id&quot; : 1,<br>  &quot;version&quot; : 0,<br>  &quot;createdDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;,<br>  &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;,<br>  &quot;title&quot; : &quot;Post one&quot;,<br>  &quot;content&quot; : &quot;content of Post one&quot;<br>}, {<br>  &quot;id&quot; : 2,<br>  &quot;version&quot; : 0,<br>  &quot;createdDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;,<br>  &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;,<br>  &quot;title&quot; : &quot;Post two&quot;,<br>  &quot;content&quot; : &quot;content of Post two&quot;<br>}, {<br>  &quot;id&quot; : 3,<br>  &quot;version&quot; : 0,<br>  &quot;createdDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;,<br>  &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;,<br>  &quot;createdBy&quot; : {<br>    &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot;<br>  },<br>  &quot;lastModifiedBy&quot; : {<br>    &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot;<br>  },<br>  &quot;title&quot; : &quot;New Post about Spring Secrity and Auth0&quot;,<br>  &quot;content&quot; : &quot;Content of this post, TBD&quot;<br>} ]</pre><p>The <em>Backend API</em> is ready for being accessed by client applications. Now let’s explore the testing facilities provided in the Spring Security Test module to test the APIs protected by a JWT token.</p><p>Spring Security provides a simple SecurityMockMvcRequestPostProcessors.jwt to mock JWT processing and bypass the JWT decoding in a Spring MockMvc environment.</p><pre>@Test<br>public void testSave() throws Exception {</pre><pre>    given(this.posts.save(any(Post.class)))<br>        .willReturn(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build());</pre><pre>    this.mockMvc<br>        .perform(<br>        post(&quot;/posts&quot;)<br>        .with(jwt().jwt(jwtBuilder().claim(&quot;scope&quot;, &quot;write:posts&quot;).build()))<br>        .content(this.objectMapper.writeValueAsBytes(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()))<br>        .contentType(MediaType.APPLICATION_JSON)<br>    )<br>        .andExpect(status().isCreated());</pre><pre>    verify(this.posts, times(1)).save(any(Post.class));<br>    verifyNoMoreInteractions(this.posts);<br>}</pre><pre>private Jwt.Builder jwtBuilder() {<br>    return Jwt.withTokenValue(&quot;token&quot;).header(&quot;alg&quot;, &quot;none&quot;).audience(List.of(audience));<br>}</pre><p>In an integration test, you can use the same access token generated from the <em>Test application</em> to interact with the <em>Backend API</em>. Adding the token into the HTTP header to access the APIs, the following testing codes are written with Rest Assured.</p><pre>@SpringBootTest(webEnvironment = RANDOM_PORT)<br>@Slf4j<br>public class IntegrationTests {</pre><pre>    @LocalServerPort<br>    private int port;</pre><pre>    @Autowired<br>    ObjectMapper objectMapper;</pre><pre>    @Value(&quot;${auth0.audience}&quot;)<br>    private String audience;</pre><pre>    private String token = &quot;...&quot;;<br>    <br>    @BeforeEach<br>    public void setup() {<br>        RestAssured.port = this.port;<br>    }<br></pre><pre>    @Test<br>    public void createPostWithoutToken() throws Exception {<br>        //@formatter:off<br>        given()<br>            .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;/posts&quot;)<br>        .then()<br>            .assertThat()<br>            .statusCode(HttpStatus.SC_UNAUTHORIZED);<br>        //@formatter:on<br>    }</pre><pre>    @Test<br>    public void createPost() throws Exception {<br>        //@formatter:off<br>        given()<br>            .auth().oauth2(token)<br>            .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;/posts&quot;)<br>        .then()<br>            .assertThat()<br>            .statusCode(HttpStatus.SC_CREATED)<br>            .header(&quot;Location&quot;, notNullValue());<br>        //@formatter:on<br>    }</pre><pre>}</pre><h4><strong>Grab a copy of the source codes from </strong><a href="https://github.com/hantsy/spring-security-auth0-sample/tree/master/api"><strong>my Github</strong></a><strong>.</strong></h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=41d579ca1e27" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">Secures REST APIs with Spring Security 5 and Auth0</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
