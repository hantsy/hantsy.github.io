<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building a Vertx application with Kotlin Coroutines
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-a-vertx-application-with-kotlin-coroutines/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building a Vertx application with Kotlin Coroutines" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the last post, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines. Photo by Yuzki Wang on Unsplash Follow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines. Firstly let’s have a look at the PostRepository. class PostRepository(private val client: PgPool) { suspend fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map { rs: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() }.await() suspend fun findById(id: UUID): Post? = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()) else null } .await() suspend fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&quot;id&quot;) } .await() suspend fun saveAll(data: List&lt;Post&gt;): Int? { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map { it.rowCount() } .await() } suspend fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } .await() suspend fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute() .map { it.rowCount() } .await() suspend fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map { it.rowCount() } .await() companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&gt; Post = { row: Row -&gt; Post( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ) } }} As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a suspended result. Let’s move to PostHandlers. class PostsHandler(val posts: PostRepository) { suspend fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); val data = posts.findAll() rc.response().end(Json.encode(data)).await() } suspend fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val data = posts.findById(uuid) if (data != null) { rc.response().end(Json.encode(data)).await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) val savedId = posts.save(Post(title = title, content = content)) rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;) .setStatusCode(201) .end() .await() } suspend fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) var existing: Post? = posts.findById(uuid) if (existing != null) { val data: Post = existing.apply { title = title content = content } posts.update(data) rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val existing = posts.findById(uuid) if (existing != null) { rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }} In the above codes, it uses sequential statements instead of Future with chained functionalities Eclipse Vertx Kotlin bindings provides a CooutineVerticle. class MainVerticle : CoroutineVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;) .use { f -&gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } override suspend fun start() { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true) vertx.createHttpServer(options) // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onComplete { println(&quot;HttpSever started at ${it.result().actualPort()}&quot;) } .await() } override suspend fun stop() { super.stop() } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;) .produces(&quot;application/json&quot;) .coroutineHandler { handlers.all(it) } router.post(&quot;/posts&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.save(it) } router.get(&quot;/posts/:id&quot;) .produces(&quot;application/json&quot;) .coroutineHandler { handlers.getById(it) } router.put(&quot;/posts/:id&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.update(it) } router.delete(&quot;/posts/:id&quot;) .coroutineHandler { handlers.delete(it) } router.route().failureHandler { if (it.failure() is PostNotFoundException) { it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &quot;message&quot; to &quot;${it.failure().message}&quot;, &quot;code&quot; to &quot;not_found&quot; ) }.toString() ) } } router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) } private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&gt; Unit) = handler { launch(it.vertx().dispatcher()) { try { fn(it) } catch (e: Exception) { it.fail(e) } } } } Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue vert-x3/vertx-lang-kotlin #194. Let’s convert the DataIntializer to use Kotlin Coroutines. class DataInitializer(private val client: PgPool) { suspend fun run() { LOGGER.info(&quot;Data initialization is starting...&quot;) val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;) val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;) val result = client .withTransaction { conn: SqlConnection -&gt; conn.query(&quot;DELETE FROM posts&quot;) .execute() .flatMap { conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&quot;SELECT * FROM posts&quot;) .execute() } }.await() result.forEach { println(it.toJson()) } LOGGER.info(&quot;Data initialization is done...&quot;) } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }} Get the example codes from my Github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with Kotlin Coroutines was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In the last post, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines. Photo by Yuzki Wang on Unsplash Follow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines. Firstly let’s have a look at the PostRepository. class PostRepository(private val client: PgPool) { suspend fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map { rs: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() }.await() suspend fun findById(id: UUID): Post? = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()) else null } .await() suspend fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&quot;id&quot;) } .await() suspend fun saveAll(data: List&lt;Post&gt;): Int? { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map { it.rowCount() } .await() } suspend fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } .await() suspend fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute() .map { it.rowCount() } .await() suspend fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map { it.rowCount() } .await() companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&gt; Post = { row: Row -&gt; Post( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ) } }} As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a suspended result. Let’s move to PostHandlers. class PostsHandler(val posts: PostRepository) { suspend fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); val data = posts.findAll() rc.response().end(Json.encode(data)).await() } suspend fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val data = posts.findById(uuid) if (data != null) { rc.response().end(Json.encode(data)).await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) val savedId = posts.save(Post(title = title, content = content)) rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;) .setStatusCode(201) .end() .await() } suspend fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) var existing: Post? = posts.findById(uuid) if (existing != null) { val data: Post = existing.apply { title = title content = content } posts.update(data) rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val existing = posts.findById(uuid) if (existing != null) { rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }} In the above codes, it uses sequential statements instead of Future with chained functionalities Eclipse Vertx Kotlin bindings provides a CooutineVerticle. class MainVerticle : CoroutineVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;) .use { f -&gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } override suspend fun start() { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true) vertx.createHttpServer(options) // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onComplete { println(&quot;HttpSever started at ${it.result().actualPort()}&quot;) } .await() } override suspend fun stop() { super.stop() } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;) .produces(&quot;application/json&quot;) .coroutineHandler { handlers.all(it) } router.post(&quot;/posts&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.save(it) } router.get(&quot;/posts/:id&quot;) .produces(&quot;application/json&quot;) .coroutineHandler { handlers.getById(it) } router.put(&quot;/posts/:id&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.update(it) } router.delete(&quot;/posts/:id&quot;) .coroutineHandler { handlers.delete(it) } router.route().failureHandler { if (it.failure() is PostNotFoundException) { it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &quot;message&quot; to &quot;${it.failure().message}&quot;, &quot;code&quot; to &quot;not_found&quot; ) }.toString() ) } } router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) } private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&gt; Unit) = handler { launch(it.vertx().dispatcher()) { try { fn(it) } catch (e: Exception) { it.fail(e) } } } } Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue vert-x3/vertx-lang-kotlin #194. Let’s convert the DataIntializer to use Kotlin Coroutines. class DataInitializer(private val client: PgPool) { suspend fun run() { LOGGER.info(&quot;Data initialization is starting...&quot;) val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;) val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;) val result = client .withTransaction { conn: SqlConnection -&gt; conn.query(&quot;DELETE FROM posts&quot;) .execute() .flatMap { conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&quot;SELECT * FROM posts&quot;) .execute() } }.await() result.forEach { println(it.toJson()) } LOGGER.info(&quot;Data initialization is done...&quot;) } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }} Get the example codes from my Github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with Kotlin Coroutines was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building a Vertx application with Kotlin Coroutines" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-23T00:00:00+00:00","datePublished":"2021-07-23T00:00:00+00:00","description":"In the last post, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines. Photo by Yuzki Wang on Unsplash Follow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines. Firstly let’s have a look at the PostRepository. class PostRepository(private val client: PgPool) { suspend fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map { rs: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() }.await() suspend fun findById(id: UUID): Post? = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()) else null } .await() suspend fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&quot;id&quot;) } .await() suspend fun saveAll(data: List&lt;Post&gt;): Int? { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map { it.rowCount() } .await() } suspend fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } .await() suspend fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute() .map { it.rowCount() } .await() suspend fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map { it.rowCount() } .await() companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&gt; Post = { row: Row -&gt; Post( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ) } }} As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a suspended result. Let’s move to PostHandlers. class PostsHandler(val posts: PostRepository) { suspend fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); val data = posts.findAll() rc.response().end(Json.encode(data)).await() } suspend fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val data = posts.findById(uuid) if (data != null) { rc.response().end(Json.encode(data)).await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) val savedId = posts.save(Post(title = title, content = content)) rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;) .setStatusCode(201) .end() .await() } suspend fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;\\npath param id: {0}\\nrequest body: {1}&quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) var existing: Post? = posts.findById(uuid) if (existing != null) { val data: Post = existing.apply { title = title content = content } posts.update(data) rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } suspend fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) val existing = posts.findById(uuid) if (existing != null) { rc.response().setStatusCode(204).end().await() } else { rc.fail(404, PostNotFoundException(uuid)) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }} In the above codes, it uses sequential statements instead of Future with chained functionalities Eclipse Vertx Kotlin bindings provides a CooutineVerticle. class MainVerticle : CoroutineVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;) .use { f -&gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } override suspend fun start() { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true) vertx.createHttpServer(options) // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onComplete { println(&quot;HttpSever started at ${it.result().actualPort()}&quot;) } .await() } override suspend fun stop() { super.stop() } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;) .produces(&quot;application/json&quot;) .coroutineHandler { handlers.all(it) } router.post(&quot;/posts&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.save(it) } router.get(&quot;/posts/:id&quot;) .produces(&quot;application/json&quot;) .coroutineHandler { handlers.getById(it) } router.put(&quot;/posts/:id&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .coroutineHandler { handlers.update(it) } router.delete(&quot;/posts/:id&quot;) .coroutineHandler { handlers.delete(it) } router.route().failureHandler { if (it.failure() is PostNotFoundException) { it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &quot;message&quot; to &quot;${it.failure().message}&quot;, &quot;code&quot; to &quot;not_found&quot; ) }.toString() ) } } router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) } private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&gt; Unit) = handler { launch(it.vertx().dispatcher()) { try { fn(it) } catch (e: Exception) { it.fail(e) } } } } Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue vert-x3/vertx-lang-kotlin #194. Let’s convert the DataIntializer to use Kotlin Coroutines. class DataInitializer(private val client: PgPool) { suspend fun run() { LOGGER.info(&quot;Data initialization is starting...&quot;) val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;) val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;) val result = client .withTransaction { conn: SqlConnection -&gt; conn.query(&quot;DELETE FROM posts&quot;) .execute() .flatMap { conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&quot;SELECT * FROM posts&quot;) .execute() } }.await() result.forEach { println(it.toJson()) } LOGGER.info(&quot;Data initialization is done...&quot;) } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }} Get the example codes from my Github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with Kotlin Coroutines was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building a Vertx application with Kotlin Coroutines","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-a-vertx-application-with-kotlin-coroutines/"},"url":"/blog/2021/building-a-vertx-application-with-kotlin-coroutines/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building a Vertx application with Kotlin Coroutines</h1>
    <p class="post-meta">July 23, 2021</p>
  </header>

  <article class="post-content">
    <p>In <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/kotlin.md">the last post</a>, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zi-wSXYA9KsoR2ALXGWNwg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@yuzkiwww?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Yuzki Wang</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Follow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines.</p><p>Firstly let’s have a look at the PostRepository.</p><pre>class PostRepository(private val client: PgPool) {</pre><pre>    suspend fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;)<br>        .execute()<br>        .map { rs: RowSet&lt;Row?&gt; -&gt;<br>            StreamSupport.stream(rs.spliterator(), false)<br>                .map { mapFun(it!!) }<br>                .toList()<br>        }.await()<br></pre><pre>    suspend fun findById(id: UUID): Post? = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;)<br>        .execute(Tuple.of(id))<br>        .map { it.iterator() }<br>        .map { if (it.hasNext()) mapFun(it.next()) else null }<br>        .await()<br></pre><pre>    suspend fun save(data: Post) =<br>        client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;)<br>            .execute(Tuple.of(data.title, data.content))<br>            .map { it.iterator().next().getUUID(&quot;id&quot;) }<br>            .await()<br></pre><pre>    suspend fun saveAll(data: List&lt;Post&gt;): Int? {<br>        val tuples = data.map { Tuple.of(it.title, it.content) }</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .executeBatch(tuples)<br>            .map { it.rowCount() }<br>            .await()<br>    }</pre><pre>    suspend fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>        .execute(Tuple.of(data.title, data.content, data.id))<br>        .map { it.rowCount() }<br>        .await()<br></pre><pre>    suspend fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute()<br>        .map { it.rowCount() }<br>        .await()<br></pre><pre>    suspend fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>        .map { it.rowCount() }<br>        .await()</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostRepository::class.java.name)<br>        val mapFun: (Row) -&gt; Post = { row: Row -&gt;<br>            Post(<br>                row.getUUID(&quot;id&quot;),<br>                row.getString(&quot;title&quot;),<br>                row.getString(&quot;content&quot;),<br>                row.getLocalDateTime(&quot;created_at&quot;)<br>            )<br>        }</pre><pre>    }<br>}</pre><p>As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a <em>suspended</em> result.</p><p>Let’s move to PostHandlers.</p><pre>class PostsHandler(val posts: PostRepository) {<br>    suspend fun all(rc: RoutingContext) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        val data = posts.findAll()<br>        rc.response().end(Json.encode(data)).await()<br>    }</pre><pre>    suspend fun getById(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        val data = posts.findById(uuid)<br>        if (data != null) {<br>            rc.response().end(Json.encode(data)).await()<br>        } else {<br>            rc.fail(404, PostNotFoundException(uuid))<br>        }<br>    }</pre><pre>    suspend fun save(rc: RoutingContext) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body)<br>        val (title, content) = body.mapTo(CreatePostCommand::class.java)<br>        val savedId = posts.save(Post(title = title, content = content))<br>        rc.response()<br>            .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;)<br>            .setStatusCode(201)<br>            .end()<br>            .await()</pre><pre>    }</pre><pre>    suspend fun update(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body))<br>        var (title, content) = body.mapTo(CreatePostCommand::class.java)</pre><pre>        var existing: Post? = posts.findById(uuid)<br>        if (existing != null) {<br>            val data: Post = existing.apply {<br>                title = title<br>                content = content<br>            }<br>            posts.update(data)<br>            rc.response().setStatusCode(204).end().await()<br>        } else {<br>            rc.fail(404, PostNotFoundException(uuid))<br>        }<br>    }</pre><pre>    suspend fun delete(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        val existing = posts.findById(uuid)<br>        if (existing != null) {<br>            rc.response().setStatusCode(204).end().await()<br>        } else {<br>            rc.fail(404, PostNotFoundException(uuid))<br>        }<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName)<br>    }<br>}</pre><p>In the above codes, it uses sequential statements instead of Future with chained functionalities</p><p>Eclipse Vertx Kotlin bindings provides a CooutineVerticle.</p><pre>class MainVerticle : CoroutineVerticle() {<br>    companion object {<br>        private val LOGGER = Logger.getLogger(MainVerticle::class.java.name)</pre><pre>        /**<br>         * Configure logging from logging.properties file.<br>         * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties<br>         * or set java.util.logging.config.file system property to locate the properties file.<br>         */<br>        @Throws(IOException::class)<br>        private fun setupLogging() {<br>            MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;)<br>                .use { f -&gt; LogManager.getLogManager().readConfiguration(f) }<br>        }</pre><pre>        init {<br>            LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;)<br>            val objectMapper = DatabindCodec.mapper()<br>            objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br>            objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            val module = JavaTimeModule()<br>            objectMapper.registerModule(module)<br>        }<br>    }</pre><pre>    override suspend fun start() {<br>        LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;)<br>        //setupLogging();</pre><pre>        //Create a PgPool instance<br>        val pgPool = pgPool()</pre><pre>        //Creating PostRepository<br>        val postRepository = PostRepository(pgPool)</pre><pre>        //Creating PostHandler<br>        val postHandlers = PostsHandler(postRepository)</pre><pre>        // Initializing the sample data<br>        val initializer = DataInitializer(pgPool)<br>        initializer.run()</pre><pre>        // Configure routes<br>        val router = routes(postHandlers)</pre><pre>        // Create the HTTP server<br>        val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true)<br>        vertx.createHttpServer(options) // Handle every request using the router<br>            .requestHandler(router) // Start listening<br>            .listen(8888) // Print the port<br>            .onComplete { println(&quot;HttpSever started at ${it.result().actualPort()}&quot;) }<br>            .await()<br>    }</pre><pre>    override suspend fun stop() {<br>        super.stop()<br>    }</pre><pre>    //create routes<br>    private fun routes(handlers: PostsHandler): Router {</pre><pre>        // Create a Router<br>        val router = Router.router(vertx)<br>        // register BodyHandler globally.<br>        //router.route().handler(BodyHandler.create());</pre><pre>        router.get(&quot;/posts&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .coroutineHandler {<br>                handlers.all(it)<br>            }</pre><pre>        router.post(&quot;/posts&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .coroutineHandler {<br>                handlers.save(it)<br>            }</pre><pre>        router.get(&quot;/posts/:id&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .coroutineHandler {<br>                handlers.getById(it)<br>            }<br></pre><pre>        router.put(&quot;/posts/:id&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .coroutineHandler {<br>                handlers.update(it)<br>            }</pre><pre>        router.delete(&quot;/posts/:id&quot;)<br>            .coroutineHandler {<br>                handlers.delete(it)<br>            }</pre><pre>        router.route().failureHandler {<br>            if (it.failure() is PostNotFoundException) {<br>                it.response()<br>                    .setStatusCode(404)<br>                    .end(<br>                        json {// an example using JSON DSL<br>                            obj(<br>                                &quot;message&quot; to &quot;${it.failure().message}&quot;,<br>                                &quot;code&quot; to &quot;not_found&quot;<br>                            )<br>                        }.toString()<br>                    )<br>            }<br>        }</pre><pre>        router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) }</pre><pre>        return router<br>    }</pre><pre>    private fun pgPool(): PgPool {<br>        val connectOptions = PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;)</pre><pre>        // Pool Options<br>        val poolOptions = PoolOptions().setMaxSize(5)</pre><pre>        // Create the pool from the data object<br>        return PgPool.pool(vertx, connectOptions, poolOptions)<br>    }</pre><pre>    private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&gt; Unit) = handler {<br>        launch(it.vertx().dispatcher()) {<br>            try {<br>                fn(it)<br>            } catch (e: Exception) {<br>                it.fail(e)<br>            }<br>        }<br>    }</pre><pre>}</pre><p>Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue <a href="https://github.com/vert-x3/vertx-lang-kotlin/issues/194">vert-x3/vertx-lang-kotlin #194</a>.</p><p>Let’s convert the DataIntializer to use Kotlin Coroutines.</p><pre>class DataInitializer(private val client: PgPool) {</pre><pre>    suspend fun run() {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;)<br>        val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;)<br>        val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;)<br></pre><pre>        val result = client<br>            .withTransaction { conn: SqlConnection -&gt;<br>                conn.query(&quot;DELETE FROM posts&quot;)<br>                    .execute()<br>                    .flatMap {<br>                        conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>                            .executeBatch(listOf(first, second))<br>                    }<br>                    .flatMap {<br>                        conn.query(&quot;SELECT * FROM posts&quot;)<br>                            .execute()<br>                    }</pre><pre>            }.await()</pre><pre>        result.forEach { println(it.toJson()) }<br>        LOGGER.info(&quot;Data initialization is done...&quot;)<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(DataInitializer::class.java.name)<br>    }<br>}</pre><p>Get <a href="https://github.com/hantsy/vertx-sandbox/tree/master/kotlin">the example codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c7dbb7ad893" width="1" height="1" alt=""><hr><p><a href="https://medium.com/nerd-for-tech/building-a-vertx-application-with-kotlin-coroutines-6c7dbb7ad893">Building a Vertx application with Kotlin Coroutines</a> was originally published in <a href="https://medium.com/nerd-for-tech">Nerd For Tech</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
