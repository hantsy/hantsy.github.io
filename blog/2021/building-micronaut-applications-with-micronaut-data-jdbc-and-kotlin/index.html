<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building Micronaut applications with Micronaut Data Jdbc and Kotlin
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building Micronaut applications with Micronaut Data Jdbc and Kotlin" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest. Photo by mingwei dong on Unsplash Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: KotlinBuild tool: GradleTest framework: KotestIncluded Features: data-jdbc, postgres, etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. Create an Entity class. @MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()) Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted. The status is an enum class. enum class Status { DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED} Note: The ID and GeneratedValue is from io.micronaut.data.annotation package. Create a Repository for Post Entity class. @JdbcRepositoryinterface PostRepository : PageableRepository&lt;Post, UUID&gt; Here we used a JdbcRepository to indicate this Repository is a data-jdbc Repository. Create a bean to initialize some sample data. @Singleton@Requires(notEnv = [&quot;mock&quot;])class DataInitializer(private val posts: PostRepository) { @EventListener fun onStartUp(e: ServerStartupEvent) { log.info(&quot;starting data initialization at ServerStartupEvent: $e&quot;) posts.deleteAll() val data = listOf( Post(title = &quot;Building Restful APIs with Micronaut and Kotlin&quot;, content = &quot;test&quot;), Post(title = &quot;Building Restful APIs with Micronaut and Kotlin: part 2&quot;, content = &quot;test&quot;) ) data.forEach { log.debug(&quot;saving: $it&quot;) } posts.saveAll(data).forEach { log.debug(&quot;saved post: $it&quot;) } log.info(&quot;data initialization is done...&quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) } } Now create a controller to expose RESTful APIs. @Controller(&quot;/posts&quot;)class PostController(private val posts: PostRepository) { @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&lt;List&lt;Post&gt;&gt; = ok(posts.findAll().toList()) @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON]) fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) fun create(@Body body: Post): HttpResponse&lt;Any&gt; { val saved = posts.save(body) return created(URI.create(&quot;/posts/&quot; + saved.id)) }} Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the application.yaml. Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the docker-compose.yaml. # docker compose up postgres Now run the application. # gradlew run // or # gradlew build# java build/xxx.jar You can use curl command to test the /posts endpoint. # curl http://localhost:8080/posts Query by Specification If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the data-jdbc also supports query by JPA Specification. Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies. Change PostRepository, make it extends JpaSpecificationExecutor. @JdbcRepositoryinterface PostRepository : PageableRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification. object Specifications { fun titleLike(title: String): PredicateSpecification&lt;Post&gt; { return PredicateSpecification&lt;Post&gt; { root, criteriaBuilder -&gt; criteriaBuilder.like( root.get(&quot;title&quot;), &quot;%$title%&quot; ) } } fun byKeyword(q: String): QuerySpecification&lt;Post&gt; { return QuerySpecification&lt;Post&gt; { root, query, criteriaBuilder -&gt; criteriaBuilder.or( criteriaBuilder.like(root.get(&quot;title&quot;), &quot;%$q%&quot;), criteriaBuilder.like(root.get(&quot;content&quot;), &quot;%$q%&quot;) ) } } fun rejectAllPendingModerated(): UpdateSpecification&lt;Post&gt; { return UpdateSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt; query.set(root.get(&quot;status&quot;), Status.REJECTED) criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.PENDING_MODERATED) } } fun removeAllRejected(): DeleteSpecification&lt;Post&gt; { return DeleteSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt; criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.REJECTED) } } } Let’s create some tests to verify these Specifications. @MicronautTest(environments = [Environment.TEST], startApplication = false)open class PostRepositoryAnnotationSpec() : AnnotationSpec() { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } @Inject private lateinit var posts: PostRepository @Inject private lateinit var template: JdbcOperations @Inject private lateinit var tx: TransactionOperations&lt;Any&gt; @BeforeEach fun beforeEach() { val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt; val sql = &quot;delete from posts&quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&quot;deleted $cnt&quot;); } @Test fun `test save and find posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } @Test fun `find by title`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } @Test fun `find by keyword`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } @Test fun `update posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } @Test fun `remove posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;REJECTED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } }} Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests. In this application, we use Kotest as testing framework. Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest. The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework. Kotest The simplest is SpringSpec, use a string to describe functionality. Let&#39;s rewrite the above testing codes with StringSepc. @MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: JdbcOperations, private val tx: TransactionOperations&lt;Any&gt;) : StringSpec({ &quot;test save and find posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } &quot;find by title&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } &quot;find by keyword&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } &quot;update posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } &quot;remove posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;REJECTED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } }) { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } override fun beforeEach(testCase: TestCase) { val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt; val sql = &quot;delete from posts&quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&quot;deleted $cnt&quot;); }} Create a test to test PostController, here we use FunSpec which wraps tests in a test method block. @MicronautTest(environments = [&quot;mock&quot;])class PostControllerTest( private val postsBean: PostRepository, @Client(&quot;/&quot;) private var client: HttpClient) : FunSpec({ test(&quot;test get posts endpoint&quot;) { val posts = getMock(postsBean) every { posts.findAll() } .returns( listOf( Post( id = UUID.randomUUID(), title = &quot;test title&quot;, content = &quot;test content&quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &quot;test title&quot; verify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun posts() = mockk&lt;PostRepository&gt;()} Here we use mockk to create a mocked PostRepository and the MockBean is located in the body of SpringSpec. The following is an integration example which use SpringSpec . @MicronautTestclass IntegrationTests( private val application: EmbeddedApplication&lt;*&gt;, @Client(&quot;/&quot;) private val client: HttpClient) : StringSpec({ &quot;test the server is running&quot; { assert(application.isRunning) } &quot;test GET /posts endpoint&quot; { val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &quot;Micronaut&quot; } }}) Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Data Jdbc and Kotlin was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest. Photo by mingwei dong on Unsplash Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: KotlinBuild tool: GradleTest framework: KotestIncluded Features: data-jdbc, postgres, etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. Create an Entity class. @MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()) Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted. The status is an enum class. enum class Status { DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED} Note: The ID and GeneratedValue is from io.micronaut.data.annotation package. Create a Repository for Post Entity class. @JdbcRepositoryinterface PostRepository : PageableRepository&lt;Post, UUID&gt; Here we used a JdbcRepository to indicate this Repository is a data-jdbc Repository. Create a bean to initialize some sample data. @Singleton@Requires(notEnv = [&quot;mock&quot;])class DataInitializer(private val posts: PostRepository) { @EventListener fun onStartUp(e: ServerStartupEvent) { log.info(&quot;starting data initialization at ServerStartupEvent: $e&quot;) posts.deleteAll() val data = listOf( Post(title = &quot;Building Restful APIs with Micronaut and Kotlin&quot;, content = &quot;test&quot;), Post(title = &quot;Building Restful APIs with Micronaut and Kotlin: part 2&quot;, content = &quot;test&quot;) ) data.forEach { log.debug(&quot;saving: $it&quot;) } posts.saveAll(data).forEach { log.debug(&quot;saved post: $it&quot;) } log.info(&quot;data initialization is done...&quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) } } Now create a controller to expose RESTful APIs. @Controller(&quot;/posts&quot;)class PostController(private val posts: PostRepository) { @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&lt;List&lt;Post&gt;&gt; = ok(posts.findAll().toList()) @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON]) fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) fun create(@Body body: Post): HttpResponse&lt;Any&gt; { val saved = posts.save(body) return created(URI.create(&quot;/posts/&quot; + saved.id)) }} Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the application.yaml. Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the docker-compose.yaml. # docker compose up postgres Now run the application. # gradlew run // or # gradlew build# java build/xxx.jar You can use curl command to test the /posts endpoint. # curl http://localhost:8080/posts Query by Specification If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the data-jdbc also supports query by JPA Specification. Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies. Change PostRepository, make it extends JpaSpecificationExecutor. @JdbcRepositoryinterface PostRepository : PageableRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification. object Specifications { fun titleLike(title: String): PredicateSpecification&lt;Post&gt; { return PredicateSpecification&lt;Post&gt; { root, criteriaBuilder -&gt; criteriaBuilder.like( root.get(&quot;title&quot;), &quot;%$title%&quot; ) } } fun byKeyword(q: String): QuerySpecification&lt;Post&gt; { return QuerySpecification&lt;Post&gt; { root, query, criteriaBuilder -&gt; criteriaBuilder.or( criteriaBuilder.like(root.get(&quot;title&quot;), &quot;%$q%&quot;), criteriaBuilder.like(root.get(&quot;content&quot;), &quot;%$q%&quot;) ) } } fun rejectAllPendingModerated(): UpdateSpecification&lt;Post&gt; { return UpdateSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt; query.set(root.get(&quot;status&quot;), Status.REJECTED) criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.PENDING_MODERATED) } } fun removeAllRejected(): DeleteSpecification&lt;Post&gt; { return DeleteSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt; criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.REJECTED) } } } Let’s create some tests to verify these Specifications. @MicronautTest(environments = [Environment.TEST], startApplication = false)open class PostRepositoryAnnotationSpec() : AnnotationSpec() { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } @Inject private lateinit var posts: PostRepository @Inject private lateinit var template: JdbcOperations @Inject private lateinit var tx: TransactionOperations&lt;Any&gt; @BeforeEach fun beforeEach() { val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt; val sql = &quot;delete from posts&quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&quot;deleted $cnt&quot;); } @Test fun `test save and find posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } @Test fun `find by title`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } @Test fun `find by keyword`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } @Test fun `update posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } @Test fun `remove posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;REJECTED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } }} Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests. In this application, we use Kotest as testing framework. Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest. The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework. Kotest The simplest is SpringSpec, use a string to describe functionality. Let&#39;s rewrite the above testing codes with StringSepc. @MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: JdbcOperations, private val tx: TransactionOperations&lt;Any&gt;) : StringSpec({ &quot;test save and find posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } &quot;find by title&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } &quot;find by keyword&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } &quot;update posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } &quot;remove posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;REJECTED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } }) { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } override fun beforeEach(testCase: TestCase) { val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt; val sql = &quot;delete from posts&quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&quot;deleted $cnt&quot;); }} Create a test to test PostController, here we use FunSpec which wraps tests in a test method block. @MicronautTest(environments = [&quot;mock&quot;])class PostControllerTest( private val postsBean: PostRepository, @Client(&quot;/&quot;) private var client: HttpClient) : FunSpec({ test(&quot;test get posts endpoint&quot;) { val posts = getMock(postsBean) every { posts.findAll() } .returns( listOf( Post( id = UUID.randomUUID(), title = &quot;test title&quot;, content = &quot;test content&quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &quot;test title&quot; verify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun posts() = mockk&lt;PostRepository&gt;()} Here we use mockk to create a mocked PostRepository and the MockBean is located in the body of SpringSpec. The following is an integration example which use SpringSpec . @MicronautTestclass IntegrationTests( private val application: EmbeddedApplication&lt;*&gt;, @Client(&quot;/&quot;) private val client: HttpClient) : StringSpec({ &quot;test the server is running&quot; { assert(application.isRunning) } &quot;test GET /posts endpoint&quot; { val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &quot;Micronaut&quot; } }}) Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Data Jdbc and Kotlin was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building Micronaut applications with Micronaut Data Jdbc and Kotlin" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-12-02T00:00:00+00:00","datePublished":"2021-12-02T00:00:00+00:00","description":"Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest. Photo by mingwei dong on Unsplash Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: KotlinBuild tool: GradleTest framework: KotestIncluded Features: data-jdbc, postgres, etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. Create an Entity class. @MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()) Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted. The status is an enum class. enum class Status { DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED} Note: The ID and GeneratedValue is from io.micronaut.data.annotation package. Create a Repository for Post Entity class. @JdbcRepositoryinterface PostRepository : PageableRepository&lt;Post, UUID&gt; Here we used a JdbcRepository to indicate this Repository is a data-jdbc Repository. Create a bean to initialize some sample data. @Singleton@Requires(notEnv = [&quot;mock&quot;])class DataInitializer(private val posts: PostRepository) { @EventListener fun onStartUp(e: ServerStartupEvent) { log.info(&quot;starting data initialization at ServerStartupEvent: $e&quot;) posts.deleteAll() val data = listOf( Post(title = &quot;Building Restful APIs with Micronaut and Kotlin&quot;, content = &quot;test&quot;), Post(title = &quot;Building Restful APIs with Micronaut and Kotlin: part 2&quot;, content = &quot;test&quot;) ) data.forEach { log.debug(&quot;saving: $it&quot;) } posts.saveAll(data).forEach { log.debug(&quot;saved post: $it&quot;) } log.info(&quot;data initialization is done...&quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) } } Now create a controller to expose RESTful APIs. @Controller(&quot;/posts&quot;)class PostController(private val posts: PostRepository) { @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&lt;List&lt;Post&gt;&gt; = ok(posts.findAll().toList()) @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON]) fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) fun create(@Body body: Post): HttpResponse&lt;Any&gt; { val saved = posts.save(body) return created(URI.create(&quot;/posts/&quot; + saved.id)) }} Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the application.yaml. Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the docker-compose.yaml. # docker compose up postgres Now run the application. # gradlew run // or # gradlew build# java build/xxx.jar You can use curl command to test the /posts endpoint. # curl http://localhost:8080/posts Query by Specification If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the data-jdbc also supports query by JPA Specification. Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies. Change PostRepository, make it extends JpaSpecificationExecutor. @JdbcRepositoryinterface PostRepository : PageableRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification. object Specifications { fun titleLike(title: String): PredicateSpecification&lt;Post&gt; { return PredicateSpecification&lt;Post&gt; { root, criteriaBuilder -&gt; criteriaBuilder.like( root.get(&quot;title&quot;), &quot;%$title%&quot; ) } } fun byKeyword(q: String): QuerySpecification&lt;Post&gt; { return QuerySpecification&lt;Post&gt; { root, query, criteriaBuilder -&gt; criteriaBuilder.or( criteriaBuilder.like(root.get(&quot;title&quot;), &quot;%$q%&quot;), criteriaBuilder.like(root.get(&quot;content&quot;), &quot;%$q%&quot;) ) } } fun rejectAllPendingModerated(): UpdateSpecification&lt;Post&gt; { return UpdateSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt; query.set(root.get(&quot;status&quot;), Status.REJECTED) criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.PENDING_MODERATED) } } fun removeAllRejected(): DeleteSpecification&lt;Post&gt; { return DeleteSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt; criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.REJECTED) } } } Let’s create some tests to verify these Specifications. @MicronautTest(environments = [Environment.TEST], startApplication = false)open class PostRepositoryAnnotationSpec() : AnnotationSpec() { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } @Inject private lateinit var posts: PostRepository @Inject private lateinit var template: JdbcOperations @Inject private lateinit var tx: TransactionOperations&lt;Any&gt; @BeforeEach fun beforeEach() { val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt; val sql = &quot;delete from posts&quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&quot;deleted $cnt&quot;); } @Test fun `test save and find posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } @Test fun `find by title`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } @Test fun `find by keyword`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } @Test fun `update posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } @Test fun `remove posts`() { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;REJECTED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } }} Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests. In this application, we use Kotest as testing framework. Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest. The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework. Kotest The simplest is SpringSpec, use a string to describe functionality. Let&#39;s rewrite the above testing codes with StringSepc. @MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: JdbcOperations, private val tx: TransactionOperations&lt;Any&gt;) : StringSpec({ &quot;test save and find posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } &quot;find by title&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.executeUpdate() } insertedCnt shouldBeEqualComparingTo 1 val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } &quot;find by keyword&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)) log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)) log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } &quot;update posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;PENDING_MODERATED&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } &quot;remove posts&quot; { val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;; val insertedCnt = template.prepareStatement(sql) { it.setString(1, &quot;test title&quot;) it.setString(2, &quot;test content&quot;) it.setString(3, &quot;REJECTED&quot;) it.addBatch() it.setString(1, &quot;test2 title&quot;) it.setString(2, &quot;test2 content&quot;) it.setString(3, &quot;DRAFT&quot;) it.addBatch() it.executeBatch() } insertedCnt.any { it == 1 } val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } }) { companion object { private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java) } override fun beforeEach(testCase: TestCase) { val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt; val sql = &quot;delete from posts&quot;; this.template.prepareStatement(sql) { it.executeUpdate() } } val cnt = tx.executeWrite(callback) println(&quot;deleted $cnt&quot;); }} Create a test to test PostController, here we use FunSpec which wraps tests in a test method block. @MicronautTest(environments = [&quot;mock&quot;])class PostControllerTest( private val postsBean: PostRepository, @Client(&quot;/&quot;) private var client: HttpClient) : FunSpec({ test(&quot;test get posts endpoint&quot;) { val posts = getMock(postsBean) every { posts.findAll() } .returns( listOf( Post( id = UUID.randomUUID(), title = &quot;test title&quot;, content = &quot;test content&quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &quot;test title&quot; verify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun posts() = mockk&lt;PostRepository&gt;()} Here we use mockk to create a mocked PostRepository and the MockBean is located in the body of SpringSpec. The following is an integration example which use SpringSpec . @MicronautTestclass IntegrationTests( private val application: EmbeddedApplication&lt;*&gt;, @Client(&quot;/&quot;) private val client: HttpClient) : StringSpec({ &quot;test the server is running&quot; { assert(application.isRunning) } &quot;test GET /posts endpoint&quot; { val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &quot;Micronaut&quot; } }}) Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Data Jdbc and Kotlin was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building Micronaut applications with Micronaut Data Jdbc and Kotlin","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin/"},"url":"/blog/2021/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building Micronaut applications with Micronaut Data Jdbc and Kotlin</h1>
    <p class="post-meta">December 2, 2021</p>
  </header>

  <article class="post-content">
    <p>Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vpMi-XOcWMHQnUiqVqNeOg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@dongmingwei?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">mingwei dong</a> on <a href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h3>Getting Started</h3><p>Open your browser and navigate to <a href="https://micronaut.io/launch">Micronaut Launch</a> to generate a new project skeleton for this post. Select the following items on this page.</p><ul><li>Java version: <strong>17</strong></li><li>Language: <strong>Kotlin</strong></li><li>Build tool: <strong>Gradle</strong></li><li>Test framework: <strong>Kotest</strong></li><li>Included Features: <strong>data-jdbc</strong>, <strong>postgres</strong>, etc.</li></ul><p>Click <strong>GENERATE PROJECT</strong> button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p><p>Create an Entity class.</p><pre>@MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)<br>data class Post(<br>    @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null,<br>    var title: String,<br>    var content: String,<br>    var status: Status? = Status.DRAFT,<br>    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()<br>)</pre><p>Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted.</p><p>The status is an enum class.</p><pre>enum class Status {<br>    DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED<br>}</pre><blockquote><em>Note: The </em><em>ID and </em><em>GeneratedValue is from </em><em>io.micronaut.data.annotation package.</em></blockquote><p>Create a Repository for Post Entity class.</p><pre>@JdbcRepository<br>interface PostRepository : PageableRepository&lt;Post, UUID&gt;</pre><p>Here we used a JdbcRepository to indicate this Repository is a <strong>data-jdbc</strong> Repository.</p><p>Create a bean to initialize some sample data.</p><pre>@Singleton<br>@Requires(notEnv = [&quot;mock&quot;])<br>class DataInitializer(private val posts: PostRepository) {</pre><pre>    @EventListener<br>    fun onStartUp(e: ServerStartupEvent) {<br>        log.info(&quot;starting data initialization at ServerStartupEvent: $e&quot;)</pre><pre>        posts.deleteAll()</pre><pre>        val data = listOf(<br>            Post(title = &quot;Building Restful APIs with Micronaut and Kotlin&quot;, content = &quot;test&quot;),<br>            Post(title = &quot;Building Restful APIs with Micronaut and Kotlin: part 2&quot;, content = &quot;test&quot;)<br>        )<br>        data.forEach { log.debug(&quot;saving: $it&quot;) }<br>        posts.saveAll(data).forEach { log.debug(&quot;saved post: $it&quot;) }<br>        log.info(&quot;data initialization is done...&quot;)<br>    }</pre><pre>    companion object DataInitializer {<br>        private val log = LoggerFactory.getLogger(DataInitializer::class.java)<br>    }</pre><pre>}</pre><p>Now create a controller to expose RESTful APIs.</p><pre>@Controller(&quot;/posts&quot;)<br>class PostController(private val posts: PostRepository) {</pre><pre>    @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON])<br>    fun all(): HttpResponse&lt;List&lt;Post&gt;&gt; = ok(posts.findAll().toList())</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON])<br>    fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {<br>        val post = posts.findById(id) ?: return notFound()<br>        return ok(post)<br>    }</pre><pre>    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])<br>    fun create(@Body body: Post): HttpResponse&lt;Any&gt; {<br>        val saved = posts.save(body)<br>        return created(URI.create(&quot;/posts/&quot; + saved.id))<br>    }<br>}</pre><p>Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the <em>application.yaml</em>.</p><p>Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the <em>docker-compose.yaml</em>.</p><pre># docker compose up postgres</pre><p>Now run the application.</p><pre># gradlew run <br>// or <br># gradlew build<br># java build/xxx.jar</pre><p>You can use curl command to test the <em>/posts</em> endpoint.</p><pre># curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a></pre><h3>Query by Specification</h3><p>If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the <strong>data-jdbc</strong> also supports query by JPA Specification.</p><p>Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies.</p><p>Change PostRepository, make it extends JpaSpecificationExecutor.</p><pre>@JdbcRepository<br>interface PostRepository : PageableRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt;</pre><p>Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification.</p><pre>object Specifications {</pre><pre>    fun titleLike(title: String): PredicateSpecification&lt;Post&gt; {<br>        return PredicateSpecification&lt;Post&gt; { root, criteriaBuilder -&gt;<br>            criteriaBuilder.like(<br>                root.get(&quot;title&quot;),<br>                &quot;%$title%&quot;<br>            )<br>        }<br>    }</pre><pre>    fun byKeyword(q: String): QuerySpecification&lt;Post&gt; {<br>        return QuerySpecification&lt;Post&gt; { root, query, criteriaBuilder -&gt;<br>            criteriaBuilder.or(<br>                criteriaBuilder.like(root.get(&quot;title&quot;), &quot;%$q%&quot;),<br>                criteriaBuilder.like(root.get(&quot;content&quot;), &quot;%$q%&quot;)<br>            )<br>        }<br>    }</pre><pre>    fun rejectAllPendingModerated(): UpdateSpecification&lt;Post&gt; {<br>        return UpdateSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt;<br>            query.set(root.get(&quot;status&quot;), Status.REJECTED)<br>            criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.PENDING_MODERATED)<br>        }<br>    }</pre><pre>    fun removeAllRejected(): DeleteSpecification&lt;Post&gt; {<br>        return DeleteSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt;<br>            criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.REJECTED)<br>        }<br>    }</pre><pre>}</pre><p>Let’s create some tests to verify these Specifications.</p><pre>@MicronautTest(environments = [Environment.TEST], startApplication = false)<br>open class PostRepositoryAnnotationSpec() : AnnotationSpec() {<br>    companion object {<br>        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)<br>    }</pre><pre>    @Inject<br>    private lateinit var posts: PostRepository</pre><pre>    @Inject<br>    private lateinit var template: JdbcOperations</pre><pre>    @Inject<br>    private lateinit var tx: TransactionOperations&lt;Any&gt;</pre><pre>    @BeforeEach<br>    fun beforeEach() {<br>        val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt;<br>            val sql = &quot;delete from posts&quot;;<br>            this.template.prepareStatement(sql) {<br>                it.executeUpdate()<br>            }<br>        }</pre><pre>        val cnt = tx.executeWrite(callback)<br>        println(&quot;deleted $cnt&quot;);<br>    }</pre><pre>    @Test<br>    fun `test save and find posts`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        log.debug(&quot;all posts: $all&quot;)<br>        all.map { it.title }.forAny { it shouldContain &quot;test&quot; }<br>    }</pre><pre>    @Test<br>    fun `find by title`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll(Specifications.titleLike(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 1</pre><pre>        val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 0<br>    }</pre><pre>    @Test<br>    fun `find by keyword`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 2</pre><pre>        val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 1<br>    }</pre><pre>    @Test<br>    fun `update posts`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br>        log.debug(&quot;updated posts size:{}&quot;, updated)<br>        updated shouldBe 2</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 2<br>        all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br>    }</pre><pre>    @Test<br>    fun `remove posts`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;REJECTED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val deleted = posts.deleteAll(Specifications.removeAllRejected())<br>        log.debug(&quot;deleted posts size:{}&quot;, deleted)<br>        deleted shouldBe 1</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br>    }<br>}</pre><p>Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests.</p><p>In this application, we use Kotest as testing framework.</p><p>Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest.</p><p>The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework.</p><h3>Kotest</h3><p>The simplest is SpringSpec, use a <em>string</em> to describe functionality. Let&#39;s rewrite the above testing codes with StringSepc.</p><pre>@MicronautTest(environments = [Environment.TEST], startApplication = false)<br>class PostRepositoryTest(<br>    private val posts: PostRepository,<br>    private val template: JdbcOperations,<br>    private val tx: TransactionOperations&lt;Any&gt;<br>) : StringSpec({</pre><pre>    &quot;test save and find posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        log.debug(&quot;all posts: $all&quot;)<br>        all.map { it.title }.forAny { it shouldContain &quot;test&quot; }<br>    }</pre><pre>    &quot;find by title&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll(Specifications.titleLike(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 1</pre><pre>        val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 0<br>    }</pre><pre>    &quot;find by keyword&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 2</pre><pre>        val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 1<br>    }</pre><pre>    &quot;update posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br>        log.debug(&quot;updated posts size:{}&quot;, updated)<br>        updated shouldBe 2</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 2<br>        all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br>    }</pre><pre>    &quot;remove posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;REJECTED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val deleted = posts.deleteAll(Specifications.removeAllRejected())<br>        log.debug(&quot;deleted posts size:{}&quot;, deleted)<br>        deleted shouldBe 1</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br>    }</pre><pre>}) {<br>    companion object {<br>        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)<br>    }</pre><pre>    override fun beforeEach(testCase: TestCase) {<br>        val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt;<br>            val sql = &quot;delete from posts&quot;;<br>            this.template.prepareStatement(sql) {<br>                it.executeUpdate()<br>            }<br>        }</pre><pre>        val cnt = tx.executeWrite(callback)<br>        println(&quot;deleted $cnt&quot;);<br>    }<br>}</pre><p>Create a test to test PostController, here we use FunSpec which wraps tests in a test method block.</p><pre>@MicronautTest(environments = [&quot;mock&quot;])<br>class PostControllerTest(<br>    private val postsBean: PostRepository,<br>    @Client(&quot;/&quot;) private var client: HttpClient<br>) : FunSpec({</pre><pre>    test(&quot;test get posts endpoint&quot;) {<br>        val posts = getMock(postsBean)<br>        every { posts.findAll() }<br>            .returns(<br>                listOf(<br>                    Post(<br>                        id = UUID.randomUUID(),<br>                        title = &quot;test title&quot;,<br>                        content = &quot;test content&quot;,<br>                        status = Status.DRAFT,<br>                        createdAt = LocalDateTime.now()<br>                    )<br>                )<br>            )<br>        val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java)</pre><pre>        response.status shouldBe HttpStatus.OK<br>        response.body()!![0].title shouldBe &quot;test title&quot;</pre><pre>        verify(exactly = 1) { posts.findAll() }<br>    }<br>}) {<br>    @MockBean(PostRepository::class)<br>    fun posts() = mockk&lt;PostRepository&gt;()<br>}</pre><p>Here we use <strong>mockk</strong> to create a mocked PostRepository and the MockBean is located in the body of SpringSpec.</p><p>The following is an integration example which use SpringSpec .</p><pre>@MicronautTest<br>class IntegrationTests(<br>    private val application: EmbeddedApplication&lt;*&gt;,<br>    @Client(&quot;/&quot;) private val client: HttpClient<br>) : StringSpec({</pre><pre>    &quot;test the server is running&quot; {<br>        assert(application.isRunning)<br>    }</pre><pre>    &quot;test GET /posts endpoint&quot; {<br>        val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java)</pre><pre>        response.status shouldBe HttpStatus.OK<br>        response.body()!!.map { it.title }.forAny {<br>            it shouldContain &quot;Micronaut&quot;<br>        }<br>    }<br>})</pre><p>Get the complete <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/jdbc-kotlin">source codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=81c1b6cf4b10" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-micronaut-applications-with-micronaut-data-jdbc-and-kotlin-81c1b6cf4b10">Building Micronaut applications with Micronaut Data Jdbc and Kotlin</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
