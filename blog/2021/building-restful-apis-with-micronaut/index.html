<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building Restful APIs with Micronaut
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-restful-apis-with-micronaut/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building Restful APIs with Micronaut" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Similar to Spring Boot, Micronaut is a JVM based framework and designated for building Microservice and cloud native applications. Photo by Joey Huang on Unsplash Unlike Spring Boot, Micronaut process IOC at compile time and erases runtime reflection, so it is easier to build native image. Spring also started a Spring native project, but it is in the early stage. For developers that new to Micronaut, it is easy to develop your applications using Micronaut if you have some knowledge of Spring Boot. In this post, I will share my experience to create a simple Restful API application from scratch using Micronaut from a Spring developer view. Generating project skeleton Similar to Spring Initializr, Micronaut provides an online service named Launch to help your generate a project skeleton. Open your browser, go to Micronaut Launch, you will see the following screen. In the Java version field, select the latest LTS version 17. Then click the Features button, add lombok, data hibernate jpa, assertj, postgres, testcontainers. Finally, hit the GENERATE PROJECT button to produce the project files into an archive for download. Extract the project files into disk, and import to your IDE. You can also create a Micronaut project using Micronaut CLI, check Micronaut Starter documentation. Exploring project structure Let’s have a look at the files in the project. .├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle.properties├── gradlew├── gradlew.bat├── micronaut-cli.yml├── settings.gradle└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── Application.java │ └── resources │ ├── application.yml │ └── logback.xml └── test ├── java │ └── com │ └── example │ └── DemoTest.java └── resources ├── application-test.yml └── logback-test.xml Besides Gradle build scripts related resources, it is similar to the Spring Boot project structure. The Application is the entry class of the application.The src/main/resources/application.yml is the application configuration.The src/main/resources/logback.xml is logging configuration.The DemoTest is an example of using @MicronautTest.Under the src/test/resources folder, there are some config resources for test purpose. Let’s have a look at build.gradle. It uses com.github.johnrengelman.shadow to package the application into a jar archive. The micronaut plugin will process the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native image. Declaring a Bean In Micronaut, it used JSR330(aka @Inject) specification to annotate the injectable beans. JSR330 originally is lead by SpringSource(now VMware) and Google. Spring also has built-in JSR330 support, by default it is not activated. You should add inject artifact in your project dependencies to enable it. When a class is annotated with @Singleton means there is only one instance shared in the application scope, @Prototype will produce a new instance for every injection. Micronaut provides a @Factory to produces simple beans in groups, for example. @Factoryclass MyConfig{ @Singleton public Foo foo(){} @Singleton public Bar bar(){}} As described in former sections, Micronaut process IOC at compile time. When building the application, explore the project build/classes folder, you will find there are a lot of extra classes generated at compile time which names are start with a USD(“$”) symbol. Setup database Open src/main/resources/application.yml, the datasources is configured when generating the project. Change the properties according to your environment. datasources: default: url: jdbc:postgresql://localhost:5432/blogdb driverClassName: org.postgresql.Driver username: user password: password schema-generate: CREATE_DROP dialect: POSTGRESjpa.default.properties.hibernate.hbm2ddl.auto: update Create a docker compose file to bootstrap Postgres in docker container. version: &#39;3.7&#39; # specify docker-compose version services: postgres: image: postgres ports: - &quot;5432:5432&quot; restart: always environment: POSTGRES_PASSWORD: password POSTGRES_DB: blogdb POSTGRES_USER: user volumes: - ./data:/var/lib/postgresql - ./pg-initdb.d:/docker-entrypoint-initdb.d Start up Postgres database. docker compose up postgres Data Accessing with Micronaut Data We added data-jpa feature when generating the project, which enables Micronaut data support. If you have experience of Spring Data JPA , it is easy to migrate to Micronaut Data. I have used a simple blog application in the former examples when demonstrating other frameworks. In this post, I will reuse the blog application concept. Basically it includes two JPA entities, Post and Comment, it is a OneToMany relation. @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &quot;posts&quot;)public class Post implements Serializable { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) UUID id; String title; String content; @Builder.Default Status status = Status.DRAFT; @Builder.Default LocalDateTime createdAt = LocalDateTime.now(); @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = &quot;post&quot;) @Builder.Default @OrderColumn(name = &quot;comment_idx&quot;) List&lt;Comment&gt; comments = new ArrayList&lt;&gt;(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Post post = (Post) o; return getTitle().equals(post.getTitle()); } @Override public int hashCode() { return Objects.hash(getTitle()); } @Override public String toString() { return &quot;Post{&quot; + &quot;id=&quot; + id + &quot;, title=&#39;&quot; + title + &#39;\&#39;&#39; + &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; + &quot;, status=&quot; + status + &quot;, createdAt=&quot; + createdAt + &#39;}&#39;; }} // Comment entity @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &quot;comments&quot;)public class Comment implements Serializable { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) private UUID id; @ManyToOne @JoinColumn(name = &quot;post_id&quot;) private Post post; private String content; @Builder.Default @Column(name = &quot;created_at&quot;) private LocalDateTime createdAt = LocalDateTime.now(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Comment comment = (Comment) o; return getContent().equals(comment.getContent()); } @Override public int hashCode() { return Objects.hash(getContent()); } @Override public String toString() { return &quot;Comment{&quot; + &quot;id=&quot; + id + &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; + &quot;, createdAt=&quot; + createdAt + &#39;}&#39;; }} They are standard JPA @Entity classes. An JPA entity class should be annotated with an @Entity annotation, and includes a @Id field to identify this entity and a none-arguments constructor. Here we use Lombok to generate setters and getters, and constructors at compile time. We use IDE to generate equals and hasCode according to the business requirements. @Repositorypublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;{ } @Repositorypublic interface CommentRepository extends JpaRepository&lt;Comment, UUID&gt; { List&lt;Comment&gt; findByPost(Post post);} Add a DataInitializer bean to initialize some sample data. @Singleton@RequiredArgsConstructor@Slf4jpublic class DataInitializer implements ApplicationEventListener&lt;ApplicationStartupEvent&gt; { private final PostRepository posts; private final TransactionOperations&lt;?&gt; tx; @Override public void onApplicationEvent(ApplicationStartupEvent event) { log.info(&quot;initializing sample data...&quot;); var data = List.of(Post.builder().title(&quot;Getting started wit Micronaut&quot;).content(&quot;test&quot;).build(), Post.builder().title(&quot;Getting started wit Micronaut: part 2&quot;).content(&quot;test&quot;).build()); tx.executeWrite(status -&gt; { this.posts.deleteAll(); this.posts.saveAll(data); return null; }); tx.executeRead(status -&gt; { this.posts.findAll().forEach(p -&gt; log.info(&quot;saved post: {}&quot;, p)); return null; }); log.info(&quot;data initialization is done...&quot;); }} Write a test to verify functionality of PostRepository. Similar to the @SpringBootTest, Micronaut provides a @MicronautTest. @MicronautTest(application = Application.class, startApplication = false)class PostRepositoryTest { @Inject PostRepository posts; @PersistenceContext EntityManager entityManager; @Test void testCreatePost() { var entity = Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build(); this.entityManager.persist(entity); assertThat(entity.getId()).isNotNull(); assertTrue(posts.findById(entity.getId()).isPresent()); } } Here we set startApplication = false, it does not start the embedded server to host the application, to test against the database, we do not need a running application We have add testcontainers feature, it will configure a Postgres for test automatically. Check the testcontainers config in the src/test/resources/application-test.yml. datasources: default: url: jdbc:tc:postgresql:12:///postgres driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver When there is a tc as database host name, testcontainer will start up a Postgres database automaticially. Exposing Restful APIs Similar to Spring WebMVC, in Micronaut, we can use a controller to expose Restful APIs. @Controller(&quot;/posts&quot;)@RequiredArgsConstructor(onConstructor_ = {@Inject})@Validatedpublic class PostController { private final PostRepository posts; private final CommentRepository comments; @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&lt;List&lt;PostSummaryDto&gt;&gt; getAll() { var body = posts.findAll() .stream() .map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())) .toList(); return ok(body); } @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) //.orElseThrow(() -&gt; new PostNotFoundException(id)); .orElseGet(HttpResponse::notFound); }} A controller is annotated with @Controller, you can set a base uri that can be applied on all methods. The @Get, @Post,@Put, @Delete is mapped to handle varied HTTP methods, it is similar to the Spring&#39;s @GetMapping, @PostMapping, etc. You can set media types using consumes or produces attributes in these annotations to limit the request and response content type, or use standalone annotations @Consumes and @Produces to set up the media types. Start up the application via Gradle command. ./gradlew run Do not forget to start up Postgres firstly. Use curl to test the /posts endpoint. curl http://localhost:8080/posts[ { &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;}, { &quot;id&quot; : &quot;8c6147ea-8de4-473f-b97d-e211c8e43bac&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;} ] curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf { &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;content&quot;: &quot;test&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;} Micronaut CLI provides commands to generate controller, bean, etc. Run mn --help to get all available commands. Write a test for the PostController. @MicronautTest(environments = Environment.TEST)public class PostControllerTest { @Inject @Client(&quot;/&quot;) HttpClient client; @Inject PostRepository posts; @Inject CommentRepository comments; @MockBean(PostRepository.class) PostRepository posts() { return mock(PostRepository.class); } @MockBean(CommentRepository.class) CommentRepository comments() { return mock(CommentRepository.class); } @Test @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;) public void testGetAllPosts() throws Exception { when(this.posts.findAll()).thenReturn( List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()) ); var response = client.toBlocking().exchange(&quot;/posts&quot;, PostSummaryDto[].class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.length).isEqualTo(1); assertThat(body[0].title()).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findAll(); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint&quot;) public void testGetSinglePost() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn( Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()) ); var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID()))); var response = client.toBlocking().exchange(request, PostDetailsDto.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.title()).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint that does not exist&quot;) public void testGetSinglePost_notFound() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null)); var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID()))); var exception = assertThrows(HttpClientResponseException.class, () -&gt; client.toBlocking().exchange(request, PostDetailsDto.class)); assertEquals(HttpStatus.NOT_FOUND, exception.getStatus()); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); }} In this test, we use Mockito to mock all dependent beans(PostRepository and CommentRepository) in the PostController. To mock beans in the test context, Micronaut provides a MockBean to produce a mocked instance to replace the real beans. Similar to Spring’s RestTemplate or WebClient, Micronaut provides a HttpClient to send request to a certain URI, by default it uses the ReactiveStreams compatible API, If you are stick on the traditional blocking API, call the toBlocking() method to switch to use it. The exchange method will return a HTTP response object, and the retrieve method returns the response body directly. Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code, it will throws a HttpClientResponseException instead. In contrast, in ReactiveStreams APIs, it will emit the exception to error channel. Exception Handling In the above PostController, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real world application, we can use an exception to envelope the exception case. Like Spring WebMVC, Micronaut also provides exception handling mechanism. For example, create an PostNotFoundException to stand for the case post was not found by id. Create a PostNotFoundException class. public class PostNotFoundException extends RuntimeException { public PostNotFoundException(UUID id) { super(&quot;Post[id=&quot; + id + &quot;] was not found&quot;); }} In the PostController, throw the exception. @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) .orElseThrow(() -&gt; new PostNotFoundException(id));} Add a PostNotFoundExceptionHandler to handle PostNotFoundException. @Produces@Singleton@Requires(classes = { PostNotFoundException.class})@RequiredArgsConstructorpublic class PostNotFoundExceptionHandler implements ExceptionHandler&lt;PostNotFoundException, HttpResponse&lt;?&gt;&gt; { private final ErrorResponseProcessor&lt;?&gt; errorResponseProcessor; @Override public HttpResponse&lt;?&gt; handle(HttpRequest request, PostNotFoundException exception) { return errorResponseProcessor.processResponse( ErrorContext.builder(request) .cause(exception) .errorMessage(exception.getMessage()) .build(), HttpResponse.notFound() ); }} Open your terminal, use curl to test the /posts/{id} endpoint with an none-existing id. # curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf -v&gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt;&lt; HTTP/1.1 404 Not Found&lt; Content-Type: application/json&lt; date: Mon, 25 Oct 2021 07:02:01 GMT&lt; content-length: 301&lt; connection: keep-alive&lt;{ &quot;message&quot; : &quot;Not Found&quot;, &quot;_links&quot; : { &quot;self&quot; : { &quot;href&quot; : &quot;/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;templated&quot; : false } }, &quot;_embedded&quot; : { &quot;errors&quot; : [ { &quot;message&quot; : &quot;Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found&quot; } ] }} Pagination Similar to Spring Data, Micronaut Data provides pagination for long query result, the findAll accepts a Pageable parameter, and returns a Page result. Micronaut Data also includes a Specification to adopt JPA Criteria APIs for type safe query. Change PostRepository , add JpaSpecificationExecutor&lt;Post&gt; to extends list. @Repositorypublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; { } Create a specific PostSpecifications to group all specifications for querying posts. Currently only add one for query by keyword and status. public class PostSpecifications { private PostSpecifications(){ // forbid to instantiate } public static Specification&lt;Post&gt; filterByKeywordAndStatus( final String keyword, final Status status ) { return (Root&lt;Post&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) -&gt; { List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if (StringUtils.hasText(keyword)) { predicates.add( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + keyword + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + keyword + &quot;%&quot;) ) ); } if (status != null) { predicates.add(cb.equal(root.get(Post_.status), status)); } return cb.and(predicates.toArray(new Predicate[0])); }; }} Change the getAll method of PostController to the following. @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;Page&lt;PostSummaryDto&gt;&gt; getAll(@QueryValue(defaultValue = &quot;&quot;) String q, @QueryValue(defaultValue = &quot;&quot;) String status, @QueryValue(defaultValue = &quot;0&quot;) int page, @QueryValue(defaultValue = &quot;10&quot;) int size) { var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(&quot;createdAt&quot;))); var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null; var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable); var body = data.map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())); return ok(body);} All the query parameters are optional. Let’s use curl to test the /posts endpiont. # curl http://localhost:8080/posts{ &quot;content&quot; : [ { &quot;id&quot; : &quot;c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot; }, { &quot;id&quot; : &quot;0a79185c-5981-4301-86d1-c266b26b4980&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot; } ], &quot;pageable&quot; : { &quot;number&quot; : 0, &quot;sort&quot; : { &quot;orderBy&quot; : [ { &quot;property&quot; : &quot;createdAt&quot;, &quot;direction&quot; : &quot;DESC&quot;, &quot;ignoreCase&quot; : false, &quot;ascending&quot; : false } ], &quot;sorted&quot; : true }, &quot;size&quot; : 10, &quot;offset&quot; : 0, &quot;sorted&quot; : true, &quot;unpaged&quot; : false }, &quot;totalSize&quot; : 2, &quot;totalPages&quot; : 1, &quot;empty&quot; : false, &quot;size&quot; : 10, &quot;offset&quot; : 0, &quot;numberOfElements&quot; : 2, &quot;pageNumber&quot; : 0} Customizing JsonSerializer The Page object rendered result is a little tedious, most of case, we do not need all these fields, we can customize it via Jackson JsonSerializer. @Singletonpublic class PageJsonSerializer extends JsonSerializer&lt;Page&lt;?&gt;&gt; { @Override public void serialize(Page&lt;?&gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeStartObject(); gen.writeNumberField(&quot;pageNumber&quot;, value.getPageNumber()); if (value.getNumberOfElements() != value.getSize()) { //only display it in the last page when number of elements is not equal to page size. gen.writeNumberField(&quot;numberOfElements&quot;, value.getNumberOfElements()); } gen.writeNumberField(&quot;size&quot;, value.getSize()); gen.writeNumberField(&quot;totalPages&quot;, value.getTotalPages()); gen.writeNumberField(&quot;totalSize&quot;, value.getTotalSize()); gen.writeObjectField(&quot;content&quot;, value.getContent()); gen.writeEndObject(); }} Run the application again, and hint /posts endpoint. # curl http://localhost:8080/posts{ &quot;pageNumber&quot; : 0, &quot;numberOfElements&quot; : 2, &quot;size&quot; : 10, &quot;totalPages&quot; : 1, &quot;totalSize&quot; : 2, &quot;content&quot; : [ { &quot;id&quot; : &quot;53fb77d5-4159-4a80-bab9-c76d9a535b36&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot; }, { &quot;id&quot; : &quot;aa02fd49-0c24-4f12-b204-2e48213c7a1e&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot; } ]} Modify the testing codes to verify changes. class PostControllerTest{ //... @Test @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;) public void testGetAllPosts() throws Exception { var content = List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()); when(this.posts.findAll(isA(Specification.class), isA(Pageable.class))).thenReturn( Page.of(content, Pageable.from(0, 20), 1) ); var request = HttpRequest.GET(&quot;/posts&quot;); var response = client.toBlocking().exchange(request, String.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(JsonPath.from(body).getInt(&quot;totalSize&quot;)).isEqualTo(1); assertThat(JsonPath.from(body).getString(&quot;content[0].title&quot;)).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findAll(isA(Specification.class), isA(Pageable.class)); verifyNoMoreInteractions(this.posts); }} Creating Posts We have discussed how to query posts by key word and get single post by id, in this section, we will focus on creating a new post. According the REST convention, we will use a POST HTTP method to send a request on endpoint /posts and accept JSON data as request body. @io.micronaut.http.annotation.Post(uri = &quot;/&quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;Void&gt; create(@Body CreatePostCommand dto) { var data = Post.builder().title(dto.title()).content(dto.content()).build(); var saved = this.posts.save(data); return HttpResponse.created(URI.create(&quot;/posts/&quot; + saved.getId()));} The request body is deserialized as a POJO by built-in Jackson JsonDesearilizers, it is annotated with a @Body annotation to indicate which target class it will be desearilized to. After the post data is saved, set the response header Location to the URI of accessing the new post. Run the application, and try to add a post via curl, and then access the newly created post. # curl -X POST -v -H &quot;Content-Type:application/json&quot; http://localhost:8080/posts -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;test content\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 47&gt;* upload completely sent off: 47 out of 47 bytes&lt; HTTP/1.1 201 Created&lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&lt; date: Mon, 25 Oct 2021 09:07:40 GMT&lt; connection: keep-alive&lt; transfer-encoding: chunked&lt;# curl http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6{ &quot;id&quot; : &quot;7db15639-62e3-4d3e-9cf4-f54413502ea6&quot;, &quot;title&quot; : &quot;test title&quot;, &quot;content&quot; : &quot;test content&quot;, &quot;status&quot; : &quot;DRAFT&quot;, &quot;createdAt&quot; : &quot;2021-10-25T17:07:40.87621&quot;} Data Validation Generally, in a real application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support. In the above CreatPostCommand class, add Bean Validation annotations on the fields. @Introspectedpublic record CreatePostCommand(@NotBlank String title, @NotBlank String content) {} You have to add @Introspected annotation to let micronaut plugin to preprocess bean validation annotations at compile time, and let Bean Validation works without any reflections APIs at runtime time. In the PostController, add a @Validated on the class and a @Valid on the method argument. @Validatedpublic class PostController { public HttpResponse&lt;Void&gt; create(@Body @Valid CreatePostCommand dto) {...} //...} Let’s try to create a post. Note, set the content field empty. curl -X POST -v -H &quot;Content-Type:application/json&quot; http://localhost:8080/posts -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 35&gt;* upload completely sent off: 35 out of 35 bytes&lt; HTTP/1.1 400 Bad Request&lt; Content-Type: application/json&lt; date: Mon, 25 Oct 2021 09:23:22 GMT&lt; content-length: 237&lt; connection: keep-alive&lt;{ &quot;message&quot; : &quot;Bad Request&quot;, &quot;_embedded&quot; : { &quot;errors&quot; : [ { &quot;message&quot; : &quot;dto.content: must not be blank&quot; } ] }, &quot;_links&quot; : { &quot;self&quot; : { &quot;href&quot; : &quot;/posts&quot;, &quot;templated&quot; : false } }} Deleting a Post According to REST convention, to delete a single post, send a DELETE request on /posts/{id}, if it is successful, returns a 204 status. If the id is not existed, returns a 404 instead. Add the following codes to the PostController. @Delete(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;?&gt; deleteById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; { this.posts.delete(p); return HttpResponse.noContent(); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);} Processing Subresources In our application, the a Comment resource, it should be a subresource of Post resource when adding comments or fetching comments of a specific post, we can design comments resource like this. POST /posts/{id}/comments , add a Comment resource to a specific Post.GET /posts/{id}/comments, get all comments of a certain Post which id value is the path variable id. // nested comments endpoints@Get(uri = &quot;/{id}/comments&quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&lt;?&gt; getCommentsByPostId(@PathVariable UUID id) { return posts.findById(id) .map(post -&gt; { var comments = this.comments.findByPost(post); return ok(comments.stream().map(c -&gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt()))); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);} @io.micronaut.http.annotation.Post(uri = &quot;/{id}/comments&quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;?&gt; create(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) { return posts.findById(id) .map(post -&gt; { var data = Comment.builder().content(dto.content()).post(post).build(); post.getComments().add(data); var saved = this.comments.save(data); return HttpResponse.created(URI.create(&quot;/comments/&quot; + saved.getId())); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); // .orElseGet(HttpResponse::notFound); } Integration Tests The following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server. @MicronautTest@Slf4jclass IntegrationTests { @Inject @Client(&quot;/&quot;) HttpClient client; @Inject EmbeddedApplication&lt;?&gt; application; @Test void testItWorks() { Assertions.assertTrue(application.isRunning()); } @Test void testGetAllPosts() { var response = client.exchange(HttpRequest.GET(&quot;/posts&quot;), String.class); var bodyFlux = Flux.from(response).map(HttpResponse::body); StepVerifier.create(bodyFlux) .consumeNextWith(posts -&gt; assertThat(JsonPath.from(posts).getInt(&quot;totalSize&quot;)).isGreaterThanOrEqualTo(2)) .verifyComplete(); } @Test public void testCrudFlow() { //create a new post var request = HttpRequest.POST(&quot;/posts&quot;, new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;)); var blockingHttpClient = client.toBlocking(); var response = blockingHttpClient.exchange(request); assertThat(response.status().getCode()).isEqualTo(201); var savedUrl = response.getHeaders().get(&quot;Location&quot;); assertThat(savedUrl).isNotNull(); log.debug(&quot;saved post url: {}&quot;, savedUrl); //get by id var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class); assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200); // add comments var addCommentRequest = HttpRequest.POST(savedUrl + &quot;/comments&quot;, new CreateCommentCommand(&quot;test content&quot;)); var addCommentResponse = blockingHttpClient.exchange(addCommentRequest); assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201); var savedCommentUrl = addCommentResponse.getHeaders().get(&quot;Location&quot;); assertThat(savedCommentUrl).isNotNull(); // get all comments var getAllCommentsRequest = HttpRequest.GET(savedUrl + &quot;/comments&quot;); var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class)); assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200); assertThat(getAllCommentsResponse.body().size()).isEqualTo(1); //delete by id var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl)); assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204); //get by id again(404) var e = Assertions.assertThrows(HttpClientResponseException.class, () -&gt; blockingHttpClient.exchange(HttpRequest.GET(savedUrl))); var getPostResponse2 = e.getResponse(); assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404); } } In the testGetAllPosts test, we try to use reactive HttpClient APIs and use reactor-test&#39;s StepVerifier to assert the data in a reactive data stream. The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post. In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using RestAssured and Java 11 new HttpClient, check the source codes and explore them yourself. The example codes are hosted on my GitHub, check hantsy/micronaut-sandbox#post-service. &lt;hr&gt;&lt;p&gt;Building Restful APIs with Micronaut was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Similar to Spring Boot, Micronaut is a JVM based framework and designated for building Microservice and cloud native applications. Photo by Joey Huang on Unsplash Unlike Spring Boot, Micronaut process IOC at compile time and erases runtime reflection, so it is easier to build native image. Spring also started a Spring native project, but it is in the early stage. For developers that new to Micronaut, it is easy to develop your applications using Micronaut if you have some knowledge of Spring Boot. In this post, I will share my experience to create a simple Restful API application from scratch using Micronaut from a Spring developer view. Generating project skeleton Similar to Spring Initializr, Micronaut provides an online service named Launch to help your generate a project skeleton. Open your browser, go to Micronaut Launch, you will see the following screen. In the Java version field, select the latest LTS version 17. Then click the Features button, add lombok, data hibernate jpa, assertj, postgres, testcontainers. Finally, hit the GENERATE PROJECT button to produce the project files into an archive for download. Extract the project files into disk, and import to your IDE. You can also create a Micronaut project using Micronaut CLI, check Micronaut Starter documentation. Exploring project structure Let’s have a look at the files in the project. .├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle.properties├── gradlew├── gradlew.bat├── micronaut-cli.yml├── settings.gradle└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── Application.java │ └── resources │ ├── application.yml │ └── logback.xml └── test ├── java │ └── com │ └── example │ └── DemoTest.java └── resources ├── application-test.yml └── logback-test.xml Besides Gradle build scripts related resources, it is similar to the Spring Boot project structure. The Application is the entry class of the application.The src/main/resources/application.yml is the application configuration.The src/main/resources/logback.xml is logging configuration.The DemoTest is an example of using @MicronautTest.Under the src/test/resources folder, there are some config resources for test purpose. Let’s have a look at build.gradle. It uses com.github.johnrengelman.shadow to package the application into a jar archive. The micronaut plugin will process the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native image. Declaring a Bean In Micronaut, it used JSR330(aka @Inject) specification to annotate the injectable beans. JSR330 originally is lead by SpringSource(now VMware) and Google. Spring also has built-in JSR330 support, by default it is not activated. You should add inject artifact in your project dependencies to enable it. When a class is annotated with @Singleton means there is only one instance shared in the application scope, @Prototype will produce a new instance for every injection. Micronaut provides a @Factory to produces simple beans in groups, for example. @Factoryclass MyConfig{ @Singleton public Foo foo(){} @Singleton public Bar bar(){}} As described in former sections, Micronaut process IOC at compile time. When building the application, explore the project build/classes folder, you will find there are a lot of extra classes generated at compile time which names are start with a USD(“$”) symbol. Setup database Open src/main/resources/application.yml, the datasources is configured when generating the project. Change the properties according to your environment. datasources: default: url: jdbc:postgresql://localhost:5432/blogdb driverClassName: org.postgresql.Driver username: user password: password schema-generate: CREATE_DROP dialect: POSTGRESjpa.default.properties.hibernate.hbm2ddl.auto: update Create a docker compose file to bootstrap Postgres in docker container. version: &#39;3.7&#39; # specify docker-compose version services: postgres: image: postgres ports: - &quot;5432:5432&quot; restart: always environment: POSTGRES_PASSWORD: password POSTGRES_DB: blogdb POSTGRES_USER: user volumes: - ./data:/var/lib/postgresql - ./pg-initdb.d:/docker-entrypoint-initdb.d Start up Postgres database. docker compose up postgres Data Accessing with Micronaut Data We added data-jpa feature when generating the project, which enables Micronaut data support. If you have experience of Spring Data JPA , it is easy to migrate to Micronaut Data. I have used a simple blog application in the former examples when demonstrating other frameworks. In this post, I will reuse the blog application concept. Basically it includes two JPA entities, Post and Comment, it is a OneToMany relation. @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &quot;posts&quot;)public class Post implements Serializable { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) UUID id; String title; String content; @Builder.Default Status status = Status.DRAFT; @Builder.Default LocalDateTime createdAt = LocalDateTime.now(); @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = &quot;post&quot;) @Builder.Default @OrderColumn(name = &quot;comment_idx&quot;) List&lt;Comment&gt; comments = new ArrayList&lt;&gt;(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Post post = (Post) o; return getTitle().equals(post.getTitle()); } @Override public int hashCode() { return Objects.hash(getTitle()); } @Override public String toString() { return &quot;Post{&quot; + &quot;id=&quot; + id + &quot;, title=&#39;&quot; + title + &#39;\&#39;&#39; + &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; + &quot;, status=&quot; + status + &quot;, createdAt=&quot; + createdAt + &#39;}&#39;; }} // Comment entity @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &quot;comments&quot;)public class Comment implements Serializable { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) private UUID id; @ManyToOne @JoinColumn(name = &quot;post_id&quot;) private Post post; private String content; @Builder.Default @Column(name = &quot;created_at&quot;) private LocalDateTime createdAt = LocalDateTime.now(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Comment comment = (Comment) o; return getContent().equals(comment.getContent()); } @Override public int hashCode() { return Objects.hash(getContent()); } @Override public String toString() { return &quot;Comment{&quot; + &quot;id=&quot; + id + &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; + &quot;, createdAt=&quot; + createdAt + &#39;}&#39;; }} They are standard JPA @Entity classes. An JPA entity class should be annotated with an @Entity annotation, and includes a @Id field to identify this entity and a none-arguments constructor. Here we use Lombok to generate setters and getters, and constructors at compile time. We use IDE to generate equals and hasCode according to the business requirements. @Repositorypublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;{ } @Repositorypublic interface CommentRepository extends JpaRepository&lt;Comment, UUID&gt; { List&lt;Comment&gt; findByPost(Post post);} Add a DataInitializer bean to initialize some sample data. @Singleton@RequiredArgsConstructor@Slf4jpublic class DataInitializer implements ApplicationEventListener&lt;ApplicationStartupEvent&gt; { private final PostRepository posts; private final TransactionOperations&lt;?&gt; tx; @Override public void onApplicationEvent(ApplicationStartupEvent event) { log.info(&quot;initializing sample data...&quot;); var data = List.of(Post.builder().title(&quot;Getting started wit Micronaut&quot;).content(&quot;test&quot;).build(), Post.builder().title(&quot;Getting started wit Micronaut: part 2&quot;).content(&quot;test&quot;).build()); tx.executeWrite(status -&gt; { this.posts.deleteAll(); this.posts.saveAll(data); return null; }); tx.executeRead(status -&gt; { this.posts.findAll().forEach(p -&gt; log.info(&quot;saved post: {}&quot;, p)); return null; }); log.info(&quot;data initialization is done...&quot;); }} Write a test to verify functionality of PostRepository. Similar to the @SpringBootTest, Micronaut provides a @MicronautTest. @MicronautTest(application = Application.class, startApplication = false)class PostRepositoryTest { @Inject PostRepository posts; @PersistenceContext EntityManager entityManager; @Test void testCreatePost() { var entity = Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build(); this.entityManager.persist(entity); assertThat(entity.getId()).isNotNull(); assertTrue(posts.findById(entity.getId()).isPresent()); } } Here we set startApplication = false, it does not start the embedded server to host the application, to test against the database, we do not need a running application We have add testcontainers feature, it will configure a Postgres for test automatically. Check the testcontainers config in the src/test/resources/application-test.yml. datasources: default: url: jdbc:tc:postgresql:12:///postgres driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver When there is a tc as database host name, testcontainer will start up a Postgres database automaticially. Exposing Restful APIs Similar to Spring WebMVC, in Micronaut, we can use a controller to expose Restful APIs. @Controller(&quot;/posts&quot;)@RequiredArgsConstructor(onConstructor_ = {@Inject})@Validatedpublic class PostController { private final PostRepository posts; private final CommentRepository comments; @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&lt;List&lt;PostSummaryDto&gt;&gt; getAll() { var body = posts.findAll() .stream() .map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())) .toList(); return ok(body); } @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) //.orElseThrow(() -&gt; new PostNotFoundException(id)); .orElseGet(HttpResponse::notFound); }} A controller is annotated with @Controller, you can set a base uri that can be applied on all methods. The @Get, @Post,@Put, @Delete is mapped to handle varied HTTP methods, it is similar to the Spring&#39;s @GetMapping, @PostMapping, etc. You can set media types using consumes or produces attributes in these annotations to limit the request and response content type, or use standalone annotations @Consumes and @Produces to set up the media types. Start up the application via Gradle command. ./gradlew run Do not forget to start up Postgres firstly. Use curl to test the /posts endpoint. curl http://localhost:8080/posts[ { &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;}, { &quot;id&quot; : &quot;8c6147ea-8de4-473f-b97d-e211c8e43bac&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;} ] curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf { &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;content&quot;: &quot;test&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;} Micronaut CLI provides commands to generate controller, bean, etc. Run mn --help to get all available commands. Write a test for the PostController. @MicronautTest(environments = Environment.TEST)public class PostControllerTest { @Inject @Client(&quot;/&quot;) HttpClient client; @Inject PostRepository posts; @Inject CommentRepository comments; @MockBean(PostRepository.class) PostRepository posts() { return mock(PostRepository.class); } @MockBean(CommentRepository.class) CommentRepository comments() { return mock(CommentRepository.class); } @Test @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;) public void testGetAllPosts() throws Exception { when(this.posts.findAll()).thenReturn( List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()) ); var response = client.toBlocking().exchange(&quot;/posts&quot;, PostSummaryDto[].class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.length).isEqualTo(1); assertThat(body[0].title()).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findAll(); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint&quot;) public void testGetSinglePost() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn( Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()) ); var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID()))); var response = client.toBlocking().exchange(request, PostDetailsDto.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.title()).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint that does not exist&quot;) public void testGetSinglePost_notFound() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null)); var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID()))); var exception = assertThrows(HttpClientResponseException.class, () -&gt; client.toBlocking().exchange(request, PostDetailsDto.class)); assertEquals(HttpStatus.NOT_FOUND, exception.getStatus()); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); }} In this test, we use Mockito to mock all dependent beans(PostRepository and CommentRepository) in the PostController. To mock beans in the test context, Micronaut provides a MockBean to produce a mocked instance to replace the real beans. Similar to Spring’s RestTemplate or WebClient, Micronaut provides a HttpClient to send request to a certain URI, by default it uses the ReactiveStreams compatible API, If you are stick on the traditional blocking API, call the toBlocking() method to switch to use it. The exchange method will return a HTTP response object, and the retrieve method returns the response body directly. Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code, it will throws a HttpClientResponseException instead. In contrast, in ReactiveStreams APIs, it will emit the exception to error channel. Exception Handling In the above PostController, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real world application, we can use an exception to envelope the exception case. Like Spring WebMVC, Micronaut also provides exception handling mechanism. For example, create an PostNotFoundException to stand for the case post was not found by id. Create a PostNotFoundException class. public class PostNotFoundException extends RuntimeException { public PostNotFoundException(UUID id) { super(&quot;Post[id=&quot; + id + &quot;] was not found&quot;); }} In the PostController, throw the exception. @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) .orElseThrow(() -&gt; new PostNotFoundException(id));} Add a PostNotFoundExceptionHandler to handle PostNotFoundException. @Produces@Singleton@Requires(classes = { PostNotFoundException.class})@RequiredArgsConstructorpublic class PostNotFoundExceptionHandler implements ExceptionHandler&lt;PostNotFoundException, HttpResponse&lt;?&gt;&gt; { private final ErrorResponseProcessor&lt;?&gt; errorResponseProcessor; @Override public HttpResponse&lt;?&gt; handle(HttpRequest request, PostNotFoundException exception) { return errorResponseProcessor.processResponse( ErrorContext.builder(request) .cause(exception) .errorMessage(exception.getMessage()) .build(), HttpResponse.notFound() ); }} Open your terminal, use curl to test the /posts/{id} endpoint with an none-existing id. # curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf -v&gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt;&lt; HTTP/1.1 404 Not Found&lt; Content-Type: application/json&lt; date: Mon, 25 Oct 2021 07:02:01 GMT&lt; content-length: 301&lt; connection: keep-alive&lt;{ &quot;message&quot; : &quot;Not Found&quot;, &quot;_links&quot; : { &quot;self&quot; : { &quot;href&quot; : &quot;/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;templated&quot; : false } }, &quot;_embedded&quot; : { &quot;errors&quot; : [ { &quot;message&quot; : &quot;Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found&quot; } ] }} Pagination Similar to Spring Data, Micronaut Data provides pagination for long query result, the findAll accepts a Pageable parameter, and returns a Page result. Micronaut Data also includes a Specification to adopt JPA Criteria APIs for type safe query. Change PostRepository , add JpaSpecificationExecutor&lt;Post&gt; to extends list. @Repositorypublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; { } Create a specific PostSpecifications to group all specifications for querying posts. Currently only add one for query by keyword and status. public class PostSpecifications { private PostSpecifications(){ // forbid to instantiate } public static Specification&lt;Post&gt; filterByKeywordAndStatus( final String keyword, final Status status ) { return (Root&lt;Post&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) -&gt; { List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if (StringUtils.hasText(keyword)) { predicates.add( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + keyword + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + keyword + &quot;%&quot;) ) ); } if (status != null) { predicates.add(cb.equal(root.get(Post_.status), status)); } return cb.and(predicates.toArray(new Predicate[0])); }; }} Change the getAll method of PostController to the following. @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;Page&lt;PostSummaryDto&gt;&gt; getAll(@QueryValue(defaultValue = &quot;&quot;) String q, @QueryValue(defaultValue = &quot;&quot;) String status, @QueryValue(defaultValue = &quot;0&quot;) int page, @QueryValue(defaultValue = &quot;10&quot;) int size) { var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(&quot;createdAt&quot;))); var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null; var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable); var body = data.map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())); return ok(body);} All the query parameters are optional. Let’s use curl to test the /posts endpiont. # curl http://localhost:8080/posts{ &quot;content&quot; : [ { &quot;id&quot; : &quot;c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot; }, { &quot;id&quot; : &quot;0a79185c-5981-4301-86d1-c266b26b4980&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot; } ], &quot;pageable&quot; : { &quot;number&quot; : 0, &quot;sort&quot; : { &quot;orderBy&quot; : [ { &quot;property&quot; : &quot;createdAt&quot;, &quot;direction&quot; : &quot;DESC&quot;, &quot;ignoreCase&quot; : false, &quot;ascending&quot; : false } ], &quot;sorted&quot; : true }, &quot;size&quot; : 10, &quot;offset&quot; : 0, &quot;sorted&quot; : true, &quot;unpaged&quot; : false }, &quot;totalSize&quot; : 2, &quot;totalPages&quot; : 1, &quot;empty&quot; : false, &quot;size&quot; : 10, &quot;offset&quot; : 0, &quot;numberOfElements&quot; : 2, &quot;pageNumber&quot; : 0} Customizing JsonSerializer The Page object rendered result is a little tedious, most of case, we do not need all these fields, we can customize it via Jackson JsonSerializer. @Singletonpublic class PageJsonSerializer extends JsonSerializer&lt;Page&lt;?&gt;&gt; { @Override public void serialize(Page&lt;?&gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeStartObject(); gen.writeNumberField(&quot;pageNumber&quot;, value.getPageNumber()); if (value.getNumberOfElements() != value.getSize()) { //only display it in the last page when number of elements is not equal to page size. gen.writeNumberField(&quot;numberOfElements&quot;, value.getNumberOfElements()); } gen.writeNumberField(&quot;size&quot;, value.getSize()); gen.writeNumberField(&quot;totalPages&quot;, value.getTotalPages()); gen.writeNumberField(&quot;totalSize&quot;, value.getTotalSize()); gen.writeObjectField(&quot;content&quot;, value.getContent()); gen.writeEndObject(); }} Run the application again, and hint /posts endpoint. # curl http://localhost:8080/posts{ &quot;pageNumber&quot; : 0, &quot;numberOfElements&quot; : 2, &quot;size&quot; : 10, &quot;totalPages&quot; : 1, &quot;totalSize&quot; : 2, &quot;content&quot; : [ { &quot;id&quot; : &quot;53fb77d5-4159-4a80-bab9-c76d9a535b36&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot; }, { &quot;id&quot; : &quot;aa02fd49-0c24-4f12-b204-2e48213c7a1e&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot; } ]} Modify the testing codes to verify changes. class PostControllerTest{ //... @Test @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;) public void testGetAllPosts() throws Exception { var content = List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()); when(this.posts.findAll(isA(Specification.class), isA(Pageable.class))).thenReturn( Page.of(content, Pageable.from(0, 20), 1) ); var request = HttpRequest.GET(&quot;/posts&quot;); var response = client.toBlocking().exchange(request, String.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(JsonPath.from(body).getInt(&quot;totalSize&quot;)).isEqualTo(1); assertThat(JsonPath.from(body).getString(&quot;content[0].title&quot;)).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findAll(isA(Specification.class), isA(Pageable.class)); verifyNoMoreInteractions(this.posts); }} Creating Posts We have discussed how to query posts by key word and get single post by id, in this section, we will focus on creating a new post. According the REST convention, we will use a POST HTTP method to send a request on endpoint /posts and accept JSON data as request body. @io.micronaut.http.annotation.Post(uri = &quot;/&quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;Void&gt; create(@Body CreatePostCommand dto) { var data = Post.builder().title(dto.title()).content(dto.content()).build(); var saved = this.posts.save(data); return HttpResponse.created(URI.create(&quot;/posts/&quot; + saved.getId()));} The request body is deserialized as a POJO by built-in Jackson JsonDesearilizers, it is annotated with a @Body annotation to indicate which target class it will be desearilized to. After the post data is saved, set the response header Location to the URI of accessing the new post. Run the application, and try to add a post via curl, and then access the newly created post. # curl -X POST -v -H &quot;Content-Type:application/json&quot; http://localhost:8080/posts -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;test content\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 47&gt;* upload completely sent off: 47 out of 47 bytes&lt; HTTP/1.1 201 Created&lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&lt; date: Mon, 25 Oct 2021 09:07:40 GMT&lt; connection: keep-alive&lt; transfer-encoding: chunked&lt;# curl http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6{ &quot;id&quot; : &quot;7db15639-62e3-4d3e-9cf4-f54413502ea6&quot;, &quot;title&quot; : &quot;test title&quot;, &quot;content&quot; : &quot;test content&quot;, &quot;status&quot; : &quot;DRAFT&quot;, &quot;createdAt&quot; : &quot;2021-10-25T17:07:40.87621&quot;} Data Validation Generally, in a real application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support. In the above CreatPostCommand class, add Bean Validation annotations on the fields. @Introspectedpublic record CreatePostCommand(@NotBlank String title, @NotBlank String content) {} You have to add @Introspected annotation to let micronaut plugin to preprocess bean validation annotations at compile time, and let Bean Validation works without any reflections APIs at runtime time. In the PostController, add a @Validated on the class and a @Valid on the method argument. @Validatedpublic class PostController { public HttpResponse&lt;Void&gt; create(@Body @Valid CreatePostCommand dto) {...} //...} Let’s try to create a post. Note, set the content field empty. curl -X POST -v -H &quot;Content-Type:application/json&quot; http://localhost:8080/posts -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 35&gt;* upload completely sent off: 35 out of 35 bytes&lt; HTTP/1.1 400 Bad Request&lt; Content-Type: application/json&lt; date: Mon, 25 Oct 2021 09:23:22 GMT&lt; content-length: 237&lt; connection: keep-alive&lt;{ &quot;message&quot; : &quot;Bad Request&quot;, &quot;_embedded&quot; : { &quot;errors&quot; : [ { &quot;message&quot; : &quot;dto.content: must not be blank&quot; } ] }, &quot;_links&quot; : { &quot;self&quot; : { &quot;href&quot; : &quot;/posts&quot;, &quot;templated&quot; : false } }} Deleting a Post According to REST convention, to delete a single post, send a DELETE request on /posts/{id}, if it is successful, returns a 204 status. If the id is not existed, returns a 404 instead. Add the following codes to the PostController. @Delete(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;?&gt; deleteById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; { this.posts.delete(p); return HttpResponse.noContent(); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);} Processing Subresources In our application, the a Comment resource, it should be a subresource of Post resource when adding comments or fetching comments of a specific post, we can design comments resource like this. POST /posts/{id}/comments , add a Comment resource to a specific Post.GET /posts/{id}/comments, get all comments of a certain Post which id value is the path variable id. // nested comments endpoints@Get(uri = &quot;/{id}/comments&quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&lt;?&gt; getCommentsByPostId(@PathVariable UUID id) { return posts.findById(id) .map(post -&gt; { var comments = this.comments.findByPost(post); return ok(comments.stream().map(c -&gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt()))); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);} @io.micronaut.http.annotation.Post(uri = &quot;/{id}/comments&quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;?&gt; create(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) { return posts.findById(id) .map(post -&gt; { var data = Comment.builder().content(dto.content()).post(post).build(); post.getComments().add(data); var saved = this.comments.save(data); return HttpResponse.created(URI.create(&quot;/comments/&quot; + saved.getId())); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); // .orElseGet(HttpResponse::notFound); } Integration Tests The following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server. @MicronautTest@Slf4jclass IntegrationTests { @Inject @Client(&quot;/&quot;) HttpClient client; @Inject EmbeddedApplication&lt;?&gt; application; @Test void testItWorks() { Assertions.assertTrue(application.isRunning()); } @Test void testGetAllPosts() { var response = client.exchange(HttpRequest.GET(&quot;/posts&quot;), String.class); var bodyFlux = Flux.from(response).map(HttpResponse::body); StepVerifier.create(bodyFlux) .consumeNextWith(posts -&gt; assertThat(JsonPath.from(posts).getInt(&quot;totalSize&quot;)).isGreaterThanOrEqualTo(2)) .verifyComplete(); } @Test public void testCrudFlow() { //create a new post var request = HttpRequest.POST(&quot;/posts&quot;, new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;)); var blockingHttpClient = client.toBlocking(); var response = blockingHttpClient.exchange(request); assertThat(response.status().getCode()).isEqualTo(201); var savedUrl = response.getHeaders().get(&quot;Location&quot;); assertThat(savedUrl).isNotNull(); log.debug(&quot;saved post url: {}&quot;, savedUrl); //get by id var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class); assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200); // add comments var addCommentRequest = HttpRequest.POST(savedUrl + &quot;/comments&quot;, new CreateCommentCommand(&quot;test content&quot;)); var addCommentResponse = blockingHttpClient.exchange(addCommentRequest); assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201); var savedCommentUrl = addCommentResponse.getHeaders().get(&quot;Location&quot;); assertThat(savedCommentUrl).isNotNull(); // get all comments var getAllCommentsRequest = HttpRequest.GET(savedUrl + &quot;/comments&quot;); var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class)); assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200); assertThat(getAllCommentsResponse.body().size()).isEqualTo(1); //delete by id var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl)); assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204); //get by id again(404) var e = Assertions.assertThrows(HttpClientResponseException.class, () -&gt; blockingHttpClient.exchange(HttpRequest.GET(savedUrl))); var getPostResponse2 = e.getResponse(); assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404); } } In the testGetAllPosts test, we try to use reactive HttpClient APIs and use reactor-test&#39;s StepVerifier to assert the data in a reactive data stream. The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post. In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using RestAssured and Java 11 new HttpClient, check the source codes and explore them yourself. The example codes are hosted on my GitHub, check hantsy/micronaut-sandbox#post-service. &lt;hr&gt;&lt;p&gt;Building Restful APIs with Micronaut was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-27T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building Restful APIs with Micronaut" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-27T00:00:00+00:00","datePublished":"2021-10-27T00:00:00+00:00","description":"Similar to Spring Boot, Micronaut is a JVM based framework and designated for building Microservice and cloud native applications. Photo by Joey Huang on Unsplash Unlike Spring Boot, Micronaut process IOC at compile time and erases runtime reflection, so it is easier to build native image. Spring also started a Spring native project, but it is in the early stage. For developers that new to Micronaut, it is easy to develop your applications using Micronaut if you have some knowledge of Spring Boot. In this post, I will share my experience to create a simple Restful API application from scratch using Micronaut from a Spring developer view. Generating project skeleton Similar to Spring Initializr, Micronaut provides an online service named Launch to help your generate a project skeleton. Open your browser, go to Micronaut Launch, you will see the following screen. In the Java version field, select the latest LTS version 17. Then click the Features button, add lombok, data hibernate jpa, assertj, postgres, testcontainers. Finally, hit the GENERATE PROJECT button to produce the project files into an archive for download. Extract the project files into disk, and import to your IDE. You can also create a Micronaut project using Micronaut CLI, check Micronaut Starter documentation. Exploring project structure Let’s have a look at the files in the project. .├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradle.properties├── gradlew├── gradlew.bat├── micronaut-cli.yml├── settings.gradle└── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ └── Application.java │ └── resources │ ├── application.yml │ └── logback.xml └── test ├── java │ └── com │ └── example │ └── DemoTest.java └── resources ├── application-test.yml └── logback-test.xml Besides Gradle build scripts related resources, it is similar to the Spring Boot project structure. The Application is the entry class of the application.The src/main/resources/application.yml is the application configuration.The src/main/resources/logback.xml is logging configuration.The DemoTest is an example of using @MicronautTest.Under the src/test/resources folder, there are some config resources for test purpose. Let’s have a look at build.gradle. It uses com.github.johnrengelman.shadow to package the application into a jar archive. The micronaut plugin will process the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native image. Declaring a Bean In Micronaut, it used JSR330(aka @Inject) specification to annotate the injectable beans. JSR330 originally is lead by SpringSource(now VMware) and Google. Spring also has built-in JSR330 support, by default it is not activated. You should add inject artifact in your project dependencies to enable it. When a class is annotated with @Singleton means there is only one instance shared in the application scope, @Prototype will produce a new instance for every injection. Micronaut provides a @Factory to produces simple beans in groups, for example. @Factoryclass MyConfig{ @Singleton public Foo foo(){} @Singleton public Bar bar(){}} As described in former sections, Micronaut process IOC at compile time. When building the application, explore the project build/classes folder, you will find there are a lot of extra classes generated at compile time which names are start with a USD(“$”) symbol. Setup database Open src/main/resources/application.yml, the datasources is configured when generating the project. Change the properties according to your environment. datasources: default: url: jdbc:postgresql://localhost:5432/blogdb driverClassName: org.postgresql.Driver username: user password: password schema-generate: CREATE_DROP dialect: POSTGRESjpa.default.properties.hibernate.hbm2ddl.auto: update Create a docker compose file to bootstrap Postgres in docker container. version: &#39;3.7&#39; # specify docker-compose version services: postgres: image: postgres ports: - &quot;5432:5432&quot; restart: always environment: POSTGRES_PASSWORD: password POSTGRES_DB: blogdb POSTGRES_USER: user volumes: - ./data:/var/lib/postgresql - ./pg-initdb.d:/docker-entrypoint-initdb.d Start up Postgres database. docker compose up postgres Data Accessing with Micronaut Data We added data-jpa feature when generating the project, which enables Micronaut data support. If you have experience of Spring Data JPA , it is easy to migrate to Micronaut Data. I have used a simple blog application in the former examples when demonstrating other frameworks. In this post, I will reuse the blog application concept. Basically it includes two JPA entities, Post and Comment, it is a OneToMany relation. @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &quot;posts&quot;)public class Post implements Serializable { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) UUID id; String title; String content; @Builder.Default Status status = Status.DRAFT; @Builder.Default LocalDateTime createdAt = LocalDateTime.now(); @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = &quot;post&quot;) @Builder.Default @OrderColumn(name = &quot;comment_idx&quot;) List&lt;Comment&gt; comments = new ArrayList&lt;&gt;(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Post post = (Post) o; return getTitle().equals(post.getTitle()); } @Override public int hashCode() { return Objects.hash(getTitle()); } @Override public String toString() { return &quot;Post{&quot; + &quot;id=&quot; + id + &quot;, title=&#39;&quot; + title + &#39;\\&#39;&#39; + &quot;, content=&#39;&quot; + content + &#39;\\&#39;&#39; + &quot;, status=&quot; + status + &quot;, createdAt=&quot; + createdAt + &#39;}&#39;; }} // Comment entity @Getter@Setter@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = &quot;comments&quot;)public class Comment implements Serializable { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) private UUID id; @ManyToOne @JoinColumn(name = &quot;post_id&quot;) private Post post; private String content; @Builder.Default @Column(name = &quot;created_at&quot;) private LocalDateTime createdAt = LocalDateTime.now(); @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Comment comment = (Comment) o; return getContent().equals(comment.getContent()); } @Override public int hashCode() { return Objects.hash(getContent()); } @Override public String toString() { return &quot;Comment{&quot; + &quot;id=&quot; + id + &quot;, content=&#39;&quot; + content + &#39;\\&#39;&#39; + &quot;, createdAt=&quot; + createdAt + &#39;}&#39;; }} They are standard JPA @Entity classes. An JPA entity class should be annotated with an @Entity annotation, and includes a @Id field to identify this entity and a none-arguments constructor. Here we use Lombok to generate setters and getters, and constructors at compile time. We use IDE to generate equals and hasCode according to the business requirements. @Repositorypublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;{ } @Repositorypublic interface CommentRepository extends JpaRepository&lt;Comment, UUID&gt; { List&lt;Comment&gt; findByPost(Post post);} Add a DataInitializer bean to initialize some sample data. @Singleton@RequiredArgsConstructor@Slf4jpublic class DataInitializer implements ApplicationEventListener&lt;ApplicationStartupEvent&gt; { private final PostRepository posts; private final TransactionOperations&lt;?&gt; tx; @Override public void onApplicationEvent(ApplicationStartupEvent event) { log.info(&quot;initializing sample data...&quot;); var data = List.of(Post.builder().title(&quot;Getting started wit Micronaut&quot;).content(&quot;test&quot;).build(), Post.builder().title(&quot;Getting started wit Micronaut: part 2&quot;).content(&quot;test&quot;).build()); tx.executeWrite(status -&gt; { this.posts.deleteAll(); this.posts.saveAll(data); return null; }); tx.executeRead(status -&gt; { this.posts.findAll().forEach(p -&gt; log.info(&quot;saved post: {}&quot;, p)); return null; }); log.info(&quot;data initialization is done...&quot;); }} Write a test to verify functionality of PostRepository. Similar to the @SpringBootTest, Micronaut provides a @MicronautTest. @MicronautTest(application = Application.class, startApplication = false)class PostRepositoryTest { @Inject PostRepository posts; @PersistenceContext EntityManager entityManager; @Test void testCreatePost() { var entity = Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build(); this.entityManager.persist(entity); assertThat(entity.getId()).isNotNull(); assertTrue(posts.findById(entity.getId()).isPresent()); } } Here we set startApplication = false, it does not start the embedded server to host the application, to test against the database, we do not need a running application We have add testcontainers feature, it will configure a Postgres for test automatically. Check the testcontainers config in the src/test/resources/application-test.yml. datasources: default: url: jdbc:tc:postgresql:12:///postgres driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver When there is a tc as database host name, testcontainer will start up a Postgres database automaticially. Exposing Restful APIs Similar to Spring WebMVC, in Micronaut, we can use a controller to expose Restful APIs. @Controller(&quot;/posts&quot;)@RequiredArgsConstructor(onConstructor_ = {@Inject})@Validatedpublic class PostController { private final PostRepository posts; private final CommentRepository comments; @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&lt;List&lt;PostSummaryDto&gt;&gt; getAll() { var body = posts.findAll() .stream() .map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())) .toList(); return ok(body); } @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON) public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) //.orElseThrow(() -&gt; new PostNotFoundException(id)); .orElseGet(HttpResponse::notFound); }} A controller is annotated with @Controller, you can set a base uri that can be applied on all methods. The @Get, @Post,@Put, @Delete is mapped to handle varied HTTP methods, it is similar to the Spring&#39;s @GetMapping, @PostMapping, etc. You can set media types using consumes or produces attributes in these annotations to limit the request and response content type, or use standalone annotations @Consumes and @Produces to set up the media types. Start up the application via Gradle command. ./gradlew run Do not forget to start up Postgres firstly. Use curl to test the /posts endpoint. curl http://localhost:8080/posts[ { &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;}, { &quot;id&quot; : &quot;8c6147ea-8de4-473f-b97d-e211c8e43bac&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;} ] curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf { &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;content&quot;: &quot;test&quot;, &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;} Micronaut CLI provides commands to generate controller, bean, etc. Run mn --help to get all available commands. Write a test for the PostController. @MicronautTest(environments = Environment.TEST)public class PostControllerTest { @Inject @Client(&quot;/&quot;) HttpClient client; @Inject PostRepository posts; @Inject CommentRepository comments; @MockBean(PostRepository.class) PostRepository posts() { return mock(PostRepository.class); } @MockBean(CommentRepository.class) CommentRepository comments() { return mock(CommentRepository.class); } @Test @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;) public void testGetAllPosts() throws Exception { when(this.posts.findAll()).thenReturn( List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()) ); var response = client.toBlocking().exchange(&quot;/posts&quot;, PostSummaryDto[].class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.length).isEqualTo(1); assertThat(body[0].title()).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findAll(); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint&quot;) public void testGetSinglePost() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn( Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()) ); var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID()))); var response = client.toBlocking().exchange(request, PostDetailsDto.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(body.title()).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); } @Test @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint that does not exist&quot;) public void testGetSinglePost_notFound() throws Exception { when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null)); var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID()))); var exception = assertThrows(HttpClientResponseException.class, () -&gt; client.toBlocking().exchange(request, PostDetailsDto.class)); assertEquals(HttpStatus.NOT_FOUND, exception.getStatus()); verify(this.posts, times(1)).findById(any(UUID.class)); verifyNoMoreInteractions(this.posts); }} In this test, we use Mockito to mock all dependent beans(PostRepository and CommentRepository) in the PostController. To mock beans in the test context, Micronaut provides a MockBean to produce a mocked instance to replace the real beans. Similar to Spring’s RestTemplate or WebClient, Micronaut provides a HttpClient to send request to a certain URI, by default it uses the ReactiveStreams compatible API, If you are stick on the traditional blocking API, call the toBlocking() method to switch to use it. The exchange method will return a HTTP response object, and the retrieve method returns the response body directly. Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code, it will throws a HttpClientResponseException instead. In contrast, in ReactiveStreams APIs, it will emit the exception to error channel. Exception Handling In the above PostController, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real world application, we can use an exception to envelope the exception case. Like Spring WebMVC, Micronaut also provides exception handling mechanism. For example, create an PostNotFoundException to stand for the case post was not found by id. Create a PostNotFoundException class. public class PostNotFoundException extends RuntimeException { public PostNotFoundException(UUID id) { super(&quot;Post[id=&quot; + id + &quot;] was not found&quot;); }} In the PostController, throw the exception. @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt()))) .orElseThrow(() -&gt; new PostNotFoundException(id));} Add a PostNotFoundExceptionHandler to handle PostNotFoundException. @Produces@Singleton@Requires(classes = { PostNotFoundException.class})@RequiredArgsConstructorpublic class PostNotFoundExceptionHandler implements ExceptionHandler&lt;PostNotFoundException, HttpResponse&lt;?&gt;&gt; { private final ErrorResponseProcessor&lt;?&gt; errorResponseProcessor; @Override public HttpResponse&lt;?&gt; handle(HttpRequest request, PostNotFoundException exception) { return errorResponseProcessor.processResponse( ErrorContext.builder(request) .cause(exception) .errorMessage(exception.getMessage()) .build(), HttpResponse.notFound() ); }} Open your terminal, use curl to test the /posts/{id} endpoint with an none-existing id. # curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf -v&gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt;&lt; HTTP/1.1 404 Not Found&lt; Content-Type: application/json&lt; date: Mon, 25 Oct 2021 07:02:01 GMT&lt; content-length: 301&lt; connection: keep-alive&lt;{ &quot;message&quot; : &quot;Not Found&quot;, &quot;_links&quot; : { &quot;self&quot; : { &quot;href&quot; : &quot;/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;, &quot;templated&quot; : false } }, &quot;_embedded&quot; : { &quot;errors&quot; : [ { &quot;message&quot; : &quot;Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found&quot; } ] }} Pagination Similar to Spring Data, Micronaut Data provides pagination for long query result, the findAll accepts a Pageable parameter, and returns a Page result. Micronaut Data also includes a Specification to adopt JPA Criteria APIs for type safe query. Change PostRepository , add JpaSpecificationExecutor&lt;Post&gt; to extends list. @Repositorypublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; { } Create a specific PostSpecifications to group all specifications for querying posts. Currently only add one for query by keyword and status. public class PostSpecifications { private PostSpecifications(){ // forbid to instantiate } public static Specification&lt;Post&gt; filterByKeywordAndStatus( final String keyword, final Status status ) { return (Root&lt;Post&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) -&gt; { List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if (StringUtils.hasText(keyword)) { predicates.add( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + keyword + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + keyword + &quot;%&quot;) ) ); } if (status != null) { predicates.add(cb.equal(root.get(Post_.status), status)); } return cb.and(predicates.toArray(new Predicate[0])); }; }} Change the getAll method of PostController to the following. @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;Page&lt;PostSummaryDto&gt;&gt; getAll(@QueryValue(defaultValue = &quot;&quot;) String q, @QueryValue(defaultValue = &quot;&quot;) String status, @QueryValue(defaultValue = &quot;0&quot;) int page, @QueryValue(defaultValue = &quot;10&quot;) int size) { var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(&quot;createdAt&quot;))); var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null; var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable); var body = data.map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt())); return ok(body);} All the query parameters are optional. Let’s use curl to test the /posts endpiont. # curl http://localhost:8080/posts{ &quot;content&quot; : [ { &quot;id&quot; : &quot;c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot; }, { &quot;id&quot; : &quot;0a79185c-5981-4301-86d1-c266b26b4980&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot; } ], &quot;pageable&quot; : { &quot;number&quot; : 0, &quot;sort&quot; : { &quot;orderBy&quot; : [ { &quot;property&quot; : &quot;createdAt&quot;, &quot;direction&quot; : &quot;DESC&quot;, &quot;ignoreCase&quot; : false, &quot;ascending&quot; : false } ], &quot;sorted&quot; : true }, &quot;size&quot; : 10, &quot;offset&quot; : 0, &quot;sorted&quot; : true, &quot;unpaged&quot; : false }, &quot;totalSize&quot; : 2, &quot;totalPages&quot; : 1, &quot;empty&quot; : false, &quot;size&quot; : 10, &quot;offset&quot; : 0, &quot;numberOfElements&quot; : 2, &quot;pageNumber&quot; : 0} Customizing JsonSerializer The Page object rendered result is a little tedious, most of case, we do not need all these fields, we can customize it via Jackson JsonSerializer. @Singletonpublic class PageJsonSerializer extends JsonSerializer&lt;Page&lt;?&gt;&gt; { @Override public void serialize(Page&lt;?&gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeStartObject(); gen.writeNumberField(&quot;pageNumber&quot;, value.getPageNumber()); if (value.getNumberOfElements() != value.getSize()) { //only display it in the last page when number of elements is not equal to page size. gen.writeNumberField(&quot;numberOfElements&quot;, value.getNumberOfElements()); } gen.writeNumberField(&quot;size&quot;, value.getSize()); gen.writeNumberField(&quot;totalPages&quot;, value.getTotalPages()); gen.writeNumberField(&quot;totalSize&quot;, value.getTotalSize()); gen.writeObjectField(&quot;content&quot;, value.getContent()); gen.writeEndObject(); }} Run the application again, and hint /posts endpoint. # curl http://localhost:8080/posts{ &quot;pageNumber&quot; : 0, &quot;numberOfElements&quot; : 2, &quot;size&quot; : 10, &quot;totalPages&quot; : 1, &quot;totalSize&quot; : 2, &quot;content&quot; : [ { &quot;id&quot; : &quot;53fb77d5-4159-4a80-bab9-c76d9a535b36&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot; }, { &quot;id&quot; : &quot;aa02fd49-0c24-4f12-b204-2e48213c7a1e&quot;, &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;, &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot; } ]} Modify the testing codes to verify changes. class PostControllerTest{ //... @Test @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;) public void testGetAllPosts() throws Exception { var content = List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build()); when(this.posts.findAll(isA(Specification.class), isA(Pageable.class))).thenReturn( Page.of(content, Pageable.from(0, 20), 1) ); var request = HttpRequest.GET(&quot;/posts&quot;); var response = client.toBlocking().exchange(request, String.class); assertEquals(HttpStatus.OK, response.status()); var body = response.body(); assertThat(JsonPath.from(body).getInt(&quot;totalSize&quot;)).isEqualTo(1); assertThat(JsonPath.from(body).getString(&quot;content[0].title&quot;)).isEqualTo(&quot;test title&quot;); verify(this.posts, times(1)).findAll(isA(Specification.class), isA(Pageable.class)); verifyNoMoreInteractions(this.posts); }} Creating Posts We have discussed how to query posts by key word and get single post by id, in this section, we will focus on creating a new post. According the REST convention, we will use a POST HTTP method to send a request on endpoint /posts and accept JSON data as request body. @io.micronaut.http.annotation.Post(uri = &quot;/&quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;Void&gt; create(@Body CreatePostCommand dto) { var data = Post.builder().title(dto.title()).content(dto.content()).build(); var saved = this.posts.save(data); return HttpResponse.created(URI.create(&quot;/posts/&quot; + saved.getId()));} The request body is deserialized as a POJO by built-in Jackson JsonDesearilizers, it is annotated with a @Body annotation to indicate which target class it will be desearilized to. After the post data is saved, set the response header Location to the URI of accessing the new post. Run the application, and try to add a post via curl, and then access the newly created post. # curl -X POST -v -H &quot;Content-Type:application/json&quot; http://localhost:8080/posts -d &quot;{\\&quot;title\\&quot;:\\&quot;test title\\&quot;,\\&quot;content\\&quot;:\\&quot;test content\\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 47&gt;* upload completely sent off: 47 out of 47 bytes&lt; HTTP/1.1 201 Created&lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6&lt; date: Mon, 25 Oct 2021 09:07:40 GMT&lt; connection: keep-alive&lt; transfer-encoding: chunked&lt;# curl http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6{ &quot;id&quot; : &quot;7db15639-62e3-4d3e-9cf4-f54413502ea6&quot;, &quot;title&quot; : &quot;test title&quot;, &quot;content&quot; : &quot;test content&quot;, &quot;status&quot; : &quot;DRAFT&quot;, &quot;createdAt&quot; : &quot;2021-10-25T17:07:40.87621&quot;} Data Validation Generally, in a real application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support. In the above CreatPostCommand class, add Bean Validation annotations on the fields. @Introspectedpublic record CreatePostCommand(@NotBlank String title, @NotBlank String content) {} You have to add @Introspected annotation to let micronaut plugin to preprocess bean validation annotations at compile time, and let Bean Validation works without any reflections APIs at runtime time. In the PostController, add a @Validated on the class and a @Valid on the method argument. @Validatedpublic class PostController { public HttpResponse&lt;Void&gt; create(@Body @Valid CreatePostCommand dto) {...} //...} Let’s try to create a post. Note, set the content field empty. curl -X POST -v -H &quot;Content-Type:application/json&quot; http://localhost:8080/posts -d &quot;{\\&quot;title\\&quot;:\\&quot;test title\\&quot;,\\&quot;content\\&quot;:\\&quot;\\&quot;}&quot;&gt; POST /posts HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.55.1&gt; Accept: */*&gt; Content-Type:application/json&gt; Content-Length: 35&gt;* upload completely sent off: 35 out of 35 bytes&lt; HTTP/1.1 400 Bad Request&lt; Content-Type: application/json&lt; date: Mon, 25 Oct 2021 09:23:22 GMT&lt; content-length: 237&lt; connection: keep-alive&lt;{ &quot;message&quot; : &quot;Bad Request&quot;, &quot;_embedded&quot; : { &quot;errors&quot; : [ { &quot;message&quot; : &quot;dto.content: must not be blank&quot; } ] }, &quot;_links&quot; : { &quot;self&quot; : { &quot;href&quot; : &quot;/posts&quot;, &quot;templated&quot; : false } }} Deleting a Post According to REST convention, to delete a single post, send a DELETE request on /posts/{id}, if it is successful, returns a 204 status. If the id is not existed, returns a 404 instead. Add the following codes to the PostController. @Delete(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;?&gt; deleteById(@PathVariable UUID id) { return posts.findById(id) .map(p -&gt; { this.posts.delete(p); return HttpResponse.noContent(); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);} Processing Subresources In our application, the a Comment resource, it should be a subresource of Post resource when adding comments or fetching comments of a specific post, we can design comments resource like this. POST /posts/{id}/comments , add a Comment resource to a specific Post.GET /posts/{id}/comments, get all comments of a certain Post which id value is the path variable id. // nested comments endpoints@Get(uri = &quot;/{id}/comments&quot;, produces = MediaType.APPLICATION_JSON)public HttpResponse&lt;?&gt; getCommentsByPostId(@PathVariable UUID id) { return posts.findById(id) .map(post -&gt; { var comments = this.comments.findByPost(post); return ok(comments.stream().map(c -&gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt()))); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); //.orElseGet(HttpResponse::notFound);} @io.micronaut.http.annotation.Post(uri = &quot;/{id}/comments&quot;, consumes = MediaType.APPLICATION_JSON)@Transactionalpublic HttpResponse&lt;?&gt; create(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) { return posts.findById(id) .map(post -&gt; { var data = Comment.builder().content(dto.content()).post(post).build(); post.getComments().add(data); var saved = this.comments.save(data); return HttpResponse.created(URI.create(&quot;/comments/&quot; + saved.getId())); }) .orElseThrow(() -&gt; new PostNotFoundException(id)); // .orElseGet(HttpResponse::notFound); } Integration Tests The following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server. @MicronautTest@Slf4jclass IntegrationTests { @Inject @Client(&quot;/&quot;) HttpClient client; @Inject EmbeddedApplication&lt;?&gt; application; @Test void testItWorks() { Assertions.assertTrue(application.isRunning()); } @Test void testGetAllPosts() { var response = client.exchange(HttpRequest.GET(&quot;/posts&quot;), String.class); var bodyFlux = Flux.from(response).map(HttpResponse::body); StepVerifier.create(bodyFlux) .consumeNextWith(posts -&gt; assertThat(JsonPath.from(posts).getInt(&quot;totalSize&quot;)).isGreaterThanOrEqualTo(2)) .verifyComplete(); } @Test public void testCrudFlow() { //create a new post var request = HttpRequest.POST(&quot;/posts&quot;, new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;)); var blockingHttpClient = client.toBlocking(); var response = blockingHttpClient.exchange(request); assertThat(response.status().getCode()).isEqualTo(201); var savedUrl = response.getHeaders().get(&quot;Location&quot;); assertThat(savedUrl).isNotNull(); log.debug(&quot;saved post url: {}&quot;, savedUrl); //get by id var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class); assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200); // add comments var addCommentRequest = HttpRequest.POST(savedUrl + &quot;/comments&quot;, new CreateCommentCommand(&quot;test content&quot;)); var addCommentResponse = blockingHttpClient.exchange(addCommentRequest); assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201); var savedCommentUrl = addCommentResponse.getHeaders().get(&quot;Location&quot;); assertThat(savedCommentUrl).isNotNull(); // get all comments var getAllCommentsRequest = HttpRequest.GET(savedUrl + &quot;/comments&quot;); var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class)); assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200); assertThat(getAllCommentsResponse.body().size()).isEqualTo(1); //delete by id var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl)); assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204); //get by id again(404) var e = Assertions.assertThrows(HttpClientResponseException.class, () -&gt; blockingHttpClient.exchange(HttpRequest.GET(savedUrl))); var getPostResponse2 = e.getResponse(); assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404); } } In the testGetAllPosts test, we try to use reactive HttpClient APIs and use reactor-test&#39;s StepVerifier to assert the data in a reactive data stream. The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post. In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using RestAssured and Java 11 new HttpClient, check the source codes and explore them yourself. The example codes are hosted on my GitHub, check hantsy/micronaut-sandbox#post-service. &lt;hr&gt;&lt;p&gt;Building Restful APIs with Micronaut was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building Restful APIs with Micronaut","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-restful-apis-with-micronaut/"},"url":"/blog/2021/building-restful-apis-with-micronaut/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building Restful APIs with Micronaut</h1>
    <p class="post-meta">October 27, 2021</p>
  </header>

  <article class="post-content">
    <p>Similar to Spring Boot, Micronaut is a JVM based framework and designated for building Microservice and cloud native applications.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zQQZFdnK1KadoGtvK5pRDA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@onice?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Joey Huang</a> on <a href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Unlike Spring Boot, Micronaut process IOC at compile time and erases runtime reflection, so it is easier to build native image.</p><blockquote><em>Spring also started a Spring native project, but it is in the early stage.</em></blockquote><p>For developers that new to Micronaut, it is easy to develop your applications using Micronaut if you have some knowledge of Spring Boot. In this post, I will share my experience to create a simple Restful API application from scratch using Micronaut from a Spring developer view.</p><h3>Generating project skeleton</h3><p>Similar to <a href="https://start.spring.io">Spring Initializr</a>, Micronaut provides an online service named <strong>Launch</strong> to help your generate a project skeleton.</p><p>Open your browser, go to <a href="https://micronaut.io/launch/">Micronaut Launch</a>, you will see the following screen.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*XfXojoTfgHQQe4Yp.png" /></figure><p>In the <strong>Java version</strong> field, select the latest LTS version <strong>17</strong>. Then click the <strong>Features</strong> button, add <em>lombok</em>, <em>data hibernate jpa</em>, <em>assertj</em>, <em>postgres</em>, <em>testcontainers</em>. Finally, hit the <strong>GENERATE PROJECT</strong> button to produce the project files into an archive for download.</p><p>Extract the project files into disk, and import to your IDE.</p><blockquote><em>You can also create a Micronaut project using Micronaut CLI, check </em><a href="https://micronaut-projects.github.io/micronaut-starter/latest/guide/#installation"><em>Micronaut Starter documentation</em></a><em>.</em></blockquote><h3>Exploring project structure</h3><p>Let’s have a look at the files in the project.</p><pre>.<br>├── build.gradle<br>├── gradle<br>│   └── wrapper<br>│       ├── gradle-wrapper.jar<br>│       └── gradle-wrapper.properties<br>├── gradle.properties<br>├── gradlew<br>├── gradlew.bat<br>├── micronaut-cli.yml<br>├── settings.gradle<br>└── src<br>    ├── main<br>    │   ├── java<br>    │   │   └── com<br>    │   │       └── example<br>    │   │           └── Application.java<br>    │   └── resources<br>    │       ├── application.yml<br>    │       └── logback.xml<br>    └── test<br>        ├── java<br>        │   └── com<br>        │       └── example<br>        │           └── DemoTest.java<br>        └── resources<br>            ├── application-test.yml<br>            └── logback-test.xml</pre><p>Besides Gradle build scripts related resources, it is similar to the Spring Boot project structure.</p><ul><li>The Application is the entry class of the application.</li><li>The <em>src/main/resources/application.yml</em> is the application configuration.</li><li>The <em>src/main/resources/logback.xml</em> is logging configuration.</li><li>The DemoTest is an example of using @MicronautTest.</li><li>Under the <em>src/test/resources</em> folder, there are some config resources for test purpose.</li></ul><p>Let’s have a look at <em>build.gradle</em>.</p><p>It uses com.github.johnrengelman.shadow to package the application into a jar archive. The micronaut plugin will process the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native image.</p><h3>Declaring a Bean</h3><p>In Micronaut, it used JSR330(aka @Inject) specification to annotate the injectable beans. JSR330 originally is lead by SpringSource(now VMware) and Google.</p><blockquote><em>Spring also has built-in JSR330 support, by default it is not activated. You should add </em><em>inject artifact in your project dependencies to enable it.</em></blockquote><p>When a class is annotated with @Singleton means there is only one instance shared in the application scope, @Prototype will produce a new instance for every injection.</p><p>Micronaut provides a @Factory to produces simple beans in groups, for example.</p><pre>@Factory<br>class MyConfig{<br>    <br>    @Singleton<br>    public Foo foo(){}<br>    <br>    @Singleton<br>    public Bar bar(){}<br>}</pre><p>As described in former sections, Micronaut process IOC at compile time. When building the application, explore the project <em>build/classes</em> folder, you will find there are a lot of extra classes generated at compile time which names are start with a USD(“<strong>$</strong>”) symbol.</p><h3>Setup database</h3><p>Open <em>src/main/resources/application.yml</em>, the datasources is configured when generating the project. Change the properties according to your environment.</p><pre>datasources:<br>  default:<br>    url: jdbc:postgresql://localhost:5432/blogdb<br>    driverClassName: org.postgresql.Driver<br>    username: user<br>    password: password<br>    schema-generate: CREATE_DROP<br>    dialect: POSTGRES<br>jpa.default.properties.hibernate.hbm2ddl.auto: update</pre><p>Create a docker compose file to bootstrap Postgres in docker container.</p><pre>version: &#39;3.7&#39; # specify docker-compose version</pre><pre>services:<br>  postgres:<br>    image: postgres<br>    ports:<br>      - &quot;5432:5432&quot;<br>    restart: always<br>    environment:<br>      POSTGRES_PASSWORD: password<br>      POSTGRES_DB: blogdb<br>      POSTGRES_USER: user<br>    volumes:<br>      - ./data:/var/lib/postgresql<br>      - ./pg-initdb.d:/docker-entrypoint-initdb.d</pre><p>Start up Postgres database.</p><pre>docker compose up postgres</pre><h3>Data Accessing with Micronaut Data</h3><p>We added <em>data-jpa</em> feature when generating the project, which enables Micronaut data support. If you have experience of Spring Data JPA , it is easy to migrate to Micronaut Data.</p><p>I have used a simple blog application in the former examples when demonstrating other frameworks. In this post, I will reuse the blog application concept.</p><p>Basically it includes two JPA entities, Post and Comment, it is a OneToMany relation.</p><pre>@Getter<br>@Setter<br>@NoArgsConstructor<br>@AllArgsConstructor<br>@Builder<br>@Entity<br>@Table(name = &quot;posts&quot;)<br>public class Post implements Serializable {</pre><pre>    @Id<br>    @GeneratedValue(generator = &quot;uuid&quot;)<br>    @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;)<br>    UUID id;<br>    String title;<br>    String content;</pre><pre>    @Builder.Default<br>    Status status = Status.DRAFT;</pre><pre>    @Builder.Default<br>    LocalDateTime createdAt = LocalDateTime.now();</pre><pre>    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = &quot;post&quot;)<br>    @Builder.Default<br>    @OrderColumn(name = &quot;comment_idx&quot;)<br>    List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();</pre><pre>    @Override<br>    public boolean equals(Object o) {<br>        if (this == o) return true;<br>        if (o == null || getClass() != o.getClass()) return false;<br>        Post post = (Post) o;<br>        return getTitle().equals(post.getTitle());<br>    }</pre><pre>    @Override<br>    public int hashCode() {<br>        return Objects.hash(getTitle());<br>    }</pre><pre>    @Override<br>    public String toString() {<br>        return &quot;Post{&quot; +<br>                &quot;id=&quot; + id +<br>                &quot;, title=&#39;&quot; + title + &#39;\&#39;&#39; +<br>                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +<br>                &quot;, status=&quot; + status +<br>                &quot;, createdAt=&quot; + createdAt +<br>                &#39;}&#39;;<br>    }<br>}</pre><pre>// Comment entity <br>@Getter<br>@Setter<br>@NoArgsConstructor<br>@AllArgsConstructor<br>@Builder<br>@Entity<br>@Table(name = &quot;comments&quot;)<br>public class Comment implements Serializable {</pre><pre>    @Id<br>    @GeneratedValue(generator = &quot;uuid&quot;)<br>    @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;)<br>    private UUID id;</pre><pre>    @ManyToOne<br>    @JoinColumn(name = &quot;post_id&quot;)<br>    private Post post;</pre><pre>    private String content;</pre><pre>    @Builder.Default<br>    @Column(name = &quot;created_at&quot;)<br>    private LocalDateTime createdAt = LocalDateTime.now();</pre><pre>    @Override<br>    public boolean equals(Object o) {<br>        if (this == o) return true;<br>        if (o == null || getClass() != o.getClass()) return false;<br>        Comment comment = (Comment) o;<br>        return getContent().equals(comment.getContent());<br>    }</pre><pre>    @Override<br>    public int hashCode() {<br>        return Objects.hash(getContent());<br>    }</pre><pre>    @Override<br>    public String toString() {<br>        return &quot;Comment{&quot; +<br>                &quot;id=&quot; + id +<br>                &quot;, content=&#39;&quot; + content + &#39;\&#39;&#39; +<br>                &quot;, createdAt=&quot; + createdAt +<br>                &#39;}&#39;;<br>    }<br>}</pre><p>They are standard JPA @Entity classes.</p><p>An JPA entity class should be annotated with an @Entity annotation, and includes a @Id field to identify this entity and a none-arguments constructor. Here we use Lombok to generate setters and getters, and constructors at compile time. We use IDE to generate equals and hasCode according to the business requirements.</p><pre>@Repository<br>public interface PostRepository extends JpaRepository&lt;Post, UUID&gt;{</pre><pre>}</pre><pre>@Repository<br>public interface CommentRepository extends JpaRepository&lt;Comment, UUID&gt; {</pre><pre>    List&lt;Comment&gt; findByPost(Post post);<br>}</pre><p>Add a DataInitializer bean to initialize some sample data.</p><pre>@Singleton<br>@RequiredArgsConstructor<br>@Slf4j<br>public class DataInitializer implements ApplicationEventListener&lt;ApplicationStartupEvent&gt; {<br>    private final PostRepository posts;</pre><pre>    private final TransactionOperations&lt;?&gt; tx;</pre><pre>    @Override<br>    public void onApplicationEvent(ApplicationStartupEvent event) {<br>        log.info(&quot;initializing sample data...&quot;);<br>        var data = List.of(Post.builder().title(&quot;Getting started wit Micronaut&quot;).content(&quot;test&quot;).build(),<br>                Post.builder().title(&quot;Getting started wit Micronaut: part 2&quot;).content(&quot;test&quot;).build());<br>        tx.executeWrite(status -&gt; {<br>            this.posts.deleteAll();<br>            this.posts.saveAll(data);<br>            return null;<br>        });<br>        tx.executeRead(status -&gt; {<br>            this.posts.findAll().forEach(p -&gt; log.info(&quot;saved post: {}&quot;, p));<br>            return null;<br>        });<br>        log.info(&quot;data initialization is done...&quot;);<br>    }<br>}</pre><p>Write a test to verify functionality of PostRepository. Similar to the @SpringBootTest, Micronaut provides a @MicronautTest.</p><pre>@MicronautTest(application = Application.class, startApplication = false)<br>class PostRepositoryTest {</pre><pre>    @Inject<br>    PostRepository posts;</pre><pre>    @PersistenceContext<br>    EntityManager entityManager;</pre><pre>    @Test<br>    void testCreatePost() {<br>        var entity = Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build();<br>        this.entityManager.persist(entity);</pre><pre>        assertThat(entity.getId()).isNotNull();<br>        assertTrue(posts.findById(entity.getId()).isPresent());<br>    }</pre><pre>}</pre><p>Here we set startApplication = false, it does not start the embedded server to host the application, to test against the database, we do not need a running application</p><p>We have add testcontainers feature, it will configure a Postgres for test automatically. Check the testcontainers config in the src/test/resources/application-test.yml.</p><pre>datasources:<br>  default:<br>    url: jdbc:tc:postgresql:12:///postgres<br>    driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver</pre><p>When there is a tc as database host name, testcontainer will start up a Postgres database automaticially.</p><h3>Exposing Restful APIs</h3><p>Similar to Spring WebMVC, in Micronaut, we can use a controller to expose Restful APIs.</p><pre>@Controller(&quot;/posts&quot;)<br>@RequiredArgsConstructor(onConstructor_ = {@Inject})<br>@Validated<br>public class PostController {<br>    private final PostRepository posts;<br>    private final CommentRepository comments;</pre><pre>    @Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON)<br>    public HttpResponse&lt;List&lt;PostSummaryDto&gt;&gt; getAll() {<br>        var body = posts.findAll()<br>                .stream()<br>                .map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt()))<br>                .toList();<br>        return ok(body);<br>    }</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)<br>    public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) {<br>        return posts.findById(id)<br>                .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt())))<br>                //.orElseThrow(() -&gt; new PostNotFoundException(id));<br>        .orElseGet(HttpResponse::notFound);<br>    }<br>}</pre><p>A controller is annotated with @Controller, you can set a base uri that can be applied on all methods. The @Get, @Post,@Put, @Delete is mapped to handle varied HTTP methods, it is similar to the Spring&#39;s @GetMapping, @PostMapping, etc. You can set media types using <em>consumes</em> or <em>produces</em> attributes in these annotations to limit the request and response content type, or use standalone annotations @Consumes and @Produces to set up the media types.</p><p>Start up the application via Gradle command.</p><pre>./gradlew run</pre><blockquote><em>Do not forget to start up Postgres firstly.</em></blockquote><p>Use curl to test the /posts endpoint.</p><pre>curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a><br>[ {<br>  &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;,<br>  &quot;title&quot; : &quot;Getting started wit Micronaut&quot;,<br>  &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;<br>}, {<br>  &quot;id&quot; : &quot;8c6147ea-8de4-473f-b97d-e211c8e43bac&quot;,<br>  &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;,<br>  &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;<br>} ]</pre><pre>curl <a href="http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf">http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf</a><br> {<br>  &quot;id&quot; : &quot;b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;,<br>  &quot;title&quot; : &quot;Getting started wit Micronaut&quot;,<br>  &quot;content&quot;: &quot;test&quot;,<br>  &quot;createdAt&quot; : &quot;2021-10-14T22:00:28.80933&quot;<br>}</pre><blockquote><em>Micronaut CLI provides commands to generate controller, bean, etc. Run </em><em>mn --help to get all available commands.</em></blockquote><p>Write a test for the PostController.</p><pre>@MicronautTest(environments = Environment.TEST)<br>public class PostControllerTest {</pre><pre>    @Inject<br>    @Client(&quot;/&quot;)<br>    HttpClient client;</pre><pre>    @Inject<br>    PostRepository posts;</pre><pre>    @Inject<br>    CommentRepository comments;</pre><pre>    @MockBean(PostRepository.class)<br>    PostRepository posts() {<br>        return mock(PostRepository.class);<br>    }</pre><pre>    @MockBean(CommentRepository.class)<br>    CommentRepository comments() {<br>        return mock(CommentRepository.class);<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;)<br>    public void testGetAllPosts() throws Exception {<br>        when(this.posts.findAll()).thenReturn(<br>                List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build())<br>        );<br>        var response = client.toBlocking().exchange(&quot;/posts&quot;, PostSummaryDto[].class);<br>        assertEquals(HttpStatus.OK, response.status());<br>        var body = response.body();<br>        assertThat(body.length).isEqualTo(1);<br>        assertThat(body[0].title()).isEqualTo(&quot;test title&quot;);</pre><pre>        verify(this.posts, times(1)).findAll();<br>        verifyNoMoreInteractions(this.posts);<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint&quot;)<br>    public void testGetSinglePost() throws Exception {<br>        when(this.posts.findById(any(UUID.class))).thenReturn(<br>                Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build())<br>        );<br>        var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID())));<br>        var response = client.toBlocking().exchange(request, PostDetailsDto.class);<br>        assertEquals(HttpStatus.OK, response.status());<br>        var body = response.body();<br>        assertThat(body.title()).isEqualTo(&quot;test title&quot;);</pre><pre>        verify(this.posts, times(1)).findById(any(UUID.class));<br>        verifyNoMoreInteractions(this.posts);<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;test GET &#39;/posts/{id}&#39; endpoint that does not exist&quot;)<br>    public void testGetSinglePost_notFound() throws Exception {<br>        when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null));<br>        var request = HttpRequest.GET(UriBuilder.of(&quot;/posts/{id}&quot;).expand(Map.of(&quot;id&quot;, UUID.randomUUID())));<br>        var exception = assertThrows(HttpClientResponseException.class, () -&gt; client.toBlocking().exchange(request, PostDetailsDto.class));</pre><pre>        assertEquals(HttpStatus.NOT_FOUND, exception.getStatus());<br>        verify(this.posts, times(1)).findById(any(UUID.class));<br>        verifyNoMoreInteractions(this.posts);<br>    }<br>}</pre><p>In this test, we use Mockito to mock all dependent beans(PostRepository and CommentRepository) in the PostController. To mock beans in the test context, Micronaut provides a MockBean to produce a mocked instance to replace the <em>real</em> beans.</p><p>Similar to Spring’s RestTemplate or WebClient, Micronaut provides a HttpClient to send request to a certain URI, by default it uses the <em>ReactiveStream</em>s compatible API, If you are stick on the traditional blocking API, call the toBlocking() method to switch to use it.</p><p>The exchange method will return a HTTP response object, and the retrieve method returns the response body directly.</p><blockquote><em>Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code, it will throws a </em><em>HttpClientResponseException instead. In contrast, in ReactiveStreams APIs, it will emit the exception to error channel.</em></blockquote><h3>Exception Handling</h3><p>In the above PostController, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real world application, we can use an exception to envelope the exception case. Like Spring WebMVC, Micronaut also provides exception handling mechanism.</p><p>For example, create an PostNotFoundException to stand for the case post was not found by id.</p><p>Create a PostNotFoundException class.</p><pre>public class PostNotFoundException extends RuntimeException {<br>    public PostNotFoundException(UUID id) {<br>        super(&quot;Post[id=&quot; + id + &quot;] was not found&quot;);<br>    }<br>}</pre><p>In the PostController, throw the exception.</p><pre>@Get(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)<br>public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) {<br>    return posts.findById(id)<br>        .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt())))<br>        .orElseThrow(() -&gt; new PostNotFoundException(id));<br>}</pre><p>Add a PostNotFoundExceptionHandler to handle PostNotFoundException.</p><pre>@Produces<br>@Singleton<br>@Requires(classes = { PostNotFoundException.class})<br>@RequiredArgsConstructor<br>public class PostNotFoundExceptionHandler implements ExceptionHandler&lt;PostNotFoundException, HttpResponse&lt;?&gt;&gt; {<br>    private final ErrorResponseProcessor&lt;?&gt; errorResponseProcessor;</pre><pre>    @Override<br>    public HttpResponse&lt;?&gt; handle(HttpRequest request, PostNotFoundException exception) {<br>        return errorResponseProcessor.processResponse(<br>                ErrorContext.builder(request)<br>                        .cause(exception)<br>                        .errorMessage(exception.getMessage())<br>                        .build(),<br>                HttpResponse.notFound()<br>        );<br>    }<br>}</pre><p>Open your terminal, use curl to test the /posts/{id} endpoint with an none-existing id.</p><pre># curl <a href="http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf">http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf</a> -v<br>&gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1<br>&gt; Host: localhost:8080<br>&gt; User-Agent: curl/7.55.1<br>&gt; Accept: */*<br>&gt;<br>&lt; HTTP/1.1 404 Not Found<br>&lt; Content-Type: application/json<br>&lt; date: Mon, 25 Oct 2021 07:02:01 GMT<br>&lt; content-length: 301<br>&lt; connection: keep-alive<br>&lt;<br>{<br>  &quot;message&quot; : &quot;Not Found&quot;,<br>  &quot;_links&quot; : {<br>    &quot;self&quot; : {<br>      &quot;href&quot; : &quot;/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf&quot;,<br>      &quot;templated&quot; : false<br>    }<br>  },<br>  &quot;_embedded&quot; : {<br>    &quot;errors&quot; : [ {<br>      &quot;message&quot; : &quot;Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found&quot;<br>    } ]<br>  }<br>}</pre><h3>Pagination</h3><p>Similar to Spring Data, Micronaut Data provides pagination for long query result, the findAll accepts a Pageable parameter, and returns a Page result. Micronaut Data also includes a Specification to adopt JPA Criteria APIs for type safe query.</p><p>Change PostRepository , add JpaSpecificationExecutor&lt;Post&gt; to extends list.</p><pre>@Repository<br>public interface PostRepository extends JpaRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; {</pre><pre>}</pre><p>Create a specific PostSpecifications to group all specifications for querying posts. Currently only add one for query by keyword and status.</p><pre>public class PostSpecifications {<br>    private PostSpecifications(){<br>        // forbid to instantiate<br>    }</pre><pre>    public static Specification&lt;Post&gt; filterByKeywordAndStatus(<br>            final String keyword,<br>            final Status status<br>    ) {<br>        return (Root&lt;Post&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) -&gt; {<br>            List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();<br>            if (StringUtils.hasText(keyword)) {<br>                predicates.add(<br>                        cb.or(<br>                                cb.like(root.get(Post_.title), &quot;%&quot; + keyword + &quot;%&quot;),<br>                                cb.like(root.get(Post_.content), &quot;%&quot; + keyword + &quot;%&quot;)<br>                        )<br>                );<br>            }</pre><pre>            if (status != null) {<br>                predicates.add(cb.equal(root.get(Post_.status), status));<br>            }</pre><pre>            return cb.and(predicates.toArray(new Predicate[0]));<br>        };<br>    }<br>}</pre><p>Change the getAll method of PostController to the following.</p><pre>@Get(uri = &quot;/&quot;, produces = MediaType.APPLICATION_JSON)<br>@Transactional<br>public HttpResponse&lt;Page&lt;PostSummaryDto&gt;&gt; getAll(@QueryValue(defaultValue = &quot;&quot;) String q,<br>                                                 @QueryValue(defaultValue = &quot;&quot;) String status,<br>                                                 @QueryValue(defaultValue = &quot;0&quot;) int page,<br>                                                 @QueryValue(defaultValue = &quot;10&quot;) int size) {<br>    var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(&quot;createdAt&quot;)));<br>    var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null;<br>    var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable);<br>    var body = data.map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt()));<br>    return ok(body);<br>}</pre><p>All the query parameters are optional.</p><p>Let’s use curl to test the <em>/posts</em> endpiont.</p><pre># curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a><br>{<br>  &quot;content&quot; : [ {<br>    &quot;id&quot; : &quot;c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6&quot;,<br>    &quot;title&quot; : &quot;Getting started wit Micronaut&quot;,<br>    &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot;<br>  }, {<br>    &quot;id&quot; : &quot;0a79185c-5981-4301-86d1-c266b26b4980&quot;,<br>    &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;,<br>    &quot;createdAt&quot; : &quot;2021-10-25T16:35:03.732951&quot;<br>  } ],<br>  &quot;pageable&quot; : {<br>    &quot;number&quot; : 0,<br>    &quot;sort&quot; : {<br>      &quot;orderBy&quot; : [ {<br>        &quot;property&quot; : &quot;createdAt&quot;,<br>        &quot;direction&quot; : &quot;DESC&quot;,<br>        &quot;ignoreCase&quot; : false,<br>        &quot;ascending&quot; : false<br>      } ],<br>      &quot;sorted&quot; : true<br>    },<br>    &quot;size&quot; : 10,<br>    &quot;offset&quot; : 0,<br>    &quot;sorted&quot; : true,<br>    &quot;unpaged&quot; : false<br>  },<br>  &quot;totalSize&quot; : 2,<br>  &quot;totalPages&quot; : 1,<br>  &quot;empty&quot; : false,<br>  &quot;size&quot; : 10,<br>  &quot;offset&quot; : 0,<br>  &quot;numberOfElements&quot; : 2,<br>  &quot;pageNumber&quot; : 0<br>}</pre><h3>Customizing JsonSerializer</h3><p>The Page object rendered result is a little tedious, most of case, we do not need all these fields, we can customize it via Jackson JsonSerializer.</p><pre>@Singleton<br>public class PageJsonSerializer extends JsonSerializer&lt;Page&lt;?&gt;&gt; {<br>    @Override<br>    public void serialize(Page&lt;?&gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException {<br>        gen.writeStartObject();<br>        gen.writeNumberField(&quot;pageNumber&quot;, value.getPageNumber());<br>        if (value.getNumberOfElements() != value.getSize()) {<br>            //only display it in the last page when number of elements is not equal to page size.<br>            gen.writeNumberField(&quot;numberOfElements&quot;, value.getNumberOfElements());<br>        }<br>        gen.writeNumberField(&quot;size&quot;, value.getSize());<br>        gen.writeNumberField(&quot;totalPages&quot;, value.getTotalPages());<br>        gen.writeNumberField(&quot;totalSize&quot;, value.getTotalSize());<br>        gen.writeObjectField(&quot;content&quot;, value.getContent());<br>        gen.writeEndObject();<br>    }<br>}</pre><p>Run the application again, and hint <em>/posts</em> endpoint.</p><pre># curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a><br>{<br>  &quot;pageNumber&quot; : 0,<br>  &quot;numberOfElements&quot; : 2,<br>  &quot;size&quot; : 10,<br>  &quot;totalPages&quot; : 1,<br>  &quot;totalSize&quot; : 2,<br>  &quot;content&quot; : [ {<br>    &quot;id&quot; : &quot;53fb77d5-4159-4a80-bab9-c76d9a535b36&quot;,<br>    &quot;title&quot; : &quot;Getting started wit Micronaut&quot;,<br>    &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot;<br>  }, {<br>    &quot;id&quot; : &quot;aa02fd49-0c24-4f12-b204-2e48213c7a1e&quot;,<br>    &quot;title&quot; : &quot;Getting started wit Micronaut: part 2&quot;,<br>    &quot;createdAt&quot; : &quot;2021-10-25T16:47:05.545594&quot;<br>  } ]<br>}</pre><p>Modify the testing codes to verify changes.</p><pre>class PostControllerTest{<br>    //...<br>    <br>    @Test<br>    @DisplayName(&quot;test GET &#39;/posts&#39; endpoint&quot;)<br>    public void testGetAllPosts() throws Exception {<br>        var content = List.of(Post.builder().id(UUID.randomUUID()).title(&quot;test title&quot;).content(&quot;test content&quot;).build());<br>        when(this.posts.findAll(isA(Specification.class), isA(Pageable.class))).thenReturn(<br>                Page.of(content, Pageable.from(0, 20), 1)<br>        );<br>        var request = HttpRequest.GET(&quot;/posts&quot;);<br>        var response = client.toBlocking().exchange(request, String.class);<br>        assertEquals(HttpStatus.OK, response.status());<br>        var body = response.body();<br>        assertThat(JsonPath.from(body).getInt(&quot;totalSize&quot;)).isEqualTo(1);<br>        assertThat(JsonPath.from(body).getString(&quot;content[0].title&quot;)).isEqualTo(&quot;test title&quot;);</pre><pre>        verify(this.posts, times(1)).findAll(isA(Specification.class), isA(Pageable.class));<br>        verifyNoMoreInteractions(this.posts);<br>    }<br>}</pre><h3>Creating Posts</h3><p>We have discussed how to query posts by key word and get single post by id, in this section, we will focus on creating a new post.</p><p>According the REST convention, we will use a POST HTTP method to send a request on endpoint <em>/posts</em> and accept JSON data as request body.</p><pre>@io.micronaut.http.annotation.Post(uri = &quot;/&quot;, consumes = MediaType.APPLICATION_JSON)<br>@Transactional<br>public HttpResponse&lt;Void&gt; create(@Body CreatePostCommand dto) {<br>    var data = Post.builder().title(dto.title()).content(dto.content()).build();<br>    var saved = this.posts.save(data);<br>    return HttpResponse.created(URI.create(&quot;/posts/&quot; + saved.getId()));<br>}</pre><p>The request body is deserialized as a POJO by built-in Jackson JsonDesearilizers, it is annotated with a @Body annotation to indicate which target class it will be desearilized to. After the post data is saved, set the response header Location to the URI of accessing the new post.</p><p>Run the application, and try to add a post via curl, and then access the newly created post.</p><pre># curl -X POST -v  -H &quot;Content-Type:application/json&quot; <a href="http://localhost:8080/posts">http://localhost:8080/posts</a> -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;test content\&quot;}&quot;<br>&gt; POST /posts HTTP/1.1<br>&gt; Host: localhost:8080<br>&gt; User-Agent: curl/7.55.1<br>&gt; Accept: */*<br>&gt; Content-Type:application/json<br>&gt; Content-Length: 47<br>&gt;<br>* upload completely sent off: 47 out of 47 bytes<br>&lt; HTTP/1.1 201 Created<br>&lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6<br>&lt; date: Mon, 25 Oct 2021 09:07:40 GMT<br>&lt; connection: keep-alive<br>&lt; transfer-encoding: chunked<br>&lt;<br># curl <a href="http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6">http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6</a><br>{<br>  &quot;id&quot; : &quot;7db15639-62e3-4d3e-9cf4-f54413502ea6&quot;,<br>  &quot;title&quot; : &quot;test title&quot;,<br>  &quot;content&quot; : &quot;test content&quot;,<br>  &quot;status&quot; : &quot;DRAFT&quot;,<br>  &quot;createdAt&quot; : &quot;2021-10-25T17:07:40.87621&quot;<br>}</pre><h3>Data Validation</h3><p>Generally, in a real application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support.</p><p>In the above CreatPostCommand class, add Bean Validation annotations on the fields.</p><pre>@Introspected<br>public record CreatePostCommand(@NotBlank String title, @NotBlank String content) {<br>}</pre><p>You have to add @Introspected annotation to let micronaut plugin to preprocess bean validation annotations at compile time, and let Bean Validation works without any reflections APIs at runtime time.</p><p>In the PostController, add a @Validated on the class and a @Valid on the method argument.</p><pre>@Validated<br>public class PostController {<br>    public HttpResponse&lt;Void&gt; create(@Body @Valid CreatePostCommand dto) {...}<br>    //...<br>}</pre><p>Let’s try to create a post. Note, set the content field empty.</p><pre>curl -X POST -v  -H &quot;Content-Type:application/json&quot; <a href="http://localhost:8080/posts">http://localhost:8080/posts</a> -d &quot;{\&quot;title\&quot;:\&quot;test title\&quot;,\&quot;content\&quot;:\&quot;\&quot;}&quot;<br>&gt; POST /posts HTTP/1.1<br>&gt; Host: localhost:8080<br>&gt; User-Agent: curl/7.55.1<br>&gt; Accept: */*<br>&gt; Content-Type:application/json<br>&gt; Content-Length: 35<br>&gt;<br>* upload completely sent off: 35 out of 35 bytes<br>&lt; HTTP/1.1 400 Bad Request<br>&lt; Content-Type: application/json<br>&lt; date: Mon, 25 Oct 2021 09:23:22 GMT<br>&lt; content-length: 237<br>&lt; connection: keep-alive<br>&lt;<br>{<br>  &quot;message&quot; : &quot;Bad Request&quot;,<br>  &quot;_embedded&quot; : {<br>    &quot;errors&quot; : [ {<br>      &quot;message&quot; : &quot;dto.content: must not be blank&quot;<br>    } ]<br>  },<br>  &quot;_links&quot; : {<br>    &quot;self&quot; : {<br>      &quot;href&quot; : &quot;/posts&quot;,<br>      &quot;templated&quot; : false<br>    }<br>  }<br>}</pre><h3>Deleting a Post</h3><p>According to REST convention, to delete a single post, send a DELETE request on /posts/{id}, if it is successful, returns a 204 status. If the id is not existed, returns a 404 instead.</p><p>Add the following codes to the PostController.</p><pre>@Delete(uri = &quot;/{id}&quot;, produces = MediaType.APPLICATION_JSON)<br>@Transactional<br>public HttpResponse&lt;?&gt; deleteById(@PathVariable UUID id) {<br>    return posts.findById(id)<br>        .map(p -&gt; {<br>            this.posts.delete(p);<br>            return HttpResponse.noContent();<br>        })<br>        .orElseThrow(() -&gt; new PostNotFoundException(id));<br>    //.orElseGet(HttpResponse::notFound);<br>}</pre><h3>Processing Subresources</h3><p>In our application, the a Comment resource, it should be a subresource of Post resource when adding comments or fetching comments of a specific post, we can design comments resource like this.</p><ul><li>POST /posts/{id}/comments , add a Comment resource to a specific Post.</li><li>GET /posts/{id}/comments, get all comments of a certain Post which id value is the path variable id.</li></ul><pre>// nested comments endpoints<br>@Get(uri = &quot;/{id}/comments&quot;, produces = MediaType.APPLICATION_JSON)<br>public HttpResponse&lt;?&gt; getCommentsByPostId(@PathVariable UUID id) {<br>    return posts.findById(id)<br>        .map(post -&gt; {<br>            var comments = this.comments.findByPost(post);<br>            return ok(comments.stream().map(c -&gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt())));<br>        })<br>        .orElseThrow(() -&gt; new PostNotFoundException(id));<br>    //.orElseGet(HttpResponse::notFound);<br>}</pre><pre>@io.micronaut.http.annotation.Post(uri = &quot;/{id}/comments&quot;, consumes = MediaType.APPLICATION_JSON)<br>@Transactional<br>public HttpResponse&lt;?&gt; create(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) {</pre><pre>    return posts.findById(id)<br>        .map(post -&gt; {<br>            var data = Comment.builder().content(dto.content()).post(post).build();<br>            post.getComments().add(data);<br>            var saved = this.comments.save(data);<br>            return HttpResponse.created(URI.create(&quot;/comments/&quot; + saved.getId()));<br>        })<br>        .orElseThrow(() -&gt; new PostNotFoundException(id));<br>    // .orElseGet(HttpResponse::notFound);</pre><pre>}</pre><h3>Integration Tests</h3><p>The following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server.</p><pre>@MicronautTest<br>@Slf4j<br>class IntegrationTests {</pre><pre>    @Inject<br>    @Client(&quot;/&quot;)<br>    HttpClient client;</pre><pre>    @Inject<br>    EmbeddedApplication&lt;?&gt; application;</pre><pre>    @Test<br>    void testItWorks() {<br>        Assertions.assertTrue(application.isRunning());<br>    }</pre><pre>    @Test<br>    void testGetAllPosts() {<br>        var response = client.exchange(HttpRequest.GET(&quot;/posts&quot;), String.class);</pre><pre>        var bodyFlux = Flux.from(response).map(HttpResponse::body);<br>        StepVerifier.create(bodyFlux)<br>                .consumeNextWith(posts -&gt; assertThat(JsonPath.from(posts).getInt(&quot;totalSize&quot;)).isGreaterThanOrEqualTo(2))<br>                .verifyComplete();<br>    }</pre><pre>    @Test<br>    public void testCrudFlow() {<br>        //create a new post<br>        var request = HttpRequest.POST(&quot;/posts&quot;, new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;));<br>        var blockingHttpClient = client.toBlocking();<br>        var response = blockingHttpClient.exchange(request);<br>        assertThat(response.status().getCode()).isEqualTo(201);<br>        var savedUrl = response.getHeaders().get(&quot;Location&quot;);<br>        assertThat(savedUrl).isNotNull();<br>        log.debug(&quot;saved post url: {}&quot;, savedUrl);</pre><pre>        //get by id<br>        var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class);<br>        assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200);</pre><pre>        // add comments<br>        var addCommentRequest = HttpRequest.POST(savedUrl + &quot;/comments&quot;, new CreateCommentCommand(&quot;test content&quot;));<br>        var addCommentResponse = blockingHttpClient.exchange(addCommentRequest);<br>        assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201);<br>        var savedCommentUrl = addCommentResponse.getHeaders().get(&quot;Location&quot;);<br>        assertThat(savedCommentUrl).isNotNull();</pre><pre>        // get all comments<br>        var getAllCommentsRequest = HttpRequest.GET(savedUrl + &quot;/comments&quot;);<br>        var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class));<br>        assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200);<br>        assertThat(getAllCommentsResponse.body().size()).isEqualTo(1);</pre><pre>        //delete by id<br>        var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl));<br>        assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204);</pre><pre>        //get by id again(404)<br>        var e = Assertions.assertThrows(HttpClientResponseException.class, () -&gt;<br>                blockingHttpClient.exchange(HttpRequest.GET(savedUrl)));<br>        var getPostResponse2 = e.getResponse();<br>        assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404);<br>    }</pre><pre>}</pre><p>In the testGetAllPosts test, we try to use reactive HttpClient APIs and use reactor-test&#39;s StepVerifier to assert the data in a reactive data stream.</p><p>The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post.</p><p>In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using RestAssured and Java 11 new HttpClient, check <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/post-service">the source codes</a> and explore them yourself.</p><p>The example codes are hosted on my GitHub, check <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/post-service">hantsy/micronaut-sandbox#post-service</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=98f4eb39211c" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-restful-apis-with-micronaut-98f4eb39211c">Building Restful APIs with Micronaut</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
