<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Integrating Vertx application with Spring framework
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/integrating-vertx-application-with-spring-framework/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Integrating Vertx application with Spring framework" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As shown in the former we assembled everything manually in the MainVerticle class. We will use Spring IOC to manage the dependencies. Photo by Hanson Lu on Unsplash For example, it looks like the following. //Create a PgPool instancevar pgPool = pgPool(); //Creating PostRepositoryvar postRepository = PostRepository.create(pgPool); //Creating PostHandlervar postHandlers = PostsHandler.create(postRepository); // Initializing the sample datavar initializer = DataInitializer.create(pgPool);initializer.run(); // Configure routesvar router = routes(postHandlers); // Create the HTTP serververtx.createHttpServer()... In this post, we will introduce Spring framework to manage the dependencies of the above items. Add the Spring context dependency into the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt; The spring-context provides basic IOC functionality which is used for assembling dependencies and providing dependency injection. Create a @Configuration class to start Spring application context. @Configuration@ComponentScanpublic class DemoApplication { public static void main(String[] args) { var context = new AnnotationConfigApplicationContext(DemoApplication.class); var vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); // deploy MainVerticle via verticle identifier name vertx.deployVerticle(factory.prefix()+&quot;:&quot;+MainVerticle.class.getName()); } @Bean public Vertx vertx(VerticleFactory verticleFactory) { Vertx vertx = Vertx.vertx(); vertx.registerVerticleFactory(verticleFactory); return vertx; } @Bean public PgPool pgPool(Vertx vertx) { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; }} In the main method, we use a AnnotationConfigApplicationContext to scan Spring components and assemble the dependencies. Then fetch Vertx bean and VerticleFactory bean from the Spring application context, and call vertx.deployVerticle. The VerticleFactory is a Vertx built-in hook for instantiating a Verticle instance. In this configuration, we also declares beans: Vertx which accepts VerticleFactory bean and registers a VerticleFactory in the Vertx bean.PgPool is used for accessing Postgres database. You can move the database configuration to a properties file, and load it by Spring @PropertySource annotation. Let’s have a look at VerticleFactory bean - a Spring context aware VerticleFactory implementation. @Componentpublic class SpringAwareVerticleFactory implements VerticleFactory, ApplicationContextAware { private ApplicationContext applicationContext; @Override public String prefix() { return &quot;spring&quot;; } @Override public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) { String clazz = VerticleFactory.removePrefix(verticleName); promise.complete(() -&gt; (Verticle) applicationContext.getBean(Class.forName(clazz))); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; }} When instantiating a Verticle by name, it will call the createVerticle method, which looks up the beans in the Spring application context. Let’s have a look at the other classes, which are declared as Spring @Component directly. For the complete source codes, check vertx-sandbox/post-service-spring from my Github. @Component@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; //...} @Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; //...} @Component@RequiredArgsConstructorpublic class PostRepository { private final PgPool client; //...} @Component@RequiredArgsConstructorpublic class DataInitializer { private final PgPool client; //...} All @Components can be scanned when DemoApplicaiton is running. As you see, through Spring IOC container, we erase all manual steps of the assembling the dependencies. Now let’s try to start the application. In the former application, the application can be run by maven exec plugin and jar file. But it uses a built-in Launcher class to deploy the Verticle. We have configured to use Spring to complete the same work, so change the configuration of maven exec plugin and maven shade plugin to the following. &lt;plugin&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-shade-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;manifestEntries&gt; &lt;Main-Class&gt;com.example.demo.DemoApplication&lt;/Main-Class&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt; &lt;/transformers&gt; &lt;artifactSet&gt; &lt;/artifactSet&gt; &lt;outputFile&gt;${project.build.directory}/${project.artifactId}-${project.version}-fat.jar &lt;/outputFile&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${exec-maven-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.demo.DemoApplication&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt; Now run the following command to start the application. mvn clean compile exec:java //ormvn clean packagejava -jar target\xxx-fat.jar In the TestMainVerticle, let&#39;s do some modifications to use Spring IOC container, eg. you can get a Vertx instance from the Spring application context. @SpringJUnitConfig(classes = DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Autowired ApplicationContext context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .onSuccess(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }) .onFailure(testContext::failNow); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body)) .onSuccess( buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ) ) .onFailure(e -&gt; { LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()); testContext.failNow(e); }); }} Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Integrating Vertx application with Spring framework was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="As shown in the former we assembled everything manually in the MainVerticle class. We will use Spring IOC to manage the dependencies. Photo by Hanson Lu on Unsplash For example, it looks like the following. //Create a PgPool instancevar pgPool = pgPool(); //Creating PostRepositoryvar postRepository = PostRepository.create(pgPool); //Creating PostHandlervar postHandlers = PostsHandler.create(postRepository); // Initializing the sample datavar initializer = DataInitializer.create(pgPool);initializer.run(); // Configure routesvar router = routes(postHandlers); // Create the HTTP serververtx.createHttpServer()... In this post, we will introduce Spring framework to manage the dependencies of the above items. Add the Spring context dependency into the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt; The spring-context provides basic IOC functionality which is used for assembling dependencies and providing dependency injection. Create a @Configuration class to start Spring application context. @Configuration@ComponentScanpublic class DemoApplication { public static void main(String[] args) { var context = new AnnotationConfigApplicationContext(DemoApplication.class); var vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); // deploy MainVerticle via verticle identifier name vertx.deployVerticle(factory.prefix()+&quot;:&quot;+MainVerticle.class.getName()); } @Bean public Vertx vertx(VerticleFactory verticleFactory) { Vertx vertx = Vertx.vertx(); vertx.registerVerticleFactory(verticleFactory); return vertx; } @Bean public PgPool pgPool(Vertx vertx) { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; }} In the main method, we use a AnnotationConfigApplicationContext to scan Spring components and assemble the dependencies. Then fetch Vertx bean and VerticleFactory bean from the Spring application context, and call vertx.deployVerticle. The VerticleFactory is a Vertx built-in hook for instantiating a Verticle instance. In this configuration, we also declares beans: Vertx which accepts VerticleFactory bean and registers a VerticleFactory in the Vertx bean.PgPool is used for accessing Postgres database. You can move the database configuration to a properties file, and load it by Spring @PropertySource annotation. Let’s have a look at VerticleFactory bean - a Spring context aware VerticleFactory implementation. @Componentpublic class SpringAwareVerticleFactory implements VerticleFactory, ApplicationContextAware { private ApplicationContext applicationContext; @Override public String prefix() { return &quot;spring&quot;; } @Override public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) { String clazz = VerticleFactory.removePrefix(verticleName); promise.complete(() -&gt; (Verticle) applicationContext.getBean(Class.forName(clazz))); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; }} When instantiating a Verticle by name, it will call the createVerticle method, which looks up the beans in the Spring application context. Let’s have a look at the other classes, which are declared as Spring @Component directly. For the complete source codes, check vertx-sandbox/post-service-spring from my Github. @Component@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; //...} @Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; //...} @Component@RequiredArgsConstructorpublic class PostRepository { private final PgPool client; //...} @Component@RequiredArgsConstructorpublic class DataInitializer { private final PgPool client; //...} All @Components can be scanned when DemoApplicaiton is running. As you see, through Spring IOC container, we erase all manual steps of the assembling the dependencies. Now let’s try to start the application. In the former application, the application can be run by maven exec plugin and jar file. But it uses a built-in Launcher class to deploy the Verticle. We have configured to use Spring to complete the same work, so change the configuration of maven exec plugin and maven shade plugin to the following. &lt;plugin&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-shade-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;manifestEntries&gt; &lt;Main-Class&gt;com.example.demo.DemoApplication&lt;/Main-Class&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt; &lt;/transformers&gt; &lt;artifactSet&gt; &lt;/artifactSet&gt; &lt;outputFile&gt;${project.build.directory}/${project.artifactId}-${project.version}-fat.jar &lt;/outputFile&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${exec-maven-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.demo.DemoApplication&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt; Now run the following command to start the application. mvn clean compile exec:java //ormvn clean packagejava -jar target\xxx-fat.jar In the TestMainVerticle, let&#39;s do some modifications to use Spring IOC container, eg. you can get a Vertx instance from the Spring application context. @SpringJUnitConfig(classes = DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Autowired ApplicationContext context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .onSuccess(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }) .onFailure(testContext::failNow); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body)) .onSuccess( buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ) ) .onFailure(e -&gt; { LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()); testContext.failNow(e); }); }} Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Integrating Vertx application with Spring framework was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Integrating Vertx application with Spring framework" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-23T00:00:00+00:00","datePublished":"2021-07-23T00:00:00+00:00","description":"As shown in the former we assembled everything manually in the MainVerticle class. We will use Spring IOC to manage the dependencies. Photo by Hanson Lu on Unsplash For example, it looks like the following. //Create a PgPool instancevar pgPool = pgPool(); //Creating PostRepositoryvar postRepository = PostRepository.create(pgPool); //Creating PostHandlervar postHandlers = PostsHandler.create(postRepository); // Initializing the sample datavar initializer = DataInitializer.create(pgPool);initializer.run(); // Configure routesvar router = routes(postHandlers); // Create the HTTP serververtx.createHttpServer()... In this post, we will introduce Spring framework to manage the dependencies of the above items. Add the Spring context dependency into the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt; The spring-context provides basic IOC functionality which is used for assembling dependencies and providing dependency injection. Create a @Configuration class to start Spring application context. @Configuration@ComponentScanpublic class DemoApplication { public static void main(String[] args) { var context = new AnnotationConfigApplicationContext(DemoApplication.class); var vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); // deploy MainVerticle via verticle identifier name vertx.deployVerticle(factory.prefix()+&quot;:&quot;+MainVerticle.class.getName()); } @Bean public Vertx vertx(VerticleFactory verticleFactory) { Vertx vertx = Vertx.vertx(); vertx.registerVerticleFactory(verticleFactory); return vertx; } @Bean public PgPool pgPool(Vertx vertx) { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; }} In the main method, we use a AnnotationConfigApplicationContext to scan Spring components and assemble the dependencies. Then fetch Vertx bean and VerticleFactory bean from the Spring application context, and call vertx.deployVerticle. The VerticleFactory is a Vertx built-in hook for instantiating a Verticle instance. In this configuration, we also declares beans: Vertx which accepts VerticleFactory bean and registers a VerticleFactory in the Vertx bean.PgPool is used for accessing Postgres database. You can move the database configuration to a properties file, and load it by Spring @PropertySource annotation. Let’s have a look at VerticleFactory bean - a Spring context aware VerticleFactory implementation. @Componentpublic class SpringAwareVerticleFactory implements VerticleFactory, ApplicationContextAware { private ApplicationContext applicationContext; @Override public String prefix() { return &quot;spring&quot;; } @Override public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) { String clazz = VerticleFactory.removePrefix(verticleName); promise.complete(() -&gt; (Verticle) applicationContext.getBean(Class.forName(clazz))); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; }} When instantiating a Verticle by name, it will call the createVerticle method, which looks up the beans in the Spring application context. Let’s have a look at the other classes, which are declared as Spring @Component directly. For the complete source codes, check vertx-sandbox/post-service-spring from my Github. @Component@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; //...} @Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; //...} @Component@RequiredArgsConstructorpublic class PostRepository { private final PgPool client; //...} @Component@RequiredArgsConstructorpublic class DataInitializer { private final PgPool client; //...} All @Components can be scanned when DemoApplicaiton is running. As you see, through Spring IOC container, we erase all manual steps of the assembling the dependencies. Now let’s try to start the application. In the former application, the application can be run by maven exec plugin and jar file. But it uses a built-in Launcher class to deploy the Verticle. We have configured to use Spring to complete the same work, so change the configuration of maven exec plugin and maven shade plugin to the following. &lt;plugin&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-shade-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;manifestEntries&gt; &lt;Main-Class&gt;com.example.demo.DemoApplication&lt;/Main-Class&gt; &lt;/manifestEntries&gt; &lt;/transformer&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt; &lt;/transformers&gt; &lt;artifactSet&gt; &lt;/artifactSet&gt; &lt;outputFile&gt;${project.build.directory}/${project.artifactId}-${project.version}-fat.jar &lt;/outputFile&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${exec-maven-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;mainClass&gt;com.example.demo.DemoApplication&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt; Now run the following command to start the application. mvn clean compile exec:java //ormvn clean packagejava -jar target\\xxx-fat.jar In the TestMainVerticle, let&#39;s do some modifications to use Spring IOC container, eg. you can get a Vertx instance from the Spring application context. @SpringJUnitConfig(classes = DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Autowired ApplicationContext context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .onSuccess(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }) .onFailure(testContext::failNow); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body)) .onSuccess( buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ) ) .onFailure(e -&gt; { LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()); testContext.failNow(e); }); }} Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Integrating Vertx application with Spring framework was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Integrating Vertx application with Spring framework","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/integrating-vertx-application-with-spring-framework/"},"url":"/blog/2021/integrating-vertx-application-with-spring-framework/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Integrating Vertx application with Spring framework</h1>
    <p class="post-meta">July 23, 2021</p>
  </header>

  <article class="post-content">
    <p>As shown in the former we assembled everything manually in the MainVerticle class. We will use Spring IOC to manage the dependencies.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BK5r0YsZvSKWQGD9exxvzQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@hansonluu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Hanson Lu</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>For example, it looks like the following.</p><pre>//Create a PgPool instance<br>var pgPool = pgPool();</pre><pre>//Creating PostRepository<br>var postRepository = PostRepository.create(pgPool);</pre><pre>//Creating PostHandler<br>var postHandlers = PostsHandler.create(postRepository);</pre><pre>// Initializing the sample data<br>var initializer = DataInitializer.create(pgPool);<br>initializer.run();</pre><pre>// Configure routes<br>var router = routes(postHandlers);</pre><pre>// Create the HTTP server<br>vertx.createHttpServer()...</pre><p>In this post, we will introduce Spring framework to manage the dependencies of the above items.</p><p>Add the Spring context dependency into the project <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>The spring-context provides basic IOC functionality which is used for assembling dependencies and providing dependency injection.</p><p>Create a @Configuration class to start Spring application context.</p><pre>@Configuration<br>@ComponentScan<br>public class DemoApplication {</pre><pre>    public static void main(String[] args) {<br>        var context = new AnnotationConfigApplicationContext(DemoApplication.class);<br>        var vertx = context.getBean(Vertx.class);<br>        var factory  = context.getBean(VerticleFactory.class);</pre><pre>        // deploy MainVerticle via verticle identifier name<br>        vertx.deployVerticle(factory.prefix()+&quot;:&quot;+MainVerticle.class.getName());<br>    }</pre><pre>    @Bean<br>    public Vertx vertx(VerticleFactory verticleFactory) {<br>        Vertx vertx = Vertx.vertx();<br>        vertx.registerVerticleFactory(verticleFactory);<br>        return vertx;<br>    }</pre><pre>    @Bean<br>    public PgPool pgPool(Vertx vertx) {<br>        PgConnectOptions connectOptions = new PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;);</pre><pre>        // Pool Options<br>        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>        // Create the pool from the data object<br>        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>        return pool;<br>    }<br>}</pre><p>In the main method, we use a AnnotationConfigApplicationContext to scan Spring components and assemble the dependencies. Then fetch Vertx bean and VerticleFactory bean from the Spring application context, and call vertx.deployVerticle.</p><blockquote><em>The </em><em>VerticleFactory is a Vertx built-in hook for instantiating a Verticle instance.</em></blockquote><p>In this configuration, we also declares beans:</p><ul><li>Vertx which accepts VerticleFactory bean and registers a VerticleFactory in the Vertx bean.</li><li>PgPool is used for accessing Postgres database. You can move the database configuration to a <em>properties</em> file, and load it by Spring @PropertySource annotation.</li></ul><p>Let’s have a look at VerticleFactory bean - a Spring context aware VerticleFactory implementation.</p><pre>@Component<br>public class SpringAwareVerticleFactory implements VerticleFactory, ApplicationContextAware {</pre><pre>    private ApplicationContext applicationContext;</pre><pre>    @Override<br>    public String prefix() {<br>        return &quot;spring&quot;;<br>    }</pre><pre>    @Override<br>    public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) {<br>        String clazz = VerticleFactory.removePrefix(verticleName);<br>        promise.complete(() -&gt; (Verticle) applicationContext.getBean(Class.forName(clazz)));<br>    }</pre><pre>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {<br>        this.applicationContext = applicationContext;<br>    }<br>}</pre><p>When instantiating a Verticle by name, it will call the createVerticle method, which looks up the beans in the Spring application context.</p><p>Let’s have a look at the other classes, which are declared as Spring @Component directly. For the complete source codes, check <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service-spring">vertx-sandbox/post-service-spring</a> from my Github.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class MainVerticle extends AbstractVerticle {<br>    final PostsHandler postHandlers;<br>    <br>    //...<br>}</pre><pre>@Component<br>@RequiredArgsConstructor<br>class PostsHandler {<br>    private final PostRepository posts;<br>    <br>    //...<br>}</pre><pre>@Component<br>@RequiredArgsConstructor<br>public class PostRepository {</pre><pre>    private final PgPool client;<br>    <br>    //...<br>}</pre><pre>@Component<br>@RequiredArgsConstructor<br>public class DataInitializer {</pre><pre>    private  final PgPool client;<br>    <br>    //...<br>}</pre><p>All @Components can be scanned when DemoApplicaiton is running.</p><p>As you see, through Spring IOC container, we erase all manual steps of the assembling the dependencies.</p><p>Now let’s try to start the application.</p><p>In the former application, the application can be run by maven exec plugin and jar file. But it uses a built-in Launcher class to deploy the Verticle. We have configured to use Spring to complete the same work, so change the configuration of maven exec plugin and maven shade plugin to the following.</p><pre>&lt;plugin&gt;<br>    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;${maven-shade-plugin.version}&lt;/version&gt;<br>    &lt;executions&gt;<br>        &lt;execution&gt;<br>            &lt;phase&gt;package&lt;/phase&gt;<br>            &lt;goals&gt;<br>                &lt;goal&gt;shade&lt;/goal&gt;<br>            &lt;/goals&gt;<br>            &lt;configuration&gt;<br>                &lt;transformers&gt;<br>                    &lt;transformer<br>                                 implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;<br>                        &lt;manifestEntries&gt;<br>                            &lt;Main-Class&gt;com.example.demo.DemoApplication&lt;/Main-Class&gt;<br>                        &lt;/manifestEntries&gt;<br>                    &lt;/transformer&gt;<br>                    &lt;transformer<br>                                 implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;<br>                &lt;/transformers&gt;<br>                &lt;artifactSet&gt;<br>                &lt;/artifactSet&gt;<br>                &lt;outputFile&gt;${project.build.directory}/${project.artifactId}-${project.version}-fat.jar<br>                &lt;/outputFile&gt;<br>            &lt;/configuration&gt;<br>        &lt;/execution&gt;<br>    &lt;/executions&gt;<br>&lt;/plugin&gt;<br>&lt;plugin&gt;<br>    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br>    &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;${exec-maven-plugin.version}&lt;/version&gt;<br>    &lt;configuration&gt;<br>        &lt;mainClass&gt;com.example.demo.DemoApplication&lt;/mainClass&gt;<br>    &lt;/configuration&gt;<br>&lt;/plugin&gt;</pre><p>Now run the following command to start the application.</p><pre>mvn clean compile exec:java</pre><pre>//or<br>mvn clean package<br>java -jar target\xxx-fat.jar</pre><p>In the TestMainVerticle, let&#39;s do some modifications to use Spring IOC container, eg. you can get a Vertx instance from the Spring application context.</p><pre>@SpringJUnitConfig(classes = DemoApplication.class)<br>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br>@ExtendWith(VertxExtension.class)<br>public class TestMainVerticle {<br>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());</pre><pre>    @Autowired<br>    ApplicationContext context;</pre><pre>    Vertx vertx;</pre><pre>    @BeforeAll<br>    public void setupAll(VertxTestContext testContext) {<br>        vertx = context.getBean(Vertx.class);<br>        var factory = context.getBean(VerticleFactory.class);<br>        vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName())<br>            .onSuccess(id -&gt; {<br>                LOGGER.info(&quot;deployed:&quot; + id);<br>                testContext.completeNow();<br>            })<br>            .onFailure(testContext::failNow);<br>    }</pre><pre>    @Test<br>    public void testVertx(VertxTestContext testContext) {<br>        assertThat(vertx).isNotNull();<br>        testContext.completeNow();<br>    }<br></pre><pre>    @Test<br>    void testGetAll(VertxTestContext testContext) {<br>        LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;);<br>        var options = new HttpClientOptions()<br>            .setDefaultPort(8888);<br>        var client = vertx.createHttpClient(options);</pre><pre>        client.request(HttpMethod.GET, &quot;/posts&quot;)<br>            .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body))<br>            .onSuccess(<br>                buffer -&gt; testContext.verify(<br>                    () -&gt; {<br>                        LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()});<br>                        assertThat(buffer.toJsonArray().size()).isGreaterThan(0);<br>                        testContext.completeNow();<br>                    }<br>                )<br>            )<br>            .onFailure(e -&gt; {<br>                LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage());<br>                testContext.failNow(e);<br>            });<br>    }<br>}</pre><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master//post-service-spring">example codes from my github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb8fca81a357" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/integrating-vertx-application-with-spring-framework-fb8fca81a357">Integrating Vertx application with Spring framework</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
