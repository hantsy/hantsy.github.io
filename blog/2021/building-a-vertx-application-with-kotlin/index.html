<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building a Vertx application with Kotlin
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-a-vertx-application-with-kotlin/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building a Vertx application with Kotlin" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As mentioned in the former posts, Eclipse Vertx expands its API to different languages such as Kotlin, Groovy via official bindings, and even Node/Typescript and PHP via community supports. Photo by Ben Gao on Unsplash In this post, we will re-implement the former RESTful APIs with Kotlin language. Open your browser and navigate to Eclipse Vertx Starter, and generate the project skeleton. Do not forget to select Kotlin in the language field. For the existing project, add the following dependency into the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;&lt;/dependency&gt; Configure kotlin-compiler-plugin to compile the Kotlin source codes. &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${kotlin.version}&lt;/version&gt; &lt;configuration&gt; &lt;jvmTarget&gt;16&lt;/jvmTarget&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; We will use the same file structure and migrate the original project(written in Java) to Kotlin. Firstly let’s have a look at the entry class — MainVerticle. class MainVerticle : AbstractVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;) .use { f -&gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } @Throws(Exception::class) override fun start(startPromise: Promise&lt;Void&gt;) { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server vertx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onSuccess { startPromise.complete() println(&quot;HTTP server started on port &quot; + it.actualPort()) } .onFailure { startPromise.fail(it) println(&quot;Failed to start HTTP server:&quot; + it.message) } } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;) .produces(&quot;application/json&quot;) .handler { handlers.all(it) } router.post(&quot;/posts&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler { handlers.save(it) } router.get(&quot;/posts/:id&quot;) .produces(&quot;application/json&quot;) .handler { handlers.getById(it) } .failureHandler { val error = it.failure() if (error is PostNotFoundException) { it.response().setStatusCode(404).end(error.message) } } router.put(&quot;/posts/:id&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler { handlers.update(it) } router.delete(&quot;/posts/:id&quot;) .handler { handlers.delete(it) } router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) }} In this class we move the original static block to a companion object. In the router function, it assembles request handlers in routes. Let’s have a look at the PostsHandlers class. class PostsHandler(val posts: PostRepository) { fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); posts.findAll() .onSuccess { rc.response().end(Json.encode(it)) } } fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] posts.findById(UUID.fromString(id)) .onSuccess { rc.response().end(Json.encode(it)) } .onFailure { rc.fail(404, it) } } fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) posts.save(Post(title = title, content = content)) .onSuccess { savedId: UUID -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;) .setStatusCode(201) .end() } } fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) posts.findById(UUID.fromString(id)) .flatMap { post: Post -&gt; post.apply { title = title content = content } posts.update(post) } .onSuccess { rc.response().setStatusCode(204).end() } .onFailure { rc.fail(it) } } fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) posts.findById(uuid) .flatMap { posts.deleteById(uuid) } .onSuccess { rc.response().setStatusCode(204).end() } .onFailure { rc.fail(404, it) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }} Let’s move to the PostRepository class. class PostRepository(private val client: PgPool) { fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map { rs: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() } fun findById(id: UUID) = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()); throw PostNotFoundException(id) } fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&quot;id&quot;) } fun saveAll(data: List&lt;Post&gt;): Future&lt;Int&gt; { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map { it.rowCount() } } fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute() .map { it.rowCount() } fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map { it.rowCount() } companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&gt; Post = { row: Row -&gt; Post( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ) } }} The POJO classes are converted to Kotlin data classes. //Models.ktdata class Post( var id: UUID? = null, var title: String, var content: String, var createdAt: LocalDateTime? = LocalDateTime.now()) data class CreatePostCommand( val title: String, val content: String) The DataIntializer is still used to insert some sample data at the application startup. class DataInitializer(private val client: PgPool) { fun run() { LOGGER.info(&quot;Data initialization is starting...&quot;) val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;) val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;) client .withTransaction { conn: SqlConnection -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute() .flatMap { conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&quot;SELECT * FROM posts&quot;).execute() } } .onSuccess { data: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(data.spliterator(), true) .forEach { LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, it!!.toJson()) } } .onComplete { //client.close(); will block the application. LOGGER.info(&quot;Data initialization is done...&quot;) } .onFailure { LOGGER.warning(&quot;Data initialization is failed:&quot; + it.message) } } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }} Run the application via maven command. mvn clean compile exec:java Additionally, Vertx Kotlin bindings provides a Json DSL extension to simplify the JSON encoding. it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &quot;message&quot; to &quot;${it.failure().message}&quot;, &quot;code&quot; to &quot;not_found&quot; ) }.toString() ) Get the source codes from my Github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with Kotlin was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="As mentioned in the former posts, Eclipse Vertx expands its API to different languages such as Kotlin, Groovy via official bindings, and even Node/Typescript and PHP via community supports. Photo by Ben Gao on Unsplash In this post, we will re-implement the former RESTful APIs with Kotlin language. Open your browser and navigate to Eclipse Vertx Starter, and generate the project skeleton. Do not forget to select Kotlin in the language field. For the existing project, add the following dependency into the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;&lt;/dependency&gt; Configure kotlin-compiler-plugin to compile the Kotlin source codes. &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${kotlin.version}&lt;/version&gt; &lt;configuration&gt; &lt;jvmTarget&gt;16&lt;/jvmTarget&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; We will use the same file structure and migrate the original project(written in Java) to Kotlin. Firstly let’s have a look at the entry class — MainVerticle. class MainVerticle : AbstractVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;) .use { f -&gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } @Throws(Exception::class) override fun start(startPromise: Promise&lt;Void&gt;) { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server vertx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onSuccess { startPromise.complete() println(&quot;HTTP server started on port &quot; + it.actualPort()) } .onFailure { startPromise.fail(it) println(&quot;Failed to start HTTP server:&quot; + it.message) } } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;) .produces(&quot;application/json&quot;) .handler { handlers.all(it) } router.post(&quot;/posts&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler { handlers.save(it) } router.get(&quot;/posts/:id&quot;) .produces(&quot;application/json&quot;) .handler { handlers.getById(it) } .failureHandler { val error = it.failure() if (error is PostNotFoundException) { it.response().setStatusCode(404).end(error.message) } } router.put(&quot;/posts/:id&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler { handlers.update(it) } router.delete(&quot;/posts/:id&quot;) .handler { handlers.delete(it) } router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) }} In this class we move the original static block to a companion object. In the router function, it assembles request handlers in routes. Let’s have a look at the PostsHandlers class. class PostsHandler(val posts: PostRepository) { fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); posts.findAll() .onSuccess { rc.response().end(Json.encode(it)) } } fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] posts.findById(UUID.fromString(id)) .onSuccess { rc.response().end(Json.encode(it)) } .onFailure { rc.fail(404, it) } } fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) posts.save(Post(title = title, content = content)) .onSuccess { savedId: UUID -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;) .setStatusCode(201) .end() } } fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) posts.findById(UUID.fromString(id)) .flatMap { post: Post -&gt; post.apply { title = title content = content } posts.update(post) } .onSuccess { rc.response().setStatusCode(204).end() } .onFailure { rc.fail(it) } } fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) posts.findById(uuid) .flatMap { posts.deleteById(uuid) } .onSuccess { rc.response().setStatusCode(204).end() } .onFailure { rc.fail(404, it) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }} Let’s move to the PostRepository class. class PostRepository(private val client: PgPool) { fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map { rs: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() } fun findById(id: UUID) = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()); throw PostNotFoundException(id) } fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&quot;id&quot;) } fun saveAll(data: List&lt;Post&gt;): Future&lt;Int&gt; { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map { it.rowCount() } } fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute() .map { it.rowCount() } fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map { it.rowCount() } companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&gt; Post = { row: Row -&gt; Post( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ) } }} The POJO classes are converted to Kotlin data classes. //Models.ktdata class Post( var id: UUID? = null, var title: String, var content: String, var createdAt: LocalDateTime? = LocalDateTime.now()) data class CreatePostCommand( val title: String, val content: String) The DataIntializer is still used to insert some sample data at the application startup. class DataInitializer(private val client: PgPool) { fun run() { LOGGER.info(&quot;Data initialization is starting...&quot;) val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;) val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;) client .withTransaction { conn: SqlConnection -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute() .flatMap { conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&quot;SELECT * FROM posts&quot;).execute() } } .onSuccess { data: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(data.spliterator(), true) .forEach { LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, it!!.toJson()) } } .onComplete { //client.close(); will block the application. LOGGER.info(&quot;Data initialization is done...&quot;) } .onFailure { LOGGER.warning(&quot;Data initialization is failed:&quot; + it.message) } } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }} Run the application via maven command. mvn clean compile exec:java Additionally, Vertx Kotlin bindings provides a Json DSL extension to simplify the JSON encoding. it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &quot;message&quot; to &quot;${it.failure().message}&quot;, &quot;code&quot; to &quot;not_found&quot; ) }.toString() ) Get the source codes from my Github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with Kotlin was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building a Vertx application with Kotlin" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-23T00:00:00+00:00","datePublished":"2021-07-23T00:00:00+00:00","description":"As mentioned in the former posts, Eclipse Vertx expands its API to different languages such as Kotlin, Groovy via official bindings, and even Node/Typescript and PHP via community supports. Photo by Ben Gao on Unsplash In this post, we will re-implement the former RESTful APIs with Kotlin language. Open your browser and navigate to Eclipse Vertx Starter, and generate the project skeleton. Do not forget to select Kotlin in the language field. For the existing project, add the following dependency into the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;&lt;/dependency&gt; Configure kotlin-compiler-plugin to compile the Kotlin source codes. &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${kotlin.version}&lt;/version&gt; &lt;configuration&gt; &lt;jvmTarget&gt;16&lt;/jvmTarget&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; We will use the same file structure and migrate the original project(written in Java) to Kotlin. Firstly let’s have a look at the entry class — MainVerticle. class MainVerticle : AbstractVerticle() { companion object { private val LOGGER = Logger.getLogger(MainVerticle::class.java.name) /** * Configure logging from logging.properties file. * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties * or set java.util.logging.config.file system property to locate the properties file. */ @Throws(IOException::class) private fun setupLogging() { MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;) .use { f -&gt; LogManager.getLogManager().readConfiguration(f) } } init { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;) val objectMapper = DatabindCodec.mapper() objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS) objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS) val module = JavaTimeModule() objectMapper.registerModule(module) } } @Throws(Exception::class) override fun start(startPromise: Promise&lt;Void&gt;) { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;) //setupLogging(); //Create a PgPool instance val pgPool = pgPool() //Creating PostRepository val postRepository = PostRepository(pgPool) //Creating PostHandler val postHandlers = PostsHandler(postRepository) // Initializing the sample data val initializer = DataInitializer(pgPool) initializer.run() // Configure routes val router = routes(postHandlers) // Create the HTTP server vertx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onSuccess { startPromise.complete() println(&quot;HTTP server started on port &quot; + it.actualPort()) } .onFailure { startPromise.fail(it) println(&quot;Failed to start HTTP server:&quot; + it.message) } } //create routes private fun routes(handlers: PostsHandler): Router { // Create a Router val router = Router.router(vertx) // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;) .produces(&quot;application/json&quot;) .handler { handlers.all(it) } router.post(&quot;/posts&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler { handlers.save(it) } router.get(&quot;/posts/:id&quot;) .produces(&quot;application/json&quot;) .handler { handlers.getById(it) } .failureHandler { val error = it.failure() if (error is PostNotFoundException) { it.response().setStatusCode(404).end(error.message) } } router.put(&quot;/posts/:id&quot;) .consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler { handlers.update(it) } router.delete(&quot;/posts/:id&quot;) .handler { handlers.delete(it) } router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) } return router } private fun pgPool(): PgPool { val connectOptions = PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;) // Pool Options val poolOptions = PoolOptions().setMaxSize(5) // Create the pool from the data object return PgPool.pool(vertx, connectOptions, poolOptions) }} In this class we move the original static block to a companion object. In the router function, it assembles request handlers in routes. Let’s have a look at the PostsHandlers class. class PostsHandler(val posts: PostRepository) { fun all(rc: RoutingContext) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); posts.findAll() .onSuccess { rc.response().end(Json.encode(it)) } } fun getById(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] posts.findById(UUID.fromString(id)) .onSuccess { rc.response().end(Json.encode(it)) } .onFailure { rc.fail(404, it) } } fun save(rc: RoutingContext) { //rc.getBodyAsJson().mapTo(PostForm.class) val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body) val (title, content) = body.mapTo(CreatePostCommand::class.java) posts.save(Post(title = title, content = content)) .onSuccess { savedId: UUID -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;) .setStatusCode(201) .end() } } fun update(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val body = rc.bodyAsJson LOGGER.log(Level.INFO, &quot;\\npath param id: {0}\\nrequest body: {1}&quot;, arrayOf(id, body)) var (title, content) = body.mapTo(CreatePostCommand::class.java) posts.findById(UUID.fromString(id)) .flatMap { post: Post -&gt; post.apply { title = title content = content } posts.update(post) } .onSuccess { rc.response().setStatusCode(204).end() } .onFailure { rc.fail(it) } } fun delete(rc: RoutingContext) { val params = rc.pathParams() val id = params[&quot;id&quot;] val uuid = UUID.fromString(id) posts.findById(uuid) .flatMap { posts.deleteById(uuid) } .onSuccess { rc.response().setStatusCode(204).end() } .onFailure { rc.fail(404, it) } } companion object { private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName) }} Let’s move to the PostRepository class. class PostRepository(private val client: PgPool) { fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map { rs: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(rs.spliterator(), false) .map { mapFun(it!!) } .toList() } fun findById(id: UUID) = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;) .execute(Tuple.of(id)) .map { it.iterator() } .map { if (it.hasNext()) mapFun(it.next()); throw PostNotFoundException(id) } fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;) .execute(Tuple.of(data.title, data.content)) .map { it.iterator().next().getUUID(&quot;id&quot;) } fun saveAll(data: List&lt;Post&gt;): Future&lt;Int&gt; { val tuples = data.map { Tuple.of(it.title, it.content) } return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map { it.rowCount() } } fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.title, data.content, data.id)) .map { it.rowCount() } fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute() .map { it.rowCount() } fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map { it.rowCount() } companion object { private val LOGGER = Logger.getLogger(PostRepository::class.java.name) val mapFun: (Row) -&gt; Post = { row: Row -&gt; Post( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ) } }} The POJO classes are converted to Kotlin data classes. //Models.ktdata class Post( var id: UUID? = null, var title: String, var content: String, var createdAt: LocalDateTime? = LocalDateTime.now()) data class CreatePostCommand( val title: String, val content: String) The DataIntializer is still used to insert some sample data at the application startup. class DataInitializer(private val client: PgPool) { fun run() { LOGGER.info(&quot;Data initialization is starting...&quot;) val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;) val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;) client .withTransaction { conn: SqlConnection -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute() .flatMap { conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(listOf(first, second)) } .flatMap { conn.query(&quot;SELECT * FROM posts&quot;).execute() } } .onSuccess { data: RowSet&lt;Row?&gt; -&gt; StreamSupport.stream(data.spliterator(), true) .forEach { LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, it!!.toJson()) } } .onComplete { //client.close(); will block the application. LOGGER.info(&quot;Data initialization is done...&quot;) } .onFailure { LOGGER.warning(&quot;Data initialization is failed:&quot; + it.message) } } companion object { private val LOGGER = Logger.getLogger(DataInitializer::class.java.name) }} Run the application via maven command. mvn clean compile exec:java Additionally, Vertx Kotlin bindings provides a Json DSL extension to simplify the JSON encoding. it.response() .setStatusCode(404) .end( json {// an example using JSON DSL obj( &quot;message&quot; to &quot;${it.failure().message}&quot;, &quot;code&quot; to &quot;not_found&quot; ) }.toString() ) Get the source codes from my Github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with Kotlin was originally published in Nerd For Tech on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building a Vertx application with Kotlin","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-a-vertx-application-with-kotlin/"},"url":"/blog/2021/building-a-vertx-application-with-kotlin/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building a Vertx application with Kotlin</h1>
    <p class="post-meta">July 23, 2021</p>
  </header>

  <article class="post-content">
    <p>As mentioned in the former posts, Eclipse Vertx expands its API to different languages such as Kotlin, Groovy via official bindings, and even Node/Typescript and PHP via community supports.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fwQOVagDLdc4Yon5G-yrHA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@bengao?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Ben Gao</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In this post, we will re-implement the former RESTful APIs with Kotlin language.</p><p>Open your browser and navigate to <a href="https://start.vertx.io">Eclipse Vertx Starter</a>, and generate the project skeleton. Do not forget to select <strong>Kotlin</strong> in the <em>language</em> field.</p><p>For the existing project, add the following dependency into the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>    &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Configure kotlin-compiler-plugin to compile the Kotlin source codes.</p><pre>&lt;plugin&gt;<br>    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br>    &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;${kotlin.version}&lt;/version&gt;<br>    &lt;configuration&gt;<br>        &lt;jvmTarget&gt;16&lt;/jvmTarget&gt;<br>    &lt;/configuration&gt;<br>    &lt;executions&gt;<br>        &lt;execution&gt;<br>            &lt;id&gt;compile&lt;/id&gt;<br>            &lt;goals&gt;<br>                &lt;goal&gt;compile&lt;/goal&gt;<br>            &lt;/goals&gt;<br>        &lt;/execution&gt;<br>        &lt;execution&gt;<br>            &lt;id&gt;test-compile&lt;/id&gt;<br>            &lt;goals&gt;<br>                &lt;goal&gt;test-compile&lt;/goal&gt;<br>            &lt;/goals&gt;<br>        &lt;/execution&gt;<br>    &lt;/executions&gt;<br>&lt;/plugin&gt;</pre><p>We will use the same file structure and migrate <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service">the original project(written in Java)</a> to Kotlin.</p><p>Firstly let’s have a look at the entry class — MainVerticle.</p><pre>class MainVerticle : AbstractVerticle() {<br>    companion object {<br>        private val LOGGER = Logger.getLogger(MainVerticle::class.java.name)</pre><pre>        /**<br>         * Configure logging from logging.properties file.<br>         * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties<br>         * or set java.util.logging.config.file system property to locate the properties file.<br>         */<br>        @Throws(IOException::class)<br>        private fun setupLogging() {<br>            MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;)<br>                .use { f -&gt; LogManager.getLogManager().readConfiguration(f) }<br>        }</pre><pre>        init {<br>            LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;)<br>            val objectMapper = DatabindCodec.mapper()<br>            objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br>            objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            val module = JavaTimeModule()<br>            objectMapper.registerModule(module)<br>        }<br>    }</pre><pre>    @Throws(Exception::class)<br>    override fun start(startPromise: Promise&lt;Void&gt;) {<br>        LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;)<br>        //setupLogging();</pre><pre>        //Create a PgPool instance<br>        val pgPool = pgPool()</pre><pre>        //Creating PostRepository<br>        val postRepository = PostRepository(pgPool)</pre><pre>        //Creating PostHandler<br>        val postHandlers = PostsHandler(postRepository)</pre><pre>        // Initializing the sample data<br>        val initializer = DataInitializer(pgPool)<br>        initializer.run()</pre><pre>        // Configure routes<br>        val router = routes(postHandlers)</pre><pre>        // Create the HTTP server<br>        vertx.createHttpServer() // Handle every request using the router<br>            .requestHandler(router) // Start listening<br>            .listen(8888) // Print the port<br>            .onSuccess {<br>                startPromise.complete()<br>                println(&quot;HTTP server started on port &quot; + it.actualPort())<br>            }<br>            .onFailure {<br>                startPromise.fail(it)<br>                println(&quot;Failed to start HTTP server:&quot; + it.message)<br>            }<br>    }</pre><pre>    //create routes<br>    private fun routes(handlers: PostsHandler): Router {</pre><pre>        // Create a Router<br>        val router = Router.router(vertx)<br>        // register BodyHandler globally.<br>        //router.route().handler(BodyHandler.create());<br>        router.get(&quot;/posts&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .handler { handlers.all(it) }</pre><pre>        router.post(&quot;/posts&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler { handlers.save(it) }</pre><pre>        router.get(&quot;/posts/:id&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .handler { handlers.getById(it) }<br>            .failureHandler {<br>                val error = it.failure()<br>                if (error is PostNotFoundException) {<br>                    it.response().setStatusCode(404).end(error.message)<br>                }<br>            }</pre><pre>        router.put(&quot;/posts/:id&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler { handlers.update(it) }</pre><pre>        router.delete(&quot;/posts/:id&quot;)<br>            .handler { handlers.delete(it) }</pre><pre>        router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) }</pre><pre>        return router<br>    }</pre><pre>    private fun pgPool(): PgPool {<br>        val connectOptions = PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;)</pre><pre>        // Pool Options<br>        val poolOptions = PoolOptions().setMaxSize(5)</pre><pre>        // Create the pool from the data object<br>        return PgPool.pool(vertx, connectOptions, poolOptions)<br>    }<br>}</pre><p>In this class we move the original <em>static</em> block to a <em>companion object</em>.</p><p>In the router function, it assembles request handlers in routes. Let’s have a look at the PostsHandlers class.</p><pre>class PostsHandler(val posts: PostRepository) {<br>    fun all(rc: RoutingContext) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        posts.findAll()<br>            .onSuccess {<br>                rc.response().end(Json.encode(it))<br>            }</pre><pre>    }</pre><pre>    fun getById(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        posts.findById(UUID.fromString(id))<br>            .onSuccess { rc.response().end(Json.encode(it)) }<br>            .onFailure { rc.fail(404, it) }<br>    }</pre><pre>    fun save(rc: RoutingContext) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body)<br>        val (title, content) = body.mapTo(CreatePostCommand::class.java)<br>        posts.save(Post(title = title, content = content))<br>            .onSuccess { savedId: UUID -&gt;<br>                rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;)<br>                    .setStatusCode(201)<br>                    .end()<br>            }<br>    }</pre><pre>    fun update(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body))<br>        var (title, content) = body.mapTo(CreatePostCommand::class.java)<br>        posts.findById(UUID.fromString(id))<br>            .flatMap { post: Post -&gt;<br>                post.apply {<br>                    title = title<br>                    content = content<br>                }<br>                posts.update(post)<br>            }<br>            .onSuccess { rc.response().setStatusCode(204).end() }<br>            .onFailure { rc.fail(it) }<br>    }</pre><pre>    fun delete(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        posts.findById(uuid)<br>            .flatMap { posts.deleteById(uuid) }<br>            .onSuccess { rc.response().setStatusCode(204).end() }<br>            .onFailure { rc.fail(404, it) }<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName)<br>    }<br>}</pre><p>Let’s move to the PostRepository class.</p><pre>class PostRepository(private val client: PgPool) {</pre><pre>    fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;)<br>        .execute()<br>        .map { rs: RowSet&lt;Row?&gt; -&gt;<br>            StreamSupport.stream(rs.spliterator(), false)<br>                .map { mapFun(it!!) }<br>                .toList()<br>        }<br></pre><pre>    fun findById(id: UUID) = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;)<br>        .execute(Tuple.of(id))<br>        .map { it.iterator() }<br>        .map {<br>            if (it.hasNext()) mapFun(it.next());<br>            throw PostNotFoundException(id)<br>        }<br></pre><pre>    fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;)<br>        .execute(Tuple.of(data.title, data.content))<br>        .map { it.iterator().next().getUUID(&quot;id&quot;) }<br></pre><pre>    fun saveAll(data: List&lt;Post&gt;): Future&lt;Int&gt; {<br>        val tuples = data.map { Tuple.of(it.title, it.content) }</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .executeBatch(tuples)<br>            .map { it.rowCount() }<br>    }</pre><pre>    fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>        .execute(Tuple.of(data.title, data.content, data.id))<br>        .map { it.rowCount() }<br></pre><pre>    fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute()<br>        .map { it.rowCount() }<br></pre><pre>    fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>        .map { it.rowCount() }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostRepository::class.java.name)<br>        val mapFun: (Row) -&gt; Post = { row: Row -&gt;<br>            Post(<br>                row.getUUID(&quot;id&quot;),<br>                row.getString(&quot;title&quot;),<br>                row.getString(&quot;content&quot;),<br>                row.getLocalDateTime(&quot;created_at&quot;)<br>            )<br>        }</pre><pre>    }<br>}</pre><p>The POJO classes are converted to Kotlin data classes.</p><pre>//Models.kt<br>data class Post(<br>    var id: UUID? = null,<br>    var title: String,<br>    var content: String,<br>    var createdAt: LocalDateTime? = LocalDateTime.now()<br>)</pre><pre>data class CreatePostCommand(<br>    val title: String,<br>    val content: String<br>)</pre><p>The DataIntializer is still used to insert some sample data at the application startup.</p><pre>class DataInitializer(private val client: PgPool) {</pre><pre>    fun run() {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;)<br>        val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;)<br>        val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;)<br>        client<br>            .withTransaction { conn: SqlConnection -&gt;<br>                conn.query(&quot;DELETE FROM posts&quot;).execute()<br>                    .flatMap {<br>                        conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>                            .executeBatch(listOf(first, second))<br>                    }<br>                    .flatMap {<br>                        conn.query(&quot;SELECT * FROM posts&quot;).execute()<br>                    }<br>            }<br>            .onSuccess { data: RowSet&lt;Row?&gt; -&gt;<br>                StreamSupport.stream(data.spliterator(), true)<br>                    .forEach {<br>                        LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, it!!.toJson())<br>                    }<br>            }<br>            .onComplete {<br>                //client.close(); will block the application.<br>                LOGGER.info(&quot;Data initialization is done...&quot;)<br>            }<br>            .onFailure { LOGGER.warning(&quot;Data initialization is failed:&quot; + it.message) }<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(DataInitializer::class.java.name)<br>    }<br>}</pre><p>Run the application via maven command.</p><pre>mvn clean compile exec:java</pre><p>Additionally, Vertx Kotlin bindings provides a Json DSL extension to simplify the JSON encoding.</p><pre>it.response()<br>     .setStatusCode(404)<br>     .end(<br>         json {// an example using JSON DSL<br>             obj(<br>                 &quot;message&quot; to &quot;${it.failure().message}&quot;,<br>                 &quot;code&quot; to &quot;not_found&quot;<br>             )<br>         }.toString()<br>     )</pre><p>Get <a href="https://github.com/hantsy/vertx-sandbox/tree/master/kotlin">the source codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1d55cb389f67" width="1" height="1" alt=""><hr><p><a href="https://medium.com/nerd-for-tech/building-avertx-application-with-kotlin-1d55cb389f67">Building a Vertx application with Kotlin</a> was originally published in <a href="https://medium.com/nerd-for-tech">Nerd For Tech</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
