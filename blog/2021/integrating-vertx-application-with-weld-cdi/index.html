<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Integrating Vertx application with Weld/CDI
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/integrating-vertx-application-with-weld-cdi/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Integrating Vertx application with Weld/CDI" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the last post, we introduced a simple approach to integrate Vertx applications with Spring framework. In this post, we will try to integrate Vertx application with CDI to replace Spring. Photo by Robynne Hu on Unsplash CDI is a Dependency and Injection specification which is introduced in Java EE 6, currently Java EE is renamed to Jakarta EE and maintained by Eclipse Foundation. Weld is a compatible provider of the Jakarta CDI specification. Add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt; &lt;artifactId&gt;weld-se-shaded&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.2.3.Final&lt;/version&gt;&lt;/dependency&gt; In the above codes: The weld-se-shaded provides a CDI runtime environment for Java SE platform.The jandex will index the classes in the application and speed up the bean searching. Add an empty beans.xml configuration in the main/resources/META-INF folder which is to enable CDI support in a Java SE application. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd&quot; bean-discovery-mode=&quot;annotated&quot;&gt;&lt;/beans&gt; In the Java EE/Jakarta EE world, CDI is enabled by default since Java EE 7, and the beans.xml configuration file is optional. Similar to the Spring version, add a DemoApplication to start the application. public class DemoApplication { private final static Logger LOGGER = Logger.getLogger(DemoApplication.class.getName()); public static void main(String[] args) { var weld = new Weld(); var container = weld.initialize(); var vertx = container.select(Vertx.class).get(); var factory = container.select(VerticleFactory.class).get(); LOGGER.info(&quot;vertx clazz:&quot; + vertx.getClass().getName());//Weld does not create proxy classes at runtime on @Singleton beans. LOGGER.info(&quot;factory clazz:&quot; + factory.getClass().getName()); // deploy MainVerticle via verticle identifier name //var deployOptions = new DeploymentOptions().setInstances(4); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()); }} Here we uses weld.initialize() to initialize the CDI container. Then retrieve the Vertx bean and VerticleFactory bean, and start to deploy the MainVerticle. Similar to the SpringAwareVerticleFactory , create a CDI aware VerticleFactory. @ApplicationScopedpublic class CdiAwareVerticleFactory implements VerticleFactory { @Inject private Instance&lt;Object&gt; instance; @Override public String prefix() { return &quot;cdi&quot;; } @Override public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) { String clazz = VerticleFactory.removePrefix(verticleName); promise.complete(() -&gt; (Verticle) instance.select(Class.forName(clazz)).get()); }} Create a simple Resources classes and expose the Vertx and PgPool beans. @ApplicationScopedpublic class Resources { private final static Logger LOGGER = Logger.getLogger(Resources.class.getName()); @Produces @Singleton public Vertx vertx(VerticleFactory verticleFactory) { Vertx vertx = Vertx.vertx(); vertx.registerVerticleFactory(verticleFactory); return vertx; } @Produces public PgPool pgPool(Vertx vertx) { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; } public void disposesPgPool(@Disposes PgPool pgPool) { LOGGER.info(&quot;disposing PgPool...&quot;); pgPool.close().onSuccess(v -&gt; LOGGER.info(&quot;PgPool is closed successfully.&quot;)); }} Other beans are similar to the Spring version, but using CDI @ApplicaitonScoped to replace the Spring @Component. @ApplicationScoped@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; //...} @ApplicationScoped@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; //...} @ApplicationScoped@RequiredArgsConstructorpublic class PostRepository { private final PgPool client; //...} @ApplicationScoped@RequiredArgsConstructorpublic class DataInitializer { private final PgPool client; //...} Please note, in the above Resources class, we add a @Singleton to the Vertx, which is a little different from the ApplicationScoped, Weld does not create a proxy object for it. Here we have to add @Singleton on Vertx bean, else there is an error of casting to VertxImpl at the application startup stage, because CDI does not create a proxy bean for VertxImpl. In the DemoApplication, we have added some log to print the class name of Vertx and VerticleFactory beans. When starting the application, in the console, you will see the class names as the following. //..INFO: vertx clazz:io.vertx.core.impl.VertxImpl//...INFO: factory clazz:com.example.demo.CdiAwareVerticleFactory$Proxy$_$$_WeldClientProxy By default CDI will create proxy classes for all beans, but if it is annotated with @Singletone, it will use the instance directly. To test the application, add the following dependency to test scope. &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt; &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt; &lt;version&gt;2.0.2.Final&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Similar to the Spring version, manually deploy the Verticle in the JUnit @BeforeAll hook before running tests. @EnableAutoWeld@AddPackages(DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Inject Instance&lt;Object&gt; context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.select(Vertx.class).get(); var factory = context.select(VerticleFactory.class).get(); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .onSuccess(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body)) .onSuccess( buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ) ) .onFailure(e -&gt; LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage())); } } Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Integrating Vertx application with Weld/CDI was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In the last post, we introduced a simple approach to integrate Vertx applications with Spring framework. In this post, we will try to integrate Vertx application with CDI to replace Spring. Photo by Robynne Hu on Unsplash CDI is a Dependency and Injection specification which is introduced in Java EE 6, currently Java EE is renamed to Jakarta EE and maintained by Eclipse Foundation. Weld is a compatible provider of the Jakarta CDI specification. Add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt; &lt;artifactId&gt;weld-se-shaded&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.2.3.Final&lt;/version&gt;&lt;/dependency&gt; In the above codes: The weld-se-shaded provides a CDI runtime environment for Java SE platform.The jandex will index the classes in the application and speed up the bean searching. Add an empty beans.xml configuration in the main/resources/META-INF folder which is to enable CDI support in a Java SE application. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd&quot; bean-discovery-mode=&quot;annotated&quot;&gt;&lt;/beans&gt; In the Java EE/Jakarta EE world, CDI is enabled by default since Java EE 7, and the beans.xml configuration file is optional. Similar to the Spring version, add a DemoApplication to start the application. public class DemoApplication { private final static Logger LOGGER = Logger.getLogger(DemoApplication.class.getName()); public static void main(String[] args) { var weld = new Weld(); var container = weld.initialize(); var vertx = container.select(Vertx.class).get(); var factory = container.select(VerticleFactory.class).get(); LOGGER.info(&quot;vertx clazz:&quot; + vertx.getClass().getName());//Weld does not create proxy classes at runtime on @Singleton beans. LOGGER.info(&quot;factory clazz:&quot; + factory.getClass().getName()); // deploy MainVerticle via verticle identifier name //var deployOptions = new DeploymentOptions().setInstances(4); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()); }} Here we uses weld.initialize() to initialize the CDI container. Then retrieve the Vertx bean and VerticleFactory bean, and start to deploy the MainVerticle. Similar to the SpringAwareVerticleFactory , create a CDI aware VerticleFactory. @ApplicationScopedpublic class CdiAwareVerticleFactory implements VerticleFactory { @Inject private Instance&lt;Object&gt; instance; @Override public String prefix() { return &quot;cdi&quot;; } @Override public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) { String clazz = VerticleFactory.removePrefix(verticleName); promise.complete(() -&gt; (Verticle) instance.select(Class.forName(clazz)).get()); }} Create a simple Resources classes and expose the Vertx and PgPool beans. @ApplicationScopedpublic class Resources { private final static Logger LOGGER = Logger.getLogger(Resources.class.getName()); @Produces @Singleton public Vertx vertx(VerticleFactory verticleFactory) { Vertx vertx = Vertx.vertx(); vertx.registerVerticleFactory(verticleFactory); return vertx; } @Produces public PgPool pgPool(Vertx vertx) { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; } public void disposesPgPool(@Disposes PgPool pgPool) { LOGGER.info(&quot;disposing PgPool...&quot;); pgPool.close().onSuccess(v -&gt; LOGGER.info(&quot;PgPool is closed successfully.&quot;)); }} Other beans are similar to the Spring version, but using CDI @ApplicaitonScoped to replace the Spring @Component. @ApplicationScoped@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; //...} @ApplicationScoped@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; //...} @ApplicationScoped@RequiredArgsConstructorpublic class PostRepository { private final PgPool client; //...} @ApplicationScoped@RequiredArgsConstructorpublic class DataInitializer { private final PgPool client; //...} Please note, in the above Resources class, we add a @Singleton to the Vertx, which is a little different from the ApplicationScoped, Weld does not create a proxy object for it. Here we have to add @Singleton on Vertx bean, else there is an error of casting to VertxImpl at the application startup stage, because CDI does not create a proxy bean for VertxImpl. In the DemoApplication, we have added some log to print the class name of Vertx and VerticleFactory beans. When starting the application, in the console, you will see the class names as the following. //..INFO: vertx clazz:io.vertx.core.impl.VertxImpl//...INFO: factory clazz:com.example.demo.CdiAwareVerticleFactory$Proxy$_$$_WeldClientProxy By default CDI will create proxy classes for all beans, but if it is annotated with @Singletone, it will use the instance directly. To test the application, add the following dependency to test scope. &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt; &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt; &lt;version&gt;2.0.2.Final&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Similar to the Spring version, manually deploy the Verticle in the JUnit @BeforeAll hook before running tests. @EnableAutoWeld@AddPackages(DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Inject Instance&lt;Object&gt; context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.select(Vertx.class).get(); var factory = context.select(VerticleFactory.class).get(); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .onSuccess(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body)) .onSuccess( buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ) ) .onFailure(e -&gt; LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage())); } } Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Integrating Vertx application with Weld/CDI was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Integrating Vertx application with Weld/CDI" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-23T00:00:00+00:00","datePublished":"2021-07-23T00:00:00+00:00","description":"In the last post, we introduced a simple approach to integrate Vertx applications with Spring framework. In this post, we will try to integrate Vertx application with CDI to replace Spring. Photo by Robynne Hu on Unsplash CDI is a Dependency and Injection specification which is introduced in Java EE 6, currently Java EE is renamed to Jakarta EE and maintained by Eclipse Foundation. Weld is a compatible provider of the Jakarta CDI specification. Add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt; &lt;artifactId&gt;weld-se-shaded&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss&lt;/groupId&gt; &lt;artifactId&gt;jandex&lt;/artifactId&gt; &lt;version&gt;2.2.3.Final&lt;/version&gt;&lt;/dependency&gt; In the above codes: The weld-se-shaded provides a CDI runtime environment for Java SE platform.The jandex will index the classes in the application and speed up the bean searching. Add an empty beans.xml configuration in the main/resources/META-INF folder which is to enable CDI support in a Java SE application. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd&quot; bean-discovery-mode=&quot;annotated&quot;&gt;&lt;/beans&gt; In the Java EE/Jakarta EE world, CDI is enabled by default since Java EE 7, and the beans.xml configuration file is optional. Similar to the Spring version, add a DemoApplication to start the application. public class DemoApplication { private final static Logger LOGGER = Logger.getLogger(DemoApplication.class.getName()); public static void main(String[] args) { var weld = new Weld(); var container = weld.initialize(); var vertx = container.select(Vertx.class).get(); var factory = container.select(VerticleFactory.class).get(); LOGGER.info(&quot;vertx clazz:&quot; + vertx.getClass().getName());//Weld does not create proxy classes at runtime on @Singleton beans. LOGGER.info(&quot;factory clazz:&quot; + factory.getClass().getName()); // deploy MainVerticle via verticle identifier name //var deployOptions = new DeploymentOptions().setInstances(4); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()); }} Here we uses weld.initialize() to initialize the CDI container. Then retrieve the Vertx bean and VerticleFactory bean, and start to deploy the MainVerticle. Similar to the SpringAwareVerticleFactory , create a CDI aware VerticleFactory. @ApplicationScopedpublic class CdiAwareVerticleFactory implements VerticleFactory { @Inject private Instance&lt;Object&gt; instance; @Override public String prefix() { return &quot;cdi&quot;; } @Override public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) { String clazz = VerticleFactory.removePrefix(verticleName); promise.complete(() -&gt; (Verticle) instance.select(Class.forName(clazz)).get()); }} Create a simple Resources classes and expose the Vertx and PgPool beans. @ApplicationScopedpublic class Resources { private final static Logger LOGGER = Logger.getLogger(Resources.class.getName()); @Produces @Singleton public Vertx vertx(VerticleFactory verticleFactory) { Vertx vertx = Vertx.vertx(); vertx.registerVerticleFactory(verticleFactory); return vertx; } @Produces public PgPool pgPool(Vertx vertx) { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; } public void disposesPgPool(@Disposes PgPool pgPool) { LOGGER.info(&quot;disposing PgPool...&quot;); pgPool.close().onSuccess(v -&gt; LOGGER.info(&quot;PgPool is closed successfully.&quot;)); }} Other beans are similar to the Spring version, but using CDI @ApplicaitonScoped to replace the Spring @Component. @ApplicationScoped@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; //...} @ApplicationScoped@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; //...} @ApplicationScoped@RequiredArgsConstructorpublic class PostRepository { private final PgPool client; //...} @ApplicationScoped@RequiredArgsConstructorpublic class DataInitializer { private final PgPool client; //...} Please note, in the above Resources class, we add a @Singleton to the Vertx, which is a little different from the ApplicationScoped, Weld does not create a proxy object for it. Here we have to add @Singleton on Vertx bean, else there is an error of casting to VertxImpl at the application startup stage, because CDI does not create a proxy bean for VertxImpl. In the DemoApplication, we have added some log to print the class name of Vertx and VerticleFactory beans. When starting the application, in the console, you will see the class names as the following. //..INFO: vertx clazz:io.vertx.core.impl.VertxImpl//...INFO: factory clazz:com.example.demo.CdiAwareVerticleFactory$Proxy$_$$_WeldClientProxy By default CDI will create proxy classes for all beans, but if it is annotated with @Singletone, it will use the instance directly. To test the application, add the following dependency to test scope. &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt; &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt; &lt;version&gt;2.0.2.Final&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Similar to the Spring version, manually deploy the Verticle in the JUnit @BeforeAll hook before running tests. @EnableAutoWeld@AddPackages(DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Inject Instance&lt;Object&gt; context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.select(Vertx.class).get(); var factory = context.select(VerticleFactory.class).get(); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .onSuccess(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body)) .onSuccess( buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ) ) .onFailure(e -&gt; LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage())); } } Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Integrating Vertx application with Weld/CDI was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Integrating Vertx application with Weld/CDI","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/integrating-vertx-application-with-weld-cdi/"},"url":"/blog/2021/integrating-vertx-application-with-weld-cdi/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Integrating Vertx application with Weld/CDI</h1>
    <p class="post-meta">July 23, 2021</p>
  </header>

  <article class="post-content">
    <p>In <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/spring.md">the last post</a>, we introduced a simple approach to integrate Vertx applications with Spring framework. In this post, we will try to integrate Vertx application with <a href="https://www.cdi-spec.org">CDI</a> to replace Spring.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IVMaWX4HIdNF5Aw45m5nCQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@robynnexy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Robynne Hu</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><blockquote><em>CDI is a Dependency and Injection specification which is introduced in Java EE 6, currently Java EE is renamed to Jakarta EE and maintained by Eclipse Foundation. Weld is a compatible provider of the Jakarta CDI specification.</em></blockquote><p>Add the following dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt;<br>    &lt;artifactId&gt;weld-se-shaded&lt;/artifactId&gt;<br>    &lt;version&gt;${weld.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss&lt;/groupId&gt;<br>    &lt;artifactId&gt;jandex&lt;/artifactId&gt;<br>    &lt;version&gt;2.2.3.Final&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>In the above codes:</p><ul><li>The weld-se-shaded provides a CDI runtime environment for Java SE platform.</li><li>The jandex will index the classes in the application and speed up the bean searching.</li></ul><p>Add an empty beans.xml configuration in the <em>main/resources/META-INF</em> folder which is to enable CDI support in a Java SE application.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans<br>        xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;<br>        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>        xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee<br>                      http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd&quot;<br>        bean-discovery-mode=&quot;annotated&quot;&gt;<br>&lt;/beans&gt;</pre><blockquote><em>In the Java EE/Jakarta EE world, CDI is enabled by default since Java EE 7, and the beans.xml configuration file is optional.</em></blockquote><p>Similar to the Spring version, add a DemoApplication to start the application.</p><pre>public class DemoApplication {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(DemoApplication.class.getName());</pre><pre>    public static void main(String[] args) {<br>        var weld = new Weld();<br>        var container = weld.initialize();<br>        var vertx = container.select(Vertx.class).get();<br>        var factory = container.select(VerticleFactory.class).get();</pre><pre>        LOGGER.info(&quot;vertx clazz:&quot; + vertx.getClass().getName());//Weld does not create proxy classes at runtime on @Singleton beans.<br>        LOGGER.info(&quot;factory clazz:&quot; + factory.getClass().getName());<br>        // deploy MainVerticle via verticle identifier name<br>        //var deployOptions = new DeploymentOptions().setInstances(4);<br>        vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName());<br>    }<br>}</pre><p>Here we uses weld.initialize() to initialize the CDI container. Then retrieve the Vertx bean and VerticleFactory bean, and start to deploy the MainVerticle.</p><p>Similar to the SpringAwareVerticleFactory , create a CDI aware VerticleFactory.</p><pre>@ApplicationScoped<br>public class CdiAwareVerticleFactory implements VerticleFactory {<br>    <br>    @Inject<br>    private Instance&lt;Object&gt; instance;</pre><pre>    @Override<br>    public String prefix() {<br>        return &quot;cdi&quot;;<br>    }</pre><pre>    @Override<br>    public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) {<br>        String clazz = VerticleFactory.removePrefix(verticleName);<br>        promise.complete(() -&gt; (Verticle) instance.select(Class.forName(clazz)).get());<br>    }<br>}</pre><p>Create a simple Resources classes and expose the Vertx and PgPool beans.</p><pre>@ApplicationScoped<br>public class Resources {<br>    private final static Logger LOGGER = Logger.getLogger(Resources.class.getName());</pre><pre>    @Produces<br>    @Singleton<br>    public Vertx vertx(VerticleFactory verticleFactory) {<br>        Vertx vertx = Vertx.vertx();<br>        vertx.registerVerticleFactory(verticleFactory);<br>        return vertx;<br>    }</pre><pre>    @Produces<br>    public PgPool pgPool(Vertx vertx) {<br>        PgConnectOptions connectOptions = new PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;);</pre><pre>        // Pool Options<br>        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>        // Create the pool from the data object<br>        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>        return pool;<br>    }</pre><pre>    public void disposesPgPool(@Disposes PgPool pgPool) {<br>        LOGGER.info(&quot;disposing PgPool...&quot;);<br>        pgPool.close().onSuccess(v -&gt; LOGGER.info(&quot;PgPool is closed successfully.&quot;));<br>    }<br>}</pre><p>Other beans are similar to the Spring version, but using CDI @ApplicaitonScoped to replace the Spring @Component.</p><pre>@ApplicationScoped<br>@RequiredArgsConstructor<br>public class MainVerticle extends AbstractVerticle {<br>    final PostsHandler postHandlers;<br>    <br>    //...<br>}</pre><pre>@ApplicationScoped<br>@RequiredArgsConstructor<br>class PostsHandler {<br>    private final PostRepository posts;<br>    <br>    //...<br>}</pre><pre>@ApplicationScoped<br>@RequiredArgsConstructor<br>public class PostRepository {</pre><pre>    private final PgPool client;<br>    <br>    //...<br>}</pre><pre>@ApplicationScoped<br>@RequiredArgsConstructor<br>public class DataInitializer {</pre><pre>    private  final PgPool client;<br>    <br>    //...<br>}</pre><p>Please note, in the above Resources class, we add a @Singleton to the Vertx, which is a little different from the ApplicationScoped, Weld does not create a proxy object for it.</p><blockquote><em>Here we have to add </em><em>@Singleton on Vertx bean, else there is an error of casting to </em><em>VertxImpl at the application startup stage, because CDI does not create a proxy bean for </em><em>VertxImpl.</em></blockquote><p>In the DemoApplication, we have added some log to print the class name of Vertx and VerticleFactory beans. When starting the application, in the console, you will see the class names as the following.</p><pre>//..<br>INFO: vertx clazz:io.vertx.core.impl.VertxImpl<br>//...<br>INFO: factory clazz:com.example.demo.CdiAwareVerticleFactory$Proxy$_$$_WeldClientProxy</pre><p>By default CDI will create proxy classes for all beans, but if it is annotated with @Singletone, it will use the instance directly.</p><p>To test the application, add the following dependency to <em>test</em> scope.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt;<br>    &lt;artifactId&gt;weld-junit5&lt;/artifactId&gt;<br>    &lt;version&gt;2.0.2.Final&lt;/version&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;</pre><p>Similar to the Spring version, manually deploy the Verticle in the JUnit @BeforeAll hook before running tests.</p><pre>@EnableAutoWeld<br>@AddPackages(DemoApplication.class)<br>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br>@ExtendWith(VertxExtension.class)<br>public class TestMainVerticle {<br>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());</pre><pre>    @Inject<br>    Instance&lt;Object&gt; context;</pre><pre>    Vertx vertx;</pre><pre>    @BeforeAll<br>    public void setupAll(VertxTestContext testContext) {<br>        vertx = context.select(Vertx.class).get();<br>        var factory = context.select(VerticleFactory.class).get();<br>        vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName())<br>            .onSuccess(id -&gt; {<br>                LOGGER.info(&quot;deployed:&quot; + id);<br>                testContext.completeNow();<br>            });<br>    }</pre><pre>    @Test<br>    public void testVertx(VertxTestContext testContext) {<br>        assertThat(vertx).isNotNull();<br>        testContext.completeNow();<br>    }<br></pre><pre>    @Test<br>    void testGetAll(VertxTestContext testContext) {<br>        LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;);<br>        var options = new HttpClientOptions()<br>            .setDefaultPort(8888);<br>        var client = vertx.createHttpClient(options);</pre><pre>        client.request(HttpMethod.GET, &quot;/posts&quot;)<br>            .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body))<br>            .onSuccess(<br>                buffer -&gt; testContext.verify(<br>                    () -&gt; {<br>                        LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()});<br>                        assertThat(buffer.toJsonArray().size()).isGreaterThan(0);<br>                        testContext.completeNow();<br>                    }<br>                )<br>            )<br>            .onFailure(e -&gt; LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()));<br>    }</pre><pre>}</pre><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service-cdi">example codes from my github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=53a7617bd963" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/integrating-vertx-application-with-weld-cdi-53a7617bd963">Integrating Vertx application with Weld/CDI</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
