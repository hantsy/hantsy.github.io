<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building GraphQL APIs with Eclipse Vertx
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-graphql-apis-with-eclipse-vertx/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building GraphQL APIs with Eclipse Vertx" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We have discussed GraphQL in a former Quarkus GraphQL post. In this post, we will explore the GraphQL support in Eclipse Vertx. Photo by Yang Shuo on Unsplash Quarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature. Follow the steps in the Building RESTful APIs with Eclipse Vertx and create a new Eclipse Vertx project, do not forget to add GraphQL into Dependencies. Or add the following dependency into the existing pom.xml file directly. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-web-graphql&lt;/artifactId&gt;&lt;/dependency&gt; Checkout the complete sample codes from my Github. Vertx provides a specific GraphQLHandler to handle GraphQL request from client. Fill the MainVerticle with the following content. @Slf4jpublic class MainVerticle extends AbstractVerticle { static { log.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public void start(Promise&lt;Void&gt; startPromise) throws Exception { log.info(&quot;Starting HTTP server...&quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); // instantiate repos var postRepository = new PostRepository(pgPool); var commentRepository = new CommentRepository(pgPool); var authorRepository = new AuthorRepository(pgPool); // Initializing the sample data var initializer = new DataInitializer(postRepository, commentRepository, authorRepository); initializer.run(); //assemble PostService var postService = new PostService(postRepository, commentRepository, authorRepository); var authorService = new AuthorService(authorRepository); // assemble DataLoaders var dataLoaders = new DataLoaders(authorService, postService); //assemble DataFetcher var dataFetchers = new DataFetchers(postService); // setup GraphQL GraphQL graphQL = setupGraphQLJava(dataFetchers); // Configure routes var router = setupRoutes(graphQL, dataLoaders); // enable GraphQL Websocket Protocol HttpServerOptions httpServerOptions = new HttpServerOptions() .addWebSocketSubProtocol(&quot;graphql-ws&quot;); // Create the HTTP server vertx.createHttpServer(httpServerOptions) // Handle every request using the router .requestHandler(router) // Start listening .listen(8080) // Print the port .onSuccess(server -&gt; { startPromise.complete(); log.info(&quot;HTTP server started on port &quot; + server.actualPort()); }) .onFailure(event -&gt; { startPromise.fail(event); log.info(&quot;Failed to start HTTP server:&quot; + event.getMessage()); }) ; } //create routes private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. router.route().handler(BodyHandler.create()); // register GraphQL Subscription websocket handler. ApolloWSOptions apolloWSOptions = new ApolloWSOptions(); router.route(&quot;/graphql&quot;).handler( ApolloWSHandler.create(graphQL, apolloWSOptions) .connectionInitHandler(connectionInitEvent -&gt; { JsonObject payload = connectionInitEvent.message().content().getJsonObject(&quot;payload&quot;); log.info(&quot;connection init event: {}&quot;, payload); if (payload != null &amp;&amp; payload.containsKey(&quot;rejectMessage&quot;)) { connectionInitEvent.fail(payload.getString(&quot;rejectMessage&quot;)); return; } connectionInitEvent.complete(payload); }) //.connectionHandler(event -&gt; log.info(&quot;connection event: {}&quot;, event)) //.messageHandler(msg -&gt; log.info(&quot;websocket message: {}&quot;, msg.content().toString())) //.endHandler(event -&gt; log.info(&quot;end event: {}&quot;, event)) ); GraphQLHandlerOptions options = new GraphQLHandlerOptions() // enable multipart for file upload. .setRequestMultipartEnabled(true) .setRequestBatchingEnabled(true); // register `/graphql` for GraphQL handler // alternatively, use `router.route()` to enable GET and POST http methods router.post(&quot;/graphql&quot;) .handler( GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) //.locale() //.queryContext() ); // register `/graphiql` endpoint for the GraphiQL UI GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions() .setEnabled(true); router.get(&quot;/graphiql/*&quot;).handler(GraphiQLHandler.create(graphiqlOptions)); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router; } private Function&lt;RoutingContext, DataLoaderRegistry&gt; buildDataLoaderRegistry(DataLoaders dataLoaders) { DataLoaderRegistry registry = new DataLoaderRegistry(); registry.register(&quot;commentsLoader&quot;, dataLoaders.commentsLoader()); registry.register(&quot;authorsLoader&quot;, dataLoaders.authorsLoader()); return rc -&gt; registry; } @SneakyThrows private GraphQL setupGraphQLJava(DataFetchers dataFetchers) { TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry(); RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers); GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring); return buildGraphQL(graphQLSchema); } private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) { return GraphQL.newGraphQL(graphQLSchema) .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler()) //.queryExecutionStrategy() //.mutationExecutionStrategy() //.subscriptionExecutionStrategy() //.instrumentation() .build(); } private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) { SchemaGenerator schemaGenerator = new SchemaGenerator(); GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring); return graphQLSchema; } private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException { var schema = Files.readString(Paths.get(getClass().getResource(&quot;/schema/schema.graphql&quot;).toURI())); //String schema = vertx.fileSystem().readFileBlocking(&quot;/schema/schema.graphql&quot;).toString(); SchemaParser schemaParser = new SchemaParser(); TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema); return typeDefinitionRegistry; } private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) { return newRuntimeWiring() // the following codes are moved to CodeRegistry, the central place to configure the execution codes. /* .wiringFactory(new WiringFactory() { @Override public DataFetcher&lt;Object&gt; getDefaultDataFetcher(FieldWiringEnvironment environment) { return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()); } }) .type(&quot;Query&quot;, builder -&gt; builder .dataFetcher(&quot;postById&quot;, dataFetchers.getPostById()) .dataFetcher(&quot;allPosts&quot;, dataFetchers.getAllPosts()) ) .type(&quot;Mutation&quot;, builder -&gt; builder.dataFetcher(&quot;createPost&quot;, dataFetchers.createPost())) .type(&quot;Post&quot;, builder -&gt; builder .dataFetcher(&quot;author&quot;, dataFetchers.authorOfPost()) .dataFetcher(&quot;comments&quot;, dataFetchers.commentsOfPost()) ) */ .codeRegistry(buildCodeRegistry(dataFetchers)) .scalar(Scalars.localDateTimeType()) .scalar(Scalars.uuidType()) .scalar(UploadScalar.build())// handling `Upload` scalar .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring()) .build(); } private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) { return GraphQLCodeRegistry.newCodeRegistry() .dataFetchers(&quot;Query&quot;, Map.of( &quot;postById&quot;, dataFetchers.getPostById(), &quot;allPosts&quot;, dataFetchers.getAllPosts() )) .dataFetchers(&quot;Mutation&quot;, Map.of( &quot;createPost&quot;, dataFetchers.createPost(), &quot;upload&quot;, dataFetchers.upload(), &quot;addComment&quot;, dataFetchers.addComment() )) .dataFetchers(&quot;Subscription&quot;, Map.of( &quot;commentAdded&quot;, dataFetchers.commentAdded() )) .dataFetchers(&quot;Post&quot;, Map.of( &quot;author&quot;, dataFetchers.authorOfPost(), &quot;comments&quot;, dataFetchers.commentsOfPost() )) //.typeResolver() //.fieldVisibility() .defaultDataFetcher(environment -&gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName())) .build(); } private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; } } The start method is similar to the one in the previous posts, but here it enabled graphql-ws WebSocket sub protocol to activate GraphQL Subscription support. In the setupRoutes method, it adds the route /graphql to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via /graphql endpoint, also adds route /graphiql to activate GraphiQL interactive Web UI. As you see, the following is used to create a GraphQLHandler instance. GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) It requires a GraphQL instance and optional options to initialize a GraphQL instance. To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects: A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method. In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance. Let’s have a look at the graphql schema file under the main/resources/schema/schema.graphql folder. directive @uppercase on FIELD_DEFINITION scalar LocalDateTimescalar UUIDscalar Upload type Post { id: ID! title: String! @uppercase content: String comments: [Comment] status: PostStatus createdAt: LocalDateTime authorId: String author: Author} type Author { id: ID! name: String! email: String! createdAt: LocalDateTime posts: [Post]}type Comment { id: ID! content: String! createdAt: LocalDateTime postId: String!} input CreatePostInput { title: String! content: String!} input CommentInput { postId: String! content: String!} type Query { allPosts: [Post!]! postById(postId: String!): Post} type Mutation { createPost(createPostInput: CreatePostInput!): UUID! upload(file: Upload!): Boolean addComment(commentInput: CommentInput!): UUID!} type Subscription{ commentAdded: Comment!} enum PostStatus { DRAFT PENDING_MODERATION PUBLISHED} In this schema file, we declare 3 top level types: Query, Mutation and Subscription which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The scalar keyword defines custom scalar types. The directive defines custom directive @uppercase applied on field. In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions. For example, when performing a Query: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method. .dataFetchers(&quot;Query&quot;, Map.of( &quot;postById&quot;, dataFetchers.getPostById(), ... Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc. The following is an example of custom Scalar type. // LocalDateTimeScalarpublic class LocalDateTimeScalar implements Coercing&lt;LocalDateTime, String&gt; { @Override public String serialize(Object dataFetcherResult) throws CoercingSerializeException { if (dataFetcherResult instanceof LocalDateTime) { return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME); } else { throw new CoercingSerializeException(&quot;Not a valid DateTime&quot;); } } @Override public LocalDateTime parseValue(Object input) throws CoercingParseValueException { return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME); } @Override public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException { if (input instanceof StringValue) { return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME); } throw new CoercingParseLiteralException(&quot;Value is not a valid ISO date time&quot;); }}//Scalarspublic class Scalars { public static GraphQLScalarType localDateTimeType() { return GraphQLScalarType.newScalar() .name(&quot;LocalDateTime&quot;) .description(&quot;LocalDateTime type&quot;) .coercing(new LocalDateTimeScalar()) .build(); }} //register custom scalar type in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .scalar(Scalars.localDateTimeType()) Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself. Similarly register a custom Directive in the buildRuntimeWiring, eg. the @uppercase directive. //UpperCaseDirectiveWiringpublic class UpperCaseDirectiveWiring implements SchemaDirectiveWiring { @Override public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) { var field = env.getElement(); var parentType = env.getFieldsContainer(); var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field); var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher, (dataFetchingEnvironment, value) -&gt; { if (value instanceof String s) { return s.toUpperCase(); } return value; } ); env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher); return field; }}//register custom scalar directive in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring()) Let’s move on to the data fetchers which are responsible for resolving the type values at runtime. For example, in the GraphiQL UI page, try to send a predefined query like this. query { allPosts{ id title content author{ name } comments{ content } }} It means, it will perform an allPosts Query, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field. When the GraphQL request is sent, GraphQLHandler will handle it. Validate the GraphQL request and ensure it follows schema type definitions.Locate the data fetchers via type coordinates, Query and allPosts.Assemble the returned values according to the request format.When resolving author field, it will try to locate Post and author to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles comments via dataFetchers.commentsOfPost().Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly. The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it. The file uploading is defined by GraphQL multipart request specification, not part of the standard GraphQL spec. The following is the data fetcher to handle the file uploading. public DataFetcher&lt;Boolean&gt; upload() { return (DataFetchingEnvironment dfe) -&gt; { FileUpload upload = dfe.getArgument(&quot;file&quot;); log.info(&quot;name: {}&quot;, upload.name()); log.info(&quot;file name: {}&quot;, upload.fileName()); log.info(&quot;uploaded file name: {}&quot;, upload.uploadedFileName()); log.info(&quot;content type: {}&quot;, upload.contentType()); log.info(&quot;charset: {}&quot;, upload.charSet()); log.info(&quot;size: {}&quot;, upload.size()); // String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString(); // log.info(&quot;file content: {}&quot;, fileContent); return true; };} Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system. For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type. The following is an example of sending notification when a comment is added. public VertxDataFetcher&lt;UUID&gt; addComment() { return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&gt; { var commentInputArg = dfe.getArgument(&quot;commentInput&quot;); var jacksonMapper = DatabindCodec.mapper(); var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class); return this.posts.addComment(input) .onSuccess(id -&gt; this.posts.getCommentById(id.toString()) .onSuccess(c -&gt; subject.onNext(c))); });} private ReplaySubject&lt;Comment&gt; subject = ReplaySubject.create(1); public DataFetcher&lt;Publisher&lt;Comment&gt;&gt; commentAdded() { return (DataFetchingEnvironment dfe) -&gt; { ApolloWSMessage message = dfe.getContext(); log.info(&quot;msg: {}, connectionParams: {}&quot;, message.content(), message.connectionParams()); ConnectableObservable&lt;Comment&gt; connectableObservable = subject.share().publish(); connectableObservable.connect(); log.info(&quot;connect to `commentAdded`&quot;); return connectableObservable.toFlowable(BackpressureStrategy.BUFFER); };} The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints. Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the complete sample codes from my Github and explore it yourself. Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java. To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about GraphQL over HTTP specification. The following is an example of testing allPosts query and createPost mutation using Vertx HttpClient. @ExtendWith(VertxExtension.class)@Slf4jpublic class TestMainVerticle { HttpClient client; @BeforeEach void setup(Vertx vertx, VertxTestContext testContext) { vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow())); var options = new HttpClientOptions() .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); client = vertx.createHttpClient(options); } @Test void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable { var query = &quot;&quot;&quot; query { allPosts{ id title content author{ name } comments{ content } } }&quot;&quot;&quot;; client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(Json.encode(Map.of(&quot;query&quot;, query)))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ) .onComplete( testContext.succeeding( buffer -&gt; testContext.verify( () -&gt; { log.info(&quot;buf: {}&quot;, buffer.toString()); JsonArray array = buffer.toJsonObject() .getJsonObject(&quot;data&quot;) .getJsonArray(&quot;allPosts&quot;); assertThat(array.size()).isGreaterThan(0); var titles = array.getList().stream().map(o -&gt; ((Map&lt;String, Object&gt;) o).get(&quot;title&quot;)).toList(); assertThat(titles).allMatch(s -&gt; ((String) s).startsWith(&quot;DGS POST&quot;)); testContext.completeNow(); } ) ) ); } @Test void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable { String TITLE = &quot;My post created by Vertx HttpClient&quot;; //var creatPostQuery = &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;; var creatPostQuery = &quot;&quot;&quot; mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input) }&quot;&quot;&quot;; client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; { String encodedJson = Json.encode(Map.of( &quot;query&quot;, creatPostQuery, &quot;variables&quot;, Map.of( &quot;input&quot;, Map.of( &quot;title&quot;, TITLE, &quot;content&quot;, &quot;content of my post&quot; ) ) )); log.info(&quot;sending encoded json: {}&quot;, encodedJson); return req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(encodedJson)//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body); } ) .flatMap(buf -&gt; { Object id = buf.toJsonObject().getJsonObject(&quot;data&quot;).getValue(&quot;createPost&quot;); log.info(&quot;created post: {}&quot;, id); assertThat(id).isNotNull(); var postById = &quot;&quot;&quot; query post($id:String!) { postById(postId:$id){id title content} }&quot;&quot;&quot;; return client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(Json.encode(Map.of( &quot;query&quot;, postById, &quot;variables&quot;, Map.of(&quot;id&quot;, id.toString()) )))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ); }) .onComplete( testContext.succeeding( buffer -&gt; testContext.verify( () -&gt; { log.info(&quot;buf: {}&quot;, buffer.toString()); String title = buffer.toJsonObject() .getJsonObject(&quot;data&quot;) .getJsonObject(&quot;postById&quot;) .getString(&quot;title&quot;); assertThat(title).isEqualTo(TITLE.toUpperCase()); testContext.completeNow(); } ) ) ); }} Get the sample codes from my Github. &lt;hr&gt;&lt;p&gt;Building GraphQL APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="We have discussed GraphQL in a former Quarkus GraphQL post. In this post, we will explore the GraphQL support in Eclipse Vertx. Photo by Yang Shuo on Unsplash Quarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature. Follow the steps in the Building RESTful APIs with Eclipse Vertx and create a new Eclipse Vertx project, do not forget to add GraphQL into Dependencies. Or add the following dependency into the existing pom.xml file directly. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-web-graphql&lt;/artifactId&gt;&lt;/dependency&gt; Checkout the complete sample codes from my Github. Vertx provides a specific GraphQLHandler to handle GraphQL request from client. Fill the MainVerticle with the following content. @Slf4jpublic class MainVerticle extends AbstractVerticle { static { log.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public void start(Promise&lt;Void&gt; startPromise) throws Exception { log.info(&quot;Starting HTTP server...&quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); // instantiate repos var postRepository = new PostRepository(pgPool); var commentRepository = new CommentRepository(pgPool); var authorRepository = new AuthorRepository(pgPool); // Initializing the sample data var initializer = new DataInitializer(postRepository, commentRepository, authorRepository); initializer.run(); //assemble PostService var postService = new PostService(postRepository, commentRepository, authorRepository); var authorService = new AuthorService(authorRepository); // assemble DataLoaders var dataLoaders = new DataLoaders(authorService, postService); //assemble DataFetcher var dataFetchers = new DataFetchers(postService); // setup GraphQL GraphQL graphQL = setupGraphQLJava(dataFetchers); // Configure routes var router = setupRoutes(graphQL, dataLoaders); // enable GraphQL Websocket Protocol HttpServerOptions httpServerOptions = new HttpServerOptions() .addWebSocketSubProtocol(&quot;graphql-ws&quot;); // Create the HTTP server vertx.createHttpServer(httpServerOptions) // Handle every request using the router .requestHandler(router) // Start listening .listen(8080) // Print the port .onSuccess(server -&gt; { startPromise.complete(); log.info(&quot;HTTP server started on port &quot; + server.actualPort()); }) .onFailure(event -&gt; { startPromise.fail(event); log.info(&quot;Failed to start HTTP server:&quot; + event.getMessage()); }) ; } //create routes private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. router.route().handler(BodyHandler.create()); // register GraphQL Subscription websocket handler. ApolloWSOptions apolloWSOptions = new ApolloWSOptions(); router.route(&quot;/graphql&quot;).handler( ApolloWSHandler.create(graphQL, apolloWSOptions) .connectionInitHandler(connectionInitEvent -&gt; { JsonObject payload = connectionInitEvent.message().content().getJsonObject(&quot;payload&quot;); log.info(&quot;connection init event: {}&quot;, payload); if (payload != null &amp;&amp; payload.containsKey(&quot;rejectMessage&quot;)) { connectionInitEvent.fail(payload.getString(&quot;rejectMessage&quot;)); return; } connectionInitEvent.complete(payload); }) //.connectionHandler(event -&gt; log.info(&quot;connection event: {}&quot;, event)) //.messageHandler(msg -&gt; log.info(&quot;websocket message: {}&quot;, msg.content().toString())) //.endHandler(event -&gt; log.info(&quot;end event: {}&quot;, event)) ); GraphQLHandlerOptions options = new GraphQLHandlerOptions() // enable multipart for file upload. .setRequestMultipartEnabled(true) .setRequestBatchingEnabled(true); // register `/graphql` for GraphQL handler // alternatively, use `router.route()` to enable GET and POST http methods router.post(&quot;/graphql&quot;) .handler( GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) //.locale() //.queryContext() ); // register `/graphiql` endpoint for the GraphiQL UI GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions() .setEnabled(true); router.get(&quot;/graphiql/*&quot;).handler(GraphiQLHandler.create(graphiqlOptions)); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router; } private Function&lt;RoutingContext, DataLoaderRegistry&gt; buildDataLoaderRegistry(DataLoaders dataLoaders) { DataLoaderRegistry registry = new DataLoaderRegistry(); registry.register(&quot;commentsLoader&quot;, dataLoaders.commentsLoader()); registry.register(&quot;authorsLoader&quot;, dataLoaders.authorsLoader()); return rc -&gt; registry; } @SneakyThrows private GraphQL setupGraphQLJava(DataFetchers dataFetchers) { TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry(); RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers); GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring); return buildGraphQL(graphQLSchema); } private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) { return GraphQL.newGraphQL(graphQLSchema) .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler()) //.queryExecutionStrategy() //.mutationExecutionStrategy() //.subscriptionExecutionStrategy() //.instrumentation() .build(); } private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) { SchemaGenerator schemaGenerator = new SchemaGenerator(); GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring); return graphQLSchema; } private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException { var schema = Files.readString(Paths.get(getClass().getResource(&quot;/schema/schema.graphql&quot;).toURI())); //String schema = vertx.fileSystem().readFileBlocking(&quot;/schema/schema.graphql&quot;).toString(); SchemaParser schemaParser = new SchemaParser(); TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema); return typeDefinitionRegistry; } private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) { return newRuntimeWiring() // the following codes are moved to CodeRegistry, the central place to configure the execution codes. /* .wiringFactory(new WiringFactory() { @Override public DataFetcher&lt;Object&gt; getDefaultDataFetcher(FieldWiringEnvironment environment) { return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()); } }) .type(&quot;Query&quot;, builder -&gt; builder .dataFetcher(&quot;postById&quot;, dataFetchers.getPostById()) .dataFetcher(&quot;allPosts&quot;, dataFetchers.getAllPosts()) ) .type(&quot;Mutation&quot;, builder -&gt; builder.dataFetcher(&quot;createPost&quot;, dataFetchers.createPost())) .type(&quot;Post&quot;, builder -&gt; builder .dataFetcher(&quot;author&quot;, dataFetchers.authorOfPost()) .dataFetcher(&quot;comments&quot;, dataFetchers.commentsOfPost()) ) */ .codeRegistry(buildCodeRegistry(dataFetchers)) .scalar(Scalars.localDateTimeType()) .scalar(Scalars.uuidType()) .scalar(UploadScalar.build())// handling `Upload` scalar .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring()) .build(); } private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) { return GraphQLCodeRegistry.newCodeRegistry() .dataFetchers(&quot;Query&quot;, Map.of( &quot;postById&quot;, dataFetchers.getPostById(), &quot;allPosts&quot;, dataFetchers.getAllPosts() )) .dataFetchers(&quot;Mutation&quot;, Map.of( &quot;createPost&quot;, dataFetchers.createPost(), &quot;upload&quot;, dataFetchers.upload(), &quot;addComment&quot;, dataFetchers.addComment() )) .dataFetchers(&quot;Subscription&quot;, Map.of( &quot;commentAdded&quot;, dataFetchers.commentAdded() )) .dataFetchers(&quot;Post&quot;, Map.of( &quot;author&quot;, dataFetchers.authorOfPost(), &quot;comments&quot;, dataFetchers.commentsOfPost() )) //.typeResolver() //.fieldVisibility() .defaultDataFetcher(environment -&gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName())) .build(); } private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; } } The start method is similar to the one in the previous posts, but here it enabled graphql-ws WebSocket sub protocol to activate GraphQL Subscription support. In the setupRoutes method, it adds the route /graphql to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via /graphql endpoint, also adds route /graphiql to activate GraphiQL interactive Web UI. As you see, the following is used to create a GraphQLHandler instance. GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) It requires a GraphQL instance and optional options to initialize a GraphQL instance. To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects: A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method. In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance. Let’s have a look at the graphql schema file under the main/resources/schema/schema.graphql folder. directive @uppercase on FIELD_DEFINITION scalar LocalDateTimescalar UUIDscalar Upload type Post { id: ID! title: String! @uppercase content: String comments: [Comment] status: PostStatus createdAt: LocalDateTime authorId: String author: Author} type Author { id: ID! name: String! email: String! createdAt: LocalDateTime posts: [Post]}type Comment { id: ID! content: String! createdAt: LocalDateTime postId: String!} input CreatePostInput { title: String! content: String!} input CommentInput { postId: String! content: String!} type Query { allPosts: [Post!]! postById(postId: String!): Post} type Mutation { createPost(createPostInput: CreatePostInput!): UUID! upload(file: Upload!): Boolean addComment(commentInput: CommentInput!): UUID!} type Subscription{ commentAdded: Comment!} enum PostStatus { DRAFT PENDING_MODERATION PUBLISHED} In this schema file, we declare 3 top level types: Query, Mutation and Subscription which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The scalar keyword defines custom scalar types. The directive defines custom directive @uppercase applied on field. In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions. For example, when performing a Query: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method. .dataFetchers(&quot;Query&quot;, Map.of( &quot;postById&quot;, dataFetchers.getPostById(), ... Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc. The following is an example of custom Scalar type. // LocalDateTimeScalarpublic class LocalDateTimeScalar implements Coercing&lt;LocalDateTime, String&gt; { @Override public String serialize(Object dataFetcherResult) throws CoercingSerializeException { if (dataFetcherResult instanceof LocalDateTime) { return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME); } else { throw new CoercingSerializeException(&quot;Not a valid DateTime&quot;); } } @Override public LocalDateTime parseValue(Object input) throws CoercingParseValueException { return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME); } @Override public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException { if (input instanceof StringValue) { return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME); } throw new CoercingParseLiteralException(&quot;Value is not a valid ISO date time&quot;); }}//Scalarspublic class Scalars { public static GraphQLScalarType localDateTimeType() { return GraphQLScalarType.newScalar() .name(&quot;LocalDateTime&quot;) .description(&quot;LocalDateTime type&quot;) .coercing(new LocalDateTimeScalar()) .build(); }} //register custom scalar type in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .scalar(Scalars.localDateTimeType()) Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself. Similarly register a custom Directive in the buildRuntimeWiring, eg. the @uppercase directive. //UpperCaseDirectiveWiringpublic class UpperCaseDirectiveWiring implements SchemaDirectiveWiring { @Override public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) { var field = env.getElement(); var parentType = env.getFieldsContainer(); var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field); var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher, (dataFetchingEnvironment, value) -&gt; { if (value instanceof String s) { return s.toUpperCase(); } return value; } ); env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher); return field; }}//register custom scalar directive in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring()) Let’s move on to the data fetchers which are responsible for resolving the type values at runtime. For example, in the GraphiQL UI page, try to send a predefined query like this. query { allPosts{ id title content author{ name } comments{ content } }} It means, it will perform an allPosts Query, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field. When the GraphQL request is sent, GraphQLHandler will handle it. Validate the GraphQL request and ensure it follows schema type definitions.Locate the data fetchers via type coordinates, Query and allPosts.Assemble the returned values according to the request format.When resolving author field, it will try to locate Post and author to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles comments via dataFetchers.commentsOfPost().Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly. The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it. The file uploading is defined by GraphQL multipart request specification, not part of the standard GraphQL spec. The following is the data fetcher to handle the file uploading. public DataFetcher&lt;Boolean&gt; upload() { return (DataFetchingEnvironment dfe) -&gt; { FileUpload upload = dfe.getArgument(&quot;file&quot;); log.info(&quot;name: {}&quot;, upload.name()); log.info(&quot;file name: {}&quot;, upload.fileName()); log.info(&quot;uploaded file name: {}&quot;, upload.uploadedFileName()); log.info(&quot;content type: {}&quot;, upload.contentType()); log.info(&quot;charset: {}&quot;, upload.charSet()); log.info(&quot;size: {}&quot;, upload.size()); // String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString(); // log.info(&quot;file content: {}&quot;, fileContent); return true; };} Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system. For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type. The following is an example of sending notification when a comment is added. public VertxDataFetcher&lt;UUID&gt; addComment() { return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&gt; { var commentInputArg = dfe.getArgument(&quot;commentInput&quot;); var jacksonMapper = DatabindCodec.mapper(); var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class); return this.posts.addComment(input) .onSuccess(id -&gt; this.posts.getCommentById(id.toString()) .onSuccess(c -&gt; subject.onNext(c))); });} private ReplaySubject&lt;Comment&gt; subject = ReplaySubject.create(1); public DataFetcher&lt;Publisher&lt;Comment&gt;&gt; commentAdded() { return (DataFetchingEnvironment dfe) -&gt; { ApolloWSMessage message = dfe.getContext(); log.info(&quot;msg: {}, connectionParams: {}&quot;, message.content(), message.connectionParams()); ConnectableObservable&lt;Comment&gt; connectableObservable = subject.share().publish(); connectableObservable.connect(); log.info(&quot;connect to `commentAdded`&quot;); return connectableObservable.toFlowable(BackpressureStrategy.BUFFER); };} The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints. Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the complete sample codes from my Github and explore it yourself. Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java. To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about GraphQL over HTTP specification. The following is an example of testing allPosts query and createPost mutation using Vertx HttpClient. @ExtendWith(VertxExtension.class)@Slf4jpublic class TestMainVerticle { HttpClient client; @BeforeEach void setup(Vertx vertx, VertxTestContext testContext) { vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow())); var options = new HttpClientOptions() .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); client = vertx.createHttpClient(options); } @Test void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable { var query = &quot;&quot;&quot; query { allPosts{ id title content author{ name } comments{ content } } }&quot;&quot;&quot;; client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(Json.encode(Map.of(&quot;query&quot;, query)))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ) .onComplete( testContext.succeeding( buffer -&gt; testContext.verify( () -&gt; { log.info(&quot;buf: {}&quot;, buffer.toString()); JsonArray array = buffer.toJsonObject() .getJsonObject(&quot;data&quot;) .getJsonArray(&quot;allPosts&quot;); assertThat(array.size()).isGreaterThan(0); var titles = array.getList().stream().map(o -&gt; ((Map&lt;String, Object&gt;) o).get(&quot;title&quot;)).toList(); assertThat(titles).allMatch(s -&gt; ((String) s).startsWith(&quot;DGS POST&quot;)); testContext.completeNow(); } ) ) ); } @Test void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable { String TITLE = &quot;My post created by Vertx HttpClient&quot;; //var creatPostQuery = &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;; var creatPostQuery = &quot;&quot;&quot; mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input) }&quot;&quot;&quot;; client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; { String encodedJson = Json.encode(Map.of( &quot;query&quot;, creatPostQuery, &quot;variables&quot;, Map.of( &quot;input&quot;, Map.of( &quot;title&quot;, TITLE, &quot;content&quot;, &quot;content of my post&quot; ) ) )); log.info(&quot;sending encoded json: {}&quot;, encodedJson); return req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(encodedJson)//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body); } ) .flatMap(buf -&gt; { Object id = buf.toJsonObject().getJsonObject(&quot;data&quot;).getValue(&quot;createPost&quot;); log.info(&quot;created post: {}&quot;, id); assertThat(id).isNotNull(); var postById = &quot;&quot;&quot; query post($id:String!) { postById(postId:$id){id title content} }&quot;&quot;&quot;; return client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(Json.encode(Map.of( &quot;query&quot;, postById, &quot;variables&quot;, Map.of(&quot;id&quot;, id.toString()) )))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ); }) .onComplete( testContext.succeeding( buffer -&gt; testContext.verify( () -&gt; { log.info(&quot;buf: {}&quot;, buffer.toString()); String title = buffer.toJsonObject() .getJsonObject(&quot;data&quot;) .getJsonObject(&quot;postById&quot;) .getString(&quot;title&quot;); assertThat(title).isEqualTo(TITLE.toUpperCase()); testContext.completeNow(); } ) ) ); }} Get the sample codes from my Github. &lt;hr&gt;&lt;p&gt;Building GraphQL APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-24T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building GraphQL APIs with Eclipse Vertx" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-24T00:00:00+00:00","datePublished":"2021-07-24T00:00:00+00:00","description":"We have discussed GraphQL in a former Quarkus GraphQL post. In this post, we will explore the GraphQL support in Eclipse Vertx. Photo by Yang Shuo on Unsplash Quarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature. Follow the steps in the Building RESTful APIs with Eclipse Vertx and create a new Eclipse Vertx project, do not forget to add GraphQL into Dependencies. Or add the following dependency into the existing pom.xml file directly. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-web-graphql&lt;/artifactId&gt;&lt;/dependency&gt; Checkout the complete sample codes from my Github. Vertx provides a specific GraphQLHandler to handle GraphQL request from client. Fill the MainVerticle with the following content. @Slf4jpublic class MainVerticle extends AbstractVerticle { static { log.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public void start(Promise&lt;Void&gt; startPromise) throws Exception { log.info(&quot;Starting HTTP server...&quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); // instantiate repos var postRepository = new PostRepository(pgPool); var commentRepository = new CommentRepository(pgPool); var authorRepository = new AuthorRepository(pgPool); // Initializing the sample data var initializer = new DataInitializer(postRepository, commentRepository, authorRepository); initializer.run(); //assemble PostService var postService = new PostService(postRepository, commentRepository, authorRepository); var authorService = new AuthorService(authorRepository); // assemble DataLoaders var dataLoaders = new DataLoaders(authorService, postService); //assemble DataFetcher var dataFetchers = new DataFetchers(postService); // setup GraphQL GraphQL graphQL = setupGraphQLJava(dataFetchers); // Configure routes var router = setupRoutes(graphQL, dataLoaders); // enable GraphQL Websocket Protocol HttpServerOptions httpServerOptions = new HttpServerOptions() .addWebSocketSubProtocol(&quot;graphql-ws&quot;); // Create the HTTP server vertx.createHttpServer(httpServerOptions) // Handle every request using the router .requestHandler(router) // Start listening .listen(8080) // Print the port .onSuccess(server -&gt; { startPromise.complete(); log.info(&quot;HTTP server started on port &quot; + server.actualPort()); }) .onFailure(event -&gt; { startPromise.fail(event); log.info(&quot;Failed to start HTTP server:&quot; + event.getMessage()); }) ; } //create routes private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. router.route().handler(BodyHandler.create()); // register GraphQL Subscription websocket handler. ApolloWSOptions apolloWSOptions = new ApolloWSOptions(); router.route(&quot;/graphql&quot;).handler( ApolloWSHandler.create(graphQL, apolloWSOptions) .connectionInitHandler(connectionInitEvent -&gt; { JsonObject payload = connectionInitEvent.message().content().getJsonObject(&quot;payload&quot;); log.info(&quot;connection init event: {}&quot;, payload); if (payload != null &amp;&amp; payload.containsKey(&quot;rejectMessage&quot;)) { connectionInitEvent.fail(payload.getString(&quot;rejectMessage&quot;)); return; } connectionInitEvent.complete(payload); }) //.connectionHandler(event -&gt; log.info(&quot;connection event: {}&quot;, event)) //.messageHandler(msg -&gt; log.info(&quot;websocket message: {}&quot;, msg.content().toString())) //.endHandler(event -&gt; log.info(&quot;end event: {}&quot;, event)) ); GraphQLHandlerOptions options = new GraphQLHandlerOptions() // enable multipart for file upload. .setRequestMultipartEnabled(true) .setRequestBatchingEnabled(true); // register `/graphql` for GraphQL handler // alternatively, use `router.route()` to enable GET and POST http methods router.post(&quot;/graphql&quot;) .handler( GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) //.locale() //.queryContext() ); // register `/graphiql` endpoint for the GraphiQL UI GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions() .setEnabled(true); router.get(&quot;/graphiql/*&quot;).handler(GraphiQLHandler.create(graphiqlOptions)); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router; } private Function&lt;RoutingContext, DataLoaderRegistry&gt; buildDataLoaderRegistry(DataLoaders dataLoaders) { DataLoaderRegistry registry = new DataLoaderRegistry(); registry.register(&quot;commentsLoader&quot;, dataLoaders.commentsLoader()); registry.register(&quot;authorsLoader&quot;, dataLoaders.authorsLoader()); return rc -&gt; registry; } @SneakyThrows private GraphQL setupGraphQLJava(DataFetchers dataFetchers) { TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry(); RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers); GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring); return buildGraphQL(graphQLSchema); } private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) { return GraphQL.newGraphQL(graphQLSchema) .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler()) //.queryExecutionStrategy() //.mutationExecutionStrategy() //.subscriptionExecutionStrategy() //.instrumentation() .build(); } private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) { SchemaGenerator schemaGenerator = new SchemaGenerator(); GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring); return graphQLSchema; } private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException { var schema = Files.readString(Paths.get(getClass().getResource(&quot;/schema/schema.graphql&quot;).toURI())); //String schema = vertx.fileSystem().readFileBlocking(&quot;/schema/schema.graphql&quot;).toString(); SchemaParser schemaParser = new SchemaParser(); TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema); return typeDefinitionRegistry; } private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) { return newRuntimeWiring() // the following codes are moved to CodeRegistry, the central place to configure the execution codes. /* .wiringFactory(new WiringFactory() { @Override public DataFetcher&lt;Object&gt; getDefaultDataFetcher(FieldWiringEnvironment environment) { return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()); } }) .type(&quot;Query&quot;, builder -&gt; builder .dataFetcher(&quot;postById&quot;, dataFetchers.getPostById()) .dataFetcher(&quot;allPosts&quot;, dataFetchers.getAllPosts()) ) .type(&quot;Mutation&quot;, builder -&gt; builder.dataFetcher(&quot;createPost&quot;, dataFetchers.createPost())) .type(&quot;Post&quot;, builder -&gt; builder .dataFetcher(&quot;author&quot;, dataFetchers.authorOfPost()) .dataFetcher(&quot;comments&quot;, dataFetchers.commentsOfPost()) ) */ .codeRegistry(buildCodeRegistry(dataFetchers)) .scalar(Scalars.localDateTimeType()) .scalar(Scalars.uuidType()) .scalar(UploadScalar.build())// handling `Upload` scalar .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring()) .build(); } private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) { return GraphQLCodeRegistry.newCodeRegistry() .dataFetchers(&quot;Query&quot;, Map.of( &quot;postById&quot;, dataFetchers.getPostById(), &quot;allPosts&quot;, dataFetchers.getAllPosts() )) .dataFetchers(&quot;Mutation&quot;, Map.of( &quot;createPost&quot;, dataFetchers.createPost(), &quot;upload&quot;, dataFetchers.upload(), &quot;addComment&quot;, dataFetchers.addComment() )) .dataFetchers(&quot;Subscription&quot;, Map.of( &quot;commentAdded&quot;, dataFetchers.commentAdded() )) .dataFetchers(&quot;Post&quot;, Map.of( &quot;author&quot;, dataFetchers.authorOfPost(), &quot;comments&quot;, dataFetchers.commentsOfPost() )) //.typeResolver() //.fieldVisibility() .defaultDataFetcher(environment -&gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName())) .build(); } private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool; } } The start method is similar to the one in the previous posts, but here it enabled graphql-ws WebSocket sub protocol to activate GraphQL Subscription support. In the setupRoutes method, it adds the route /graphql to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via /graphql endpoint, also adds route /graphiql to activate GraphiQL interactive Web UI. As you see, the following is used to create a GraphQLHandler instance. GraphQLHandler.create(graphQL, options) .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders)) It requires a GraphQL instance and optional options to initialize a GraphQL instance. To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects: A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method. In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance. Let’s have a look at the graphql schema file under the main/resources/schema/schema.graphql folder. directive @uppercase on FIELD_DEFINITION scalar LocalDateTimescalar UUIDscalar Upload type Post { id: ID! title: String! @uppercase content: String comments: [Comment] status: PostStatus createdAt: LocalDateTime authorId: String author: Author} type Author { id: ID! name: String! email: String! createdAt: LocalDateTime posts: [Post]}type Comment { id: ID! content: String! createdAt: LocalDateTime postId: String!} input CreatePostInput { title: String! content: String!} input CommentInput { postId: String! content: String!} type Query { allPosts: [Post!]! postById(postId: String!): Post} type Mutation { createPost(createPostInput: CreatePostInput!): UUID! upload(file: Upload!): Boolean addComment(commentInput: CommentInput!): UUID!} type Subscription{ commentAdded: Comment!} enum PostStatus { DRAFT PENDING_MODERATION PUBLISHED} In this schema file, we declare 3 top level types: Query, Mutation and Subscription which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The scalar keyword defines custom scalar types. The directive defines custom directive @uppercase applied on field. In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions. For example, when performing a Query: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method. .dataFetchers(&quot;Query&quot;, Map.of( &quot;postById&quot;, dataFetchers.getPostById(), ... Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc. The following is an example of custom Scalar type. // LocalDateTimeScalarpublic class LocalDateTimeScalar implements Coercing&lt;LocalDateTime, String&gt; { @Override public String serialize(Object dataFetcherResult) throws CoercingSerializeException { if (dataFetcherResult instanceof LocalDateTime) { return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME); } else { throw new CoercingSerializeException(&quot;Not a valid DateTime&quot;); } } @Override public LocalDateTime parseValue(Object input) throws CoercingParseValueException { return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME); } @Override public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException { if (input instanceof StringValue) { return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME); } throw new CoercingParseLiteralException(&quot;Value is not a valid ISO date time&quot;); }}//Scalarspublic class Scalars { public static GraphQLScalarType localDateTimeType() { return GraphQLScalarType.newScalar() .name(&quot;LocalDateTime&quot;) .description(&quot;LocalDateTime type&quot;) .coercing(new LocalDateTimeScalar()) .build(); }} //register custom scalar type in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .scalar(Scalars.localDateTimeType()) Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself. Similarly register a custom Directive in the buildRuntimeWiring, eg. the @uppercase directive. //UpperCaseDirectiveWiringpublic class UpperCaseDirectiveWiring implements SchemaDirectiveWiring { @Override public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) { var field = env.getElement(); var parentType = env.getFieldsContainer(); var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field); var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher, (dataFetchingEnvironment, value) -&gt; { if (value instanceof String s) { return s.toUpperCase(); } return value; } ); env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher); return field; }}//register custom scalar directive in the MainVertcle buildRuntimeWiringnewRuntimeWiring() ... .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring()) Let’s move on to the data fetchers which are responsible for resolving the type values at runtime. For example, in the GraphiQL UI page, try to send a predefined query like this. query { allPosts{ id title content author{ name } comments{ content } }} It means, it will perform an allPosts Query, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field. When the GraphQL request is sent, GraphQLHandler will handle it. Validate the GraphQL request and ensure it follows schema type definitions.Locate the data fetchers via type coordinates, Query and allPosts.Assemble the returned values according to the request format.When resolving author field, it will try to locate Post and author to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles comments via dataFetchers.commentsOfPost().Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly. The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it. The file uploading is defined by GraphQL multipart request specification, not part of the standard GraphQL spec. The following is the data fetcher to handle the file uploading. public DataFetcher&lt;Boolean&gt; upload() { return (DataFetchingEnvironment dfe) -&gt; { FileUpload upload = dfe.getArgument(&quot;file&quot;); log.info(&quot;name: {}&quot;, upload.name()); log.info(&quot;file name: {}&quot;, upload.fileName()); log.info(&quot;uploaded file name: {}&quot;, upload.uploadedFileName()); log.info(&quot;content type: {}&quot;, upload.contentType()); log.info(&quot;charset: {}&quot;, upload.charSet()); log.info(&quot;size: {}&quot;, upload.size()); // String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString(); // log.info(&quot;file content: {}&quot;, fileContent); return true; };} Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system. For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type. The following is an example of sending notification when a comment is added. public VertxDataFetcher&lt;UUID&gt; addComment() { return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&gt; { var commentInputArg = dfe.getArgument(&quot;commentInput&quot;); var jacksonMapper = DatabindCodec.mapper(); var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class); return this.posts.addComment(input) .onSuccess(id -&gt; this.posts.getCommentById(id.toString()) .onSuccess(c -&gt; subject.onNext(c))); });} private ReplaySubject&lt;Comment&gt; subject = ReplaySubject.create(1); public DataFetcher&lt;Publisher&lt;Comment&gt;&gt; commentAdded() { return (DataFetchingEnvironment dfe) -&gt; { ApolloWSMessage message = dfe.getContext(); log.info(&quot;msg: {}, connectionParams: {}&quot;, message.content(), message.connectionParams()); ConnectableObservable&lt;Comment&gt; connectableObservable = subject.share().publish(); connectableObservable.connect(); log.info(&quot;connect to `commentAdded`&quot;); return connectableObservable.toFlowable(BackpressureStrategy.BUFFER); };} The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints. Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the complete sample codes from my Github and explore it yourself. Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java. To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about GraphQL over HTTP specification. The following is an example of testing allPosts query and createPost mutation using Vertx HttpClient. @ExtendWith(VertxExtension.class)@Slf4jpublic class TestMainVerticle { HttpClient client; @BeforeEach void setup(Vertx vertx, VertxTestContext testContext) { vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow())); var options = new HttpClientOptions() .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); client = vertx.createHttpClient(options); } @Test void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable { var query = &quot;&quot;&quot; query { allPosts{ id title content author{ name } comments{ content } } }&quot;&quot;&quot;; client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(Json.encode(Map.of(&quot;query&quot;, query)))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ) .onComplete( testContext.succeeding( buffer -&gt; testContext.verify( () -&gt; { log.info(&quot;buf: {}&quot;, buffer.toString()); JsonArray array = buffer.toJsonObject() .getJsonObject(&quot;data&quot;) .getJsonArray(&quot;allPosts&quot;); assertThat(array.size()).isGreaterThan(0); var titles = array.getList().stream().map(o -&gt; ((Map&lt;String, Object&gt;) o).get(&quot;title&quot;)).toList(); assertThat(titles).allMatch(s -&gt; ((String) s).startsWith(&quot;DGS POST&quot;)); testContext.completeNow(); } ) ) ); } @Test void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable { String TITLE = &quot;My post created by Vertx HttpClient&quot;; //var creatPostQuery = &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;; var creatPostQuery = &quot;&quot;&quot; mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input) }&quot;&quot;&quot;; client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; { String encodedJson = Json.encode(Map.of( &quot;query&quot;, creatPostQuery, &quot;variables&quot;, Map.of( &quot;input&quot;, Map.of( &quot;title&quot;, TITLE, &quot;content&quot;, &quot;content of my post&quot; ) ) )); log.info(&quot;sending encoded json: {}&quot;, encodedJson); return req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(encodedJson)//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body); } ) .flatMap(buf -&gt; { Object id = buf.toJsonObject().getJsonObject(&quot;data&quot;).getValue(&quot;createPost&quot;); log.info(&quot;created post: {}&quot;, id); assertThat(id).isNotNull(); var postById = &quot;&quot;&quot; query post($id:String!) { postById(postId:$id){id title content} }&quot;&quot;&quot;; return client.request(HttpMethod.POST, &quot;/graphql&quot;) .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) .putHeader(&quot;Accept&quot;, &quot;application/json&quot;) .send(Json.encode(Map.of( &quot;query&quot;, postById, &quot;variables&quot;, Map.of(&quot;id&quot;, id.toString()) )))//have to use Json.encode to convert objects to json string. .flatMap(HttpClientResponse::body) ); }) .onComplete( testContext.succeeding( buffer -&gt; testContext.verify( () -&gt; { log.info(&quot;buf: {}&quot;, buffer.toString()); String title = buffer.toJsonObject() .getJsonObject(&quot;data&quot;) .getJsonObject(&quot;postById&quot;) .getString(&quot;title&quot;); assertThat(title).isEqualTo(TITLE.toUpperCase()); testContext.completeNow(); } ) ) ); }} Get the sample codes from my Github. &lt;hr&gt;&lt;p&gt;Building GraphQL APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building GraphQL APIs with Eclipse Vertx","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-graphql-apis-with-eclipse-vertx/"},"url":"/blog/2021/building-graphql-apis-with-eclipse-vertx/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building GraphQL APIs with Eclipse Vertx</h1>
    <p class="post-meta">July 24, 2021</p>
  </header>

  <article class="post-content">
    <p>We have discussed GraphQL in a former <a href="https://itnext.io/building-graphql-apis-with-quarkus-dbbf23f897df">Quarkus GraphQL post</a>. In this post, we will explore the GraphQL support in Eclipse Vertx.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*m_nulmhV7cbLfrp0iAmbcg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@yangshuo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Yang Shuo</a> on <a href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><blockquote><em>Quarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature.</em></blockquote><p>Follow the steps in the <a href="https://itnext.io/building-restful-apis-with-eclipse-vertx-4ce89d8eeb74">Building RESTful APIs with Eclipse Vertx</a> and create a new Eclipse Vertx project, do not forget to add <em>GraphQL</em> into <strong>Dependencies</strong>.</p><p>Or add the following dependency into the existing <em>pom.xml</em> file directly.</p><pre>&lt;dependency&gt;<br>     &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>     &lt;artifactId&gt;vertx-web-graphql&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h4>Checkout the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql">complete sample codes from my Github</a>.</h4><p>Vertx provides a specific GraphQLHandler to handle GraphQL request from client.</p><p>Fill the MainVerticle with the following content.</p><pre>@Slf4j<br>public class MainVerticle extends AbstractVerticle {</pre><pre>    static {<br>        log.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;);<br>        var objectMapper = DatabindCodec.mapper();<br>        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>        objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br>        objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</pre><pre>        JavaTimeModule module = new JavaTimeModule();<br>        objectMapper.registerModule(module);<br>    }</pre><pre>    @Override<br>    public void start(Promise&lt;Void&gt; startPromise) throws Exception {<br>        log.info(&quot;Starting HTTP server...&quot;);<br>        //setupLogging();</pre><pre>        //Create a PgPool instance<br>        var pgPool = pgPool();</pre><pre>        // instantiate repos<br>        var postRepository = new PostRepository(pgPool);<br>        var commentRepository = new CommentRepository(pgPool);<br>        var authorRepository = new AuthorRepository(pgPool);</pre><pre>        // Initializing the sample data<br>        var initializer = new DataInitializer(postRepository, commentRepository, authorRepository);<br>        initializer.run();</pre><pre>        //assemble PostService<br>        var postService = new PostService(postRepository, commentRepository, authorRepository);<br>        var authorService = new AuthorService(authorRepository);</pre><pre>        // assemble DataLoaders<br>        var dataLoaders = new DataLoaders(authorService, postService);</pre><pre>        //assemble DataFetcher<br>        var dataFetchers = new DataFetchers(postService);</pre><pre>        // setup GraphQL<br>        GraphQL graphQL = setupGraphQLJava(dataFetchers);</pre><pre>        // Configure routes<br>        var router = setupRoutes(graphQL, dataLoaders);</pre><pre>        // enable GraphQL Websocket Protocol<br>        HttpServerOptions httpServerOptions = new HttpServerOptions()<br>            .addWebSocketSubProtocol(&quot;graphql-ws&quot;);<br>        // Create the HTTP server<br>        vertx.createHttpServer(httpServerOptions)<br>            // Handle every request using the router<br>            .requestHandler(router)<br>            // Start listening<br>            .listen(8080)<br>            // Print the port<br>            .onSuccess(server -&gt; {<br>                startPromise.complete();<br>                log.info(&quot;HTTP server started on port &quot; + server.actualPort());<br>            })<br>            .onFailure(event -&gt; {<br>                startPromise.fail(event);<br>                log.info(&quot;Failed to start HTTP server:&quot; + event.getMessage());<br>            })<br>        ;<br>    }</pre><pre>    //create routes<br>    private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) {</pre><pre>        // Create a Router<br>        Router router = Router.router(vertx);</pre><pre>        // register BodyHandler globally.<br>        router.route().handler(BodyHandler.create());</pre><pre>        // register GraphQL Subscription websocket handler.<br>        ApolloWSOptions apolloWSOptions = new ApolloWSOptions();<br>        router.route(&quot;/graphql&quot;).handler(<br>            ApolloWSHandler.create(graphQL, apolloWSOptions)<br>                .connectionInitHandler(connectionInitEvent -&gt; {<br>                    JsonObject payload = connectionInitEvent.message().content().getJsonObject(&quot;payload&quot;);<br>                    log.info(&quot;connection init event: {}&quot;, payload);<br>                    if (payload != null &amp;&amp; payload.containsKey(&quot;rejectMessage&quot;)) {<br>                        connectionInitEvent.fail(payload.getString(&quot;rejectMessage&quot;));<br>                        return;<br>                    }<br>                    connectionInitEvent.complete(payload);<br>                })<br>                //.connectionHandler(event -&gt; log.info(&quot;connection event: {}&quot;, event))<br>                //.messageHandler(msg -&gt; log.info(&quot;websocket message: {}&quot;, msg.content().toString()))<br>                //.endHandler(event -&gt; log.info(&quot;end event: {}&quot;, event))<br>        );</pre><pre>        GraphQLHandlerOptions options = new GraphQLHandlerOptions()<br>            // enable multipart for file upload.<br>            .setRequestMultipartEnabled(true)<br>            .setRequestBatchingEnabled(true);<br>        // register `/graphql` for GraphQL handler<br>        // alternatively, use `router.route()` to enable GET and POST http methods<br>        router.post(&quot;/graphql&quot;)<br>            .handler(<br>                GraphQLHandler.create(graphQL, options)<br>                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))<br>                //.locale()<br>                //.queryContext()<br>            );</pre><pre>        // register `/graphiql` endpoint for the GraphiQL UI<br>        GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions()<br>            .setEnabled(true);<br>        router.get(&quot;/graphiql/*&quot;).handler(GraphiQLHandler.create(graphiqlOptions));</pre><pre>        router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;));</pre><pre>        return router;<br>    }</pre><pre>    private Function&lt;RoutingContext, DataLoaderRegistry&gt; buildDataLoaderRegistry(DataLoaders dataLoaders) {<br>        DataLoaderRegistry registry = new DataLoaderRegistry();<br>        registry.register(&quot;commentsLoader&quot;, dataLoaders.commentsLoader());<br>        registry.register(&quot;authorsLoader&quot;, dataLoaders.authorsLoader());<br>        return rc -&gt; registry;<br>    }</pre><pre>    @SneakyThrows<br>    private GraphQL setupGraphQLJava(DataFetchers dataFetchers) {<br>        TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry();<br>        RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers);<br>        GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring);<br>        return buildGraphQL(graphQLSchema);<br>    }</pre><pre>    private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) {<br>        return GraphQL.newGraphQL(graphQLSchema)<br>            .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler())<br>            //.queryExecutionStrategy()<br>            //.mutationExecutionStrategy()<br>            //.subscriptionExecutionStrategy()<br>            //.instrumentation()<br>            .build();<br>    }</pre><pre>    private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) {<br>        SchemaGenerator schemaGenerator = new SchemaGenerator();<br>        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);<br>        return graphQLSchema;<br>    }</pre><pre>    private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException {<br>        var schema = Files.readString(Paths.get(getClass().getResource(&quot;/schema/schema.graphql&quot;).toURI()));<br>        //String schema = vertx.fileSystem().readFileBlocking(&quot;/schema/schema.graphql&quot;).toString();</pre><pre>        SchemaParser schemaParser = new SchemaParser();<br>        TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema);<br>        return typeDefinitionRegistry;<br>    }</pre><pre>    private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) {<br>        return newRuntimeWiring()<br>            // the following codes are moved to CodeRegistry, the central place to configure the execution codes.<br>            /*<br>            .wiringFactory(new WiringFactory() {<br>                @Override<br>                public DataFetcher&lt;Object&gt; getDefaultDataFetcher(FieldWiringEnvironment environment) {<br>                    return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());<br>                }<br>            })<br>            .type(&quot;Query&quot;, builder -&gt; builder<br>                .dataFetcher(&quot;postById&quot;, dataFetchers.getPostById())<br>                .dataFetcher(&quot;allPosts&quot;, dataFetchers.getAllPosts())<br>            )<br>            .type(&quot;Mutation&quot;, builder -&gt; builder.dataFetcher(&quot;createPost&quot;, dataFetchers.createPost()))<br>            .type(&quot;Post&quot;, builder -&gt; builder<br>                .dataFetcher(&quot;author&quot;, dataFetchers.authorOfPost())<br>                .dataFetcher(&quot;comments&quot;, dataFetchers.commentsOfPost())<br>            )<br>            */<br>            .codeRegistry(buildCodeRegistry(dataFetchers))<br>            .scalar(Scalars.localDateTimeType())<br>            .scalar(Scalars.uuidType())<br>            .scalar(UploadScalar.build())// handling `Upload` scalar<br>            .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring())<br>            .build();<br>    }</pre><pre>    private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) {<br>        return GraphQLCodeRegistry.newCodeRegistry()<br>            .dataFetchers(&quot;Query&quot;, Map.of(<br>                &quot;postById&quot;, dataFetchers.getPostById(),<br>                &quot;allPosts&quot;, dataFetchers.getAllPosts()<br>            ))<br>            .dataFetchers(&quot;Mutation&quot;, Map.of(<br>                &quot;createPost&quot;, dataFetchers.createPost(),<br>                &quot;upload&quot;, dataFetchers.upload(),<br>                &quot;addComment&quot;, dataFetchers.addComment()<br>            ))<br>            .dataFetchers(&quot;Subscription&quot;, Map.of(<br>                &quot;commentAdded&quot;, dataFetchers.commentAdded()<br>            ))<br>            .dataFetchers(&quot;Post&quot;, Map.of(<br>                &quot;author&quot;, dataFetchers.authorOfPost(),<br>                &quot;comments&quot;, dataFetchers.commentsOfPost()<br>            ))<br>            //.typeResolver()<br>            //.fieldVisibility()<br>            .defaultDataFetcher(environment -&gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()))<br>            .build();<br>    }</pre><pre>    private PgPool pgPool() {<br>        PgConnectOptions connectOptions = new PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;);</pre><pre>        // Pool Options<br>        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>        // Create the pool from the data object<br>        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>        return pool;<br>    }</pre><pre>}</pre><p>The start method is similar to the one in the previous posts, but here it enabled <em>graphql-ws</em> WebSocket sub protocol to activate GraphQL <em>Subscription</em> support.</p><p>In the <em>setupRoutes</em> method, it adds the route <em>/graphql</em> to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via <em>/graphql</em> endpoint, also adds route <em>/graphiql</em> to activate GraphiQL interactive Web UI.</p><p>As you see, the following is used to create a GraphQLHandler instance.</p><pre>GraphQLHandler.create(graphQL, options)<br>                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))</pre><p>It requires a GraphQL instance and optional options to initialize a GraphQL instance.</p><p>To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects:</p><ul><li>A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.</li><li>A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method.</li></ul><p>In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance.</p><p>Let’s have a look at the graphql schema file under the <em>main/resources/schema/schema.graphql</em> folder.</p><pre>directive @uppercase on FIELD_DEFINITION</pre><pre>scalar LocalDateTime<br>scalar UUID<br>scalar Upload</pre><pre>type Post {<br>    id: ID!<br>    title: String! @uppercase<br>    content: String<br>    comments: [Comment]<br>    status: PostStatus<br>    createdAt: LocalDateTime<br>    authorId: String<br>    author: Author<br>}</pre><pre>type Author {<br>    id: ID!<br>    name: String!<br>    email: String!<br>    createdAt: LocalDateTime<br>    posts: [Post]<br>}<br>type Comment {<br>    id: ID!<br>    content: String!<br>    createdAt: LocalDateTime<br>    postId: String!<br>}</pre><pre>input CreatePostInput {<br>    title: String!<br>    content: String!<br>}</pre><pre>input CommentInput {<br>    postId: String!<br>    content: String!<br>}</pre><pre>type Query {<br>    allPosts: [Post!]!<br>    postById(postId: String!): Post<br>}</pre><pre>type Mutation {<br>    createPost(createPostInput: CreatePostInput!): UUID!<br>    upload(file: Upload!): Boolean<br>    addComment(commentInput: CommentInput!): UUID!<br>}</pre><pre>type Subscription{<br>    commentAdded: Comment!<br>}</pre><pre>enum PostStatus {<br>    DRAFT<br>    PENDING_MODERATION<br>    PUBLISHED<br>}</pre><p>In this schema file, we declare 3 top level types: <em>Query</em>, <em>Mutation</em> and <em>Subscription</em> which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The <em>scalar</em> keyword defines custom scalar types. The <em>directive</em> defines custom directive <em>@uppercase</em> applied on field.</p><p>In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions.</p><p>For example, when performing a <em>Query</em>: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method.</p><pre>.dataFetchers(&quot;Query&quot;, Map.of(<br>                &quot;postById&quot;, dataFetchers.getPostById(),<br>    ...</pre><p>Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc.</p><p>The following is an example of custom Scalar type.</p><pre>// LocalDateTimeScalar<br>public class LocalDateTimeScalar implements Coercing&lt;LocalDateTime, String&gt; {<br>    @Override<br>    public String serialize(Object dataFetcherResult) throws CoercingSerializeException {<br>        if (dataFetcherResult instanceof LocalDateTime) {<br>            return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME);<br>        } else {<br>            throw new CoercingSerializeException(&quot;Not a valid DateTime&quot;);<br>        }<br>    }</pre><pre>    @Override<br>    public LocalDateTime parseValue(Object input) throws CoercingParseValueException {<br>        return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME);<br>    }</pre><pre>    @Override<br>    public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException {<br>        if (input instanceof StringValue) {<br>            return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME);<br>        }</pre><pre>        throw new CoercingParseLiteralException(&quot;Value is not a valid ISO date time&quot;);<br>    }<br>}<br>//Scalars<br>public class Scalars {</pre><pre>    public static GraphQLScalarType localDateTimeType() {<br>        return GraphQLScalarType.newScalar()<br>                .name(&quot;LocalDateTime&quot;)<br>                .description(&quot;LocalDateTime type&quot;)<br>                .coercing(new LocalDateTimeScalar())<br>                .build();<br>    }<br>}</pre><pre>//register custom scalar type in the MainVertcle buildRuntimeWiring<br>newRuntimeWiring()<br>    ...<br>    .scalar(Scalars.localDateTimeType())</pre><p>Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself.</p><p>Similarly register a custom <em>Directive</em> in the buildRuntimeWiring, eg. the @uppercase directive.</p><pre>//UpperCaseDirectiveWiring<br>public class UpperCaseDirectiveWiring implements SchemaDirectiveWiring {<br>    @Override<br>    public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) {</pre><pre>        var field = env.getElement();<br>        var parentType = env.getFieldsContainer();</pre><pre>        var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field);<br>        var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher,<br>                (dataFetchingEnvironment, value) -&gt; {<br>                    if (value instanceof String s) {<br>                        return s.toUpperCase();<br>                    }<br>                    return value;<br>                }<br>        );</pre><pre>        env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher);<br>        return field;<br>    }<br>}<br>//register custom scalar directive in the MainVertcle buildRuntimeWiring<br>newRuntimeWiring()<br>    ...<br>    .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring())</pre><p>Let’s move on to the data fetchers which are responsible for resolving the type values at runtime.</p><p>For example, in the GraphiQL UI page, try to send a predefined query like this.</p><pre>query {<br>    allPosts{<br>        id<br>        title<br>        content<br>        author{ name }<br>        comments{ content }<br>    }<br>}</pre><p>It means, it will perform an allPosts <em>Query</em>, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field.</p><p>When the GraphQL request is sent, GraphQLHandler will handle it.</p><ul><li>Validate the GraphQL request and ensure it follows schema type definitions.</li><li>Locate the data fetchers via type coordinates, <em>Query</em> and <em>allPosts</em>.</li><li>Assemble the returned values according to the request format.</li><li>When resolving author field, it will try to locate <em>Post</em> and <em>author</em> to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles <em>comments</em> via dataFetchers.commentsOfPost().</li><li>Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly.</li></ul><p>The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it.</p><p>The file uploading is defined by <a href="https://github.com/jaydenseric/graphql-multipart-request-spec">GraphQL multipart request specification</a>, not part of the standard GraphQL spec.</p><p>The following is the data fetcher to handle the file uploading.</p><pre>public DataFetcher&lt;Boolean&gt; upload() {<br>    return (DataFetchingEnvironment dfe) -&gt; {</pre><pre>        FileUpload upload = dfe.getArgument(&quot;file&quot;);<br>        log.info(&quot;name: {}&quot;, upload.name());<br>        log.info(&quot;file name: {}&quot;, upload.fileName());<br>        log.info(&quot;uploaded file name: {}&quot;, upload.uploadedFileName());<br>        log.info(&quot;content type: {}&quot;, upload.contentType());<br>        log.info(&quot;charset: {}&quot;, upload.charSet());<br>        log.info(&quot;size: {}&quot;, upload.size());<br>        //            String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString();<br>        //            log.info(&quot;file content: {}&quot;, fileContent);<br>        return true;<br>    };<br>}</pre><p>Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system.</p><p>For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type.</p><p>The following is an example of sending notification when a comment is added.</p><pre>public VertxDataFetcher&lt;UUID&gt; addComment() {<br>    return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&gt; {<br>        var commentInputArg = dfe.getArgument(&quot;commentInput&quot;);<br>        var jacksonMapper = DatabindCodec.mapper();<br>        var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class);<br>        return this.posts.addComment(input)<br>            .onSuccess(id -&gt; this.posts.getCommentById(id.toString())<br>                       .onSuccess(c -&gt; subject.onNext(c)));<br>    });<br>}</pre><pre>private ReplaySubject&lt;Comment&gt; subject = ReplaySubject.create(1);</pre><pre>public DataFetcher&lt;Publisher&lt;Comment&gt;&gt; commentAdded() {<br>    return (DataFetchingEnvironment dfe) -&gt; {<br>        ApolloWSMessage message = dfe.getContext();<br>        log.info(&quot;msg: {}, connectionParams: {}&quot;, message.content(), message.connectionParams());<br>        ConnectableObservable&lt;Comment&gt; connectableObservable = subject.share().publish();<br>        connectableObservable.connect();<br>        log.info(&quot;connect to `commentAdded`&quot;);<br>        return connectableObservable.toFlowable(BackpressureStrategy.BUFFER);<br>    };<br>}</pre><p>The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints.</p><p>Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql">complete sample codes from my Github</a> and explore it yourself.</p><p>Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java.</p><p>To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about <a href="https://graphql.org/learn/serving-over-http/">GraphQL over HTTP specification</a>.</p><p>The following is an example of testing <em>allPosts</em> query and <em>createPost</em> mutation using Vertx HttpClient.</p><pre>@ExtendWith(VertxExtension.class)<br>@Slf4j<br>public class TestMainVerticle {</pre><pre>    HttpClient client;</pre><pre>    @BeforeEach<br>    void setup(Vertx vertx, VertxTestContext testContext) {<br>        vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow()));<br>        var options = new HttpClientOptions()<br>            .setDefaultHost(&quot;localhost&quot;)<br>            .setDefaultPort(8080);<br>        client = vertx.createHttpClient(options);<br>    }</pre><pre>    @Test<br>    void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable {<br>        var query = &quot;&quot;&quot;<br>            query {<br>                allPosts{<br>                    id<br>                    title<br>                    content<br>                    author{ name }<br>                    comments{ content }<br>                }<br>            }&quot;&quot;&quot;;<br>        client.request(HttpMethod.POST, &quot;/graphql&quot;)<br>            .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                .putHeader(&quot;Accept&quot;, &quot;application/json&quot;)<br>                .send(Json.encode(Map.of(&quot;query&quot;, query)))//have to use Json.encode to convert objects to json string.<br>                .flatMap(HttpClientResponse::body)<br>            )<br>            .onComplete(<br>                testContext.succeeding(<br>                    buffer -&gt; testContext.verify(<br>                        () -&gt; {<br>                            log.info(&quot;buf: {}&quot;, buffer.toString());<br>                            JsonArray array = buffer.toJsonObject()<br>                                .getJsonObject(&quot;data&quot;)<br>                                .getJsonArray(&quot;allPosts&quot;);<br>                            assertThat(array.size()).isGreaterThan(0);</pre><pre>                            var titles = array.getList().stream().map(o -&gt; ((Map&lt;String, Object&gt;) o).get(&quot;title&quot;)).toList();<br>                            assertThat(titles).allMatch(s -&gt; ((String) s).startsWith(&quot;DGS POST&quot;));<br>                            testContext.completeNow();<br>                        }<br>                    )<br>                )<br>            );<br>    }</pre><pre>    @Test<br>    void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable {<br>        String TITLE = &quot;My post created by Vertx HttpClient&quot;;<br>        //var creatPostQuery = &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;;<br>        var creatPostQuery = &quot;&quot;&quot;<br>            mutation newPost($input:CreatePostInput!){<br>                createPost(createPostInput:$input)<br>            }&quot;&quot;&quot;;<br>        client.request(HttpMethod.POST, &quot;/graphql&quot;)<br>            .flatMap(req -&gt; {<br>                    String encodedJson = Json.encode(Map.of(<br>                        &quot;query&quot;, creatPostQuery,<br>                        &quot;variables&quot;, Map.of(<br>                            &quot;input&quot;, Map.of(<br>                                &quot;title&quot;, TITLE,<br>                                &quot;content&quot;, &quot;content of my post&quot;<br>                            )<br>                        )<br>                    ));<br>                    log.info(&quot;sending encoded json: {}&quot;, encodedJson);<br>                    return req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                        .putHeader(&quot;Accept&quot;, &quot;application/json&quot;)<br>                        .send(encodedJson)//have to use Json.encode to convert objects to json string.<br>                        .flatMap(HttpClientResponse::body);<br>                }<br>            )<br>            .flatMap(buf -&gt; {<br>                Object id = buf.toJsonObject().getJsonObject(&quot;data&quot;).getValue(&quot;createPost&quot;);</pre><pre>                log.info(&quot;created post: {}&quot;, id);<br>                assertThat(id).isNotNull();</pre><pre>                var postById = &quot;&quot;&quot;<br>                    query post($id:String!) {<br>                        postById(postId:$id){id title content}<br>                    }&quot;&quot;&quot;;</pre><pre>                return client.request(HttpMethod.POST, &quot;/graphql&quot;)<br>                    .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                        .putHeader(&quot;Accept&quot;, &quot;application/json&quot;)<br>                        .send(Json.encode(Map.of(<br>                            &quot;query&quot;, postById,<br>                            &quot;variables&quot;, Map.of(&quot;id&quot;, id.toString())<br>                        )))//have to use Json.encode to convert objects to json string.<br>                        .flatMap(HttpClientResponse::body)<br>                    );<br>            })<br>            .onComplete(<br>                testContext.succeeding(<br>                    buffer -&gt; testContext.verify(<br>                        () -&gt; {<br>                            log.info(&quot;buf: {}&quot;, buffer.toString());<br>                            String title = buffer.toJsonObject()<br>                                .getJsonObject(&quot;data&quot;)<br>                                .getJsonObject(&quot;postById&quot;)<br>                                .getString(&quot;title&quot;);<br>                            assertThat(title).isEqualTo(TITLE.toUpperCase());<br>                            testContext.completeNow();<br>                        }<br>                    )<br>                )<br>            );<br>    }<br>}</pre><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql">sample codes from my Github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2f3a4e584370" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-graphql-apis-with-eclipse-vertx-2f3a4e584370">Building GraphQL APIs with Eclipse Vertx</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
