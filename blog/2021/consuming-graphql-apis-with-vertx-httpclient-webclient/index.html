<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Consuming GraphQL APIs with Vertx HttpClient/WebClient
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/consuming-graphql-apis-with-vertx-httpclient-webclient/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Consuming GraphQL APIs with Vertx HttpClient/WebClient" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In a previous post, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in the last post. Photo by Sam Balye on Unsplash Firstly, let’s review the difference between the HttpClient and WebClient. The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient. Checkout the complete sample codes from my Github. Assume you have read the GraphQL over HTTP specification and GraphQL multipart request specification. Create a Eclipse Vertx project through the Eclipse Vertx Starter. In the start method of the MainVerticle class, create a WebClient object firstly. var options = new WebClientOptions() .setUserAgent(WebClientOptions.loadUserAgent()) .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); var client = WebClient.create(vertx, options); The following is an example sending a GraphQL request to retrieve all posts. client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&quot;, &quot;variables&quot;, Map.of() )) .onSuccess( data -&gt; log.info(&quot;data of allPosts: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); The request body format is like the following. { &quot;query&quot;: &quot;...&quot;, &quot;operationName&quot;: &quot;...&quot;, &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }} The query is accepting a Schema Definition Language in string. The operationName and variables are optional. And the response body is like. { &quot;data&quot;: &quot;...&quot;, &quot;errors&quot;: &quot;...&quot;} When an error occurs, data is empty, and errors will contains the error details to describe the error or exception. Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200. The following example is to demonstrate how to create a post and then retrieve the newly created post by id. client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;, &quot;variables&quot;, Map.of( &quot;input&quot;, Map.of(&quot;title&quot;, &quot;create post from WebClient&quot;, &quot;content&quot;, &quot;content of the new post&quot;) ) )) .onSuccess( data -&gt; { log.info(&quot;data of createPost: {}&quot;, data.bodyAsString()); var createdId = data.bodyAsJsonObject().getJsonObject(&quot;data&quot;).getString(&quot;createPost&quot;); // get the created post. getPostById(client, createdId); // add comment. addComment(client, createdId); } ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); //getPostByIdprivate void getPostById(WebClient client, String id) { client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&quot;, &quot;variables&quot;, Map.of( &quot;id&quot;, id ) )) .onSuccess( data -&gt; log.info(&quot;data of postByID: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); } Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (Subscription). private void addComment(WebClient client, String id) { // switch to HttpClient to handle WebSocket var options = new HttpClientOptions() .setWebSocketClosingTimeout(7200) .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); // see: https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java var httpClient = vertx.createHttpClient(options); httpClient.webSocket(&quot;/graphql&quot;) .onSuccess(ws -&gt; { ws.closeHandler(v -&gt; log.info(&quot;websocket is being closed&quot;)); ws.endHandler(v -&gt; log.info(&quot;websocket is being ended&quot;)); ws.exceptionHandler(e -&gt; log.info(&quot;catching websocket exception: {}&quot;, e.getMessage())); ws.textMessageHandler(text -&gt; { //log.info(&quot;websocket message handler:{}&quot;, text); JsonObject obj = new JsonObject(text); ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&quot;type&quot;)); if (type.equals(CONNECTION_KEEP_ALIVE)) { return;// do nothing when ka. } else if (type.equals(DATA)) { // handle the subscription `commentAdded` data. log.info(&quot;subscription commentAdded data: {}&quot;, obj.getJsonObject(&quot;payload&quot;).getJsonObject(&quot;data&quot;).getJsonObject(&quot;commentAdded&quot;)); } }); JsonObject messageInit = new JsonObject() .put(&quot;type&quot;, &quot;connection_init&quot;)//this is required to initialize a connection. .put(&quot;id&quot;, &quot;1&quot;); JsonObject message = new JsonObject() .put(&quot;payload&quot;, new JsonObject() .put(&quot;query&quot;, &quot;subscription onCommentAdded { commentAdded { id content } }&quot;)) .put(&quot;type&quot;, &quot;start&quot;) .put(&quot;id&quot;, &quot;1&quot;); ws.write(messageInit.toBuffer()); ws.write(message.toBuffer()); }) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); addCommentToPost(client, id); addCommentToPost(client, id); addCommentToPost(client, id);} In the above addComment method, we have switch to use HttpClient to handle WebSocket request. Firstly it opens a WebSocket connection to /graphql WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side. Let’s have a look at the file uploads. private void uploadFile(WebClient client) { Buffer fileBuf = vertx.fileSystem().readFileBlocking(&quot;test.txt&quot;); MultipartForm form = MultipartForm.create(); String query = &quot;&quot;&quot; mutation upload($file:Upload!){ upload(file:$file) } &quot;&quot;&quot;; var variables = new HashMap&lt;String, Object&gt;(); variables.put(&quot;file&quot;, null); form.attribute(&quot;operations&quot;, Json.encode(Map.of(&quot;query&quot;, query, &quot;variables&quot;, variables))); form.attribute(&quot;map&quot;, Json.encode(Map.of(&quot;file0&quot;, List.of(&quot;variables.file&quot;)))); form.textFileUpload(&quot;file0&quot;, &quot;test.txt&quot;, fileBuf, &quot;text/plain&quot;); client.post(&quot;/graphql&quot;) .sendMultipartForm(form) .onSuccess( data -&gt; log.info(&quot;data of upload: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));} As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API. Get the sample codes from my Github. &lt;hr&gt;&lt;p&gt;Consuming GraphQL APIs with Vertx HttpClient/WebClient was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In a previous post, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in the last post. Photo by Sam Balye on Unsplash Firstly, let’s review the difference between the HttpClient and WebClient. The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient. Checkout the complete sample codes from my Github. Assume you have read the GraphQL over HTTP specification and GraphQL multipart request specification. Create a Eclipse Vertx project through the Eclipse Vertx Starter. In the start method of the MainVerticle class, create a WebClient object firstly. var options = new WebClientOptions() .setUserAgent(WebClientOptions.loadUserAgent()) .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); var client = WebClient.create(vertx, options); The following is an example sending a GraphQL request to retrieve all posts. client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&quot;, &quot;variables&quot;, Map.of() )) .onSuccess( data -&gt; log.info(&quot;data of allPosts: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); The request body format is like the following. { &quot;query&quot;: &quot;...&quot;, &quot;operationName&quot;: &quot;...&quot;, &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }} The query is accepting a Schema Definition Language in string. The operationName and variables are optional. And the response body is like. { &quot;data&quot;: &quot;...&quot;, &quot;errors&quot;: &quot;...&quot;} When an error occurs, data is empty, and errors will contains the error details to describe the error or exception. Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200. The following example is to demonstrate how to create a post and then retrieve the newly created post by id. client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;, &quot;variables&quot;, Map.of( &quot;input&quot;, Map.of(&quot;title&quot;, &quot;create post from WebClient&quot;, &quot;content&quot;, &quot;content of the new post&quot;) ) )) .onSuccess( data -&gt; { log.info(&quot;data of createPost: {}&quot;, data.bodyAsString()); var createdId = data.bodyAsJsonObject().getJsonObject(&quot;data&quot;).getString(&quot;createPost&quot;); // get the created post. getPostById(client, createdId); // add comment. addComment(client, createdId); } ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); //getPostByIdprivate void getPostById(WebClient client, String id) { client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&quot;, &quot;variables&quot;, Map.of( &quot;id&quot;, id ) )) .onSuccess( data -&gt; log.info(&quot;data of postByID: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); } Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (Subscription). private void addComment(WebClient client, String id) { // switch to HttpClient to handle WebSocket var options = new HttpClientOptions() .setWebSocketClosingTimeout(7200) .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); // see: https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java var httpClient = vertx.createHttpClient(options); httpClient.webSocket(&quot;/graphql&quot;) .onSuccess(ws -&gt; { ws.closeHandler(v -&gt; log.info(&quot;websocket is being closed&quot;)); ws.endHandler(v -&gt; log.info(&quot;websocket is being ended&quot;)); ws.exceptionHandler(e -&gt; log.info(&quot;catching websocket exception: {}&quot;, e.getMessage())); ws.textMessageHandler(text -&gt; { //log.info(&quot;websocket message handler:{}&quot;, text); JsonObject obj = new JsonObject(text); ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&quot;type&quot;)); if (type.equals(CONNECTION_KEEP_ALIVE)) { return;// do nothing when ka. } else if (type.equals(DATA)) { // handle the subscription `commentAdded` data. log.info(&quot;subscription commentAdded data: {}&quot;, obj.getJsonObject(&quot;payload&quot;).getJsonObject(&quot;data&quot;).getJsonObject(&quot;commentAdded&quot;)); } }); JsonObject messageInit = new JsonObject() .put(&quot;type&quot;, &quot;connection_init&quot;)//this is required to initialize a connection. .put(&quot;id&quot;, &quot;1&quot;); JsonObject message = new JsonObject() .put(&quot;payload&quot;, new JsonObject() .put(&quot;query&quot;, &quot;subscription onCommentAdded { commentAdded { id content } }&quot;)) .put(&quot;type&quot;, &quot;start&quot;) .put(&quot;id&quot;, &quot;1&quot;); ws.write(messageInit.toBuffer()); ws.write(message.toBuffer()); }) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); addCommentToPost(client, id); addCommentToPost(client, id); addCommentToPost(client, id);} In the above addComment method, we have switch to use HttpClient to handle WebSocket request. Firstly it opens a WebSocket connection to /graphql WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side. Let’s have a look at the file uploads. private void uploadFile(WebClient client) { Buffer fileBuf = vertx.fileSystem().readFileBlocking(&quot;test.txt&quot;); MultipartForm form = MultipartForm.create(); String query = &quot;&quot;&quot; mutation upload($file:Upload!){ upload(file:$file) } &quot;&quot;&quot;; var variables = new HashMap&lt;String, Object&gt;(); variables.put(&quot;file&quot;, null); form.attribute(&quot;operations&quot;, Json.encode(Map.of(&quot;query&quot;, query, &quot;variables&quot;, variables))); form.attribute(&quot;map&quot;, Json.encode(Map.of(&quot;file0&quot;, List.of(&quot;variables.file&quot;)))); form.textFileUpload(&quot;file0&quot;, &quot;test.txt&quot;, fileBuf, &quot;text/plain&quot;); client.post(&quot;/graphql&quot;) .sendMultipartForm(form) .onSuccess( data -&gt; log.info(&quot;data of upload: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));} As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API. Get the sample codes from my Github. &lt;hr&gt;&lt;p&gt;Consuming GraphQL APIs with Vertx HttpClient/WebClient was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-24T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Consuming GraphQL APIs with Vertx HttpClient/WebClient" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-24T00:00:00+00:00","datePublished":"2021-07-24T00:00:00+00:00","description":"In a previous post, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in the last post. Photo by Sam Balye on Unsplash Firstly, let’s review the difference between the HttpClient and WebClient. The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient. Checkout the complete sample codes from my Github. Assume you have read the GraphQL over HTTP specification and GraphQL multipart request specification. Create a Eclipse Vertx project through the Eclipse Vertx Starter. In the start method of the MainVerticle class, create a WebClient object firstly. var options = new WebClientOptions() .setUserAgent(WebClientOptions.loadUserAgent()) .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); var client = WebClient.create(vertx, options); The following is an example sending a GraphQL request to retrieve all posts. client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&quot;, &quot;variables&quot;, Map.of() )) .onSuccess( data -&gt; log.info(&quot;data of allPosts: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); The request body format is like the following. { &quot;query&quot;: &quot;...&quot;, &quot;operationName&quot;: &quot;...&quot;, &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }} The query is accepting a Schema Definition Language in string. The operationName and variables are optional. And the response body is like. { &quot;data&quot;: &quot;...&quot;, &quot;errors&quot;: &quot;...&quot;} When an error occurs, data is empty, and errors will contains the error details to describe the error or exception. Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200. The following example is to demonstrate how to create a post and then retrieve the newly created post by id. client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;, &quot;variables&quot;, Map.of( &quot;input&quot;, Map.of(&quot;title&quot;, &quot;create post from WebClient&quot;, &quot;content&quot;, &quot;content of the new post&quot;) ) )) .onSuccess( data -&gt; { log.info(&quot;data of createPost: {}&quot;, data.bodyAsString()); var createdId = data.bodyAsJsonObject().getJsonObject(&quot;data&quot;).getString(&quot;createPost&quot;); // get the created post. getPostById(client, createdId); // add comment. addComment(client, createdId); } ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); //getPostByIdprivate void getPostById(WebClient client, String id) { client.post(&quot;/graphql&quot;) .sendJson(Map.of( &quot;query&quot;, &quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&quot;, &quot;variables&quot;, Map.of( &quot;id&quot;, id ) )) .onSuccess( data -&gt; log.info(&quot;data of postByID: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); } Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (Subscription). private void addComment(WebClient client, String id) { // switch to HttpClient to handle WebSocket var options = new HttpClientOptions() .setWebSocketClosingTimeout(7200) .setDefaultHost(&quot;localhost&quot;) .setDefaultPort(8080); // see: https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java var httpClient = vertx.createHttpClient(options); httpClient.webSocket(&quot;/graphql&quot;) .onSuccess(ws -&gt; { ws.closeHandler(v -&gt; log.info(&quot;websocket is being closed&quot;)); ws.endHandler(v -&gt; log.info(&quot;websocket is being ended&quot;)); ws.exceptionHandler(e -&gt; log.info(&quot;catching websocket exception: {}&quot;, e.getMessage())); ws.textMessageHandler(text -&gt; { //log.info(&quot;websocket message handler:{}&quot;, text); JsonObject obj = new JsonObject(text); ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&quot;type&quot;)); if (type.equals(CONNECTION_KEEP_ALIVE)) { return;// do nothing when ka. } else if (type.equals(DATA)) { // handle the subscription `commentAdded` data. log.info(&quot;subscription commentAdded data: {}&quot;, obj.getJsonObject(&quot;payload&quot;).getJsonObject(&quot;data&quot;).getJsonObject(&quot;commentAdded&quot;)); } }); JsonObject messageInit = new JsonObject() .put(&quot;type&quot;, &quot;connection_init&quot;)//this is required to initialize a connection. .put(&quot;id&quot;, &quot;1&quot;); JsonObject message = new JsonObject() .put(&quot;payload&quot;, new JsonObject() .put(&quot;query&quot;, &quot;subscription onCommentAdded { commentAdded { id content } }&quot;)) .put(&quot;type&quot;, &quot;start&quot;) .put(&quot;id&quot;, &quot;1&quot;); ws.write(messageInit.toBuffer()); ws.write(message.toBuffer()); }) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e)); addCommentToPost(client, id); addCommentToPost(client, id); addCommentToPost(client, id);} In the above addComment method, we have switch to use HttpClient to handle WebSocket request. Firstly it opens a WebSocket connection to /graphql WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side. Let’s have a look at the file uploads. private void uploadFile(WebClient client) { Buffer fileBuf = vertx.fileSystem().readFileBlocking(&quot;test.txt&quot;); MultipartForm form = MultipartForm.create(); String query = &quot;&quot;&quot; mutation upload($file:Upload!){ upload(file:$file) } &quot;&quot;&quot;; var variables = new HashMap&lt;String, Object&gt;(); variables.put(&quot;file&quot;, null); form.attribute(&quot;operations&quot;, Json.encode(Map.of(&quot;query&quot;, query, &quot;variables&quot;, variables))); form.attribute(&quot;map&quot;, Json.encode(Map.of(&quot;file0&quot;, List.of(&quot;variables.file&quot;)))); form.textFileUpload(&quot;file0&quot;, &quot;test.txt&quot;, fileBuf, &quot;text/plain&quot;); client.post(&quot;/graphql&quot;) .sendMultipartForm(form) .onSuccess( data -&gt; log.info(&quot;data of upload: {}&quot;, data.bodyAsString()) ) .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));} As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API. Get the sample codes from my Github. &lt;hr&gt;&lt;p&gt;Consuming GraphQL APIs with Vertx HttpClient/WebClient was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Consuming GraphQL APIs with Vertx HttpClient/WebClient","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/consuming-graphql-apis-with-vertx-httpclient-webclient/"},"url":"/blog/2021/consuming-graphql-apis-with-vertx-httpclient-webclient/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Consuming GraphQL APIs with Vertx HttpClient/WebClient</h1>
    <p class="post-meta">July 24, 2021</p>
  </header>

  <article class="post-content">
    <p>In <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/client">a previous post</a>, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/graphql.md">the last post</a>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jVl9u3hRpyj1g8ySAxcD3w.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@sambalye?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Sam Balye</a> on <a href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Firstly, let’s review the difference between the HttpClient and WebClient.</p><ul><li>The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.</li><li>The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient.</li></ul><h4>Checkout the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient">complete sample codes from my Github</a>.</h4><p>Assume you have read the <a href="https://graphql.org/learn/serving-over-http/">GraphQL over HTTP specification</a> and <a href="https://github.com/jaydenseric/graphql-multipart-request-spec">GraphQL multipart request specification</a>.</p><p>Create a Eclipse Vertx project through the <a href="https://start.vertx.io">Eclipse Vertx Starter</a>.</p><p>In the start method of the MainVerticle class, create a WebClient object firstly.</p><pre>var options = new WebClientOptions()<br>    .setUserAgent(WebClientOptions.loadUserAgent())<br>    .setDefaultHost(&quot;localhost&quot;)<br>    .setDefaultPort(8080);</pre><pre>var client = WebClient.create(vertx, options);</pre><p>The following is an example sending a GraphQL request to retrieve all posts.</p><pre>client.post(&quot;/graphql&quot;)<br>     .sendJson(Map.of(<br>         &quot;query&quot;, &quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&quot;,<br>         &quot;variables&quot;, Map.of()<br>     ))<br>     .onSuccess(<br>         data -&gt; log.info(&quot;data of allPosts: {}&quot;, data.bodyAsString())<br>     )<br>     .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));</pre><p>The request body format is like the following.</p><pre>{<br>  &quot;query&quot;: &quot;...&quot;,<br>  &quot;operationName&quot;: &quot;...&quot;,<br>  &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }<br>}</pre><p>The query is accepting a <em>Schema Definition Language</em> in string. The <em>operationName</em> and <em>variables</em> are optional.</p><p>And the response body is like.</p><pre>{<br>  &quot;data&quot;: &quot;...&quot;,<br>  &quot;errors&quot;: &quot;...&quot;<br>}</pre><p>When an error occurs, data is empty, and errors will contains the error details to describe the error or exception.</p><blockquote><em>Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200.</em></blockquote><p>The following example is to demonstrate how to create a post and then retrieve the newly created post by id.</p><pre>client.post(&quot;/graphql&quot;)<br>     .sendJson(Map.of(<br>         &quot;query&quot;, &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;,<br>         &quot;variables&quot;, Map.of(<br>             &quot;input&quot;, Map.of(&quot;title&quot;, &quot;create post from WebClient&quot;, &quot;content&quot;, &quot;content of the new post&quot;)<br>         )<br>     ))<br>     .onSuccess(<br>         data -&gt; {<br>             log.info(&quot;data of createPost: {}&quot;, data.bodyAsString());<br>             var createdId = data.bodyAsJsonObject().getJsonObject(&quot;data&quot;).getString(&quot;createPost&quot;);<br>             // get the created post.<br>             getPostById(client, createdId);<br>             // add comment.<br>             addComment(client, createdId);<br>         }<br>     )<br>     .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));</pre><pre>//getPostById<br>private void getPostById(WebClient client, String id) {<br>        client.post(&quot;/graphql&quot;)<br>            .sendJson(Map.of(<br>                &quot;query&quot;, &quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&quot;,<br>                &quot;variables&quot;, Map.of(<br>                    &quot;id&quot;, id<br>                )<br>            ))<br>            .onSuccess(<br>                data -&gt; log.info(&quot;data of postByID: {}&quot;, data.bodyAsString())<br>            )<br>            .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));<br>    }</pre><p>Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (<em>Subscription</em>).</p><pre>private void addComment(WebClient client, String id) {<br></pre><pre>    // switch to HttpClient to handle WebSocket<br>    var options = new HttpClientOptions()<br>        .setWebSocketClosingTimeout(7200)<br>        .setDefaultHost(&quot;localhost&quot;)<br>        .setDefaultPort(8080);</pre><pre>    // see: <a href="https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java">https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java</a><br>    var httpClient = vertx.createHttpClient(options);<br>    httpClient.webSocket(&quot;/graphql&quot;)<br>        .onSuccess(ws -&gt; {<br>            ws.closeHandler(v -&gt; log.info(&quot;websocket is being closed&quot;));<br>            ws.endHandler(v -&gt; log.info(&quot;websocket is being ended&quot;));<br>            ws.exceptionHandler(e -&gt; log.info(&quot;catching websocket exception: {}&quot;, e.getMessage()));</pre><pre>            ws.textMessageHandler(text -&gt; {<br>                //log.info(&quot;websocket message handler:{}&quot;, text);<br>                JsonObject obj = new JsonObject(text);<br>                ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&quot;type&quot;));<br>                if (type.equals(CONNECTION_KEEP_ALIVE)) {<br>                    return;// do nothing when ka.<br>                } else if (type.equals(DATA)) {<br>                    // handle the subscription `commentAdded` data.<br>                    log.info(&quot;subscription commentAdded data: {}&quot;, obj.getJsonObject(&quot;payload&quot;).getJsonObject(&quot;data&quot;).getJsonObject(&quot;commentAdded&quot;));<br>                }<br>            });</pre><pre>            JsonObject messageInit = new JsonObject()<br>                .put(&quot;type&quot;, &quot;connection_init&quot;)//this is required to initialize a connection.<br>                .put(&quot;id&quot;, &quot;1&quot;);</pre><pre>            JsonObject message = new JsonObject()<br>                .put(&quot;payload&quot;, new JsonObject()<br>                     .put(&quot;query&quot;, &quot;subscription onCommentAdded { commentAdded { id content } }&quot;))<br>                .put(&quot;type&quot;, &quot;start&quot;)<br>                .put(&quot;id&quot;, &quot;1&quot;);</pre><pre>            ws.write(messageInit.toBuffer());<br>            ws.write(message.toBuffer());<br>        })<br>        .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));</pre><pre>    addCommentToPost(client, id);<br>    addCommentToPost(client, id);<br>    addCommentToPost(client, id);<br>}</pre><p>In the above addComment method, we have switch to use HttpClient to handle WebSocket request.</p><p>Firstly it opens a WebSocket connection to <em>/graphql</em> WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side.</p><p>Let’s have a look at the file uploads.</p><pre>private void uploadFile(WebClient client) {<br>    Buffer fileBuf = vertx.fileSystem().readFileBlocking(&quot;test.txt&quot;);<br>    MultipartForm form = MultipartForm.create();<br>    String query = &quot;&quot;&quot;<br>        mutation upload($file:Upload!){<br>        upload(file:$file)<br>    }<br>    &quot;&quot;&quot;;<br>        var variables = new HashMap&lt;String, Object&gt;();<br>    variables.put(&quot;file&quot;, null);<br>    form.attribute(&quot;operations&quot;, Json.encode(Map.of(&quot;query&quot;, query, &quot;variables&quot;, variables)));<br>    form.attribute(&quot;map&quot;, Json.encode(Map.of(&quot;file0&quot;, List.of(&quot;variables.file&quot;))));<br>    form.textFileUpload(&quot;file0&quot;, &quot;test.txt&quot;, fileBuf, &quot;text/plain&quot;);</pre><pre>    client.post(&quot;/graphql&quot;)<br>        .sendMultipartForm(form)<br>        .onSuccess(<br>        data -&gt; log.info(&quot;data of upload: {}&quot;, data.bodyAsString())<br>    )<br>    .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));<br>}</pre><p>As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API.</p><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient">sample codes from my Github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=db410c410aa2" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/consuming-graphql-apis-with-vertx-httpclient-webclient-db410c410aa2">Consuming GraphQL APIs with Vertx HttpClient/WebClient</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
