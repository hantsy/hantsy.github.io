<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines. Photo by Gigi on Unsplash In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model. Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: KotlinBuild tool: Gradle KotlinTest framework: KotestIncluded Features: data-r2dbc, postgres, kotlin-extension-functions etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. Open pom.xml file, add Kotlin Coroutines into the project dependencies. //kotlin coroutinesimplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;)implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&quot;) The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API. Create an Entity mapped to a table in the database. @MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @AutoPopulated//generated value UUID does not work here. @field:Id var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()) Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database. Create a Repository interface for Post entity. @R2dbcRepository(dialect = Dialect.POSTGRES)interface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt; Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a suspend result in the functions. The @R2dbcRepository requires a dialect here, else it will fail at the application startup. Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post. Let’s move to the Controller, create a new controller class named PostController. @Controller(&quot;/posts&quot;)class PostController(private val posts: PostRepository) { @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll()) @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON]) suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; { val saved = posts.save(body) return created(URI.create(&quot;/posts/&quot; + saved.id)) }} It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context. Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent. @Singletonclass DataInitializer(private val posts: PostRepository) { @EventListener//does not support `suspend` fun onStartUp(e: ServerStartupEvent) { log.info(&quot;starting data initialization at StartUpEvent: $e&quot;) runBlocking { val deleteAll = posts.deleteAll() log.info(&quot;deleted posts: $deleteAll&quot;) val data = listOf( Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine&quot;, content = &quot;test&quot;), Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&quot;, content = &quot;test&quot;) ) data.forEach { log.debug(&quot;saving: $it&quot;) } posts.saveAll(data) .onEach { log.debug(&quot;saved post: $it&quot;) } .onCompletion { log.debug(&quot;completed.&quot;) } .flowOn(Dispatchers.IO) .launchIn(this); } log.info(&quot;data initialization is done...&quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) } } The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the suspend functions in sequence. JPA Criteria API Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines. Add jakarta-persistence-api into dependencies to provide JPA Criteria API. implementation(&quot;jakarta.persistence:jakarta.persistence-api:3.0.0&quot;) Let’s reuse Specifications we have created in the last post. Create a test to verify the criteria defined in the Specifications. @MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: R2dbcOperations) : StringSpec({ &quot;save and find posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; Mono.from( status.connection.createStatement(sql) .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .log() .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll().toList() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } } &quot;find by title&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; Mono.from( status.connection.createStatement(sql) .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)).toList() log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)).toList() log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } } &quot;find by keyword&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .add() statement.bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;DRAFT&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)).toList() log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)).toList() log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } } &quot;update posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;PENDING_MODERATED&quot;) .add() statement .bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;PENDING_MODERATED&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll().toList() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } } &quot;remove posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;REJECTED&quot;) .add() statement .bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;DRAFT&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll().toList() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } } }) { companion object { private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java) } override fun beforeEach(testCase: TestCase) { val sql = &quot;delete from posts&quot;; val latch = CountDownLatch(1) Mono .from( this.template.withConnection { conn: Connection -&gt; Mono.from(conn.beginTransaction()) .then(Mono.from(conn.createStatement(sql).execute()) .flatMap { Mono.from(it.rowsUpdated) } .doOnNext { log.debug(&quot;deleted rows: $it &quot;) } ) .then(Mono.from(conn.commitTransaction())) .doOnError { Mono.from(conn.rollbackTransaction()).then() } } ) .log() .doOnTerminate { latch.countDown() } .subscribe( { data -&gt; log.debug(&quot;deleted posts: $data &quot;) }, { error -&gt; log.error(&quot;error of cleaning posts: $error&quot;) }, { log.info(&quot;done&quot;) } ) latch.await(5000, TimeUnit.MILLISECONDS) }} We converted the existing Jdbc version to R2dbc, there are some mainly difference. Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.R2dbc Connection is based on ReactiveStreams API.When binding parameters to the SQL statement, the parameter indices start with 0.The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2... Testing Controller In this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context. The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies. //gradle.propertieskotlinCoVersion=1.6.0-RC //build.gradle.ktval kotlinCoVersion=project.properties.get(&quot;kotlinCoVersoin&quot;) //update versions of kotlin coroutinesimplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&quot;)implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&quot;) testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&quot;) There is an issue to use runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use runTest instead. Similar to the runBlocking, you can use runTest to wrap the testing functionality. @Testfun `test GET all posts endpoint with runTest`() = runTest { val response = client.exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java).awaitSingle() response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &quot;Micronaut&quot; }} The runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines. We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc. @MicronautTest(environments = [&quot;mock&quot;])class PostControllerTest( private val postRepository: PostRepository, @Client(&quot;/&quot;) private var client: HttpClient) : FunSpec({ test(&quot;test get posts endpoint&quot;) { val posts = getMock(postRepository) coEvery { posts.findAll() } .returns( flowOf( Post( id = UUID.randomUUID(), title = &quot;test title&quot;, content = &quot;test content&quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &quot;test title&quot; coVerify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun mockedPostRepository() = mockk&lt;PostRepository&gt;()} Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause. Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines. Photo by Gigi on Unsplash In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model. Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: KotlinBuild tool: Gradle KotlinTest framework: KotestIncluded Features: data-r2dbc, postgres, kotlin-extension-functions etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. Open pom.xml file, add Kotlin Coroutines into the project dependencies. //kotlin coroutinesimplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;)implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&quot;) The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API. Create an Entity mapped to a table in the database. @MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @AutoPopulated//generated value UUID does not work here. @field:Id var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()) Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database. Create a Repository interface for Post entity. @R2dbcRepository(dialect = Dialect.POSTGRES)interface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt; Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a suspend result in the functions. The @R2dbcRepository requires a dialect here, else it will fail at the application startup. Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post. Let’s move to the Controller, create a new controller class named PostController. @Controller(&quot;/posts&quot;)class PostController(private val posts: PostRepository) { @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll()) @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON]) suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; { val saved = posts.save(body) return created(URI.create(&quot;/posts/&quot; + saved.id)) }} It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context. Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent. @Singletonclass DataInitializer(private val posts: PostRepository) { @EventListener//does not support `suspend` fun onStartUp(e: ServerStartupEvent) { log.info(&quot;starting data initialization at StartUpEvent: $e&quot;) runBlocking { val deleteAll = posts.deleteAll() log.info(&quot;deleted posts: $deleteAll&quot;) val data = listOf( Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine&quot;, content = &quot;test&quot;), Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&quot;, content = &quot;test&quot;) ) data.forEach { log.debug(&quot;saving: $it&quot;) } posts.saveAll(data) .onEach { log.debug(&quot;saved post: $it&quot;) } .onCompletion { log.debug(&quot;completed.&quot;) } .flowOn(Dispatchers.IO) .launchIn(this); } log.info(&quot;data initialization is done...&quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) } } The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the suspend functions in sequence. JPA Criteria API Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines. Add jakarta-persistence-api into dependencies to provide JPA Criteria API. implementation(&quot;jakarta.persistence:jakarta.persistence-api:3.0.0&quot;) Let’s reuse Specifications we have created in the last post. Create a test to verify the criteria defined in the Specifications. @MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: R2dbcOperations) : StringSpec({ &quot;save and find posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; Mono.from( status.connection.createStatement(sql) .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .log() .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll().toList() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } } &quot;find by title&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; Mono.from( status.connection.createStatement(sql) .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)).toList() log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)).toList() log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } } &quot;find by keyword&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .add() statement.bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;DRAFT&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)).toList() log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)).toList() log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } } &quot;update posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;PENDING_MODERATED&quot;) .add() statement .bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;PENDING_MODERATED&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll().toList() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } } &quot;remove posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;REJECTED&quot;) .add() statement .bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;DRAFT&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll().toList() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } } }) { companion object { private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java) } override fun beforeEach(testCase: TestCase) { val sql = &quot;delete from posts&quot;; val latch = CountDownLatch(1) Mono .from( this.template.withConnection { conn: Connection -&gt; Mono.from(conn.beginTransaction()) .then(Mono.from(conn.createStatement(sql).execute()) .flatMap { Mono.from(it.rowsUpdated) } .doOnNext { log.debug(&quot;deleted rows: $it &quot;) } ) .then(Mono.from(conn.commitTransaction())) .doOnError { Mono.from(conn.rollbackTransaction()).then() } } ) .log() .doOnTerminate { latch.countDown() } .subscribe( { data -&gt; log.debug(&quot;deleted posts: $data &quot;) }, { error -&gt; log.error(&quot;error of cleaning posts: $error&quot;) }, { log.info(&quot;done&quot;) } ) latch.await(5000, TimeUnit.MILLISECONDS) }} We converted the existing Jdbc version to R2dbc, there are some mainly difference. Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.R2dbc Connection is based on ReactiveStreams API.When binding parameters to the SQL statement, the parameter indices start with 0.The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2... Testing Controller In this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context. The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies. //gradle.propertieskotlinCoVersion=1.6.0-RC //build.gradle.ktval kotlinCoVersion=project.properties.get(&quot;kotlinCoVersoin&quot;) //update versions of kotlin coroutinesimplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&quot;)implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&quot;) testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&quot;) There is an issue to use runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use runTest instead. Similar to the runBlocking, you can use runTest to wrap the testing functionality. @Testfun `test GET all posts endpoint with runTest`() = runTest { val response = client.exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java).awaitSingle() response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &quot;Micronaut&quot; }} The runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines. We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc. @MicronautTest(environments = [&quot;mock&quot;])class PostControllerTest( private val postRepository: PostRepository, @Client(&quot;/&quot;) private var client: HttpClient) : FunSpec({ test(&quot;test get posts endpoint&quot;) { val posts = getMock(postRepository) coEvery { posts.findAll() } .returns( flowOf( Post( id = UUID.randomUUID(), title = &quot;test title&quot;, content = &quot;test content&quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &quot;test title&quot; coVerify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun mockedPostRepository() = mockk&lt;PostRepository&gt;()} Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause. Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-08T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-12-08T00:00:00+00:00","datePublished":"2021-12-08T00:00:00+00:00","description":"In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines. Photo by Gigi on Unsplash In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model. Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: KotlinBuild tool: Gradle KotlinTest framework: KotestIncluded Features: data-r2dbc, postgres, kotlin-extension-functions etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. Open pom.xml file, add Kotlin Coroutines into the project dependencies. //kotlin coroutinesimplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;)implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&quot;) The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API. Create an Entity mapped to a table in the database. @MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)data class Post( @AutoPopulated//generated value UUID does not work here. @field:Id var id: UUID? = null, var title: String, var content: String, var status: Status? = Status.DRAFT, @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()) Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database. Create a Repository interface for Post entity. @R2dbcRepository(dialect = Dialect.POSTGRES)interface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt; Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a suspend result in the functions. The @R2dbcRepository requires a dialect here, else it will fail at the application startup. Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post. Let’s move to the Controller, create a new controller class named PostController. @Controller(&quot;/posts&quot;)class PostController(private val posts: PostRepository) { @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON]) fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll()) @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON]) suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; { val post = posts.findById(id) ?: return notFound() return ok(post) } @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON]) suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; { val saved = posts.save(body) return created(URI.create(&quot;/posts/&quot; + saved.id)) }} It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context. Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent. @Singletonclass DataInitializer(private val posts: PostRepository) { @EventListener//does not support `suspend` fun onStartUp(e: ServerStartupEvent) { log.info(&quot;starting data initialization at StartUpEvent: $e&quot;) runBlocking { val deleteAll = posts.deleteAll() log.info(&quot;deleted posts: $deleteAll&quot;) val data = listOf( Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine&quot;, content = &quot;test&quot;), Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&quot;, content = &quot;test&quot;) ) data.forEach { log.debug(&quot;saving: $it&quot;) } posts.saveAll(data) .onEach { log.debug(&quot;saved post: $it&quot;) } .onCompletion { log.debug(&quot;completed.&quot;) } .flowOn(Dispatchers.IO) .launchIn(this); } log.info(&quot;data initialization is done...&quot;) } companion object DataInitializer { private val log = LoggerFactory.getLogger(DataInitializer::class.java) } } The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the suspend functions in sequence. JPA Criteria API Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines. Add jakarta-persistence-api into dependencies to provide JPA Criteria API. implementation(&quot;jakarta.persistence:jakarta.persistence-api:3.0.0&quot;) Let’s reuse Specifications we have created in the last post. Create a test to verify the criteria defined in the Specifications. @MicronautTest(environments = [Environment.TEST], startApplication = false)class PostRepositoryTest( private val posts: PostRepository, private val template: R2dbcOperations) : StringSpec({ &quot;save and find posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; Mono.from( status.connection.createStatement(sql) .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .log() .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll().toList() all shouldHaveSize 1 log.debug(&quot;all posts: $all&quot;) all.map { it.title }.forAny { it shouldContain &quot;test&quot; } } } &quot;find by title&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Mono .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; Mono.from( status.connection.createStatement(sql) .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .execute() ).flatMap { Mono.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)).toList() log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 1 val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)).toList() log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 0 } } &quot;find by keyword&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;DRAFT&quot;) .add() statement.bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;DRAFT&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)).toList() log.debug(&quot;all posts size:{}&quot;, all.size) all shouldHaveSize 2 val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)).toList() log.debug(&quot;all2 posts size:{}&quot;, all2.size) all2 shouldHaveSize 1 } } &quot;update posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;PENDING_MODERATED&quot;) .add() statement .bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;PENDING_MODERATED&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val updated = posts.updateAll(Specifications.rejectAllPendingModerated()) log.debug(&quot;updated posts size:{}&quot;, updated) updated shouldBe 2 val all = posts.findAll().toList() all shouldHaveSize 2 all.map { it.status }.forAny { it shouldBe Status.REJECTED } } } &quot;remove posts&quot; { val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;; Flux .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt; val statement = status.connection.createStatement(sql) statement .bind(0, &quot;test title&quot;) .bind(1, &quot;test content&quot;) .bind(2, &quot;REJECTED&quot;) .add() statement .bind(0, &quot;test2 title&quot;) .bind(1, &quot;test2 content&quot;) .bind(2, &quot;DRAFT&quot;) .add() Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) } }) .`as` { StepVerifier.create(it) } .consumeNextWith { it shouldBeEqualComparingTo 1 } .consumeNextWith { it shouldBeEqualComparingTo 1 } .verifyComplete() runBlocking { val deleted = posts.deleteAll(Specifications.removeAllRejected()) log.debug(&quot;deleted posts size:{}&quot;, deleted) deleted shouldBe 1 val all = posts.findAll().toList() all shouldHaveSize 1 all.map { it.status }.forAny { it shouldBe Status.DRAFT } } } }) { companion object { private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java) } override fun beforeEach(testCase: TestCase) { val sql = &quot;delete from posts&quot;; val latch = CountDownLatch(1) Mono .from( this.template.withConnection { conn: Connection -&gt; Mono.from(conn.beginTransaction()) .then(Mono.from(conn.createStatement(sql).execute()) .flatMap { Mono.from(it.rowsUpdated) } .doOnNext { log.debug(&quot;deleted rows: $it &quot;) } ) .then(Mono.from(conn.commitTransaction())) .doOnError { Mono.from(conn.rollbackTransaction()).then() } } ) .log() .doOnTerminate { latch.countDown() } .subscribe( { data -&gt; log.debug(&quot;deleted posts: $data &quot;) }, { error -&gt; log.error(&quot;error of cleaning posts: $error&quot;) }, { log.info(&quot;done&quot;) } ) latch.await(5000, TimeUnit.MILLISECONDS) }} We converted the existing Jdbc version to R2dbc, there are some mainly difference. Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.R2dbc Connection is based on ReactiveStreams API.When binding parameters to the SQL statement, the parameter indices start with 0.The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2... Testing Controller In this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context. The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies. //gradle.propertieskotlinCoVersion=1.6.0-RC //build.gradle.ktval kotlinCoVersion=project.properties.get(&quot;kotlinCoVersoin&quot;) //update versions of kotlin coroutinesimplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&quot;)implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&quot;) testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&quot;) There is an issue to use runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use runTest instead. Similar to the runBlocking, you can use runTest to wrap the testing functionality. @Testfun `test GET all posts endpoint with runTest`() = runTest { val response = client.exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java).awaitSingle() response.status shouldBe HttpStatus.OK response.body()!!.map { it.title }.forAny { it shouldContain &quot;Micronaut&quot; }} The runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines. We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc. @MicronautTest(environments = [&quot;mock&quot;])class PostControllerTest( private val postRepository: PostRepository, @Client(&quot;/&quot;) private var client: HttpClient) : FunSpec({ test(&quot;test get posts endpoint&quot;) { val posts = getMock(postRepository) coEvery { posts.findAll() } .returns( flowOf( Post( id = UUID.randomUUID(), title = &quot;test title&quot;, content = &quot;test content&quot;, status = Status.DRAFT, createdAt = LocalDateTime.now() ) ) ) val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java) response.status shouldBe HttpStatus.OK response.body()!![0].title shouldBe &quot;test title&quot; coVerify(exactly = 1) { posts.findAll() } }}) { @MockBean(PostRepository::class) fun mockedPostRepository() = mockk&lt;PostRepository&gt;()} Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause. Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines/"},"url":"/blog/2021/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines</h1>
    <p class="post-meta">December 8, 2021</p>
  </header>

  <article class="post-content">
    <p>In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qU5tVqVsr_jHM71udRktIw.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@ling_gigi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Gigi</a> on <a href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model.</p><h3>Getting Started</h3><p>Open your browser and navigate to <a href="https://micronaut.io/launch">Micronaut Launch</a> to generate a new project skeleton for this post. Select the following items on this page.</p><ul><li>Java version: <strong>17</strong></li><li>Language: <strong>Kotlin</strong></li><li>Build tool: <strong>Gradle Kotlin</strong></li><li>Test framework: <strong>Kotest</strong></li><li>Included Features: <strong>data-r2dbc</strong>, <strong>postgres</strong>, <strong>kotlin-extension-functions</strong> etc.</li></ul><p>Click <strong>GENERATE PROJECT</strong> button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p><p>Open <em>pom.xml</em> file, add Kotlin Coroutines into the project dependencies.</p><pre>//kotlin coroutines<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;)<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&quot;)</pre><p>The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API.</p><p>Create an Entity mapped to a table in the database.</p><pre>@MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)<br>data class Post(<br>    @AutoPopulated//generated value UUID does not work here.<br>    @field:Id var id: UUID? = null,<br>    var title: String,<br>    var content: String,<br>    var status: Status? = Status.DRAFT,<br>    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()<br>)</pre><p>Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database.</p><p>Create a Repository interface for Post entity.</p><pre>@R2dbcRepository(dialect = Dialect.POSTGRES)<br>interface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt;</pre><p>Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a <em>suspend</em> result in the functions.</p><blockquote><em>The </em><em>@R2dbcRepository requires a </em><em>dialect here, else it will fail at the application startup.</em></blockquote><p>Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post.</p><p>Let’s move to the Controller, create a new controller class named PostController.</p><pre>@Controller(&quot;/posts&quot;)<br>class PostController(private val posts: PostRepository) {</pre><pre>    @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON])<br>    fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll())</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON])<br>    suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {<br>        val post = posts.findById(id) ?: return notFound()<br>        return ok(post)<br>    }</pre><pre>    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])<br>    suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; {<br>        val saved = posts.save(body)<br>        return created(URI.create(&quot;/posts/&quot; + saved.id))<br>    }<br>}</pre><p>It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context.</p><p>Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent.</p><pre>@Singleton<br>class DataInitializer(private val posts: PostRepository) {</pre><pre>    @EventListener//does not support `suspend`<br>    fun onStartUp(e: ServerStartupEvent) {<br>        log.info(&quot;starting data initialization at StartUpEvent: $e&quot;)</pre><pre>        runBlocking {<br>            val deleteAll = posts.deleteAll()<br>            log.info(&quot;deleted posts: $deleteAll&quot;)</pre><pre>            val data = listOf(<br>                Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine&quot;, content = &quot;test&quot;),<br>                Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&quot;, content = &quot;test&quot;)<br>            )<br>            data.forEach { log.debug(&quot;saving: $it&quot;) }<br>            posts.saveAll(data)<br>                .onEach { log.debug(&quot;saved post: $it&quot;) }<br>                .onCompletion { log.debug(&quot;completed.&quot;) }<br>                .flowOn(Dispatchers.IO)<br>                .launchIn(this);<br>        }</pre><pre>        log.info(&quot;data initialization is done...&quot;)<br>    }</pre><pre>    companion object DataInitializer {<br>        private val log = LoggerFactory.getLogger(DataInitializer::class.java)<br>    }</pre><pre>}</pre><p>The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the <em>suspend</em> functions in sequence.</p><h3>JPA Criteria API</h3><p>Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines.</p><p>Add jakarta-persistence-api into dependencies to provide JPA Criteria API.</p><pre>implementation(&quot;jakarta.persistence:jakarta.persistence-api:3.0.0&quot;)</pre><p>Let’s reuse Specifications we have created in the last post.</p><p>Create a test to verify the criteria defined in the Specifications.</p><pre>@MicronautTest(environments = [Environment.TEST], startApplication = false)<br>class PostRepositoryTest(<br>    private val posts: PostRepository,<br>    private val template: R2dbcOperations<br>) : StringSpec({</pre><pre>    &quot;save and find posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Mono<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                Mono.from(<br>                    status.connection.createStatement(sql)<br>                        .bind(0, &quot;test title&quot;)<br>                        .bind(1, &quot;test content&quot;)<br>                        .bind(2, &quot;DRAFT&quot;)<br>                        .execute()<br>                ).flatMap { Mono.from(it.rowsUpdated) }<br>            })<br>            .log()<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val all = posts.findAll().toList()<br>            all shouldHaveSize 1<br>            log.debug(&quot;all posts: $all&quot;)<br>            all.map { it.title }.forAny { it shouldContain &quot;test&quot; }<br>        }</pre><pre>    }</pre><pre>    &quot;find by title&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Mono<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                Mono.from(<br>                    status.connection.createStatement(sql)<br>                        .bind(0, &quot;test title&quot;)<br>                        .bind(1, &quot;test content&quot;)<br>                        .bind(2, &quot;DRAFT&quot;)<br>                        .execute()<br>                ).flatMap { Mono.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)).toList()<br>            log.debug(&quot;all posts size:{}&quot;, all.size)<br>            all shouldHaveSize 1</pre><pre>            val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)).toList()<br>            log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>            all2 shouldHaveSize 0<br>        }</pre><pre>    }</pre><pre>    &quot;find by keyword&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Flux<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                val statement = status.connection.createStatement(sql)<br>                statement<br>                    .bind(0, &quot;test title&quot;)<br>                    .bind(1, &quot;test content&quot;)<br>                    .bind(2, &quot;DRAFT&quot;)<br>                    .add()<br>                statement.bind(0, &quot;test2 title&quot;)<br>                    .bind(1, &quot;test2 content&quot;)<br>                    .bind(2, &quot;DRAFT&quot;)<br>                    .add()</pre><pre>                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)).toList()<br>            log.debug(&quot;all posts size:{}&quot;, all.size)<br>            all shouldHaveSize 2</pre><pre>            val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)).toList()<br>            log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>            all2 shouldHaveSize 1<br>        }<br>    }</pre><pre>    &quot;update posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Flux<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                val statement = status.connection.createStatement(sql)<br>                statement<br>                    .bind(0, &quot;test title&quot;)<br>                    .bind(1, &quot;test content&quot;)<br>                    .bind(2, &quot;PENDING_MODERATED&quot;)<br>                    .add()</pre><pre>                statement<br>                    .bind(0, &quot;test2 title&quot;)<br>                    .bind(1, &quot;test2 content&quot;)<br>                    .bind(2, &quot;PENDING_MODERATED&quot;)<br>                    .add()</pre><pre>                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br>            log.debug(&quot;updated posts size:{}&quot;, updated)<br>            updated shouldBe 2</pre><pre>            val all = posts.findAll().toList()<br>            all shouldHaveSize 2<br>            all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br>        }<br>    }</pre><pre>    &quot;remove posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Flux<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                val statement = status.connection.createStatement(sql)<br>                statement<br>                    .bind(0, &quot;test title&quot;)<br>                    .bind(1, &quot;test content&quot;)<br>                    .bind(2, &quot;REJECTED&quot;)<br>                    .add()<br>                statement<br>                    .bind(0, &quot;test2 title&quot;)<br>                    .bind(1, &quot;test2 content&quot;)<br>                    .bind(2, &quot;DRAFT&quot;)<br>                    .add()</pre><pre>                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val deleted = posts.deleteAll(Specifications.removeAllRejected())<br>            log.debug(&quot;deleted posts size:{}&quot;, deleted)<br>            deleted shouldBe 1</pre><pre>            val all = posts.findAll().toList()<br>            all shouldHaveSize 1<br>            all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br>        }<br>    }</pre><pre>}) {<br>    companion object {<br>        private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java)<br>    }</pre><pre>    override fun beforeEach(testCase: TestCase) {<br>        val sql = &quot;delete from posts&quot;;</pre><pre>        val latch = CountDownLatch(1)<br>        Mono<br>            .from(<br>                this.template.withConnection { conn: Connection -&gt;<br>                    Mono.from(conn.beginTransaction())<br>                        .then(Mono.from(conn.createStatement(sql).execute())<br>                            .flatMap { Mono.from(it.rowsUpdated) }<br>                            .doOnNext { log.debug(&quot;deleted rows: $it &quot;) }<br>                        )<br>                        .then(Mono.from(conn.commitTransaction()))<br>                        .doOnError { Mono.from(conn.rollbackTransaction()).then() }<br>                }<br>            )<br>            .log()<br>            .doOnTerminate { latch.countDown() }<br>            .subscribe(<br>                { data -&gt; log.debug(&quot;deleted posts: $data &quot;) },<br>                { error -&gt; log.error(&quot;error of cleaning posts: $error&quot;) },<br>                { log.info(&quot;done&quot;) }<br>            )</pre><pre>        latch.await(5000, TimeUnit.MILLISECONDS)<br>    }<br>}</pre><p>We converted the existing Jdbc version to R2dbc, there are some mainly difference.</p><ul><li>Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.</li><li>R2dbc Connection is based on ReactiveStreams API.</li><li>When binding parameters to the SQL statement, the parameter indices start with <strong>0</strong>.</li><li>The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2...</li></ul><h3>Testing Controller</h3><p>In this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context.</p><p>The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies.</p><pre>//gradle.properties<br>kotlinCoVersion=1.6.0-RC</pre><pre>//build.gradle.kt<br>val kotlinCoVersion=project.properties.get(&quot;kotlinCoVersoin&quot;)</pre><pre>//update versions of kotlin coroutines<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&quot;)<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&quot;)</pre><pre>testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&quot;)</pre><blockquote><em>There is </em><a href="https://stackoverflow.com/questions/70243380/test-kotlin-coroutines-with-runblockingtest-failed"><em>an issue</em></a><em> to use </em><em>runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use </em><em>runTest instead.</em></blockquote><p>Similar to the runBlocking, you can use runTest to wrap the testing functionality.</p><pre>@Test<br>fun `test GET all posts endpoint with runTest`() = runTest {<br>    val response = client.exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java).awaitSingle()<br>    response.status shouldBe HttpStatus.OK<br>    response.body()!!.map { it.title }.forAny {<br>        it shouldContain &quot;Micronaut&quot;<br>    }<br>}</pre><blockquote><em>The </em><em>runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines.</em></blockquote><p>We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc.</p><pre>@MicronautTest(environments = [&quot;mock&quot;])<br>class PostControllerTest(<br>    private val postRepository: PostRepository,<br>    @Client(&quot;/&quot;) private var client: HttpClient<br>) : FunSpec({</pre><pre>    test(&quot;test get posts endpoint&quot;) {<br>        val posts = getMock(postRepository)<br>        coEvery { posts.findAll() }<br>            .returns(<br>                flowOf(<br>                    Post(<br>                        id = UUID.randomUUID(),<br>                        title = &quot;test title&quot;,<br>                        content = &quot;test content&quot;,<br>                        status = Status.DRAFT,<br>                        createdAt = LocalDateTime.now()<br>                    )<br>                )<br>            )<br>        val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java)</pre><pre>        response.status shouldBe HttpStatus.OK<br>        response.body()!![0].title shouldBe &quot;test title&quot;</pre><pre>        coVerify(exactly = 1) { posts.findAll() }<br>    }<br>}) {<br>    @MockBean(PostRepository::class)<br>    fun mockedPostRepository() = mockk&lt;PostRepository&gt;()<br>}</pre><p>Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause.</p><h4>Get the complete <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/r2dbc-kotlin-co">source codes</a> from my Github.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a1416db5a7d0" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines-a1416db5a7d0">Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
