<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building RESTful APIs with Eclipse Vertx
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-restful-apis-with-eclipse-vertx/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building RESTful APIs with Eclipse Vertx" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post, we will explore how to build a simple RESTful example application with Eclipse Vertx and reactive Postgres Client. Photo by Sam Beasley on Unsplash Unlike other frameworks in which reactive is an addition to the existing features, Eclipse Vertx is born for reactive applications, read the official introduction guide to get know the reactive support in Vertx . Similar to the Spring Boot intializr, Eclipse Vertx also provides a scaffold tool to generate the project skeleton for you. Open your browser, navigate to the Vertx Starter page. In the Dependencies field, select Vertx Web, Reactive PostgreSQL Client, and optionally expand the Advance options and select the latest Java version(at the moment it is 16). Leave others options as they are, it will use the default values, then hit Generate Project button to generate the project into an archive for downloading. Download the project archive, and extract the files into local disc, and import into your IDEs, eg. Intellij IDEA. Open the pom.xml. As you see, it uses maven-shade-plugin to package the built results into a fat jar, and the Main-Class is the Vertx built-in io.vertx.core.Launcher. When running the application via java -jar target\xxx.jar , it will use the Launcher to deploy the declared MainVerticle . A Verticle is a Vertx specific deployment unit to group the resources, such as Network, HTTP, etc. Let’s move to the MainVerticle class. public class MainVerticle extends AbstractVerticle { } Generally , to code our business logic, you just need to override the start() method or start(Promise&lt;Void&gt; startPromise). In our application, we will start a HTTP Server to serve the HTTP requests. Replace the content of the start(Promise&lt;Void&gt; startPromise) method with the following. // Create the HTTP serververtx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onSuccess(server -&gt; { startPromise.complete(); System.out.println(&quot;HTTP server started on port &quot; + server.actualPort()); }) .onFailure(event -&gt; { startPromise.fail(event); System.out.println(&quot;Failed to start HTTP server:&quot; + event.getMessage()); }); The request handling work is done by the above .requestHandler(Handler&lt;HttpServerRequest&gt;). The Router is a specific Handler&lt;HttpServerRequest&gt; which simplifies the handling HTTP requests and allows chaining a sequence of handlers. Add a reoutes method to handle requests of all routes in a central place, it returns the router. //create routesprivate Router routes(PostsHandler handlers) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;).handler(handlers::all); router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::save); router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;).handler(handlers::get).failureHandler(frc -&gt; frc.response().setStatusCode(404).end()); router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::update); router.delete(&quot;/posts/:id&quot;).handler(handlers::delete); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router;} For post and put HTTP methods, the BodyHandler is required to handling consuming the HTTP request body. Extract all handing details into a new PostHandler class. class PostsHandler { private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName()); PostRepository posts; private PostsHandler(PostRepository _posts) { this.posts = _posts; } //factory method public static PostsHandler create(PostRepository posts) { return new PostsHandler(posts); } public void all(RoutingContext rc) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); this.posts.findAll() .onSuccess( data -&gt; rc.response().end(Json.encode(data)) ); } public void get(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); this.posts.findById(UUID.fromString(id)) .onSuccess( post -&gt; rc.response().end(Json.encode(post)) ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } public void save(RoutingContext rc) { //rc.getBodyAsJson().mapTo(PostForm.class) var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body); var form = body.mapTo(PostForm.class); this.posts.save(Post.of(form.getTitle(), form.getContent())) .onSuccess( savedId -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId) .setStatusCode(201) .end() ); } public void update(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body}); var form = body.mapTo(PostForm.class); this.posts.findById(UUID.fromString(id)) .compose( post -&gt; { post.setTitle(form.getTitle()); post.setContent(form.getContent()); return this.posts.update(post); } ) .onSuccess( data -&gt; rc.response().setStatusCode(204).end() ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } public void delete(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var uuid = UUID.fromString(id); this.posts.findById(uuid) .compose( post -&gt; this.posts.deleteById(uuid) ) .onSuccess( data -&gt; rc.response().setStatusCode(204).end() ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } } From the RoutingContext, it is easy to read the request params etc. PostRepository is responsible for interacting with your backend database Postgres, when the database operation is done, then send result to the HTTP response through RoutingContext.response(). Let’s have a look at the PostRepository class. public class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private static Function&lt;Row, Post&gt; MAPPER = (row) -&gt; Post.of( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ); private final PgPool client; private PostRepository(PgPool _client) { this.client = _client; } //factory method public static PostRepository create(PgPool client) { return new PostRepository(client); } public Future&lt;List&lt;Post&gt;&gt; findAll() { return client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map(rs -&gt; StreamSupport.stream(rs.spliterator(), false) .map(MAPPER) .collect(Collectors.toList()) ); } public Future&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map(RowSet::iterator) .map(iterator -&gt; iterator.hasNext() ? MAPPER.apply(iterator.next()) : null) .map(Optional::ofNullable) .map(p -&gt; p.orElseThrow(() -&gt; new PostNotFoundException(id))); } public Future&lt;UUID&gt; save(Post data) { return client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;).execute(Tuple.of(data.getTitle(), data.getContent())) .map(rs -&gt; rs.iterator().next().getUUID(&quot;id&quot;)); } public Future&lt;Integer&gt; saveAll(List&lt;Post&gt; data) { var tuples = data.stream() .map( d -&gt; Tuple.of(d.getTitle(), d.getContent()) ) .collect(Collectors.toList()); return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map(SqlResult::rowCount); } public Future&lt;Integer&gt; update(Post data) { return client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.getTitle(), data.getContent(), data.getId())) .map(SqlResult::rowCount); } public Future&lt;Integer&gt; deleteAll() { return client.query(&quot;DELETE FROM posts&quot;).execute() .map(SqlResult::rowCount); } public Future&lt;Integer&gt; deleteById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map(SqlResult::rowCount); } } The pgPool is a Postgres client to interact with the Postgres database, the operations are very similar to the traditional JDBC, but it is based on the Vertx&#39;s Future API. Similar to Java 8 CompletionStage or Reactor Mono /Flux, Vertx Future provides very limited APIs for producing, transforming and observing the completed result in an asynchronous mode. More details about the Reactive PostgreSQL Client, read PostgreSQL Client docs. In Vertx, almost all async methods provide a variant of accepting a Promise like callback as parameter instead of return a Future instance. But personally I think the Promise is evil if the handling progress is passed into a sequence of transitions, thus the Promise will nest another Promise, and so on. It will put you in an infinite Promise hole. Create a method in the MainVerticle to produce a PgPool instance. private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool;} Create a class to initialize some sample data. public class DataInitializer { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private PgPool client; public DataInitializer(PgPool client) { this.client = client; } public static DataInitializer create(PgPool client) { return new DataInitializer(client); } public void run() { LOGGER.info(&quot;Data initialization is starting...&quot;); Tuple first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;); Tuple second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;); client .withTransaction( conn -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute() .flatMap(r -&gt; conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(List.of(first, second)) ) .flatMap(r -&gt; conn.query(&quot;SELECT * FROM posts&quot;).execute()) ) .onSuccess(data -&gt; StreamSupport.stream(data.spliterator(), true) .forEach(row -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, new Object[]{row.toJson()})) ) .onComplete( r -&gt; { //client.close(); will block the application. LOGGER.info(&quot;Data initialization is done...&quot;); } ) .onFailure( throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage()) ); }} In the above codes, use the withTransaction method to wrap a series of database operations in a single transaction. Let’s assemble all the resources in the MainVerticle&#39;s start method. @Overridepublic void start(Promise&lt;Void&gt; startPromise) throws Exception { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); //Creating PostRepository var postRepository = PostRepository.create(pgPool); //Creating PostHandler var postHandlers = PostsHandler.create(postRepository); // Initializing the sample data var initializer = DataInitializer.create(pgPool); initializer.run(); // Configure routes var router = routes(postHandlers); // Create the HTTP server vertx.createHttpServer() // Handle every request using the router .requestHandler(router) ...} By default Vertx Web uses Jackson to serialize and deserialize the request/response payload. Unfortunately it does not register a Java DateTime module by default. Add the following dependencies in the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt;&lt;/dependency&gt; Add a jackson.version property to the properties section. &lt;jackson.version&gt;2.11.3&lt;/jackson.version&gt; Then add a static block to configure DateTime serialization and deserialization in the MainVerticle class. static { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module);} Let’s start the application. Simply fetch the source codes, it provides a docker compose file. Run the following command to start a Postgres instance in Docker container. docker compose postgres It will prepare the essential tables through the initial scripts when the database is starting. Now switch to the project folder, run the following command to start the application. mvn clean compile exec:java Or build the project firstly, and run the final jar file. mvn clean packagejava -jar target/demo.jar After the application is started, open a terminal, and use curl to test the /posts endpoints. curl http://localhost:8888/posts -H &quot;Accept: application/json&quot;[{&quot;id&quot;:&quot;1f99032b-3bb0-4795-ba9f-b0437b59cfbe&quot;,&quot;title&quot;:&quot;Hello Quarkus&quot;,&quot;content&quot;:&quot;My first post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;},{&quot;id&quot;:&quot;adda9ca6-2c4c-4223-9cb6-b8407c15ba03&quot;,&quot;title&quot;:&quot;Hello Again, Quarkus&quot;,&quot;content&quot;:&quot;My second post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;}] Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building RESTful APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In this post, we will explore how to build a simple RESTful example application with Eclipse Vertx and reactive Postgres Client. Photo by Sam Beasley on Unsplash Unlike other frameworks in which reactive is an addition to the existing features, Eclipse Vertx is born for reactive applications, read the official introduction guide to get know the reactive support in Vertx . Similar to the Spring Boot intializr, Eclipse Vertx also provides a scaffold tool to generate the project skeleton for you. Open your browser, navigate to the Vertx Starter page. In the Dependencies field, select Vertx Web, Reactive PostgreSQL Client, and optionally expand the Advance options and select the latest Java version(at the moment it is 16). Leave others options as they are, it will use the default values, then hit Generate Project button to generate the project into an archive for downloading. Download the project archive, and extract the files into local disc, and import into your IDEs, eg. Intellij IDEA. Open the pom.xml. As you see, it uses maven-shade-plugin to package the built results into a fat jar, and the Main-Class is the Vertx built-in io.vertx.core.Launcher. When running the application via java -jar target\xxx.jar , it will use the Launcher to deploy the declared MainVerticle . A Verticle is a Vertx specific deployment unit to group the resources, such as Network, HTTP, etc. Let’s move to the MainVerticle class. public class MainVerticle extends AbstractVerticle { } Generally , to code our business logic, you just need to override the start() method or start(Promise&lt;Void&gt; startPromise). In our application, we will start a HTTP Server to serve the HTTP requests. Replace the content of the start(Promise&lt;Void&gt; startPromise) method with the following. // Create the HTTP serververtx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onSuccess(server -&gt; { startPromise.complete(); System.out.println(&quot;HTTP server started on port &quot; + server.actualPort()); }) .onFailure(event -&gt; { startPromise.fail(event); System.out.println(&quot;Failed to start HTTP server:&quot; + event.getMessage()); }); The request handling work is done by the above .requestHandler(Handler&lt;HttpServerRequest&gt;). The Router is a specific Handler&lt;HttpServerRequest&gt; which simplifies the handling HTTP requests and allows chaining a sequence of handlers. Add a reoutes method to handle requests of all routes in a central place, it returns the router. //create routesprivate Router routes(PostsHandler handlers) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;).handler(handlers::all); router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::save); router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;).handler(handlers::get).failureHandler(frc -&gt; frc.response().setStatusCode(404).end()); router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::update); router.delete(&quot;/posts/:id&quot;).handler(handlers::delete); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router;} For post and put HTTP methods, the BodyHandler is required to handling consuming the HTTP request body. Extract all handing details into a new PostHandler class. class PostsHandler { private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName()); PostRepository posts; private PostsHandler(PostRepository _posts) { this.posts = _posts; } //factory method public static PostsHandler create(PostRepository posts) { return new PostsHandler(posts); } public void all(RoutingContext rc) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); this.posts.findAll() .onSuccess( data -&gt; rc.response().end(Json.encode(data)) ); } public void get(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); this.posts.findById(UUID.fromString(id)) .onSuccess( post -&gt; rc.response().end(Json.encode(post)) ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } public void save(RoutingContext rc) { //rc.getBodyAsJson().mapTo(PostForm.class) var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body); var form = body.mapTo(PostForm.class); this.posts.save(Post.of(form.getTitle(), form.getContent())) .onSuccess( savedId -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId) .setStatusCode(201) .end() ); } public void update(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body}); var form = body.mapTo(PostForm.class); this.posts.findById(UUID.fromString(id)) .compose( post -&gt; { post.setTitle(form.getTitle()); post.setContent(form.getContent()); return this.posts.update(post); } ) .onSuccess( data -&gt; rc.response().setStatusCode(204).end() ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } public void delete(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var uuid = UUID.fromString(id); this.posts.findById(uuid) .compose( post -&gt; this.posts.deleteById(uuid) ) .onSuccess( data -&gt; rc.response().setStatusCode(204).end() ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } } From the RoutingContext, it is easy to read the request params etc. PostRepository is responsible for interacting with your backend database Postgres, when the database operation is done, then send result to the HTTP response through RoutingContext.response(). Let’s have a look at the PostRepository class. public class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private static Function&lt;Row, Post&gt; MAPPER = (row) -&gt; Post.of( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ); private final PgPool client; private PostRepository(PgPool _client) { this.client = _client; } //factory method public static PostRepository create(PgPool client) { return new PostRepository(client); } public Future&lt;List&lt;Post&gt;&gt; findAll() { return client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map(rs -&gt; StreamSupport.stream(rs.spliterator(), false) .map(MAPPER) .collect(Collectors.toList()) ); } public Future&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map(RowSet::iterator) .map(iterator -&gt; iterator.hasNext() ? MAPPER.apply(iterator.next()) : null) .map(Optional::ofNullable) .map(p -&gt; p.orElseThrow(() -&gt; new PostNotFoundException(id))); } public Future&lt;UUID&gt; save(Post data) { return client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;).execute(Tuple.of(data.getTitle(), data.getContent())) .map(rs -&gt; rs.iterator().next().getUUID(&quot;id&quot;)); } public Future&lt;Integer&gt; saveAll(List&lt;Post&gt; data) { var tuples = data.stream() .map( d -&gt; Tuple.of(d.getTitle(), d.getContent()) ) .collect(Collectors.toList()); return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map(SqlResult::rowCount); } public Future&lt;Integer&gt; update(Post data) { return client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.getTitle(), data.getContent(), data.getId())) .map(SqlResult::rowCount); } public Future&lt;Integer&gt; deleteAll() { return client.query(&quot;DELETE FROM posts&quot;).execute() .map(SqlResult::rowCount); } public Future&lt;Integer&gt; deleteById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map(SqlResult::rowCount); } } The pgPool is a Postgres client to interact with the Postgres database, the operations are very similar to the traditional JDBC, but it is based on the Vertx&#39;s Future API. Similar to Java 8 CompletionStage or Reactor Mono /Flux, Vertx Future provides very limited APIs for producing, transforming and observing the completed result in an asynchronous mode. More details about the Reactive PostgreSQL Client, read PostgreSQL Client docs. In Vertx, almost all async methods provide a variant of accepting a Promise like callback as parameter instead of return a Future instance. But personally I think the Promise is evil if the handling progress is passed into a sequence of transitions, thus the Promise will nest another Promise, and so on. It will put you in an infinite Promise hole. Create a method in the MainVerticle to produce a PgPool instance. private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool;} Create a class to initialize some sample data. public class DataInitializer { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private PgPool client; public DataInitializer(PgPool client) { this.client = client; } public static DataInitializer create(PgPool client) { return new DataInitializer(client); } public void run() { LOGGER.info(&quot;Data initialization is starting...&quot;); Tuple first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;); Tuple second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;); client .withTransaction( conn -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute() .flatMap(r -&gt; conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(List.of(first, second)) ) .flatMap(r -&gt; conn.query(&quot;SELECT * FROM posts&quot;).execute()) ) .onSuccess(data -&gt; StreamSupport.stream(data.spliterator(), true) .forEach(row -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, new Object[]{row.toJson()})) ) .onComplete( r -&gt; { //client.close(); will block the application. LOGGER.info(&quot;Data initialization is done...&quot;); } ) .onFailure( throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage()) ); }} In the above codes, use the withTransaction method to wrap a series of database operations in a single transaction. Let’s assemble all the resources in the MainVerticle&#39;s start method. @Overridepublic void start(Promise&lt;Void&gt; startPromise) throws Exception { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); //Creating PostRepository var postRepository = PostRepository.create(pgPool); //Creating PostHandler var postHandlers = PostsHandler.create(postRepository); // Initializing the sample data var initializer = DataInitializer.create(pgPool); initializer.run(); // Configure routes var router = routes(postHandlers); // Create the HTTP server vertx.createHttpServer() // Handle every request using the router .requestHandler(router) ...} By default Vertx Web uses Jackson to serialize and deserialize the request/response payload. Unfortunately it does not register a Java DateTime module by default. Add the following dependencies in the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt;&lt;/dependency&gt; Add a jackson.version property to the properties section. &lt;jackson.version&gt;2.11.3&lt;/jackson.version&gt; Then add a static block to configure DateTime serialization and deserialization in the MainVerticle class. static { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module);} Let’s start the application. Simply fetch the source codes, it provides a docker compose file. Run the following command to start a Postgres instance in Docker container. docker compose postgres It will prepare the essential tables through the initial scripts when the database is starting. Now switch to the project folder, run the following command to start the application. mvn clean compile exec:java Or build the project firstly, and run the final jar file. mvn clean packagejava -jar target/demo.jar After the application is started, open a terminal, and use curl to test the /posts endpoints. curl http://localhost:8888/posts -H &quot;Accept: application/json&quot;[{&quot;id&quot;:&quot;1f99032b-3bb0-4795-ba9f-b0437b59cfbe&quot;,&quot;title&quot;:&quot;Hello Quarkus&quot;,&quot;content&quot;:&quot;My first post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;},{&quot;id&quot;:&quot;adda9ca6-2c4c-4223-9cb6-b8407c15ba03&quot;,&quot;title&quot;:&quot;Hello Again, Quarkus&quot;,&quot;content&quot;:&quot;My second post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;}] Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building RESTful APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building RESTful APIs with Eclipse Vertx" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-02T00:00:00+00:00","datePublished":"2021-07-02T00:00:00+00:00","description":"In this post, we will explore how to build a simple RESTful example application with Eclipse Vertx and reactive Postgres Client. Photo by Sam Beasley on Unsplash Unlike other frameworks in which reactive is an addition to the existing features, Eclipse Vertx is born for reactive applications, read the official introduction guide to get know the reactive support in Vertx . Similar to the Spring Boot intializr, Eclipse Vertx also provides a scaffold tool to generate the project skeleton for you. Open your browser, navigate to the Vertx Starter page. In the Dependencies field, select Vertx Web, Reactive PostgreSQL Client, and optionally expand the Advance options and select the latest Java version(at the moment it is 16). Leave others options as they are, it will use the default values, then hit Generate Project button to generate the project into an archive for downloading. Download the project archive, and extract the files into local disc, and import into your IDEs, eg. Intellij IDEA. Open the pom.xml. As you see, it uses maven-shade-plugin to package the built results into a fat jar, and the Main-Class is the Vertx built-in io.vertx.core.Launcher. When running the application via java -jar target\\xxx.jar , it will use the Launcher to deploy the declared MainVerticle . A Verticle is a Vertx specific deployment unit to group the resources, such as Network, HTTP, etc. Let’s move to the MainVerticle class. public class MainVerticle extends AbstractVerticle { } Generally , to code our business logic, you just need to override the start() method or start(Promise&lt;Void&gt; startPromise). In our application, we will start a HTTP Server to serve the HTTP requests. Replace the content of the start(Promise&lt;Void&gt; startPromise) method with the following. // Create the HTTP serververtx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onSuccess(server -&gt; { startPromise.complete(); System.out.println(&quot;HTTP server started on port &quot; + server.actualPort()); }) .onFailure(event -&gt; { startPromise.fail(event); System.out.println(&quot;Failed to start HTTP server:&quot; + event.getMessage()); }); The request handling work is done by the above .requestHandler(Handler&lt;HttpServerRequest&gt;). The Router is a specific Handler&lt;HttpServerRequest&gt; which simplifies the handling HTTP requests and allows chaining a sequence of handlers. Add a reoutes method to handle requests of all routes in a central place, it returns the router. //create routesprivate Router routes(PostsHandler handlers) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;).handler(handlers::all); router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::save); router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;).handler(handlers::get).failureHandler(frc -&gt; frc.response().setStatusCode(404).end()); router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::update); router.delete(&quot;/posts/:id&quot;).handler(handlers::delete); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router;} For post and put HTTP methods, the BodyHandler is required to handling consuming the HTTP request body. Extract all handing details into a new PostHandler class. class PostsHandler { private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName()); PostRepository posts; private PostsHandler(PostRepository _posts) { this.posts = _posts; } //factory method public static PostsHandler create(PostRepository posts) { return new PostsHandler(posts); } public void all(RoutingContext rc) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); this.posts.findAll() .onSuccess( data -&gt; rc.response().end(Json.encode(data)) ); } public void get(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); this.posts.findById(UUID.fromString(id)) .onSuccess( post -&gt; rc.response().end(Json.encode(post)) ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } public void save(RoutingContext rc) { //rc.getBodyAsJson().mapTo(PostForm.class) var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body); var form = body.mapTo(PostForm.class); this.posts.save(Post.of(form.getTitle(), form.getContent())) .onSuccess( savedId -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId) .setStatusCode(201) .end() ); } public void update(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;\\npath param id: {0}\\nrequest body: {1}&quot;, new Object[]{id, body}); var form = body.mapTo(PostForm.class); this.posts.findById(UUID.fromString(id)) .compose( post -&gt; { post.setTitle(form.getTitle()); post.setContent(form.getContent()); return this.posts.update(post); } ) .onSuccess( data -&gt; rc.response().setStatusCode(204).end() ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } public void delete(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var uuid = UUID.fromString(id); this.posts.findById(uuid) .compose( post -&gt; this.posts.deleteById(uuid) ) .onSuccess( data -&gt; rc.response().setStatusCode(204).end() ) .onFailure( throwable -&gt; rc.fail(404, throwable) ); } } From the RoutingContext, it is easy to read the request params etc. PostRepository is responsible for interacting with your backend database Postgres, when the database operation is done, then send result to the HTTP response through RoutingContext.response(). Let’s have a look at the PostRepository class. public class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private static Function&lt;Row, Post&gt; MAPPER = (row) -&gt; Post.of( row.getUUID(&quot;id&quot;), row.getString(&quot;title&quot;), row.getString(&quot;content&quot;), row.getLocalDateTime(&quot;created_at&quot;) ); private final PgPool client; private PostRepository(PgPool _client) { this.client = _client; } //factory method public static PostRepository create(PgPool client) { return new PostRepository(client); } public Future&lt;List&lt;Post&gt;&gt; findAll() { return client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;) .execute() .map(rs -&gt; StreamSupport.stream(rs.spliterator(), false) .map(MAPPER) .collect(Collectors.toList()) ); } public Future&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map(RowSet::iterator) .map(iterator -&gt; iterator.hasNext() ? MAPPER.apply(iterator.next()) : null) .map(Optional::ofNullable) .map(p -&gt; p.orElseThrow(() -&gt; new PostNotFoundException(id))); } public Future&lt;UUID&gt; save(Post data) { return client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;).execute(Tuple.of(data.getTitle(), data.getContent())) .map(rs -&gt; rs.iterator().next().getUUID(&quot;id&quot;)); } public Future&lt;Integer&gt; saveAll(List&lt;Post&gt; data) { var tuples = data.stream() .map( d -&gt; Tuple.of(d.getTitle(), d.getContent()) ) .collect(Collectors.toList()); return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(tuples) .map(SqlResult::rowCount); } public Future&lt;Integer&gt; update(Post data) { return client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;) .execute(Tuple.of(data.getTitle(), data.getContent(), data.getId())) .map(SqlResult::rowCount); } public Future&lt;Integer&gt; deleteAll() { return client.query(&quot;DELETE FROM posts&quot;).execute() .map(SqlResult::rowCount); } public Future&lt;Integer&gt; deleteById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id)) .map(SqlResult::rowCount); } } The pgPool is a Postgres client to interact with the Postgres database, the operations are very similar to the traditional JDBC, but it is based on the Vertx&#39;s Future API. Similar to Java 8 CompletionStage or Reactor Mono /Flux, Vertx Future provides very limited APIs for producing, transforming and observing the completed result in an asynchronous mode. More details about the Reactive PostgreSQL Client, read PostgreSQL Client docs. In Vertx, almost all async methods provide a variant of accepting a Promise like callback as parameter instead of return a Future instance. But personally I think the Promise is evil if the handling progress is passed into a sequence of transitions, thus the Promise will nest another Promise, and so on. It will put you in an infinite Promise hole. Create a method in the MainVerticle to produce a PgPool instance. private PgPool pgPool() { PgConnectOptions connectOptions = new PgConnectOptions() .setPort(5432) .setHost(&quot;localhost&quot;) .setDatabase(&quot;blogdb&quot;) .setUser(&quot;user&quot;) .setPassword(&quot;password&quot;); // Pool Options PoolOptions poolOptions = new PoolOptions().setMaxSize(5); // Create the pool from the data object PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions); return pool;} Create a class to initialize some sample data. public class DataInitializer { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private PgPool client; public DataInitializer(PgPool client) { this.client = client; } public static DataInitializer create(PgPool client) { return new DataInitializer(client); } public void run() { LOGGER.info(&quot;Data initialization is starting...&quot;); Tuple first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;); Tuple second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;); client .withTransaction( conn -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute() .flatMap(r -&gt; conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;) .executeBatch(List.of(first, second)) ) .flatMap(r -&gt; conn.query(&quot;SELECT * FROM posts&quot;).execute()) ) .onSuccess(data -&gt; StreamSupport.stream(data.spliterator(), true) .forEach(row -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, new Object[]{row.toJson()})) ) .onComplete( r -&gt; { //client.close(); will block the application. LOGGER.info(&quot;Data initialization is done...&quot;); } ) .onFailure( throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage()) ); }} In the above codes, use the withTransaction method to wrap a series of database operations in a single transaction. Let’s assemble all the resources in the MainVerticle&#39;s start method. @Overridepublic void start(Promise&lt;Void&gt; startPromise) throws Exception { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;); //setupLogging(); //Create a PgPool instance var pgPool = pgPool(); //Creating PostRepository var postRepository = PostRepository.create(pgPool); //Creating PostHandler var postHandlers = PostsHandler.create(postRepository); // Initializing the sample data var initializer = DataInitializer.create(pgPool); initializer.run(); // Configure routes var router = routes(postHandlers); // Create the HTTP server vertx.createHttpServer() // Handle every request using the router .requestHandler(router) ...} By default Vertx Web uses Jackson to serialize and deserialize the request/response payload. Unfortunately it does not register a Java DateTime module by default. Add the following dependencies in the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt;&lt;/dependency&gt; Add a jackson.version property to the properties section. &lt;jackson.version&gt;2.11.3&lt;/jackson.version&gt; Then add a static block to configure DateTime serialization and deserialization in the MainVerticle class. static { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module);} Let’s start the application. Simply fetch the source codes, it provides a docker compose file. Run the following command to start a Postgres instance in Docker container. docker compose postgres It will prepare the essential tables through the initial scripts when the database is starting. Now switch to the project folder, run the following command to start the application. mvn clean compile exec:java Or build the project firstly, and run the final jar file. mvn clean packagejava -jar target/demo.jar After the application is started, open a terminal, and use curl to test the /posts endpoints. curl http://localhost:8888/posts -H &quot;Accept: application/json&quot;[{&quot;id&quot;:&quot;1f99032b-3bb0-4795-ba9f-b0437b59cfbe&quot;,&quot;title&quot;:&quot;Hello Quarkus&quot;,&quot;content&quot;:&quot;My first post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;},{&quot;id&quot;:&quot;adda9ca6-2c4c-4223-9cb6-b8407c15ba03&quot;,&quot;title&quot;:&quot;Hello Again, Quarkus&quot;,&quot;content&quot;:&quot;My second post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;}] Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building RESTful APIs with Eclipse Vertx was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building RESTful APIs with Eclipse Vertx","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-restful-apis-with-eclipse-vertx/"},"url":"/blog/2021/building-restful-apis-with-eclipse-vertx/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building RESTful APIs with Eclipse Vertx</h1>
    <p class="post-meta">July 2, 2021</p>
  </header>

  <article class="post-content">
    <p>In this post, we will explore how to build a simple RESTful example application with Eclipse Vertx and reactive Postgres Client.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xR6gc7dEF0E7gXxf_57izA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@sam_beasley?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Sam Beasley</a> on <a href="https://unsplash.com/s/photos/china-gugong?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Unlike other frameworks in which <em>reactive</em> is an addition to the existing features, Eclipse Vertx is born for <em>reactive applications</em>, read <a href="https://vertx.io/introduction-to-vertx-and-reactive/">the official introduction guide</a> to get know the reactive support in Vertx .</p><p>Similar to the <a href="https://start.spring.io">Spring Boot intializr</a>, Eclipse Vertx also provides a scaffold tool to generate the project skeleton for you.</p><p>Open your browser, navigate to the <a href="https://start.vertx.io/">Vertx Starter page</a>. In the <strong>Dependencies</strong> field, select <em>Vertx Web</em>, <em>Reactive PostgreSQL Client</em>, and optionally expand the <strong>Advance options</strong> and select the <em>latest Java version</em>(at the moment it is <strong>16</strong>).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JJa1u3eVqoVUlw7k.png" /></figure><p>Leave others options as they are, it will use the default values, then hit <strong>Generate Project</strong> button to generate the project into an archive for downloading.</p><p>Download the project archive, and extract the files into local disc, and import into your IDEs, eg. Intellij IDEA.</p><p>Open the <em>pom.xml</em>. As you see, it uses maven-shade-plugin to package the built results into a fat jar, and the <em>Main-Class</em> is the Vertx built-in io.vertx.core.Launcher. When running the application via java -jar target\xxx.jar , it will use the Launcher to deploy the declared MainVerticle . A Verticle is a Vertx specific deployment unit to group the resources, such as Network, HTTP, etc.</p><p>Let’s move to the MainVerticle class.</p><pre>public class MainVerticle extends AbstractVerticle {<br>    <br>}</pre><p>Generally , to code our business logic, you just need to override the start() method or start(Promise&lt;Void&gt; startPromise).</p><p>In our application, we will start a HTTP Server to serve the HTTP requests. Replace the content of the start(Promise&lt;Void&gt; startPromise) method with the following.</p><pre>// Create the HTTP server<br>vertx.createHttpServer()<br>    // Handle every request using the router<br>    .requestHandler(router)<br>    // Start listening<br>    .listen(8888)<br>    // Print the port<br>    .onSuccess(server -&gt; {<br>        startPromise.complete();<br>        System.out.println(&quot;HTTP server started on port &quot; + server.actualPort());<br>    })<br>    .onFailure(event -&gt; {<br>        startPromise.fail(event);<br>        System.out.println(&quot;Failed to start HTTP server:&quot; + event.getMessage());<br>    });</pre><p>The request handling work is done by the above .requestHandler(Handler&lt;HttpServerRequest&gt;). The Router is a specific Handler&lt;HttpServerRequest&gt; which simplifies the handling HTTP requests and allows chaining a sequence of handlers.</p><p>Add a reoutes method to handle requests of all routes in a central place, it returns the router.</p><pre>//create routes<br>private Router routes(PostsHandler handlers) {</pre><pre>    // Create a Router<br>    Router router = Router.router(vertx);<br>    // register BodyHandler globally.<br>    //router.route().handler(BodyHandler.create());<br>    router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;).handler(handlers::all);<br>   	router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::save);<br>    router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;).handler(handlers::get).failureHandler(frc -&gt; frc.response().setStatusCode(404).end());<br>    router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::update);<br>    router.delete(&quot;/posts/:id&quot;).handler(handlers::delete);</pre><pre>    router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;));</pre><pre>    return router;<br>}</pre><p>For post and put HTTP methods, the BodyHandler is required to handling consuming the HTTP request body.</p><p>Extract all handing details into a new PostHandler class.</p><pre>class PostsHandler {<br>    private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName());</pre><pre>    PostRepository posts;</pre><pre>    private PostsHandler(PostRepository _posts) {<br>        this.posts = _posts;<br>    }</pre><pre>    //factory method<br>    public static PostsHandler create(PostRepository posts) {<br>        return new PostsHandler(posts);<br>    }</pre><pre>    public void all(RoutingContext rc) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        this.posts.findAll()<br>            .onSuccess(<br>                data -&gt; rc.response().end(Json.encode(data))<br>            );<br>    }</pre><pre>    public void get(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        this.posts.findById(UUID.fromString(id))<br>            .onSuccess(<br>                post -&gt; rc.response().end(Json.encode(post))<br>            )<br>            .onFailure(<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }<br></pre><pre>    public void save(RoutingContext rc) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body);<br>        var form = body.mapTo(PostForm.class);<br>        this.posts.save(Post.of(form.getTitle(), form.getContent()))<br>            .onSuccess(<br>                savedId -&gt; rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId)<br>                    .setStatusCode(201)<br>                    .end()</pre><pre>            );<br>    }</pre><pre>    public void update(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body});<br>        var form = body.mapTo(PostForm.class);<br>        this.posts.findById(UUID.fromString(id))<br>            .compose(<br>                post -&gt; {<br>                    post.setTitle(form.getTitle());<br>                    post.setContent(form.getContent());</pre><pre>                    return this.posts.update(post);<br>                }<br>            )<br>            .onSuccess(<br>                data -&gt; rc.response().setStatusCode(204).end()<br>            )<br>            .onFailure(<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }</pre><pre>    public void delete(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);</pre><pre>        var uuid = UUID.fromString(id);<br>        this.posts.findById(uuid)<br>            .compose(<br>                post -&gt; this.posts.deleteById(uuid)<br>            )<br>            .onSuccess(<br>                data -&gt; rc.response().setStatusCode(204).end()<br>            )<br>            .onFailure(<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }</pre><pre>}</pre><p>From the RoutingContext, it is easy to read the request params etc. PostRepository is responsible for interacting with your backend database Postgres, when the database operation is done, then send result to the HTTP response through RoutingContext.response().</p><p>Let’s have a look at the PostRepository class.</p><pre>public class PostRepository {<br>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</pre><pre>    private static Function&lt;Row, Post&gt; MAPPER = (row) -&gt;<br>        Post.of(<br>            row.getUUID(&quot;id&quot;),<br>            row.getString(&quot;title&quot;),<br>            row.getString(&quot;content&quot;),<br>            row.getLocalDateTime(&quot;created_at&quot;)<br>        );<br></pre><pre>    private final PgPool client;</pre><pre>    private PostRepository(PgPool _client) {<br>        this.client = _client;<br>    }</pre><pre>    //factory method<br>    public static PostRepository create(PgPool client) {<br>        return new PostRepository(client);<br>    }</pre><pre>    public Future&lt;List&lt;Post&gt;&gt; findAll() {<br>        return client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;)<br>            .execute()<br>            .map(rs -&gt; StreamSupport.stream(rs.spliterator(), false)<br>                .map(MAPPER)<br>                .collect(Collectors.toList())<br>            );<br>    }<br></pre><pre>    public Future&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>            .map(RowSet::iterator)<br>            .map(iterator -&gt; iterator.hasNext() ? MAPPER.apply(iterator.next()) : null)<br>            .map(Optional::ofNullable)<br>            .map(p -&gt; p.orElseThrow(() -&gt; new PostNotFoundException(id)));<br>    }</pre><pre>    public Future&lt;UUID&gt; save(Post data) {<br>        return client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;).execute(Tuple.of(data.getTitle(), data.getContent()))<br>            .map(rs -&gt; rs.iterator().next().getUUID(&quot;id&quot;));<br>    }</pre><pre>    public Future&lt;Integer&gt; saveAll(List&lt;Post&gt; data) {<br>        var tuples = data.stream()<br>            .map(<br>                d -&gt; Tuple.of(d.getTitle(), d.getContent())<br>            )<br>            .collect(Collectors.toList());</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .executeBatch(tuples)<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Future&lt;Integer&gt; update(Post data) {<br>        return client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>            .execute(Tuple.of(data.getTitle(), data.getContent(), data.getId()))<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Future&lt;Integer&gt; deleteAll() {<br>        return client.query(&quot;DELETE FROM posts&quot;).execute()<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Future&lt;Integer&gt; deleteById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>}</pre><p>The pgPool is a Postgres client to interact with the Postgres database, the operations are very similar to the traditional JDBC, but it is based on the Vertx&#39;s Future API. Similar to Java 8 CompletionStage or Reactor Mono /Flux, Vertx Future provides very limited APIs for producing, transforming and observing the completed result in an asynchronous mode.</p><blockquote><em>More details about the Reactive PostgreSQL Client, read </em><a href="https://vertx.io/docs/vertx-pg-client/java/"><em>PostgreSQL Client docs</em></a><em>.</em></blockquote><blockquote><em>In Vertx, almost all async methods provide a variant of accepting a </em><em>Promise like callback as parameter instead of return a </em><em>Future instance. But personally I think the </em><em>Promise is evil if the handling progress is passed into a sequence of transitions, thus the </em><em>Promise will nest another </em><em>Promise, and so on. It will put you in an infinite </em><em>Promise hole.</em></blockquote><p>Create a method in the MainVerticle to produce a PgPool instance.</p><pre>private PgPool pgPool() {<br>    PgConnectOptions connectOptions = new PgConnectOptions()<br>        .setPort(5432)<br>        .setHost(&quot;localhost&quot;)<br>        .setDatabase(&quot;blogdb&quot;)<br>        .setUser(&quot;user&quot;)<br>        .setPassword(&quot;password&quot;);</pre><pre>    // Pool Options<br>    PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>    // Create the pool from the data object<br>    PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>    return pool;<br>}</pre><p>Create a class to initialize some sample data.</p><pre>public class DataInitializer {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());</pre><pre>    private PgPool client;</pre><pre>    public DataInitializer(PgPool client) {<br>        this.client = client;<br>    }</pre><pre>    public static DataInitializer create(PgPool client) {<br>        return new DataInitializer(client);<br>    }</pre><pre>    public void run() {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;);</pre><pre>        Tuple first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;);<br>        Tuple second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;);</pre><pre>        client<br>            .withTransaction(<br>                conn -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute()<br>                    .flatMap(r -&gt; conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>                        .executeBatch(List.of(first, second))<br>                    )<br>                    .flatMap(r -&gt; conn.query(&quot;SELECT * FROM posts&quot;).execute())<br>            )<br>            .onSuccess(data -&gt; StreamSupport.stream(data.spliterator(), true)<br>                .forEach(row -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, new Object[]{row.toJson()}))<br>            )<br>            .onComplete(<br>                r -&gt; {<br>                    //client.close(); will block the application.<br>                    LOGGER.info(&quot;Data initialization is done...&quot;);<br>                }<br>            )<br>            .onFailure(<br>                throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage())<br>            );<br>    }<br>}</pre><p>In the above codes, use the withTransaction method to wrap a series of database operations in a single transaction.</p><p>Let’s assemble all the resources in the MainVerticle&#39;s start method.</p><pre>@Override<br>public void start(Promise&lt;Void&gt; startPromise) throws Exception {<br>    LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;);<br>    //setupLogging();</pre><pre>    //Create a PgPool instance<br>    var pgPool = pgPool();</pre><pre>    //Creating PostRepository<br>    var postRepository = PostRepository.create(pgPool);</pre><pre>    //Creating PostHandler<br>    var postHandlers = PostsHandler.create(postRepository);</pre><pre>    // Initializing the sample data<br>    var initializer = DataInitializer.create(pgPool);<br>    initializer.run();</pre><pre>    // Configure routes<br>    var router = routes(postHandlers);</pre><pre>    // Create the HTTP server<br>    vertx.createHttpServer()<br>        // Handle every request using the router<br>    	.requestHandler(router)<br>        ...<br>}</pre><p>By default Vertx Web uses Jackson to serialize and deserialize the request/response payload. Unfortunately it does not register a Java DateTime module by default.</p><p>Add the following dependencies in the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br>    &lt;version&gt;${jackson.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;<br>    &lt;version&gt;${jackson.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>Add a jackson.version property to the properties section.</p><pre>&lt;jackson.version&gt;2.11.3&lt;/jackson.version&gt;</pre><p>Then add a static block to configure DateTime serialization and deserialization in the MainVerticle class.</p><pre>static {<br>    LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;);<br>    var objectMapper = DatabindCodec.mapper();<br>    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>    objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br>    objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</pre><pre>    JavaTimeModule module = new JavaTimeModule();<br>    objectMapper.registerModule(module);<br>}</pre><p>Let’s start the application.</p><p>Simply fetch <a href="https://github.com/hantsy/vertx-sandbox">the source codes</a>, it provides a docker compose file.</p><p>Run the following command to start a Postgres instance in Docker container.</p><pre>docker compose postgres</pre><p>It will prepare the essential tables through <a href="https://github.com/hantsy/vertx-sandbox/tree/master/pg-initdb.d">the initial scripts</a> when the database is starting.</p><p>Now switch to the project folder, run the following command to start the application.</p><pre>mvn clean compile exec:java</pre><p>Or build the project firstly, and run the final jar file.</p><pre>mvn clean package<br>java -jar target/demo.jar</pre><p>After the application is started, open a terminal, and use curl to test the /posts endpoints.</p><pre>curl <a href="http://localhost:8888/posts">http://localhost:8888/posts</a> -H &quot;Accept: application/json&quot;<br>[{&quot;id&quot;:&quot;1f99032b-3bb0-4795-ba9f-b0437b59cfbe&quot;,&quot;title&quot;:&quot;Hello Quarkus&quot;,&quot;content&quot;:&quot;My first post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;},{&quot;id&quot;:&quot;adda9ca6-2c4c-4223-9cb6-b8407c15ba03&quot;,&quot;title&quot;:&quot;Hello Again, Quarkus&quot;,&quot;content&quot;:&quot;My second post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;}]</pre><h4>Get <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service">the complete source codes</a> from my Github.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4ce89d8eeb74" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-restful-apis-with-eclipse-vertx-4ce89d8eeb74">Building RESTful APIs with Eclipse Vertx</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
