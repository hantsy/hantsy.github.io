<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Secures RESTful APIs with Quarkus OIDC and Auth0
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/secures-restful-apis-with-quarkus-oidc-and-auth0/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Secures RESTful APIs with Quarkus OIDC and Auth0" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Quarkus has great support of OAuth 2 and OIDC protocol. In this post, we will explore how to protect RESTful APIs with Quarkus OIDC and Auth0. Photo by Ling Tang on Unsplash Quarkus is well-known as a supersonic subatomic Java framework to build Kubernetes-friendly cloud native applications. In an earlier post we have discussed how to secure RESTful APIs with Spring Security and Auth0, we will implement the same functionality with Quarkus OIDC extension. Go to Quarkus Start Coding page, make sure you have added these extensions: oidc, resteasy, resteasy-jackson, hibernate-validator , hibernate-orm-panache, jdbc-postgresql. Then generate a project skeleton as usual that we have done in the former posts. Import the source codes into your IDE. Open the project pom.xml file you should see the following dependencies. Add an extra Lombok dependency to clean up the POJOs. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- Erase getters and setters --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; In this post we will focus on how to integrate Quarkus OIDC and Auth0. We have no plan to explain the development progress of the RESTful APIs, the details of the source codes are very similar to the ones we have discussed in my introduction to Quarkus. Before jumping to the next steps, check out a copy of the source codes of this post from my github and explore them yourself. Unlike Spring Security, Quarkus Security does not follow the naming (resourceserver, client and authorizationserver etc.) of OAuth2 roles to categorize the configuration properties. Quarkus binds the OAuth2/OIDC configuration properties to functionality name (eg. quarkus.oidc.xxx, quarkus.oidc-flow.xxx, etc), which are confusing when you are the first time come to Quarkus world. And most of the official Quarkus OAuth2 and OIDC examples and guides are dependent on Keycloak — the open source OAuth2/OIDC compatible authorization server from Redhat. If you know well about the OAuth2/OIDC protocols, it is not diffcult to move on to Auth0. To make Quakrus OIDC work with Auth0, add the following configuration in the application.properties. # Oidc auth config for resource serverquarkus.oidc.client-id=backend-apiquarkus.oidc.auth-server-url=https://dev-ese8241b.us.auth0.com/quarkus.oidc.token.audience=https://hantsy.github.io/api#quarkus.oidc.application-type=service The default quarkus.oidc.application-type is service, which is used for identifying the application type, service is equivalent to resourceserver in Spring Security. Note: The quarkus.oidc.client-id must be provided although this is not an OAuth2 client role. When parsing the JWT token, Quarkus OIDC also can discover the jwt set url automatically from a base auth-server-url value if the authorization server supports OIDC configuratoin protocol. When a token audience is provided, Quarkus will verify it automatically. You can also validate the audience or other items in the JWT token yourself. //@Providerpublic class AudienceValidator implements ContainerRequestFilter { @Inject OidcConfigurationMetadata configMetadata; @Inject JsonWebToken jwt; @Inject SecurityIdentity identity; public void filter(ContainerRequestContext requestContext) { String aud = configMetadata.get(&quot;audience&quot;);//.replace(&quot;{tenant-id}&quot;, identity.getAttribute(&quot;tenant-id&quot;)); if (!jwt.getAudience().contains(aud)) { requestContext.abortWith(Response.status(401).build()); } }} In the above example, the OidcConfigurationMetadata is the OIDC configuration properties of this application. The JsonWebToken is the parsed token claims. The SecurityIdenity is a general-purpose security context object to envelope the user principal and roles, similar to the traditional Jakarta EE SecurityContext API from JaxRS, EJB, etc. To protect the APIs and make some APIs only be accessible for the authenticated user, Quarkus Security provides a @Authenticated annotation. The following is a modified version of PostResource in which we added @Authenticated annotations on all write operations to protect the resources. @Path(&quot;/posts&quot;)@RequestScopedpublic class PostResource { private final static Logger LOGGER = Logger.getLogger(PostResource.class.getName()); private final PostRepository posts; @Context UriInfo uriInfo; @Inject public PostResource(PostRepository posts) { this.posts = posts; } @Path(&quot;count&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response countAllPosts(@QueryParam(&quot;q&quot;) String q) { return ok(this.posts.countByKeyword(q)).build(); } @GET @Produces(MediaType.APPLICATION_JSON) public Response getAllPosts( @QueryParam(&quot;q&quot;) String q, @QueryParam(&quot;offset&quot;) @DefaultValue(&quot;0&quot;) int offset, @QueryParam(&quot;limit&quot;) @DefaultValue(&quot;10&quot;) int limit ) { return ok(this.posts.findByKeyword(q, offset, limit)).build(); } @POST @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response savePost(@Valid CreatePostCommand post) { Post saved = this.posts.save(Post.builder().title(post.title()).content(post.content()).build()); return created( uriInfo.getBaseUriBuilder() .path(&quot;/posts/{id}&quot;) .build(saved.getId()) ).build(); } @Path(&quot;{id}&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response getPostById(@PathParam(&quot;id&quot;) final Long id) { return this.posts.findByIdOptional(id) .map(post -&gt; ok(post).build()) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}&quot;) @PUT @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response updatePost(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostCommand post) { return this.posts.findByIdOptional(id) .map(existed -&gt; { existed.setTitle(post.title()); existed.setContent(post.content()); Post saved = this.posts.save(existed); return noContent().build(); }) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}/status&quot;) @PUT @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response updatePostStatus(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostStatusCommand status) { return this.posts.findByIdOptional(id) .map(existed -&gt; { existed.setStatus(status.status()); Post saved = this.posts.save(existed); return noContent().build(); }) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}&quot;) @DELETE @Authenticated public Response deletePost(@PathParam(&quot;id&quot;) final Long id) { this.posts.deleteById(id); return noContent().build(); } } To test the application manually, log in the auth0 dashboard, follow the steps we have introduced in the former Spring Security and Auth0 integration post to get a token via the Test Application provided by auth0 and then use curl command or Postman like tools to access the protected APIs. In my opinion, Quarkus test framework is not flexible as Spring. In Spring ecosystem, Spring Security provides test utilities to mock MVC and JWT decode in the unit tests, unfortunately Quarkus does not provide such a simple helper. But there are some possible approaches to test the security concern of the service type application. Add the following dependencies in the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-test-security&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-elytron-security-properties-file-deployment&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; To focus on testing the business logic in Quarkus applications, you can set up the embedded users in a properties file to replace the real users in the database and enable Http Basic authentication to pass by the JWT token authorization. Create a src/test/resources/application-embedded-users.properties file to setup the embedded users and enable basic auth . quarkus.security.users.embedded.enabled=truequarkus.security.users.embedded.plain-text=truequarkus.security.users.embedded.users.alice=passwordquarkus.security.users.embedded.roles.alice=userquarkus.security.users.embedded.users.admin=passwordquarkus.security.users.embedded.roles.admin=adminquarkus.http.auth.basic=truequarkus.oidc.enabled=false Create a QuarkusTestProfile to categorize the test resources for some special purpose. public class PropertiesFileEmbeddedUsersProfile implements QuarkusTestProfile { @Override public String getConfigProfile() { return &quot;embedded-users&quot;; }} Create a simple test to apply this test profile via the @TestProfile annotation. @QuarkusTest@TestHTTPEndpoint(PostResource.class)@TestProfile(PropertiesFileEmbeddedUsersProfile.class)public class TestSecurityLazyAuthTest { @Test public void testGetAllPostsWithoutAuth() { //@formatter:off given() .accept(ContentType.JSON) .when() .get(&quot;&quot;) .then() .statusCode(200); //@formatter:on } @Test //@TestSecurity(authorizationEnabled = false) public void testCreatPostsWithoutAuth() { //@formatter:off given() .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;&quot;) .then() .statusCode(401); //@formatter:on } @Test @TestSecurity(user = &quot;alice&quot;, roles = &quot;user&quot;) public void testCreatPostsWithAuth() { //@formatter:off given() .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;&quot;) .then() .statusCode(201); //@formatter:on }} Additionally, you can generate a local RSA public/private key pair to perform the JWT token verification progress. Generating Keys with OpenSSL. openssl genrsa -out rsaPrivateKey.pem 2048openssl rsa -pubout -in rsaPrivateKey.pem -out publicKey.pem An additional step is needed for generating the private key for converting it into the PKCS#8 format. openssl pkcs8 -topk8 -nocrypt -inform pem -in rsaPrivateKey.pem -outform pem -out privateKey.pem Create a TestProfile class to setup the properties to use local public key to verify the JWT token. public class InlinedPublicKeyProfile implements QuarkusTestProfile { @Override public Map&lt;String, String&gt; getConfigOverrides() { return Map.of( &quot;quarkus.oidc.client-id&quot;, &quot;test&quot;, &quot;quarkus.oidc.public-key&quot;, &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzcAl1DgYnAkpYelL4lxl&quot; + &quot;csdX0dHj92g+pMyjzWE3nzSV8i726lTJtg5kxaJyv8epEOAiMcelFk0v+9HMOPla&quot; + &quot;6/pgkEHE5PPyaHlgegDIzge2RQLidDwl8IWBksUkfDWjQk+JfrEPJxrES4OXUOyp&quot; + &quot;mO/XsNIGcbZfopi1Ook7XIjBPohuiHBcp8Fw1NVzaP7EvyYzxcxoIpa4Y/knF1Sa&quot; + &quot;FIBuMmA/lE7PHKlBqcsS1EXkyI1TBGcdH+VWhUvsDVehKSlZoUCE6XrWY3M/xzyb&quot; + &quot;gN+C9KPln+fQZ42Fnqo6PpD++NWRo8vgWxsMsqb+nltEQADfd8CFEuLt1BvObh8N&quot; + &quot;fQIDAQAB&quot;, &quot;quarkus.oidc.token.audience&quot;, &quot;https://service.example.com&quot;, &quot;smallrye.jwt.sign.key-location&quot;, &quot;privateKey.jwk&quot; ); } } Now write a test to verify it. The getAccessToken to generate a token using our private key generated in the last step. @QuarkusTest@TestProfile(InlinedPublicKeyProfile.class)public class InlinedPublicKeyAuthorizationTest { @Test public void testBearerToken() { //@formatter:off given() .auth().oauth2(getAccessToken(&quot;alice&quot;, Set.of(&quot;user&quot;))) .body(new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;)) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .statusCode(201); //@formatter:on } // private String getAccessToken(String userName, Set&lt;String&gt; groups) { return Jwt.preferredUserName(userName) .claim(&quot;scope&quot;, &quot;write:posts&quot;) .groups(groups) .issuer(&quot;https://server.example.com&quot;) .audience(&quot;https://service.example.com&quot;) .jws() .keyId(&quot;1&quot;) .sign(&quot;privateKey.jwk&quot;); }} As you see, we used a custom private/public key pair in our tests to pass by fetching the public key via jwk set url from the remote authorization server. Let’s put all together and run the application. Grab the source codes from github. Start the application. docker compose up postgresqlmvn clean quarkus:dev Copy the ui codes from hantsy/spring-security-auth0-sample that we have done in Integrating Auth0 into your Angular applications. It is a SPA application written in Angular 12. npm installnpm run start Open your browser and navigate to http://localhost:4200. Login and click the Blog menu item, you will see the data from the backend API application. &lt;hr&gt;&lt;p&gt;Secures RESTful APIs with Quarkus OIDC and Auth0 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Quarkus has great support of OAuth 2 and OIDC protocol. In this post, we will explore how to protect RESTful APIs with Quarkus OIDC and Auth0. Photo by Ling Tang on Unsplash Quarkus is well-known as a supersonic subatomic Java framework to build Kubernetes-friendly cloud native applications. In an earlier post we have discussed how to secure RESTful APIs with Spring Security and Auth0, we will implement the same functionality with Quarkus OIDC extension. Go to Quarkus Start Coding page, make sure you have added these extensions: oidc, resteasy, resteasy-jackson, hibernate-validator , hibernate-orm-panache, jdbc-postgresql. Then generate a project skeleton as usual that we have done in the former posts. Import the source codes into your IDE. Open the project pom.xml file you should see the following dependencies. Add an extra Lombok dependency to clean up the POJOs. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- Erase getters and setters --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; In this post we will focus on how to integrate Quarkus OIDC and Auth0. We have no plan to explain the development progress of the RESTful APIs, the details of the source codes are very similar to the ones we have discussed in my introduction to Quarkus. Before jumping to the next steps, check out a copy of the source codes of this post from my github and explore them yourself. Unlike Spring Security, Quarkus Security does not follow the naming (resourceserver, client and authorizationserver etc.) of OAuth2 roles to categorize the configuration properties. Quarkus binds the OAuth2/OIDC configuration properties to functionality name (eg. quarkus.oidc.xxx, quarkus.oidc-flow.xxx, etc), which are confusing when you are the first time come to Quarkus world. And most of the official Quarkus OAuth2 and OIDC examples and guides are dependent on Keycloak — the open source OAuth2/OIDC compatible authorization server from Redhat. If you know well about the OAuth2/OIDC protocols, it is not diffcult to move on to Auth0. To make Quakrus OIDC work with Auth0, add the following configuration in the application.properties. # Oidc auth config for resource serverquarkus.oidc.client-id=backend-apiquarkus.oidc.auth-server-url=https://dev-ese8241b.us.auth0.com/quarkus.oidc.token.audience=https://hantsy.github.io/api#quarkus.oidc.application-type=service The default quarkus.oidc.application-type is service, which is used for identifying the application type, service is equivalent to resourceserver in Spring Security. Note: The quarkus.oidc.client-id must be provided although this is not an OAuth2 client role. When parsing the JWT token, Quarkus OIDC also can discover the jwt set url automatically from a base auth-server-url value if the authorization server supports OIDC configuratoin protocol. When a token audience is provided, Quarkus will verify it automatically. You can also validate the audience or other items in the JWT token yourself. //@Providerpublic class AudienceValidator implements ContainerRequestFilter { @Inject OidcConfigurationMetadata configMetadata; @Inject JsonWebToken jwt; @Inject SecurityIdentity identity; public void filter(ContainerRequestContext requestContext) { String aud = configMetadata.get(&quot;audience&quot;);//.replace(&quot;{tenant-id}&quot;, identity.getAttribute(&quot;tenant-id&quot;)); if (!jwt.getAudience().contains(aud)) { requestContext.abortWith(Response.status(401).build()); } }} In the above example, the OidcConfigurationMetadata is the OIDC configuration properties of this application. The JsonWebToken is the parsed token claims. The SecurityIdenity is a general-purpose security context object to envelope the user principal and roles, similar to the traditional Jakarta EE SecurityContext API from JaxRS, EJB, etc. To protect the APIs and make some APIs only be accessible for the authenticated user, Quarkus Security provides a @Authenticated annotation. The following is a modified version of PostResource in which we added @Authenticated annotations on all write operations to protect the resources. @Path(&quot;/posts&quot;)@RequestScopedpublic class PostResource { private final static Logger LOGGER = Logger.getLogger(PostResource.class.getName()); private final PostRepository posts; @Context UriInfo uriInfo; @Inject public PostResource(PostRepository posts) { this.posts = posts; } @Path(&quot;count&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response countAllPosts(@QueryParam(&quot;q&quot;) String q) { return ok(this.posts.countByKeyword(q)).build(); } @GET @Produces(MediaType.APPLICATION_JSON) public Response getAllPosts( @QueryParam(&quot;q&quot;) String q, @QueryParam(&quot;offset&quot;) @DefaultValue(&quot;0&quot;) int offset, @QueryParam(&quot;limit&quot;) @DefaultValue(&quot;10&quot;) int limit ) { return ok(this.posts.findByKeyword(q, offset, limit)).build(); } @POST @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response savePost(@Valid CreatePostCommand post) { Post saved = this.posts.save(Post.builder().title(post.title()).content(post.content()).build()); return created( uriInfo.getBaseUriBuilder() .path(&quot;/posts/{id}&quot;) .build(saved.getId()) ).build(); } @Path(&quot;{id}&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response getPostById(@PathParam(&quot;id&quot;) final Long id) { return this.posts.findByIdOptional(id) .map(post -&gt; ok(post).build()) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}&quot;) @PUT @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response updatePost(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostCommand post) { return this.posts.findByIdOptional(id) .map(existed -&gt; { existed.setTitle(post.title()); existed.setContent(post.content()); Post saved = this.posts.save(existed); return noContent().build(); }) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}/status&quot;) @PUT @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response updatePostStatus(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostStatusCommand status) { return this.posts.findByIdOptional(id) .map(existed -&gt; { existed.setStatus(status.status()); Post saved = this.posts.save(existed); return noContent().build(); }) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}&quot;) @DELETE @Authenticated public Response deletePost(@PathParam(&quot;id&quot;) final Long id) { this.posts.deleteById(id); return noContent().build(); } } To test the application manually, log in the auth0 dashboard, follow the steps we have introduced in the former Spring Security and Auth0 integration post to get a token via the Test Application provided by auth0 and then use curl command or Postman like tools to access the protected APIs. In my opinion, Quarkus test framework is not flexible as Spring. In Spring ecosystem, Spring Security provides test utilities to mock MVC and JWT decode in the unit tests, unfortunately Quarkus does not provide such a simple helper. But there are some possible approaches to test the security concern of the service type application. Add the following dependencies in the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-test-security&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-elytron-security-properties-file-deployment&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; To focus on testing the business logic in Quarkus applications, you can set up the embedded users in a properties file to replace the real users in the database and enable Http Basic authentication to pass by the JWT token authorization. Create a src/test/resources/application-embedded-users.properties file to setup the embedded users and enable basic auth . quarkus.security.users.embedded.enabled=truequarkus.security.users.embedded.plain-text=truequarkus.security.users.embedded.users.alice=passwordquarkus.security.users.embedded.roles.alice=userquarkus.security.users.embedded.users.admin=passwordquarkus.security.users.embedded.roles.admin=adminquarkus.http.auth.basic=truequarkus.oidc.enabled=false Create a QuarkusTestProfile to categorize the test resources for some special purpose. public class PropertiesFileEmbeddedUsersProfile implements QuarkusTestProfile { @Override public String getConfigProfile() { return &quot;embedded-users&quot;; }} Create a simple test to apply this test profile via the @TestProfile annotation. @QuarkusTest@TestHTTPEndpoint(PostResource.class)@TestProfile(PropertiesFileEmbeddedUsersProfile.class)public class TestSecurityLazyAuthTest { @Test public void testGetAllPostsWithoutAuth() { //@formatter:off given() .accept(ContentType.JSON) .when() .get(&quot;&quot;) .then() .statusCode(200); //@formatter:on } @Test //@TestSecurity(authorizationEnabled = false) public void testCreatPostsWithoutAuth() { //@formatter:off given() .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;&quot;) .then() .statusCode(401); //@formatter:on } @Test @TestSecurity(user = &quot;alice&quot;, roles = &quot;user&quot;) public void testCreatPostsWithAuth() { //@formatter:off given() .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;&quot;) .then() .statusCode(201); //@formatter:on }} Additionally, you can generate a local RSA public/private key pair to perform the JWT token verification progress. Generating Keys with OpenSSL. openssl genrsa -out rsaPrivateKey.pem 2048openssl rsa -pubout -in rsaPrivateKey.pem -out publicKey.pem An additional step is needed for generating the private key for converting it into the PKCS#8 format. openssl pkcs8 -topk8 -nocrypt -inform pem -in rsaPrivateKey.pem -outform pem -out privateKey.pem Create a TestProfile class to setup the properties to use local public key to verify the JWT token. public class InlinedPublicKeyProfile implements QuarkusTestProfile { @Override public Map&lt;String, String&gt; getConfigOverrides() { return Map.of( &quot;quarkus.oidc.client-id&quot;, &quot;test&quot;, &quot;quarkus.oidc.public-key&quot;, &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzcAl1DgYnAkpYelL4lxl&quot; + &quot;csdX0dHj92g+pMyjzWE3nzSV8i726lTJtg5kxaJyv8epEOAiMcelFk0v+9HMOPla&quot; + &quot;6/pgkEHE5PPyaHlgegDIzge2RQLidDwl8IWBksUkfDWjQk+JfrEPJxrES4OXUOyp&quot; + &quot;mO/XsNIGcbZfopi1Ook7XIjBPohuiHBcp8Fw1NVzaP7EvyYzxcxoIpa4Y/knF1Sa&quot; + &quot;FIBuMmA/lE7PHKlBqcsS1EXkyI1TBGcdH+VWhUvsDVehKSlZoUCE6XrWY3M/xzyb&quot; + &quot;gN+C9KPln+fQZ42Fnqo6PpD++NWRo8vgWxsMsqb+nltEQADfd8CFEuLt1BvObh8N&quot; + &quot;fQIDAQAB&quot;, &quot;quarkus.oidc.token.audience&quot;, &quot;https://service.example.com&quot;, &quot;smallrye.jwt.sign.key-location&quot;, &quot;privateKey.jwk&quot; ); } } Now write a test to verify it. The getAccessToken to generate a token using our private key generated in the last step. @QuarkusTest@TestProfile(InlinedPublicKeyProfile.class)public class InlinedPublicKeyAuthorizationTest { @Test public void testBearerToken() { //@formatter:off given() .auth().oauth2(getAccessToken(&quot;alice&quot;, Set.of(&quot;user&quot;))) .body(new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;)) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .statusCode(201); //@formatter:on } // private String getAccessToken(String userName, Set&lt;String&gt; groups) { return Jwt.preferredUserName(userName) .claim(&quot;scope&quot;, &quot;write:posts&quot;) .groups(groups) .issuer(&quot;https://server.example.com&quot;) .audience(&quot;https://service.example.com&quot;) .jws() .keyId(&quot;1&quot;) .sign(&quot;privateKey.jwk&quot;); }} As you see, we used a custom private/public key pair in our tests to pass by fetching the public key via jwk set url from the remote authorization server. Let’s put all together and run the application. Grab the source codes from github. Start the application. docker compose up postgresqlmvn clean quarkus:dev Copy the ui codes from hantsy/spring-security-auth0-sample that we have done in Integrating Auth0 into your Angular applications. It is a SPA application written in Angular 12. npm installnpm run start Open your browser and navigate to http://localhost:4200. Login and click the Blog menu item, you will see the data from the backend API application. &lt;hr&gt;&lt;p&gt;Secures RESTful APIs with Quarkus OIDC and Auth0 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-09T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Secures RESTful APIs with Quarkus OIDC and Auth0" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-06-09T00:00:00+00:00","datePublished":"2021-06-09T00:00:00+00:00","description":"Quarkus has great support of OAuth 2 and OIDC protocol. In this post, we will explore how to protect RESTful APIs with Quarkus OIDC and Auth0. Photo by Ling Tang on Unsplash Quarkus is well-known as a supersonic subatomic Java framework to build Kubernetes-friendly cloud native applications. In an earlier post we have discussed how to secure RESTful APIs with Spring Security and Auth0, we will implement the same functionality with Quarkus OIDC extension. Go to Quarkus Start Coding page, make sure you have added these extensions: oidc, resteasy, resteasy-jackson, hibernate-validator , hibernate-orm-panache, jdbc-postgresql. Then generate a project skeleton as usual that we have done in the former posts. Import the source codes into your IDE. Open the project pom.xml file you should see the following dependencies. Add an extra Lombok dependency to clean up the POJOs. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- Erase getters and setters --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; In this post we will focus on how to integrate Quarkus OIDC and Auth0. We have no plan to explain the development progress of the RESTful APIs, the details of the source codes are very similar to the ones we have discussed in my introduction to Quarkus. Before jumping to the next steps, check out a copy of the source codes of this post from my github and explore them yourself. Unlike Spring Security, Quarkus Security does not follow the naming (resourceserver, client and authorizationserver etc.) of OAuth2 roles to categorize the configuration properties. Quarkus binds the OAuth2/OIDC configuration properties to functionality name (eg. quarkus.oidc.xxx, quarkus.oidc-flow.xxx, etc), which are confusing when you are the first time come to Quarkus world. And most of the official Quarkus OAuth2 and OIDC examples and guides are dependent on Keycloak — the open source OAuth2/OIDC compatible authorization server from Redhat. If you know well about the OAuth2/OIDC protocols, it is not diffcult to move on to Auth0. To make Quakrus OIDC work with Auth0, add the following configuration in the application.properties. # Oidc auth config for resource serverquarkus.oidc.client-id=backend-apiquarkus.oidc.auth-server-url=https://dev-ese8241b.us.auth0.com/quarkus.oidc.token.audience=https://hantsy.github.io/api#quarkus.oidc.application-type=service The default quarkus.oidc.application-type is service, which is used for identifying the application type, service is equivalent to resourceserver in Spring Security. Note: The quarkus.oidc.client-id must be provided although this is not an OAuth2 client role. When parsing the JWT token, Quarkus OIDC also can discover the jwt set url automatically from a base auth-server-url value if the authorization server supports OIDC configuratoin protocol. When a token audience is provided, Quarkus will verify it automatically. You can also validate the audience or other items in the JWT token yourself. //@Providerpublic class AudienceValidator implements ContainerRequestFilter { @Inject OidcConfigurationMetadata configMetadata; @Inject JsonWebToken jwt; @Inject SecurityIdentity identity; public void filter(ContainerRequestContext requestContext) { String aud = configMetadata.get(&quot;audience&quot;);//.replace(&quot;{tenant-id}&quot;, identity.getAttribute(&quot;tenant-id&quot;)); if (!jwt.getAudience().contains(aud)) { requestContext.abortWith(Response.status(401).build()); } }} In the above example, the OidcConfigurationMetadata is the OIDC configuration properties of this application. The JsonWebToken is the parsed token claims. The SecurityIdenity is a general-purpose security context object to envelope the user principal and roles, similar to the traditional Jakarta EE SecurityContext API from JaxRS, EJB, etc. To protect the APIs and make some APIs only be accessible for the authenticated user, Quarkus Security provides a @Authenticated annotation. The following is a modified version of PostResource in which we added @Authenticated annotations on all write operations to protect the resources. @Path(&quot;/posts&quot;)@RequestScopedpublic class PostResource { private final static Logger LOGGER = Logger.getLogger(PostResource.class.getName()); private final PostRepository posts; @Context UriInfo uriInfo; @Inject public PostResource(PostRepository posts) { this.posts = posts; } @Path(&quot;count&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response countAllPosts(@QueryParam(&quot;q&quot;) String q) { return ok(this.posts.countByKeyword(q)).build(); } @GET @Produces(MediaType.APPLICATION_JSON) public Response getAllPosts( @QueryParam(&quot;q&quot;) String q, @QueryParam(&quot;offset&quot;) @DefaultValue(&quot;0&quot;) int offset, @QueryParam(&quot;limit&quot;) @DefaultValue(&quot;10&quot;) int limit ) { return ok(this.posts.findByKeyword(q, offset, limit)).build(); } @POST @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response savePost(@Valid CreatePostCommand post) { Post saved = this.posts.save(Post.builder().title(post.title()).content(post.content()).build()); return created( uriInfo.getBaseUriBuilder() .path(&quot;/posts/{id}&quot;) .build(saved.getId()) ).build(); } @Path(&quot;{id}&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response getPostById(@PathParam(&quot;id&quot;) final Long id) { return this.posts.findByIdOptional(id) .map(post -&gt; ok(post).build()) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}&quot;) @PUT @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response updatePost(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostCommand post) { return this.posts.findByIdOptional(id) .map(existed -&gt; { existed.setTitle(post.title()); existed.setContent(post.content()); Post saved = this.posts.save(existed); return noContent().build(); }) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}/status&quot;) @PUT @Consumes(MediaType.APPLICATION_JSON) @Authenticated public Response updatePostStatus(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostStatusCommand status) { return this.posts.findByIdOptional(id) .map(existed -&gt; { existed.setStatus(status.status()); Post saved = this.posts.save(existed); return noContent().build(); }) .orElse(status(NOT_FOUND).build()); } @Path(&quot;{id}&quot;) @DELETE @Authenticated public Response deletePost(@PathParam(&quot;id&quot;) final Long id) { this.posts.deleteById(id); return noContent().build(); } } To test the application manually, log in the auth0 dashboard, follow the steps we have introduced in the former Spring Security and Auth0 integration post to get a token via the Test Application provided by auth0 and then use curl command or Postman like tools to access the protected APIs. In my opinion, Quarkus test framework is not flexible as Spring. In Spring ecosystem, Spring Security provides test utilities to mock MVC and JWT decode in the unit tests, unfortunately Quarkus does not provide such a simple helper. But there are some possible approaches to test the security concern of the service type application. Add the following dependencies in the pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-test-security&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-elytron-security-properties-file-deployment&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; To focus on testing the business logic in Quarkus applications, you can set up the embedded users in a properties file to replace the real users in the database and enable Http Basic authentication to pass by the JWT token authorization. Create a src/test/resources/application-embedded-users.properties file to setup the embedded users and enable basic auth . quarkus.security.users.embedded.enabled=truequarkus.security.users.embedded.plain-text=truequarkus.security.users.embedded.users.alice=passwordquarkus.security.users.embedded.roles.alice=userquarkus.security.users.embedded.users.admin=passwordquarkus.security.users.embedded.roles.admin=adminquarkus.http.auth.basic=truequarkus.oidc.enabled=false Create a QuarkusTestProfile to categorize the test resources for some special purpose. public class PropertiesFileEmbeddedUsersProfile implements QuarkusTestProfile { @Override public String getConfigProfile() { return &quot;embedded-users&quot;; }} Create a simple test to apply this test profile via the @TestProfile annotation. @QuarkusTest@TestHTTPEndpoint(PostResource.class)@TestProfile(PropertiesFileEmbeddedUsersProfile.class)public class TestSecurityLazyAuthTest { @Test public void testGetAllPostsWithoutAuth() { //@formatter:off given() .accept(ContentType.JSON) .when() .get(&quot;&quot;) .then() .statusCode(200); //@formatter:on } @Test //@TestSecurity(authorizationEnabled = false) public void testCreatPostsWithoutAuth() { //@formatter:off given() .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;&quot;) .then() .statusCode(401); //@formatter:on } @Test @TestSecurity(user = &quot;alice&quot;, roles = &quot;user&quot;) public void testCreatPostsWithAuth() { //@formatter:off given() .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build()) .contentType(ContentType.JSON) .when() .post(&quot;&quot;) .then() .statusCode(201); //@formatter:on }} Additionally, you can generate a local RSA public/private key pair to perform the JWT token verification progress. Generating Keys with OpenSSL. openssl genrsa -out rsaPrivateKey.pem 2048openssl rsa -pubout -in rsaPrivateKey.pem -out publicKey.pem An additional step is needed for generating the private key for converting it into the PKCS#8 format. openssl pkcs8 -topk8 -nocrypt -inform pem -in rsaPrivateKey.pem -outform pem -out privateKey.pem Create a TestProfile class to setup the properties to use local public key to verify the JWT token. public class InlinedPublicKeyProfile implements QuarkusTestProfile { @Override public Map&lt;String, String&gt; getConfigOverrides() { return Map.of( &quot;quarkus.oidc.client-id&quot;, &quot;test&quot;, &quot;quarkus.oidc.public-key&quot;, &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzcAl1DgYnAkpYelL4lxl&quot; + &quot;csdX0dHj92g+pMyjzWE3nzSV8i726lTJtg5kxaJyv8epEOAiMcelFk0v+9HMOPla&quot; + &quot;6/pgkEHE5PPyaHlgegDIzge2RQLidDwl8IWBksUkfDWjQk+JfrEPJxrES4OXUOyp&quot; + &quot;mO/XsNIGcbZfopi1Ook7XIjBPohuiHBcp8Fw1NVzaP7EvyYzxcxoIpa4Y/knF1Sa&quot; + &quot;FIBuMmA/lE7PHKlBqcsS1EXkyI1TBGcdH+VWhUvsDVehKSlZoUCE6XrWY3M/xzyb&quot; + &quot;gN+C9KPln+fQZ42Fnqo6PpD++NWRo8vgWxsMsqb+nltEQADfd8CFEuLt1BvObh8N&quot; + &quot;fQIDAQAB&quot;, &quot;quarkus.oidc.token.audience&quot;, &quot;https://service.example.com&quot;, &quot;smallrye.jwt.sign.key-location&quot;, &quot;privateKey.jwk&quot; ); } } Now write a test to verify it. The getAccessToken to generate a token using our private key generated in the last step. @QuarkusTest@TestProfile(InlinedPublicKeyProfile.class)public class InlinedPublicKeyAuthorizationTest { @Test public void testBearerToken() { //@formatter:off given() .auth().oauth2(getAccessToken(&quot;alice&quot;, Set.of(&quot;user&quot;))) .body(new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;)) .contentType(ContentType.JSON) .when() .post(&quot;/posts&quot;) .then() .statusCode(201); //@formatter:on } // private String getAccessToken(String userName, Set&lt;String&gt; groups) { return Jwt.preferredUserName(userName) .claim(&quot;scope&quot;, &quot;write:posts&quot;) .groups(groups) .issuer(&quot;https://server.example.com&quot;) .audience(&quot;https://service.example.com&quot;) .jws() .keyId(&quot;1&quot;) .sign(&quot;privateKey.jwk&quot;); }} As you see, we used a custom private/public key pair in our tests to pass by fetching the public key via jwk set url from the remote authorization server. Let’s put all together and run the application. Grab the source codes from github. Start the application. docker compose up postgresqlmvn clean quarkus:dev Copy the ui codes from hantsy/spring-security-auth0-sample that we have done in Integrating Auth0 into your Angular applications. It is a SPA application written in Angular 12. npm installnpm run start Open your browser and navigate to http://localhost:4200. Login and click the Blog menu item, you will see the data from the backend API application. &lt;hr&gt;&lt;p&gt;Secures RESTful APIs with Quarkus OIDC and Auth0 was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Secures RESTful APIs with Quarkus OIDC and Auth0","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/secures-restful-apis-with-quarkus-oidc-and-auth0/"},"url":"/blog/2021/secures-restful-apis-with-quarkus-oidc-and-auth0/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Secures RESTful APIs with Quarkus OIDC and Auth0</h1>
    <p class="post-meta">June 9, 2021</p>
  </header>

  <article class="post-content">
    <p>Quarkus has great support of OAuth 2 and OIDC protocol. In this post, we will explore how to protect RESTful APIs with Quarkus OIDC and Auth0.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e8eToBkiLUtTgQeiIbxXIQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@linglivestolaugh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Ling Tang</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p><a href="https://www.quarkus.io">Quarkus</a> is well-known as a <em>supersonic subatomic Java framework</em> to build Kubernetes-friendly cloud native applications. In <a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">an earlier post</a> we have discussed how to secure RESTful APIs with Spring Security and Auth0, we will implement the same functionality with Quarkus OIDC extension.</p><p>Go to <a href="https://code.quarkus.io/">Quarkus Start Coding</a> page, make sure you have added these extensions: <em>oidc</em>, <em>resteasy</em>, <em>resteasy-jackson</em>, <em>hibernate-validator</em> , <em>hibernate-orm-panache</em>, <em>jdbc-postgresql</em>. Then generate a project skeleton as usual that we have done in the <a href="https://itnext.io/building-graphql-apis-with-quarkus-dbbf23f897df">former posts</a>. Import the source codes into your IDE.</p><p>Open the project <em>pom.xml</em> file you should see the following dependencies. Add an extra <em>Lombok</em> dependency to clean up the POJOs.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- Erase getters and setters --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>    &lt;version&gt;1.18.20&lt;/version&gt;<br>    &lt;optional&gt;true&lt;/optional&gt;<br>&lt;/dependency&gt;</pre><p>In this post we will focus on how to integrate Quarkus OIDC and Auth0. We have no plan to explain the development progress of the RESTful APIs, the details of the source codes are very similar to the ones we have discussed in <a href="https://hantsy.medium.com/kickstart-your-first-quarkus-application-cde54f469973">my introduction to Quarkus</a>. Before jumping to the next steps, check out a copy of <a href="https://github.com/hantsy/quarkus-auth0-sample">the source codes of this post from my github</a> and explore them yourself.</p><p>Unlike Spring Security, Quarkus Security does not follow the naming (resourceserver, client and authorizationserver etc.) of OAuth2 roles to categorize the configuration properties. Quarkus binds the OAuth2/OIDC configuration properties to functionality name (eg. quarkus.oidc.xxx, quarkus.oidc-flow.xxx, etc), which are confusing when you are the first time come to Quarkus world.</p><p>And most of the official Quarkus OAuth2 and OIDC examples and guides are dependent on <a href="https://www.keycloak.org/">Keycloak</a> — the open source OAuth2/OIDC compatible authorization server from Redhat. If you know well about the OAuth2/OIDC protocols, it is not diffcult to move on to Auth0.</p><p>To make Quakrus OIDC work with Auth0, add the following configuration in the <em>application.properties</em>.</p><pre># Oidc auth config for resource server<br>quarkus.oidc.client-id=backend-api<br>quarkus.oidc.auth-server-url=https://dev-ese8241b.us.auth0.com/<br>quarkus.oidc.token.audience=https://hantsy.github.io/api<br>#quarkus.oidc.application-type=service</pre><p>The default <em>quarkus.oidc.application-type</em> is <em>service</em>, which is used for identifying the application type, <em>service</em> is equivalent to <em>resourceserver</em> in Spring Security.</p><blockquote><em>Note: The </em>quarkus.oidc.client-id<em> must be provided although this is not an OAuth2 </em>client<em> role.</em></blockquote><p>When parsing the JWT token, Quarkus OIDC also can discover the <em>jwt set url</em> automatically from a base <em>auth-server-url</em> value if the authorization server supports OIDC configuratoin protocol.</p><p>When a token audience is provided, Quarkus will verify it automatically. You can also validate the audience or other items in the JWT token yourself.</p><pre>//@Provider<br>public class AudienceValidator implements ContainerRequestFilter {</pre><pre>    @Inject<br>    OidcConfigurationMetadata configMetadata;</pre><pre>    @Inject<br>    JsonWebToken jwt;</pre><pre>    @Inject<br>    SecurityIdentity identity;</pre><pre>    public void filter(ContainerRequestContext requestContext) {<br>        String aud = configMetadata.get(&quot;audience&quot;);//.replace(&quot;{tenant-id}&quot;, identity.getAttribute(&quot;tenant-id&quot;));<br>        if (!jwt.getAudience().contains(aud)) {<br>            requestContext.abortWith(Response.status(401).build());<br>        }<br>    }<br>}</pre><p>In the above example, the OidcConfigurationMetadata is the OIDC configuration properties of this application. The JsonWebToken is the parsed token claims. The SecurityIdenity is a general-purpose security context object to envelope the user principal and roles, similar to the traditional Jakarta EE SecurityContext API from JaxRS, EJB, etc.</p><p>To protect the APIs and make some APIs only be accessible for the authenticated user, Quarkus Security provides a @Authenticated annotation. The following is a modified version of PostResource in which we added @Authenticated annotations on all <em>write</em> operations to protect the resources.</p><pre>@Path(&quot;/posts&quot;)<br>@RequestScoped<br>public class PostResource {<br>    private final static Logger LOGGER = Logger.getLogger(PostResource.class.getName());</pre><pre>    private final PostRepository posts;</pre><pre>    @Context<br>    UriInfo uriInfo;</pre><pre>    @Inject<br>    public PostResource(PostRepository posts) {<br>        this.posts = posts;<br>    }</pre><pre>    @Path(&quot;count&quot;)<br>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response countAllPosts(@QueryParam(&quot;q&quot;) String q) {<br>        return ok(this.posts.countByKeyword(q)).build();<br>    }</pre><pre>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response getAllPosts(<br>            @QueryParam(&quot;q&quot;) String q,<br>            @QueryParam(&quot;offset&quot;) @DefaultValue(&quot;0&quot;) int offset,<br>            @QueryParam(&quot;limit&quot;) @DefaultValue(&quot;10&quot;) int limit</pre><pre>    ) {<br>        return ok(this.posts.findByKeyword(q, offset, limit)).build();<br>    }</pre><pre>    @POST<br>    @Consumes(MediaType.APPLICATION_JSON)<br>    @Authenticated<br>    public Response savePost(@Valid CreatePostCommand post) {<br>        Post saved = this.posts.save(Post.builder().title(post.title()).content(post.content()).build());<br>        return created(<br>                uriInfo.getBaseUriBuilder()<br>                        .path(&quot;/posts/{id}&quot;)<br>                        .build(saved.getId())<br>        ).build();<br>    }</pre><pre>    @Path(&quot;{id}&quot;)<br>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response getPostById(@PathParam(&quot;id&quot;) final Long id) {<br>        return this.posts.findByIdOptional(id)<br>                .map(post -&gt; ok(post).build())<br>                .orElse(status(NOT_FOUND).build());<br>    }</pre><pre>    @Path(&quot;{id}&quot;)<br>    @PUT<br>    @Consumes(MediaType.APPLICATION_JSON)<br>    @Authenticated<br>    public Response updatePost(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostCommand post) {<br>        return this.posts.findByIdOptional(id)<br>                .map(existed -&gt; {<br>                    existed.setTitle(post.title());<br>                    existed.setContent(post.content());</pre><pre>                    Post saved = this.posts.save(existed);<br>                    return noContent().build();<br>                })<br>                .orElse(status(NOT_FOUND).build());<br>    }</pre><pre>    @Path(&quot;{id}/status&quot;)<br>    @PUT<br>    @Consumes(MediaType.APPLICATION_JSON)<br>    @Authenticated<br>    public Response updatePostStatus(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostStatusCommand status) {<br>        return this.posts.findByIdOptional(id)<br>                .map(existed -&gt; {<br>                    existed.setStatus(status.status());<br>                    Post saved = this.posts.save(existed);<br>                    return noContent().build();<br>                })<br>                .orElse(status(NOT_FOUND).build());<br>    }</pre><pre>    @Path(&quot;{id}&quot;)<br>    @DELETE<br>    @Authenticated<br>    public Response deletePost(@PathParam(&quot;id&quot;) final Long id) {<br>        this.posts.deleteById(id);<br>        return noContent().build();<br>    }</pre><pre>}</pre><p>To test the application manually, log in the auth0 dashboard, follow the steps we have introduced in <a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">the former Spring Security and Auth0 integration post</a> to get a token via the <em>Test Application</em> provided by auth0 and then use curl command or Postman like tools to access the protected APIs.</p><p>In my opinion, Quarkus test framework is not flexible as Spring. In Spring ecosystem, Spring Security provides test utilities to mock MVC and JWT decode in the unit tests, unfortunately Quarkus does not provide such a simple helper. But there are some possible approaches to test the security concern of the <em>service</em> type application.</p><p>Add the following dependencies in the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-test-security&lt;/artifactId&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-elytron-security-properties-file-deployment&lt;/artifactId&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>To focus on testing the business logic in Quarkus applications, you can set up the embedded users in a properties file to replace the real users in the database and enable Http Basic authentication to pass by the JWT token authorization.</p><p>Create a <em>src/test/resources/application-embedded-users.properties</em> file to setup the embedded users and enable <em>basic</em> auth .</p><pre>quarkus.security.users.embedded.enabled=true<br>quarkus.security.users.embedded.plain-text=true<br>quarkus.security.users.embedded.users.alice=password<br>quarkus.security.users.embedded.roles.alice=user<br>quarkus.security.users.embedded.users.admin=password<br>quarkus.security.users.embedded.roles.admin=admin<br>quarkus.http.auth.basic=true<br>quarkus.oidc.enabled=false</pre><p>Create a QuarkusTestProfile to categorize the test resources for some special purpose.</p><pre>public class PropertiesFileEmbeddedUsersProfile implements QuarkusTestProfile {<br>    @Override<br>    public String getConfigProfile() {<br>        return &quot;embedded-users&quot;;<br>    }<br>}</pre><p>Create a simple test to apply this test profile via the @TestProfile annotation.</p><pre>@QuarkusTest<br>@TestHTTPEndpoint(PostResource.class)<br>@TestProfile(PropertiesFileEmbeddedUsersProfile.class)<br>public class TestSecurityLazyAuthTest {<br></pre><pre>    @Test<br>    public void testGetAllPostsWithoutAuth() {<br>        //@formatter:off<br>        given()<br>            .accept(ContentType.JSON)<br>        .when()<br>            .get(&quot;&quot;)<br>        .then()<br>            .statusCode(200);<br>        //@formatter:on<br>    }</pre><pre>    @Test<br>    //@TestSecurity(authorizationEnabled = false)<br>    public void testCreatPostsWithoutAuth() {<br>        //@formatter:off<br>        given()<br>            .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;&quot;)<br>        .then()<br>            .statusCode(401);<br>        //@formatter:on<br>    }</pre><pre>    @Test<br>    @TestSecurity(user = &quot;alice&quot;, roles = &quot;user&quot;)<br>    public void testCreatPostsWithAuth() {<br>        //@formatter:off<br>        given()<br>            .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;&quot;)<br>        .then()<br>            .statusCode(201);<br>        //@formatter:on<br>    }<br>}</pre><p>Additionally, you can generate a local RSA public/private key pair to perform the JWT token verification progress.</p><p>Generating Keys with OpenSSL.</p><pre>openssl genrsa -out rsaPrivateKey.pem 2048<br>openssl rsa -pubout -in rsaPrivateKey.pem -out publicKey.pem</pre><p>An additional step is needed for generating the private key for converting it into the PKCS#8 format.</p><pre>openssl pkcs8 -topk8 -nocrypt -inform pem -in rsaPrivateKey.pem -outform pem -out privateKey.pem</pre><p>Create a TestProfile class to setup the properties to use local public key to verify the JWT token.</p><pre>public class InlinedPublicKeyProfile implements QuarkusTestProfile {<br>    @Override<br>    public Map&lt;String, String&gt; getConfigOverrides() {<br>        return Map.of(<br>                &quot;quarkus.oidc.client-id&quot;, &quot;test&quot;,<br>                &quot;quarkus.oidc.public-key&quot;, &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzcAl1DgYnAkpYelL4lxl&quot; +<br>                        &quot;csdX0dHj92g+pMyjzWE3nzSV8i726lTJtg5kxaJyv8epEOAiMcelFk0v+9HMOPla&quot; +<br>                        &quot;6/pgkEHE5PPyaHlgegDIzge2RQLidDwl8IWBksUkfDWjQk+JfrEPJxrES4OXUOyp&quot; +<br>                        &quot;mO/XsNIGcbZfopi1Ook7XIjBPohuiHBcp8Fw1NVzaP7EvyYzxcxoIpa4Y/knF1Sa&quot; +<br>                        &quot;FIBuMmA/lE7PHKlBqcsS1EXkyI1TBGcdH+VWhUvsDVehKSlZoUCE6XrWY3M/xzyb&quot; +<br>                        &quot;gN+C9KPln+fQZ42Fnqo6PpD++NWRo8vgWxsMsqb+nltEQADfd8CFEuLt1BvObh8N&quot; +<br>                        &quot;fQIDAQAB&quot;,<br>                &quot;quarkus.oidc.token.audience&quot;, &quot;https://service.example.com&quot;,<br>                &quot;smallrye.jwt.sign.key-location&quot;, &quot;privateKey.jwk&quot;<br>        );<br>    }</pre><pre>}</pre><p>Now write a test to verify it. The getAccessToken to generate a token using our private key generated in the last step.</p><pre>@QuarkusTest<br>@TestProfile(InlinedPublicKeyProfile.class)<br>public class InlinedPublicKeyAuthorizationTest {</pre><pre>    @Test<br>    public void testBearerToken() {<br>        //@formatter:off<br>        given()<br>            .auth().oauth2(getAccessToken(&quot;alice&quot;, Set.of(&quot;user&quot;)))<br>            .body(new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;))<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;/posts&quot;)<br>        .then()<br>            .statusCode(201);<br>        //@formatter:on<br>    }</pre><pre>    //<br>    private String getAccessToken(String userName, Set&lt;String&gt; groups) {<br>        return Jwt.preferredUserName(userName)<br>                .claim(&quot;scope&quot;, &quot;write:posts&quot;)<br>                .groups(groups)<br>                .issuer(&quot;https://server.example.com&quot;)<br>                .audience(&quot;https://service.example.com&quot;)<br>                .jws()<br>                .keyId(&quot;1&quot;)<br>                .sign(&quot;privateKey.jwk&quot;);<br>    }<br>}</pre><p>As you see, we used a custom private/public key pair in our tests to pass by fetching the public key via jwk set url from the remote authorization server.</p><p>Let’s put all together and run the application.</p><p>Grab the <a href="https://github.com/hantsy/quarkus-auth0-sample">source codes</a> from github.</p><p>Start the application.</p><pre>docker compose up postgresql<br>mvn clean quarkus:dev</pre><p>Copy the ui codes from <a href="https://github.com/hantsy/spring-security-auth0-sample/tree/master/ui">hantsy/spring-security-auth0-sample</a> that we have done in <a href="https://itnext.io/integrating-auth0-into-your-angular-applications-42fabef31f3e">Integrating Auth0 into your Angular applications</a>. It is a SPA application written in Angular 12.</p><pre>npm install<br>npm run start</pre><p>Open your browser and navigate to <a href="http://localhost:4200">http://localhost:4200</a>. Login and click the <em>Blog</em> menu item, you will see the data from the backend <em>API</em> application.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*rH5z16Wd3GW_F2pX.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=643475a9710c" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/secures-restful-apis-with-quarkus-oidc-and-auth0-643475a9710c">Secures RESTful APIs with Quarkus OIDC and Auth0</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
