<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the Spring integration post, we use Spring to assemble the resources and start up the application. Photo by 昊蓝 毛 on Unsplash In this post, we will reuse the Spring base codes, but: Use Hibernate Reactive to replace the raw Postgres Clientand use SmallRye Mutiny Vertx bindings to replace the original Vertx API, eg. Future etc.. Add the Hibernate related dependencies into the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt; &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt; &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; In the above codes, The hibernate-reactive-core provides Hibernate Reactive which use Vertx Postgres Client, etc to implement reactive APIs, currently it supports Java 8 CompletionStage and SmallRye Mutiny. In this post, we only uses the SmallRye Mutiny APIs.The hibernate-jpamodelgen will generate the JPA Entity metadata classes when compiling the project. Add a persistence.xml configuration in the main/resources/META-INF folder. &lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot; version=&quot;2.2&quot;&gt; &lt;persistence-unit name=&quot;blogPU&quot;&gt; &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt; &lt;class&gt;com.example.demo.Post&lt;/class&gt; &lt;properties&gt; &lt;!-- PostgreSQL --&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt; &lt;!-- Credentials --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt; &lt;!-- The Vert.x SQL Client connection pool size --&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt; &lt;!-- Automatic schema export --&gt; &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- SQL statement logging --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; &lt;/persistence&gt; It is a standard JPA configuration, but here we use the specific org.hibernate.reactive.provider.ReactivePersistenceProvider as provider to provides ReactiveStreams supports. Next, add SmallRye related dependencies. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-core&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-web&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-pg-client&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt; In the DemoApplication, expose a Mutiny.SessionFactory bean. @Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&quot;blogPU&quot;) .unwrap(Mutiny.SessionFactory.class);} Note: you have to update all imports to use items from package io.vertx.mutiny, including Vertx, etc. Replace the PostRepository with the following. @Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&lt;List&lt;Post&gt;&gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList()); } public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id)); } public Uni&lt;Post&gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush)); } } public Uni&lt;Post[]&gt; saveAll(List&lt;Post&gt; data) { Post[] array = data.toArray(new Post[0]); return this.sessionFactory.withSession(session -&gt; { session.persistAll(array); session.flush(); return Uni.createFrom().item(array); }); } public Uni&lt;Integer&gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } public Uni&lt;Integer&gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } } It is very similar to the standard JPA codes, but when using Mutiny.SessionFactory to perform the queries, it will return the SmallRye Mutiny specific Uni type instead. Update the content of PostsHandler. @Component@RequiredArgsConstructorclass PostsHandler { private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName()); private final PostRepository posts; public void all(RoutingContext rc) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); this.posts.findAll() .subscribe() .with( data -&gt; { LOGGER.log(Level.INFO, &quot;posts data: {0}&quot;, data); rc.response().endAndAwait(Json.encode(data)); }, rc::fail ); } public void get(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); this.posts.findById(UUID.fromString(id)) .subscribe() .with( post -&gt; rc.response().endAndAwait(Json.encode(post)), throwable -&gt; rc.fail(404, throwable) ); } public void save(RoutingContext rc) { //rc.getBodyAsJson().mapTo(PostForm.class) var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body); var form = body.mapTo(CreatePostCommand.class); this.posts .save(Post.builder() .title(form.getTitle()) .content(form.getContent()) .build() ) .subscribe() .with( savedId -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId) .setStatusCode(201) .endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); } public void update(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body}); var form = body.mapTo(CreatePostCommand.class); this.posts.findById(UUID.fromString(id)) .flatMap( post -&gt; { post.setTitle(form.getTitle()); post.setContent(form.getContent()); return this.posts.save(post); } ) .subscribe() .with( data -&gt; rc.response().setStatusCode(204).endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); } public void delete(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var uuid = UUID.fromString(id); this.posts.findById(uuid) .flatMap( post -&gt; this.posts.deleteById(uuid) ) .subscribe() .with( data -&gt; rc.response().setStatusCode(204).endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); }} Let’s have a look at MainVerticle . //...other imports.import io.smallrye.mutiny.Uni;import io.smallrye.mutiny.vertx.core.AbstractVerticle;import io.vertx.core.json.jackson.DatabindCodec;import io.vertx.mutiny.ext.web.Router;import io.vertx.mutiny.ext.web.handler.BodyHandler; @Component@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; private final static Logger LOGGER = Logger.getLogger(MainVerticle.class.getName()); static { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public Uni&lt;Void&gt; asyncStart() { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;); // Configure routes var router = routes(postHandlers); // Create the HTTP server return vertx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onItem().invoke(() -&gt; LOGGER.info(&quot;Http server is listening on http://127.0.0.1:8888&quot;)) .onFailure().invoke(Throwable::printStackTrace) .replaceWithVoid(); } //create routes private Router routes(PostsHandler handlers) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;) .handler(handlers::all); router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler(handlers::save); router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;) .handler(handlers::get) .failureHandler(frc -&gt; frc.response().setStatusCode(404).endAndAwait()); router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler(handlers::update); router.delete(&quot;/posts/:id&quot;) .handler(handlers::delete); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router; } } The above codes are very similar to the former Spring version. The SmallRye Mutiny version Router provides some variant methods to accept a simple function instead of the original RequestHandler, eg. there is an example to use respond method. //MainVerticle.javarouter.get(&quot;/posts&quot;).produces(&quot;application/json&quot;) .respond(handlers::all); //PostHandler.javapublic Uni&lt;List&lt;Post&gt;&gt; all(RoutingContext rc) { return this.posts.findAll();} To the test the application, add the following dependency into test scope. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-junit5&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; It provides argument injection for io.vertx.mutiny.core.Vertx and TestContext in a test method . import io.vertx.mutiny.core.Vertx;import io.vertx.mutiny.core.http.HttpClientRequest;import io.vertx.mutiny.core.http.HttpClientResponse;//other imports @SpringJUnitConfig(classes = DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Autowired ApplicationContext context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .subscribe() .with(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }, testContext::failNow ); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(HttpClientRequest::send) .flatMap(HttpClientResponse::body) .subscribe() .with(buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ), e -&gt; { LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()); testContext.failNow(e); } ); } } Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In the Spring integration post, we use Spring to assemble the resources and start up the application. Photo by 昊蓝 毛 on Unsplash In this post, we will reuse the Spring base codes, but: Use Hibernate Reactive to replace the raw Postgres Clientand use SmallRye Mutiny Vertx bindings to replace the original Vertx API, eg. Future etc.. Add the Hibernate related dependencies into the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt; &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt; &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; In the above codes, The hibernate-reactive-core provides Hibernate Reactive which use Vertx Postgres Client, etc to implement reactive APIs, currently it supports Java 8 CompletionStage and SmallRye Mutiny. In this post, we only uses the SmallRye Mutiny APIs.The hibernate-jpamodelgen will generate the JPA Entity metadata classes when compiling the project. Add a persistence.xml configuration in the main/resources/META-INF folder. &lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot; version=&quot;2.2&quot;&gt; &lt;persistence-unit name=&quot;blogPU&quot;&gt; &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt; &lt;class&gt;com.example.demo.Post&lt;/class&gt; &lt;properties&gt; &lt;!-- PostgreSQL --&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt; &lt;!-- Credentials --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt; &lt;!-- The Vert.x SQL Client connection pool size --&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt; &lt;!-- Automatic schema export --&gt; &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- SQL statement logging --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; &lt;/persistence&gt; It is a standard JPA configuration, but here we use the specific org.hibernate.reactive.provider.ReactivePersistenceProvider as provider to provides ReactiveStreams supports. Next, add SmallRye related dependencies. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-core&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-web&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-pg-client&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt; In the DemoApplication, expose a Mutiny.SessionFactory bean. @Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&quot;blogPU&quot;) .unwrap(Mutiny.SessionFactory.class);} Note: you have to update all imports to use items from package io.vertx.mutiny, including Vertx, etc. Replace the PostRepository with the following. @Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&lt;List&lt;Post&gt;&gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList()); } public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id)); } public Uni&lt;Post&gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush)); } } public Uni&lt;Post[]&gt; saveAll(List&lt;Post&gt; data) { Post[] array = data.toArray(new Post[0]); return this.sessionFactory.withSession(session -&gt; { session.persistAll(array); session.flush(); return Uni.createFrom().item(array); }); } public Uni&lt;Integer&gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } public Uni&lt;Integer&gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } } It is very similar to the standard JPA codes, but when using Mutiny.SessionFactory to perform the queries, it will return the SmallRye Mutiny specific Uni type instead. Update the content of PostsHandler. @Component@RequiredArgsConstructorclass PostsHandler { private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName()); private final PostRepository posts; public void all(RoutingContext rc) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); this.posts.findAll() .subscribe() .with( data -&gt; { LOGGER.log(Level.INFO, &quot;posts data: {0}&quot;, data); rc.response().endAndAwait(Json.encode(data)); }, rc::fail ); } public void get(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); this.posts.findById(UUID.fromString(id)) .subscribe() .with( post -&gt; rc.response().endAndAwait(Json.encode(post)), throwable -&gt; rc.fail(404, throwable) ); } public void save(RoutingContext rc) { //rc.getBodyAsJson().mapTo(PostForm.class) var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body); var form = body.mapTo(CreatePostCommand.class); this.posts .save(Post.builder() .title(form.getTitle()) .content(form.getContent()) .build() ) .subscribe() .with( savedId -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId) .setStatusCode(201) .endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); } public void update(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body}); var form = body.mapTo(CreatePostCommand.class); this.posts.findById(UUID.fromString(id)) .flatMap( post -&gt; { post.setTitle(form.getTitle()); post.setContent(form.getContent()); return this.posts.save(post); } ) .subscribe() .with( data -&gt; rc.response().setStatusCode(204).endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); } public void delete(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var uuid = UUID.fromString(id); this.posts.findById(uuid) .flatMap( post -&gt; this.posts.deleteById(uuid) ) .subscribe() .with( data -&gt; rc.response().setStatusCode(204).endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); }} Let’s have a look at MainVerticle . //...other imports.import io.smallrye.mutiny.Uni;import io.smallrye.mutiny.vertx.core.AbstractVerticle;import io.vertx.core.json.jackson.DatabindCodec;import io.vertx.mutiny.ext.web.Router;import io.vertx.mutiny.ext.web.handler.BodyHandler; @Component@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; private final static Logger LOGGER = Logger.getLogger(MainVerticle.class.getName()); static { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public Uni&lt;Void&gt; asyncStart() { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;); // Configure routes var router = routes(postHandlers); // Create the HTTP server return vertx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onItem().invoke(() -&gt; LOGGER.info(&quot;Http server is listening on http://127.0.0.1:8888&quot;)) .onFailure().invoke(Throwable::printStackTrace) .replaceWithVoid(); } //create routes private Router routes(PostsHandler handlers) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;) .handler(handlers::all); router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler(handlers::save); router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;) .handler(handlers::get) .failureHandler(frc -&gt; frc.response().setStatusCode(404).endAndAwait()); router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler(handlers::update); router.delete(&quot;/posts/:id&quot;) .handler(handlers::delete); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router; } } The above codes are very similar to the former Spring version. The SmallRye Mutiny version Router provides some variant methods to accept a simple function instead of the original RequestHandler, eg. there is an example to use respond method. //MainVerticle.javarouter.get(&quot;/posts&quot;).produces(&quot;application/json&quot;) .respond(handlers::all); //PostHandler.javapublic Uni&lt;List&lt;Post&gt;&gt; all(RoutingContext rc) { return this.posts.findAll();} To the test the application, add the following dependency into test scope. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-junit5&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; It provides argument injection for io.vertx.mutiny.core.Vertx and TestContext in a test method . import io.vertx.mutiny.core.Vertx;import io.vertx.mutiny.core.http.HttpClientRequest;import io.vertx.mutiny.core.http.HttpClientResponse;//other imports @SpringJUnitConfig(classes = DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Autowired ApplicationContext context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .subscribe() .with(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }, testContext::failNow ); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(HttpClientRequest::send) .flatMap(HttpClientResponse::body) .subscribe() .with(buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ), e -&gt; { LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()); testContext.failNow(e); } ); } } Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-23T00:00:00+00:00","datePublished":"2021-07-23T00:00:00+00:00","description":"In the Spring integration post, we use Spring to assemble the resources and start up the application. Photo by 昊蓝 毛 on Unsplash In this post, we will reuse the Spring base codes, but: Use Hibernate Reactive to replace the raw Postgres Clientand use SmallRye Mutiny Vertx bindings to replace the original Vertx API, eg. Future etc.. Add the Hibernate related dependencies into the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt; &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt; &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; In the above codes, The hibernate-reactive-core provides Hibernate Reactive which use Vertx Postgres Client, etc to implement reactive APIs, currently it supports Java 8 CompletionStage and SmallRye Mutiny. In this post, we only uses the SmallRye Mutiny APIs.The hibernate-jpamodelgen will generate the JPA Entity metadata classes when compiling the project. Add a persistence.xml configuration in the main/resources/META-INF folder. &lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot; version=&quot;2.2&quot;&gt; &lt;persistence-unit name=&quot;blogPU&quot;&gt; &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt; &lt;class&gt;com.example.demo.Post&lt;/class&gt; &lt;properties&gt; &lt;!-- PostgreSQL --&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt; &lt;!-- Credentials --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt; &lt;!-- The Vert.x SQL Client connection pool size --&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt; &lt;!-- Automatic schema export --&gt; &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- SQL statement logging --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; &lt;/persistence&gt; It is a standard JPA configuration, but here we use the specific org.hibernate.reactive.provider.ReactivePersistenceProvider as provider to provides ReactiveStreams supports. Next, add SmallRye related dependencies. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-core&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-web&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-pg-client&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;&lt;/dependency&gt; In the DemoApplication, expose a Mutiny.SessionFactory bean. @Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&quot;blogPU&quot;) .unwrap(Mutiny.SessionFactory.class);} Note: you have to update all imports to use items from package io.vertx.mutiny, including Vertx, etc. Replace the PostRepository with the following. @Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&lt;List&lt;Post&gt;&gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList()); } public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id)); } public Uni&lt;Post&gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush)); } } public Uni&lt;Post[]&gt; saveAll(List&lt;Post&gt; data) { Post[] array = data.toArray(new Post[0]); return this.sessionFactory.withSession(session -&gt; { session.persistAll(array); session.flush(); return Uni.createFrom().item(array); }); } public Uni&lt;Integer&gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } public Uni&lt;Integer&gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } } It is very similar to the standard JPA codes, but when using Mutiny.SessionFactory to perform the queries, it will return the SmallRye Mutiny specific Uni type instead. Update the content of PostsHandler. @Component@RequiredArgsConstructorclass PostsHandler { private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName()); private final PostRepository posts; public void all(RoutingContext rc) {// var params = rc.queryParams();// var q = params.get(&quot;q&quot;);// var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));// var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));// LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset}); this.posts.findAll() .subscribe() .with( data -&gt; { LOGGER.log(Level.INFO, &quot;posts data: {0}&quot;, data); rc.response().endAndAwait(Json.encode(data)); }, rc::fail ); } public void get(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); this.posts.findById(UUID.fromString(id)) .subscribe() .with( post -&gt; rc.response().endAndAwait(Json.encode(post)), throwable -&gt; rc.fail(404, throwable) ); } public void save(RoutingContext rc) { //rc.getBodyAsJson().mapTo(PostForm.class) var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body); var form = body.mapTo(CreatePostCommand.class); this.posts .save(Post.builder() .title(form.getTitle()) .content(form.getContent()) .build() ) .subscribe() .with( savedId -&gt; rc.response() .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId) .setStatusCode(201) .endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); } public void update(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var body = rc.getBodyAsJson(); LOGGER.log(Level.INFO, &quot;\\npath param id: {0}\\nrequest body: {1}&quot;, new Object[]{id, body}); var form = body.mapTo(CreatePostCommand.class); this.posts.findById(UUID.fromString(id)) .flatMap( post -&gt; { post.setTitle(form.getTitle()); post.setContent(form.getContent()); return this.posts.save(post); } ) .subscribe() .with( data -&gt; rc.response().setStatusCode(204).endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); } public void delete(RoutingContext rc) { var params = rc.pathParams(); var id = params.get(&quot;id&quot;); var uuid = UUID.fromString(id); this.posts.findById(uuid) .flatMap( post -&gt; this.posts.deleteById(uuid) ) .subscribe() .with( data -&gt; rc.response().setStatusCode(204).endAndAwait(), throwable -&gt; rc.fail(404, throwable) ); }} Let’s have a look at MainVerticle . //...other imports.import io.smallrye.mutiny.Uni;import io.smallrye.mutiny.vertx.core.AbstractVerticle;import io.vertx.core.json.jackson.DatabindCodec;import io.vertx.mutiny.ext.web.Router;import io.vertx.mutiny.ext.web.handler.BodyHandler; @Component@RequiredArgsConstructorpublic class MainVerticle extends AbstractVerticle { final PostsHandler postHandlers; private final static Logger LOGGER = Logger.getLogger(MainVerticle.class.getName()); static { LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;); var objectMapper = DatabindCodec.mapper(); objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS); objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS); JavaTimeModule module = new JavaTimeModule(); objectMapper.registerModule(module); } @Override public Uni&lt;Void&gt; asyncStart() { LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;); // Configure routes var router = routes(postHandlers); // Create the HTTP server return vertx.createHttpServer() // Handle every request using the router .requestHandler(router) // Start listening .listen(8888) // Print the port .onItem().invoke(() -&gt; LOGGER.info(&quot;Http server is listening on http://127.0.0.1:8888&quot;)) .onFailure().invoke(Throwable::printStackTrace) .replaceWithVoid(); } //create routes private Router routes(PostsHandler handlers) { // Create a Router Router router = Router.router(vertx); // register BodyHandler globally. //router.route().handler(BodyHandler.create()); router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;) .handler(handlers::all); router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler(handlers::save); router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;) .handler(handlers::get) .failureHandler(frc -&gt; frc.response().setStatusCode(404).endAndAwait()); router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;) .handler(BodyHandler.create()) .handler(handlers::update); router.delete(&quot;/posts/:id&quot;) .handler(handlers::delete); router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;)); return router; } } The above codes are very similar to the former Spring version. The SmallRye Mutiny version Router provides some variant methods to accept a simple function instead of the original RequestHandler, eg. there is an example to use respond method. //MainVerticle.javarouter.get(&quot;/posts&quot;).produces(&quot;application/json&quot;) .respond(handlers::all); //PostHandler.javapublic Uni&lt;List&lt;Post&gt;&gt; all(RoutingContext rc) { return this.posts.findAll();} To the test the application, add the following dependency into test scope. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;smallrye-mutiny-vertx-junit5&lt;/artifactId&gt; &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; It provides argument injection for io.vertx.mutiny.core.Vertx and TestContext in a test method . import io.vertx.mutiny.core.Vertx;import io.vertx.mutiny.core.http.HttpClientRequest;import io.vertx.mutiny.core.http.HttpClientResponse;//other imports @SpringJUnitConfig(classes = DemoApplication.class)@TestInstance(TestInstance.Lifecycle.PER_CLASS)@ExtendWith(VertxExtension.class)public class TestMainVerticle { private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName()); @Autowired ApplicationContext context; Vertx vertx; @BeforeAll public void setupAll(VertxTestContext testContext) { vertx = context.getBean(Vertx.class); var factory = context.getBean(VerticleFactory.class); vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName()) .subscribe() .with(id -&gt; { LOGGER.info(&quot;deployed:&quot; + id); testContext.completeNow(); }, testContext::failNow ); } @Test public void testVertx(VertxTestContext testContext) { assertThat(vertx).isNotNull(); testContext.completeNow(); } @Test void testGetAll(VertxTestContext testContext) { LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;); var options = new HttpClientOptions() .setDefaultPort(8888); var client = vertx.createHttpClient(options); client.request(HttpMethod.GET, &quot;/posts&quot;) .flatMap(HttpClientRequest::send) .flatMap(HttpClientResponse::body) .subscribe() .with(buffer -&gt; testContext.verify( () -&gt; { LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()}); assertThat(buffer.toJsonArray().size()).isGreaterThan(0); testContext.completeNow(); } ), e -&gt; { LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage()); testContext.failNow(e); } ); } } Get the example codes from my github. &lt;hr&gt;&lt;p&gt;Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive/"},"url":"/blog/2021/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive</h1>
    <p class="post-meta">July 23, 2021</p>
  </header>

  <article class="post-content">
    <p>In the <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/spring.md">Spring integration post</a>, we use Spring to assemble the resources and start up the application.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lBVdgaRt4mrtNwLaEosQ4Q.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@maohaolan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">昊蓝 毛</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In this post, we will reuse the Spring base codes, but:</p><ul><li>Use Hibernate Reactive to replace the raw Postgres Client</li><li>and use SmallRye Mutiny Vertx bindings to replace the original Vertx API, eg. Future etc..</li></ul><p>Add the Hibernate related dependencies into the project <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- <a href="https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen">https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen</a> --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>In the above codes,</p><ul><li>The hibernate-reactive-core provides Hibernate Reactive which use Vertx Postgres Client, etc to implement reactive APIs, currently it supports Java 8 CompletionStage and SmallRye Mutiny. In this post, we only uses the SmallRye Mutiny APIs.</li><li>The hibernate-jpamodelgen will generate the JPA Entity metadata classes when compiling the project.</li></ul><p>Add a <em>persistence.xml</em> configuration in the <em>main/resources/META-INF</em> folder.</p><pre>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;<br>             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>             xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;<br>             version=&quot;2.2&quot;&gt;</pre><pre>    &lt;persistence-unit name=&quot;blogPU&quot;&gt;<br>        &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt;</pre><pre>        &lt;class&gt;com.example.demo.Post&lt;/class&gt;</pre><pre>        &lt;properties&gt;</pre><pre>            &lt;!-- PostgreSQL --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.url&quot;<br>                      value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt;</pre><pre>            &lt;!-- Credentials --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.user&quot;<br>                      value=&quot;user&quot;/&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.password&quot;<br>                      value=&quot;password&quot;/&gt;</pre><pre>            &lt;!-- The Vert.x SQL Client connection pool size --&gt;<br>            &lt;property name=&quot;hibernate.connection.pool_size&quot;<br>                      value=&quot;10&quot;/&gt;</pre><pre>            &lt;!-- Automatic schema export --&gt;<br>            &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot;<br>                      value=&quot;drop-and-create&quot;/&gt;</pre><pre>            &lt;!-- SQL statement logging --&gt;<br>            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt;</pre><pre>        &lt;/properties&gt;</pre><pre>    &lt;/persistence-unit&gt;</pre><pre>&lt;/persistence&gt;</pre><p>It is a standard JPA configuration, but here we use the specific org.hibernate.reactive.provider.ReactivePersistenceProvider as provider to provides ReactiveStreams supports.</p><p>Next, add SmallRye related dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-core&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-web&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-pg-client&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>In the DemoApplication, expose a Mutiny.SessionFactory bean.</p><pre>@Bean<br>public Mutiny.SessionFactory sessionFactory() {<br>    return Persistence.createEntityManagerFactory(&quot;blogPU&quot;)<br>        .unwrap(Mutiny.SessionFactory.class);<br>}</pre><blockquote><em>Note: you have to update all imports to use items from package </em><em>io.vertx.mutiny, including </em><em>Vertx, etc.</em></blockquote><p>Replace the PostRepository with the following.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class PostRepository {<br>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</pre><pre>    private final Mutiny.SessionFactory sessionFactory;</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList());<br>    }</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) {</pre><pre>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);</pre><pre>        // if keyword is provided<br>        if (q != null &amp;&amp; !q.trim().isEmpty()) {<br>            query.where(<br>                cb.or(<br>                    cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;),<br>                    cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;)<br>                )<br>            );<br>        }<br>        //perform query<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query)<br>            .setFirstResult(offset)<br>            .setMaxResults(limit)<br>            .getResultList());<br>    }<br></pre><pre>    public Uni&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id))<br>            .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id));<br>    }</pre><pre>    public Uni&lt;Post&gt; save(Post post) {<br>        if (post.getId() == null) {<br>            return this.sessionFactory.withSession(session -&gt;<br>                session.persist(post)<br>                    .chain(session::flush)<br>                    .replaceWith(post)<br>            );<br>        } else {<br>            return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush));<br>        }<br>    }</pre><pre>    public Uni&lt;Post[]&gt; saveAll(List&lt;Post&gt; data) {<br>        Post[] array = data.toArray(new Post[0]);<br>        return this.sessionFactory.withSession(session -&gt; {<br>            session.persistAll(array);<br>            session.flush();<br>            return Uni.createFrom().item(array);<br>        });<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteById(UUID id) {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // set where clause<br>        delete.where(cb.equal(root.get(Post_.id), id));<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>}</pre><p>It is very similar to the standard JPA codes, but when using Mutiny.SessionFactory to perform the queries, it will return the SmallRye Mutiny specific Uni type instead.</p><p>Update the content of PostsHandler.</p><pre>@Component<br>@RequiredArgsConstructor<br>class PostsHandler {<br>    private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName());</pre><pre>    private final PostRepository posts;<br></pre><pre>    public void all(RoutingContext rc) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        this.posts.findAll()<br>            .subscribe()<br>            .with(<br>                data -&gt; {<br>                    LOGGER.log(Level.INFO, &quot;posts data: {0}&quot;, data);<br>                    rc.response().endAndAwait(Json.encode(data));<br>                },<br>                rc::fail<br>            );<br>    }</pre><pre>    public void get(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        this.posts.findById(UUID.fromString(id))<br>            .subscribe()<br>            .with(<br>                post -&gt; rc.response().endAndAwait(Json.encode(post)),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }</pre><pre>    public void save(RoutingContext rc) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body);<br>        var form = body.mapTo(CreatePostCommand.class);<br>        this.posts<br>            .save(Post.builder()<br>                .title(form.getTitle())<br>                .content(form.getContent())<br>                .build()<br>            )<br>            .subscribe()<br>            .with(<br>                savedId -&gt; rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId)<br>                    .setStatusCode(201)<br>                    .endAndAwait(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }</pre><pre>    public void update(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body});<br>        var form = body.mapTo(CreatePostCommand.class);<br>        this.posts.findById(UUID.fromString(id))<br>            .flatMap(<br>                post -&gt; {<br>                    post.setTitle(form.getTitle());<br>                    post.setContent(form.getContent());</pre><pre>                    return this.posts.save(post);<br>                }<br>            )<br>            .subscribe()<br>            .with(<br>                data -&gt; rc.response().setStatusCode(204).endAndAwait(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }</pre><pre>    public void delete(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);</pre><pre>        var uuid = UUID.fromString(id);<br>        this.posts.findById(uuid)<br>            .flatMap(<br>                post -&gt; this.posts.deleteById(uuid)<br>            )<br>            .subscribe()<br>            .with(<br>                data -&gt; rc.response().setStatusCode(204).endAndAwait(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }<br>}</pre><p>Let’s have a look at MainVerticle .</p><pre>//...other imports.<br>import io.smallrye.mutiny.Uni;<br>import io.smallrye.mutiny.vertx.core.AbstractVerticle;<br>import io.vertx.core.json.jackson.DatabindCodec;<br>import io.vertx.mutiny.ext.web.Router;<br>import io.vertx.mutiny.ext.web.handler.BodyHandler;</pre><pre>@Component<br>@RequiredArgsConstructor<br>public class MainVerticle extends AbstractVerticle {<br>    final PostsHandler postHandlers;</pre><pre>    private final static Logger LOGGER = Logger.getLogger(MainVerticle.class.getName());</pre><pre>    static {<br>        LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;);<br>        var objectMapper = DatabindCodec.mapper();<br>        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>        objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br>        objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</pre><pre>        JavaTimeModule module = new JavaTimeModule();<br>        objectMapper.registerModule(module);<br>    }</pre><pre>    @Override<br>    public Uni&lt;Void&gt; asyncStart() {<br>        LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;);</pre><pre>        // Configure routes<br>        var router = routes(postHandlers);</pre><pre>        // Create the HTTP server<br>        return vertx.createHttpServer()<br>            // Handle every request using the router<br>            .requestHandler(router)<br>            // Start listening<br>            .listen(8888)<br>            // Print the port<br>            .onItem().invoke(() -&gt; LOGGER.info(&quot;Http server is listening on http://127.0.0.1:8888&quot;))<br>            .onFailure().invoke(Throwable::printStackTrace)<br>            .replaceWithVoid();<br>    }</pre><pre>    //create routes<br>    private Router routes(PostsHandler handlers) {</pre><pre>        // Create a Router<br>        Router router = Router.router(vertx);<br>        // register BodyHandler globally.<br>        //router.route().handler(BodyHandler.create());<br>        router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;)<br>            .handler(handlers::all);<br>        router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler(handlers::save);<br>        router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;)<br>            .handler(handlers::get)<br>            .failureHandler(frc -&gt; frc.response().setStatusCode(404).endAndAwait());<br>        router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler(handlers::update);<br>        router.delete(&quot;/posts/:id&quot;)<br>            .handler(handlers::delete);</pre><pre>        router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;));</pre><pre>        return router;<br>    }</pre><pre>}</pre><p>The above codes are very similar to the former Spring version.</p><p>The SmallRye Mutiny version Router provides some variant methods to accept a simple function instead of the original RequestHandler, eg. there is an example to use respond method.</p><pre>//MainVerticle.java<br>router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;)<br>    .respond(handlers::all);</pre><pre>//PostHandler.java<br>public Uni&lt;List&lt;Post&gt;&gt; all(RoutingContext rc) {<br>    return this.posts.findAll();<br>}</pre><p>To the test the application, add the following dependency into <em>test</em> scope.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-junit5&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>It provides argument injection for io.vertx.mutiny.core.Vertx and TestContext in a test method .</p><pre>import io.vertx.mutiny.core.Vertx;<br>import io.vertx.mutiny.core.http.HttpClientRequest;<br>import io.vertx.mutiny.core.http.HttpClientResponse;<br>//other imports</pre><pre>@SpringJUnitConfig(classes = DemoApplication.class)<br>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br>@ExtendWith(VertxExtension.class)<br>public class TestMainVerticle {<br>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());</pre><pre>    @Autowired<br>    ApplicationContext context;</pre><pre>    Vertx vertx;</pre><pre>    @BeforeAll<br>    public void setupAll(VertxTestContext testContext) {<br>        vertx = context.getBean(Vertx.class);<br>        var factory = context.getBean(VerticleFactory.class);<br>        vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName())<br>            .subscribe()<br>            .with(id -&gt; {<br>                    LOGGER.info(&quot;deployed:&quot; + id);<br>                    testContext.completeNow();<br>                },<br>                testContext::failNow<br>            );<br>    }</pre><pre>    @Test<br>    public void testVertx(VertxTestContext testContext) {<br>        assertThat(vertx).isNotNull();<br>        testContext.completeNow();<br>    }<br></pre><pre>    @Test<br>    void testGetAll(VertxTestContext testContext) {<br>        LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;);<br>        var options = new HttpClientOptions()<br>            .setDefaultPort(8888);<br>        var client = vertx.createHttpClient(options);</pre><pre>        client.request(HttpMethod.GET, &quot;/posts&quot;)<br>            .flatMap(HttpClientRequest::send)<br>            .flatMap(HttpClientResponse::body)<br>            .subscribe()<br>            .with(buffer -&gt;<br>                    testContext.verify(<br>                        () -&gt; {<br>                            LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()});<br>                            assertThat(buffer.toJsonArray().size()).isGreaterThan(0);<br>                            testContext.completeNow();<br>                        }<br>                    ),<br>                e -&gt; {<br>                    LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage());<br>                    testContext.failNow(e);<br>                }<br>            );<br>    }<br></pre><pre>}</pre><h4><a href="https://github.com/hantsy/vertx-sandbox/tree/master/mutiny-spring-hibernate">Get the example codes from my github.</a></h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5cf10b57983a" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive-5cf10b57983a">Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
