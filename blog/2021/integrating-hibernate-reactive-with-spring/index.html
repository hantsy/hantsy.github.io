<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Integrating Hibernate Reactive with Spring
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2021/integrating-hibernate-reactive-with-spring/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Integrating Hibernate Reactive with Spring" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework. Photo by Vivek Kumar on Unsplash In the former post Integrating Vertx with Spring framework and the further post , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead. Open your browser and navigate to https://start.spring.io, and generate a Spring project skeleton with the following dependencies, WebFluxLombok Extract the downloaded files into disc, and import the project into your IDE. Open the project pom.xml file, add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt; &lt;version&gt;${vertx-pg-client.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt; &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt; &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; In the above the codes: The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.The hibernate-reactive-core is the core dependency of Hibernate Reactive.Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes. Add a persistence.xml to src/main/resources/META-INF folder. &lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot; version=&quot;2.2&quot;&gt; &lt;persistence-unit name=&quot;blogPU&quot;&gt; &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt; &lt;class&gt;com.example.demo.Post&lt;/class&gt; &lt;properties&gt; &lt;!-- PostgreSQL --&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt; &lt;!-- Credentials --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt; &lt;!-- The Vert.x SQL Client connection pool size --&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt; &lt;!-- Automatic schema export --&gt; &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- SQL statement logging --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; &lt;/persistence&gt; Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this persistence.xml file. Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the persistence.xml file. @Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&quot;blogPU&quot;) .unwrap(Mutiny.SessionFactory.class);} Create a sample entity class. @Data@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)@Builder@Entity@Table(name = &quot;posts&quot;)public class Post { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) UUID id; String title; String content; @Builder.Default @Column(name = &quot;created_at&quot;) @CreationTimestamp LocalDateTime createdAt = LocalDateTime.now();} And then create a Repository class for it. @Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&lt;List&lt;Post&gt;&gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList()); } public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id)); } public Uni&lt;Post&gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush)); } } public Uni&lt;Integer&gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } public Uni&lt;Integer&gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } } Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&#39;s begin to build the web handling part. There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on Smallrye Munity project. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post. But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc. There are some possible solutions that we can use to overcome this barrier. Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor. Let’s explore them one by one. Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request. Add the following dependency to the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt; &lt;version&gt;${mutiny-reactor.version}&lt;/version&gt;&lt;/dependency&gt; The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor. The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs. @Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; public Mono&lt;ServerResponse&gt; all(ServerRequest req) { return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class); } public Mono&lt;ServerResponse&gt; create(ServerRequest req) { return req.bodyToMono(CreatePostCommand.class) .flatMap(post -&gt; this.posts.save( Post.builder() .title(post.getTitle()) .content(post.getContent()) .build() ) .convert().with(toMono()) ) .flatMap(p -&gt; ServerResponse.created(URI.create(&quot;/posts/&quot; + p.getId())).build()); } public Mono&lt;ServerResponse&gt; get(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return this.posts.findById(id).convert().with(toMono()) .flatMap(post -&gt; ServerResponse.ok().body(Mono.just(post), Post.class)) .switchIfEmpty(ServerResponse.notFound().build()); } public Mono&lt;ServerResponse&gt; update(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return Mono.zip((data) -&gt; { Post p = (Post) data[0]; UpdatePostCommand p2 = (UpdatePostCommand) data[1]; p.setTitle(p2.getTitle()); p.setContent(p2.getContent()); return p; }, this.posts.findById(id).convert().with(toMono()), req.bodyToMono(UpdatePostCommand.class) ) //.cast(Post.class) .flatMap(post -&gt; this.posts.save(post).convert().with(toMono())) .flatMap(post -&gt; ServerResponse.noContent().build()); } public Mono&lt;ServerResponse&gt; delete(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return this.posts.deleteById(id).convert().with(toMono()) .flatMap(d -&gt; ServerResponse.noContent().build()); }} Then assemble the web handlers in a RouterFunction bean. @Beanpublic RouterFunction&lt;ServerResponse&gt; routes(PostsHandler handler) { return route(GET(&quot;/posts&quot;), handler::all) .andRoute(POST(&quot;/posts&quot;), handler::create) .andRoute(GET(&quot;/posts/{id}&quot;), handler::get) .andRoute(PUT(&quot;/posts/{id}&quot;), handler::update) .andRoute(DELETE(&quot;/posts/{id}&quot;), handler::delete);} Add a DataInitializer bean to initialize some sample data when starting up the application. @Component@RequiredArgsConstructorpublic class DataInitializer implements ApplicationRunner { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private final Mutiny.SessionFactory sessionFactory; @Override public void run(ApplicationArguments args) throws Exception { LOGGER.info(&quot;Data initialization is starting...&quot;); Post first = Post.of(null, &quot;Hello Spring&quot;, &quot;My first post of Spring&quot;, null); Post second = Post.of(null, &quot;Hello Hibernate Reactive&quot;, &quot;My second Hibernate Reactive&quot;, null); sessionFactory .withTransaction( (conn, tx) -&gt; conn.createQuery(&quot;DELETE FROM Post&quot;).executeUpdate() .flatMap(r -&gt; conn.persistAll(first, second)) .chain(conn::flush) .flatMap(r -&gt; conn.createQuery(&quot;SELECT p from Post p&quot;, Post.class).getResultList()) ) .subscribe() .with( data -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, data), throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage()) ); }} Start up a Postgres database. There is a docker-compose.yml file available to start a Postgres instance in Docker container. Then run the application via Spring Boot Maven plugin. // start postgres databasedocker compose up // run the applicationmvn clean spring-root:run When the application is running successfully, open your terminal, and try to test http://localhost:8080/posts endpoints with curl command. # curl http://localhost:8080/posts[{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;},{&quot;id&quot;:&quot;e09ffa71-905f-4241-9449-0860977de666&quot;,&quot;title&quot;:&quot;Hello Hibernate Reactive&quot;,&quot;content&quot;:&quot;My second Hibernate Reactive&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.116677&quot;}] # curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;} Then let’s discuss the second solution. Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework. We’ll create a new adapter to register Mutiny APIs as expected. @Component@RequiredArgsConstructor@Slf4jpublic class MutinyAdapter { private final ReactiveAdapterRegistry registry; @PostConstruct public void registerAdapters(){ log.debug(&quot;registering MutinyAdapter&quot;); registry.registerReactiveType( ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&gt; Uni.createFrom().nothing()), uni -&gt;((Uni&lt;?&gt;)uni).convert().toPublisher(), publisher -&gt; Uni.createFrom().publisher(publisher) ); registry.registerReactiveType( ReactiveTypeDescriptor.multiValue(Multi.class, ()-&gt; Multi.createFrom().empty()), multi -&gt; (Multi&lt;?&gt;) multi, publisher-&gt; Multi.createFrom().publisher(publisher)); }} Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&lt;ResponseEntity&gt; type directly, no need explicit conversion work there. @RestController@RequestMapping(&quot;/posts&quot;)@RequiredArgsConstructorclass PostController { private final PostRepository posts; @GetMapping(value = &quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;?&gt; all() { return ok().body(this.posts.findAll()); } @PostMapping(value = &quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;?&gt;&gt; create(@RequestBody CreatePostCommand data) { return this.posts.save( Post.builder() .title(data.getTitle()) .content(data.getContent()) .build() ) .map(p -&gt; created(URI.create(&quot;/posts/&quot; + p.getId())).build()); } @GetMapping(value = &quot;{id}&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;Post&gt;&gt; get(@PathVariable UUID id) { return this.posts.findById(id) .map(post -&gt; ok().body(post)); } @PutMapping(value = &quot;{id}&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;?&gt;&gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) { return Uni.combine().all() .unis( this.posts.findById(id), Uni.createFrom().item(data) ) .combinedWith((p, d) -&gt; { p.setTitle(d.getTitle()); p.setContent(d.getContent()); return p; }) .flatMap(this.posts::save) .map(post -&gt; noContent().build()); } @DeleteMapping(&quot;{id}&quot;) public Uni&lt;ResponseEntity&lt;?&gt;&gt; delete(@PathVariable UUID id) { return this.posts.deleteById(id).map(d -&gt; noContent().build()); }} Run this application again, you will get the same result as the former solution. Get the source codes of this post from my GitHub, they are available in two separate projects, hibernate-reactive and hibernate-reactive-mutiny. &lt;hr&gt;&lt;p&gt;Integrating Hibernate Reactive with Spring was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework. Photo by Vivek Kumar on Unsplash In the former post Integrating Vertx with Spring framework and the further post , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead. Open your browser and navigate to https://start.spring.io, and generate a Spring project skeleton with the following dependencies, WebFluxLombok Extract the downloaded files into disc, and import the project into your IDE. Open the project pom.xml file, add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt; &lt;version&gt;${vertx-pg-client.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt; &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt; &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; In the above the codes: The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.The hibernate-reactive-core is the core dependency of Hibernate Reactive.Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes. Add a persistence.xml to src/main/resources/META-INF folder. &lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot; version=&quot;2.2&quot;&gt; &lt;persistence-unit name=&quot;blogPU&quot;&gt; &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt; &lt;class&gt;com.example.demo.Post&lt;/class&gt; &lt;properties&gt; &lt;!-- PostgreSQL --&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt; &lt;!-- Credentials --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt; &lt;!-- The Vert.x SQL Client connection pool size --&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt; &lt;!-- Automatic schema export --&gt; &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- SQL statement logging --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; &lt;/persistence&gt; Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this persistence.xml file. Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the persistence.xml file. @Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&quot;blogPU&quot;) .unwrap(Mutiny.SessionFactory.class);} Create a sample entity class. @Data@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)@Builder@Entity@Table(name = &quot;posts&quot;)public class Post { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) UUID id; String title; String content; @Builder.Default @Column(name = &quot;created_at&quot;) @CreationTimestamp LocalDateTime createdAt = LocalDateTime.now();} And then create a Repository class for it. @Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&lt;List&lt;Post&gt;&gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList()); } public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id)); } public Uni&lt;Post&gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush)); } } public Uni&lt;Integer&gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } public Uni&lt;Integer&gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } } Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&#39;s begin to build the web handling part. There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on Smallrye Munity project. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post. But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc. There are some possible solutions that we can use to overcome this barrier. Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor. Let’s explore them one by one. Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request. Add the following dependency to the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt; &lt;version&gt;${mutiny-reactor.version}&lt;/version&gt;&lt;/dependency&gt; The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor. The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs. @Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; public Mono&lt;ServerResponse&gt; all(ServerRequest req) { return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class); } public Mono&lt;ServerResponse&gt; create(ServerRequest req) { return req.bodyToMono(CreatePostCommand.class) .flatMap(post -&gt; this.posts.save( Post.builder() .title(post.getTitle()) .content(post.getContent()) .build() ) .convert().with(toMono()) ) .flatMap(p -&gt; ServerResponse.created(URI.create(&quot;/posts/&quot; + p.getId())).build()); } public Mono&lt;ServerResponse&gt; get(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return this.posts.findById(id).convert().with(toMono()) .flatMap(post -&gt; ServerResponse.ok().body(Mono.just(post), Post.class)) .switchIfEmpty(ServerResponse.notFound().build()); } public Mono&lt;ServerResponse&gt; update(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return Mono.zip((data) -&gt; { Post p = (Post) data[0]; UpdatePostCommand p2 = (UpdatePostCommand) data[1]; p.setTitle(p2.getTitle()); p.setContent(p2.getContent()); return p; }, this.posts.findById(id).convert().with(toMono()), req.bodyToMono(UpdatePostCommand.class) ) //.cast(Post.class) .flatMap(post -&gt; this.posts.save(post).convert().with(toMono())) .flatMap(post -&gt; ServerResponse.noContent().build()); } public Mono&lt;ServerResponse&gt; delete(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return this.posts.deleteById(id).convert().with(toMono()) .flatMap(d -&gt; ServerResponse.noContent().build()); }} Then assemble the web handlers in a RouterFunction bean. @Beanpublic RouterFunction&lt;ServerResponse&gt; routes(PostsHandler handler) { return route(GET(&quot;/posts&quot;), handler::all) .andRoute(POST(&quot;/posts&quot;), handler::create) .andRoute(GET(&quot;/posts/{id}&quot;), handler::get) .andRoute(PUT(&quot;/posts/{id}&quot;), handler::update) .andRoute(DELETE(&quot;/posts/{id}&quot;), handler::delete);} Add a DataInitializer bean to initialize some sample data when starting up the application. @Component@RequiredArgsConstructorpublic class DataInitializer implements ApplicationRunner { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private final Mutiny.SessionFactory sessionFactory; @Override public void run(ApplicationArguments args) throws Exception { LOGGER.info(&quot;Data initialization is starting...&quot;); Post first = Post.of(null, &quot;Hello Spring&quot;, &quot;My first post of Spring&quot;, null); Post second = Post.of(null, &quot;Hello Hibernate Reactive&quot;, &quot;My second Hibernate Reactive&quot;, null); sessionFactory .withTransaction( (conn, tx) -&gt; conn.createQuery(&quot;DELETE FROM Post&quot;).executeUpdate() .flatMap(r -&gt; conn.persistAll(first, second)) .chain(conn::flush) .flatMap(r -&gt; conn.createQuery(&quot;SELECT p from Post p&quot;, Post.class).getResultList()) ) .subscribe() .with( data -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, data), throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage()) ); }} Start up a Postgres database. There is a docker-compose.yml file available to start a Postgres instance in Docker container. Then run the application via Spring Boot Maven plugin. // start postgres databasedocker compose up // run the applicationmvn clean spring-root:run When the application is running successfully, open your terminal, and try to test http://localhost:8080/posts endpoints with curl command. # curl http://localhost:8080/posts[{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;},{&quot;id&quot;:&quot;e09ffa71-905f-4241-9449-0860977de666&quot;,&quot;title&quot;:&quot;Hello Hibernate Reactive&quot;,&quot;content&quot;:&quot;My second Hibernate Reactive&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.116677&quot;}] # curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;} Then let’s discuss the second solution. Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework. We’ll create a new adapter to register Mutiny APIs as expected. @Component@RequiredArgsConstructor@Slf4jpublic class MutinyAdapter { private final ReactiveAdapterRegistry registry; @PostConstruct public void registerAdapters(){ log.debug(&quot;registering MutinyAdapter&quot;); registry.registerReactiveType( ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&gt; Uni.createFrom().nothing()), uni -&gt;((Uni&lt;?&gt;)uni).convert().toPublisher(), publisher -&gt; Uni.createFrom().publisher(publisher) ); registry.registerReactiveType( ReactiveTypeDescriptor.multiValue(Multi.class, ()-&gt; Multi.createFrom().empty()), multi -&gt; (Multi&lt;?&gt;) multi, publisher-&gt; Multi.createFrom().publisher(publisher)); }} Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&lt;ResponseEntity&gt; type directly, no need explicit conversion work there. @RestController@RequestMapping(&quot;/posts&quot;)@RequiredArgsConstructorclass PostController { private final PostRepository posts; @GetMapping(value = &quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;?&gt; all() { return ok().body(this.posts.findAll()); } @PostMapping(value = &quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;?&gt;&gt; create(@RequestBody CreatePostCommand data) { return this.posts.save( Post.builder() .title(data.getTitle()) .content(data.getContent()) .build() ) .map(p -&gt; created(URI.create(&quot;/posts/&quot; + p.getId())).build()); } @GetMapping(value = &quot;{id}&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;Post&gt;&gt; get(@PathVariable UUID id) { return this.posts.findById(id) .map(post -&gt; ok().body(post)); } @PutMapping(value = &quot;{id}&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;?&gt;&gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) { return Uni.combine().all() .unis( this.posts.findById(id), Uni.createFrom().item(data) ) .combinedWith((p, d) -&gt; { p.setTitle(d.getTitle()); p.setContent(d.getContent()); return p; }) .flatMap(this.posts::save) .map(post -&gt; noContent().build()); } @DeleteMapping(&quot;{id}&quot;) public Uni&lt;ResponseEntity&lt;?&gt;&gt; delete(@PathVariable UUID id) { return this.posts.deleteById(id).map(d -&gt; noContent().build()); }} Run this application again, you will get the same result as the former solution. Get the source codes of this post from my GitHub, they are available in two separate projects, hibernate-reactive and hibernate-reactive-mutiny. &lt;hr&gt;&lt;p&gt;Integrating Hibernate Reactive with Spring was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-27T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Integrating Hibernate Reactive with Spring" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-08-27T00:00:00+00:00","datePublished":"2021-08-27T00:00:00+00:00","description":"Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework. Photo by Vivek Kumar on Unsplash In the former post Integrating Vertx with Spring framework and the further post , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead. Open your browser and navigate to https://start.spring.io, and generate a Spring project skeleton with the following dependencies, WebFluxLombok Extract the downloaded files into disc, and import the project into your IDE. Open the project pom.xml file, add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;io.vertx&lt;/groupId&gt; &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt; &lt;version&gt;${vertx-pg-client.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt; &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt; &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; In the above the codes: The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.The hibernate-reactive-core is the core dependency of Hibernate Reactive.Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes. Add a persistence.xml to src/main/resources/META-INF folder. &lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot; version=&quot;2.2&quot;&gt; &lt;persistence-unit name=&quot;blogPU&quot;&gt; &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt; &lt;class&gt;com.example.demo.Post&lt;/class&gt; &lt;properties&gt; &lt;!-- PostgreSQL --&gt; &lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt; &lt;!-- Credentials --&gt; &lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;user&quot;/&gt; &lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;password&quot;/&gt; &lt;!-- The Vert.x SQL Client connection pool size --&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt; &lt;!-- Automatic schema export --&gt; &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- SQL statement logging --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; &lt;/persistence&gt; Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this persistence.xml file. Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the persistence.xml file. @Beanpublic Mutiny.SessionFactory sessionFactory() { return Persistence.createEntityManagerFactory(&quot;blogPU&quot;) .unwrap(Mutiny.SessionFactory.class);} Create a sample entity class. @Data@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)@Builder@Entity@Table(name = &quot;posts&quot;)public class Post { @Id @GeneratedValue(generator = &quot;uuid&quot;) @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;) UUID id; String title; String content; @Builder.Default @Column(name = &quot;created_at&quot;) @CreationTimestamp LocalDateTime createdAt = LocalDateTime.now();} And then create a Repository class for it. @Component@RequiredArgsConstructorpublic class PostRepository { private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName()); private final Mutiny.SessionFactory sessionFactory; public Uni&lt;List&lt;Post&gt;&gt; findAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList()); } public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create query CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class); // set the root class Root&lt;Post&gt; root = query.from(Post.class); // if keyword is provided if (q != null &amp;&amp; !q.trim().isEmpty()) { query.where( cb.or( cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;), cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;) ) ); } //perform query return this.sessionFactory.withSession(session -&gt; session.createQuery(query) .setFirstResult(offset) .setMaxResults(limit) .getResultList()); } public Uni&lt;Post&gt; findById(UUID id) { Objects.requireNonNull(id, &quot;id can not be null&quot;); return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id)) .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id)); } public Uni&lt;Post&gt; save(Post post) { if (post.getId() == null) { return this.sessionFactory.withSession(session -&gt; session.persist(post) .chain(session::flush) .replaceWith(post) ); } else { return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush)); } } public Uni&lt;Integer&gt; deleteById(UUID id) { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // set where clause delete.where(cb.equal(root.get(Post_.id), id)); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } public Uni&lt;Integer&gt; deleteAll() { CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder(); // create delete CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class); // set the root class Root&lt;Post&gt; root = delete.from(Post.class); // perform update return this.sessionFactory.withTransaction((session, tx) -&gt; session.createQuery(delete).executeUpdate() ); } } Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&#39;s begin to build the web handling part. There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on Smallrye Munity project. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post. But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc. There are some possible solutions that we can use to overcome this barrier. Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor. Let’s explore them one by one. Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request. Add the following dependency to the project pom.xml file. &lt;dependency&gt; &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt; &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt; &lt;version&gt;${mutiny-reactor.version}&lt;/version&gt;&lt;/dependency&gt; The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor. The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs. @Component@RequiredArgsConstructorclass PostsHandler { private final PostRepository posts; public Mono&lt;ServerResponse&gt; all(ServerRequest req) { return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class); } public Mono&lt;ServerResponse&gt; create(ServerRequest req) { return req.bodyToMono(CreatePostCommand.class) .flatMap(post -&gt; this.posts.save( Post.builder() .title(post.getTitle()) .content(post.getContent()) .build() ) .convert().with(toMono()) ) .flatMap(p -&gt; ServerResponse.created(URI.create(&quot;/posts/&quot; + p.getId())).build()); } public Mono&lt;ServerResponse&gt; get(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return this.posts.findById(id).convert().with(toMono()) .flatMap(post -&gt; ServerResponse.ok().body(Mono.just(post), Post.class)) .switchIfEmpty(ServerResponse.notFound().build()); } public Mono&lt;ServerResponse&gt; update(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return Mono.zip((data) -&gt; { Post p = (Post) data[0]; UpdatePostCommand p2 = (UpdatePostCommand) data[1]; p.setTitle(p2.getTitle()); p.setContent(p2.getContent()); return p; }, this.posts.findById(id).convert().with(toMono()), req.bodyToMono(UpdatePostCommand.class) ) //.cast(Post.class) .flatMap(post -&gt; this.posts.save(post).convert().with(toMono())) .flatMap(post -&gt; ServerResponse.noContent().build()); } public Mono&lt;ServerResponse&gt; delete(ServerRequest req) { var id = UUID.fromString(req.pathVariable(&quot;id&quot;)); return this.posts.deleteById(id).convert().with(toMono()) .flatMap(d -&gt; ServerResponse.noContent().build()); }} Then assemble the web handlers in a RouterFunction bean. @Beanpublic RouterFunction&lt;ServerResponse&gt; routes(PostsHandler handler) { return route(GET(&quot;/posts&quot;), handler::all) .andRoute(POST(&quot;/posts&quot;), handler::create) .andRoute(GET(&quot;/posts/{id}&quot;), handler::get) .andRoute(PUT(&quot;/posts/{id}&quot;), handler::update) .andRoute(DELETE(&quot;/posts/{id}&quot;), handler::delete);} Add a DataInitializer bean to initialize some sample data when starting up the application. @Component@RequiredArgsConstructorpublic class DataInitializer implements ApplicationRunner { private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName()); private final Mutiny.SessionFactory sessionFactory; @Override public void run(ApplicationArguments args) throws Exception { LOGGER.info(&quot;Data initialization is starting...&quot;); Post first = Post.of(null, &quot;Hello Spring&quot;, &quot;My first post of Spring&quot;, null); Post second = Post.of(null, &quot;Hello Hibernate Reactive&quot;, &quot;My second Hibernate Reactive&quot;, null); sessionFactory .withTransaction( (conn, tx) -&gt; conn.createQuery(&quot;DELETE FROM Post&quot;).executeUpdate() .flatMap(r -&gt; conn.persistAll(first, second)) .chain(conn::flush) .flatMap(r -&gt; conn.createQuery(&quot;SELECT p from Post p&quot;, Post.class).getResultList()) ) .subscribe() .with( data -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, data), throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage()) ); }} Start up a Postgres database. There is a docker-compose.yml file available to start a Postgres instance in Docker container. Then run the application via Spring Boot Maven plugin. // start postgres databasedocker compose up // run the applicationmvn clean spring-root:run When the application is running successfully, open your terminal, and try to test http://localhost:8080/posts endpoints with curl command. # curl http://localhost:8080/posts[{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;},{&quot;id&quot;:&quot;e09ffa71-905f-4241-9449-0860977de666&quot;,&quot;title&quot;:&quot;Hello Hibernate Reactive&quot;,&quot;content&quot;:&quot;My second Hibernate Reactive&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.116677&quot;}] # curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;} Then let’s discuss the second solution. Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework. We’ll create a new adapter to register Mutiny APIs as expected. @Component@RequiredArgsConstructor@Slf4jpublic class MutinyAdapter { private final ReactiveAdapterRegistry registry; @PostConstruct public void registerAdapters(){ log.debug(&quot;registering MutinyAdapter&quot;); registry.registerReactiveType( ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&gt; Uni.createFrom().nothing()), uni -&gt;((Uni&lt;?&gt;)uni).convert().toPublisher(), publisher -&gt; Uni.createFrom().publisher(publisher) ); registry.registerReactiveType( ReactiveTypeDescriptor.multiValue(Multi.class, ()-&gt; Multi.createFrom().empty()), multi -&gt; (Multi&lt;?&gt;) multi, publisher-&gt; Multi.createFrom().publisher(publisher)); }} Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&lt;ResponseEntity&gt; type directly, no need explicit conversion work there. @RestController@RequestMapping(&quot;/posts&quot;)@RequiredArgsConstructorclass PostController { private final PostRepository posts; @GetMapping(value = &quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;?&gt; all() { return ok().body(this.posts.findAll()); } @PostMapping(value = &quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;?&gt;&gt; create(@RequestBody CreatePostCommand data) { return this.posts.save( Post.builder() .title(data.getTitle()) .content(data.getContent()) .build() ) .map(p -&gt; created(URI.create(&quot;/posts/&quot; + p.getId())).build()); } @GetMapping(value = &quot;{id}&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;Post&gt;&gt; get(@PathVariable UUID id) { return this.posts.findById(id) .map(post -&gt; ok().body(post)); } @PutMapping(value = &quot;{id}&quot;, consumes = MediaType.APPLICATION_JSON_VALUE) public Uni&lt;ResponseEntity&lt;?&gt;&gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) { return Uni.combine().all() .unis( this.posts.findById(id), Uni.createFrom().item(data) ) .combinedWith((p, d) -&gt; { p.setTitle(d.getTitle()); p.setContent(d.getContent()); return p; }) .flatMap(this.posts::save) .map(post -&gt; noContent().build()); } @DeleteMapping(&quot;{id}&quot;) public Uni&lt;ResponseEntity&lt;?&gt;&gt; delete(@PathVariable UUID id) { return this.posts.deleteById(id).map(d -&gt; noContent().build()); }} Run this application again, you will get the same result as the former solution. Get the source codes of this post from my GitHub, they are available in two separate projects, hibernate-reactive and hibernate-reactive-mutiny. &lt;hr&gt;&lt;p&gt;Integrating Hibernate Reactive with Spring was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Integrating Hibernate Reactive with Spring","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2021/integrating-hibernate-reactive-with-spring/"},"url":"/blog/2021/integrating-hibernate-reactive-with-spring/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Integrating Hibernate Reactive with Spring</h1>
    <p class="post-meta">August 27, 2021</p>
  </header>

  <article class="post-content">
    <p>Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*n4q8pWVkhuvNGMID3AOKHw.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@qriusv?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Vivek Kumar</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In the former post <a href="https://itnext.io/integrating-vertx-application-with-spring-framework-fb8fca81a357">Integrating Vertx with Spring framework</a> and <a href="https://itnext.io/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive-5cf10b57983a">the further post</a> , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead.</p><p>Open your browser and navigate to <a href="https://start.spring.io">https://start.spring.io</a>, and generate a Spring project skeleton with the following dependencies,</p><ul><li><em>WebFlux</em></li><li><em>Lombok</em></li></ul><p>Extract the downloaded files into disc, and import the project into your IDE.</p><p>Open the project <em>pom.xml</em> file, add the following dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>    &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt;<br>    &lt;version&gt;${vertx-pg-client.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;<br>    &lt;optional&gt;true&lt;/optional&gt;<br>&lt;/dependency&gt;</pre><p>In the above the codes:</p><ul><li>The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.</li><li>The hibernate-reactive-core is the core dependency of Hibernate Reactive.</li><li>Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes.</li></ul><p>Add a <em>persistence.xml</em> to <em>src/main/resources/META-INF</em> folder.</p><pre>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;<br>             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>             xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;<br>             version=&quot;2.2&quot;&gt;</pre><pre>    &lt;persistence-unit name=&quot;blogPU&quot;&gt;<br>        &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt;</pre><pre>        &lt;class&gt;com.example.demo.Post&lt;/class&gt;</pre><pre>        &lt;properties&gt;</pre><pre>            &lt;!-- PostgreSQL --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.url&quot;<br>                      value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt;</pre><pre>            &lt;!-- Credentials --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.user&quot;<br>                      value=&quot;user&quot;/&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.password&quot;<br>                      value=&quot;password&quot;/&gt;</pre><pre>            &lt;!-- The Vert.x SQL Client connection pool size --&gt;<br>            &lt;property name=&quot;hibernate.connection.pool_size&quot;<br>                      value=&quot;10&quot;/&gt;</pre><pre>            &lt;!-- Automatic schema export --&gt;<br>            &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot;<br>                      value=&quot;drop-and-create&quot;/&gt;</pre><pre>            &lt;!-- SQL statement logging --&gt;<br>            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt;</pre><pre>        &lt;/properties&gt;</pre><pre>    &lt;/persistence-unit&gt;</pre><pre>&lt;/persistence&gt;</pre><p>Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this <em>persistence.xml</em> file.</p><p>Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the <em>persistence.xml</em> file.</p><pre>@Bean<br>public Mutiny.SessionFactory sessionFactory() {<br>    return Persistence.createEntityManagerFactory(&quot;blogPU&quot;)<br>        .unwrap(Mutiny.SessionFactory.class);<br>}</pre><p>Create a sample entity class.</p><pre>@Data<br>@NoArgsConstructor<br>@AllArgsConstructor(staticName = &quot;of&quot;)<br>@Builder<br>@Entity<br>@Table(name = &quot;posts&quot;)<br>public class Post {</pre><pre>    @Id<br>    @GeneratedValue(generator = &quot;uuid&quot;)<br>    @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;)<br>    UUID id;<br>    String title;<br>    String content;</pre><pre>    @Builder.Default<br>    @Column(name = &quot;created_at&quot;)<br>    @CreationTimestamp<br>    LocalDateTime createdAt = LocalDateTime.now();<br>}</pre><p>And then create a Repository class for it.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class PostRepository {<br>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</pre><pre>    private final Mutiny.SessionFactory sessionFactory;</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList());<br>    }</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) {</pre><pre>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);</pre><pre>        // if keyword is provided<br>        if (q != null &amp;&amp; !q.trim().isEmpty()) {<br>            query.where(<br>                cb.or(<br>                    cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;),<br>                    cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;)<br>                )<br>            );<br>        }<br>        //perform query<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query)<br>            .setFirstResult(offset)<br>            .setMaxResults(limit)<br>            .getResultList());<br>    }<br></pre><pre>    public Uni&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id))<br>            .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id));<br>    }</pre><pre>    public Uni&lt;Post&gt; save(Post post) {<br>        if (post.getId() == null) {<br>            return this.sessionFactory.withSession(session -&gt;<br>                session.persist(post)<br>                    .chain(session::flush)<br>                    .replaceWith(post)<br>            );<br>        } else {<br>            return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush));<br>        }<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteById(UUID id) {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // set where clause<br>        delete.where(cb.equal(root.get(Post_.id), id));<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>}</pre><p>Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&#39;s begin to build the web handling part.</p><p>There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on <a href="https://smallrye.io/smallrye-mutiny">Smallrye Munity project</a>. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post.</p><p>But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc.</p><p>There are some possible solutions that we can use to overcome this barrier.</p><ul><li>Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.</li><li>Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor.</li></ul><p>Let’s explore them one by one.</p><p>Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request.</p><p>Add the following dependency to the project <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-reactor.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor.</p><p>The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs.</p><pre>@Component<br>@RequiredArgsConstructor<br>class PostsHandler {</pre><pre>    private final PostRepository posts;</pre><pre>    public Mono&lt;ServerResponse&gt; all(ServerRequest req) {<br>        return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class);<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; create(ServerRequest req) {<br>        return req.bodyToMono(CreatePostCommand.class)<br>            .flatMap(post -&gt; this.posts.save(<br>                        Post.builder()<br>                            .title(post.getTitle())<br>                            .content(post.getContent())<br>                            .build()<br>                    )<br>                    .convert().with(toMono())<br>            )<br>            .flatMap(p -&gt; ServerResponse.created(URI.create(&quot;/posts/&quot; + p.getId())).build());<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; get(ServerRequest req) {<br>        var id = UUID.fromString(req.pathVariable(&quot;id&quot;));<br>        return this.posts.findById(id).convert().with(toMono())<br>            .flatMap(post -&gt; ServerResponse.ok().body(Mono.just(post), Post.class))<br>            .switchIfEmpty(ServerResponse.notFound().build());<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; update(ServerRequest req) {</pre><pre>        var id = UUID.fromString(req.pathVariable(&quot;id&quot;));<br>        return Mono.zip((data) -&gt; {<br>                    Post p = (Post) data[0];<br>                    UpdatePostCommand p2 = (UpdatePostCommand) data[1];<br>                    p.setTitle(p2.getTitle());<br>                    p.setContent(p2.getContent());<br>                    return p;<br>                },<br>                this.posts.findById(id).convert().with(toMono()),<br>                req.bodyToMono(UpdatePostCommand.class)<br>            )<br>            //.cast(Post.class)<br>            .flatMap(post -&gt; this.posts.save(post).convert().with(toMono()))<br>            .flatMap(post -&gt; ServerResponse.noContent().build());<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; delete(ServerRequest req) {<br>        var id = UUID.fromString(req.pathVariable(&quot;id&quot;));<br>        return this.posts.deleteById(id).convert().with(toMono())<br>            .flatMap(d -&gt; ServerResponse.noContent().build());<br>    }<br>}</pre><p>Then assemble the web handlers in a RouterFunction bean.</p><pre>@Bean<br>public RouterFunction&lt;ServerResponse&gt; routes(PostsHandler handler) {<br>    return route(GET(&quot;/posts&quot;), handler::all)<br>        .andRoute(POST(&quot;/posts&quot;), handler::create)<br>        .andRoute(GET(&quot;/posts/{id}&quot;), handler::get)<br>        .andRoute(PUT(&quot;/posts/{id}&quot;), handler::update)<br>        .andRoute(DELETE(&quot;/posts/{id}&quot;), handler::delete);<br>}</pre><p>Add a DataInitializer bean to initialize some sample data when starting up the application.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class DataInitializer implements ApplicationRunner {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());</pre><pre>    private final Mutiny.SessionFactory sessionFactory;</pre><pre>    @Override<br>    public void run(ApplicationArguments args) throws Exception {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;);</pre><pre>        Post first = Post.of(null, &quot;Hello Spring&quot;, &quot;My first post of Spring&quot;, null);<br>        Post second = Post.of(null, &quot;Hello Hibernate Reactive&quot;, &quot;My second Hibernate Reactive&quot;, null);</pre><pre>        sessionFactory<br>            .withTransaction(<br>                (conn, tx) -&gt; conn.createQuery(&quot;DELETE FROM Post&quot;).executeUpdate()<br>                    .flatMap(r -&gt; conn.persistAll(first, second))<br>                    .chain(conn::flush)<br>                    .flatMap(r -&gt; conn.createQuery(&quot;SELECT p from Post p&quot;, Post.class).getResultList())<br>            )<br>            .subscribe()<br>            .with(<br>                data -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, data),<br>                throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage())<br>            );<br>    }<br>}</pre><p>Start up a Postgres database. There is a <a href="https://github.com/hantsy/spring-puzzles/blob/master/hibernate-reactive/docker-compose.yml"><em>docker-compose.yml</em></a> file available to start a Postgres instance in Docker container.</p><p>Then run the application via Spring Boot Maven plugin.</p><pre>// start postgres database<br>docker compose up </pre><pre>// run the application<br>mvn clean spring-root:run</pre><p>When the application is running successfully, open your terminal, and try to test <a href="http://localhost:8080/posts">http://localhost:8080/posts</a> endpoints with curl command.</p><pre># curl http://localhost:8080/posts<br>[{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;},{&quot;id&quot;:&quot;e09ffa71-905f-4241-9449-0860977de666&quot;,&quot;title&quot;:&quot;Hello Hibernate Reactive&quot;,&quot;content&quot;:&quot;My second Hibernate Reactive&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.116677&quot;}]</pre><pre># curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f<br>{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;}</pre><p>Then let’s discuss the second solution.</p><p>Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework.</p><p>We’ll create a new adapter to register Mutiny APIs as expected.</p><pre>@Component<br>@RequiredArgsConstructor<br>@Slf4j<br>public class MutinyAdapter {<br>    private final ReactiveAdapterRegistry registry;</pre><pre>    @PostConstruct<br>    public void registerAdapters(){<br>        log.debug(&quot;registering MutinyAdapter&quot;);<br>        registry.registerReactiveType(<br>            ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&gt; Uni.createFrom().nothing()),<br>            uni -&gt;((Uni&lt;?&gt;)uni).convert().toPublisher(),<br>            publisher -&gt;  Uni.createFrom().publisher(publisher)<br>        );</pre><pre>        registry.registerReactiveType(<br>            ReactiveTypeDescriptor.multiValue(Multi.class, ()-&gt; Multi.createFrom().empty()),<br>            multi -&gt; (Multi&lt;?&gt;) multi,<br>            publisher-&gt; Multi.createFrom().publisher(publisher));<br>    }<br>}</pre><p>Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&lt;ResponseEntity&gt; type directly, no need explicit conversion work there.</p><pre>@RestController<br>@RequestMapping(&quot;/posts&quot;)<br>@RequiredArgsConstructor<br>class PostController {</pre><pre>    private final PostRepository posts;</pre><pre>    @GetMapping(value = &quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE)<br>    public ResponseEntity&lt;?&gt; all() {<br>        return ok().body(this.posts.findAll());<br>    }</pre><pre>    @PostMapping(value = &quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)<br>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; create(@RequestBody CreatePostCommand data) {<br>        return this.posts.save(<br>                Post.builder()<br>                    .title(data.getTitle())<br>                    .content(data.getContent())<br>                    .build()<br>            )<br>            .map(p -&gt; created(URI.create(&quot;/posts/&quot; + p.getId())).build());<br>    }</pre><pre>    @GetMapping(value = &quot;{id}&quot;, produces = MediaType.APPLICATION_JSON_VALUE)<br>    public Uni&lt;ResponseEntity&lt;Post&gt;&gt; get(@PathVariable UUID id) {<br>        return this.posts.findById(id)<br>            .map(post -&gt; ok().body(post));<br>    }</pre><pre>    @PutMapping(value = &quot;{id}&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)<br>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) {</pre><pre>        return Uni.combine().all()<br>            .unis(<br>                this.posts.findById(id),<br>                Uni.createFrom().item(data)<br>            )<br>            .combinedWith((p, d) -&gt; {<br>                p.setTitle(d.getTitle());<br>                p.setContent(d.getContent());<br>                return p;<br>            })<br>            .flatMap(this.posts::save)<br>            .map(post -&gt; noContent().build());<br>    }</pre><pre>    @DeleteMapping(&quot;{id}&quot;)<br>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; delete(@PathVariable UUID id) {<br>        return this.posts.deleteById(id).map(d -&gt; noContent().build());<br>    }<br>}</pre><p>Run this application again, you will get the same result as the former solution.</p><h4>Get the source codes of this post from my GitHub, they are available in two separate projects, <a href="https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive">hibernate-reactive</a> and <a href="https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive-mutiny">hibernate-reactive-mutiny</a>.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5427440607fe" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/integrating-hibernate-reactive-with-spring-5427440607fe">Integrating Hibernate Reactive with Spring</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
