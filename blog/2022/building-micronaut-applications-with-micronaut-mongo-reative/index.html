<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building Micronaut applications with Micronaut Mongo Reative
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2022/building-micronaut-applications-with-micronaut-mongo-reative/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building Micronaut applications with Micronaut Mongo Reative" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties. Photo by Fabian Mardi on Unsplash Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: JavaBuild tool: GradleTest framework: SpockIncluded Features: mongo-reactive etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests. Create a Mongo document entity class. @Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)public class Customer { private ObjectId id; private String name; private int age; private Address address; public static Customer of(String name, int age, Address address) { return Customer.of(null, name, age, address); }} The Address is an embedded Document in a Customer Document. @Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)public class Address { private String street; private String city; private String zip;} Create a Repository class to perform CRUD operations on Customer. @Singleton@RequiredArgsConstructor@Slf4jpublic class CustomerRepository { private final MongoClient mongoClient; private final DefaultMongoConfiguration mongoConfiguration; public Flux&lt;Customer&gt; findAll() { return Flux.from(customersCollection().find()); } public Mono&lt;Customer&gt; findById(ObjectId id) { return Mono.from(customersCollection().find(Filters.eq(id))); } public Mono&lt;ObjectId&gt; insertOne(Customer data) { return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false))) .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue()); } public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) { return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true))) .map(InsertManyResult::getInsertedIds); } public Mono&lt;Long&gt; deleteById(ObjectId id) { return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } public void init() { var people = List.of( Customer.of(&quot;Charles Babbage&quot;, 45, Address.of(&quot;5 Devonshire Street&quot;, &quot;London&quot;, &quot;W11&quot;)), Customer.of(&quot;Alan Turing&quot;, 28, Address.of(&quot;Bletchley Hall&quot;, &quot;Bletchley Park&quot;, &quot;MK12&quot;)), Customer.of(&quot;Timothy Berners-Lee&quot;, 61, Address.of(&quot;Colehill&quot;, &quot;Wimborne&quot;, null)) ); Mono.from(customersCollection().drop()) .then() .thenMany(this.insertMany(people)) .subscribe( result -&gt; result.forEach((key, value) -&gt; log.debug(&quot;saved key: {}, value: {}&quot;, key, value)), error -&gt; log.debug(&quot;initialization failed: {}&quot;, error), () -&gt; log.debug(&quot;done&quot;) ); } public Mono&lt;Long&gt; deleteAll() { return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } private MongoCollection&lt;Customer&gt; customersCollection() { return mongoClient .getDatabase(&quot;userdb&quot;) .getCollection(&quot;customers&quot;, Customer.class); } } When a mongo.uri is set in the application.yml, there is a reactive MongoClient bean is available. In the above codes: The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the customers document _id in MongoDB automatically.The MongoClient provides methods for CRUD operations, but it is based on the Reactive Streams APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs. Now let’s create a test to test the CustomerRepository. @MicronautTest(startApplication = false)@Slf4jclass CustomerRepositorySpec extends Specification { @Inject EmbeddedApplication&lt;?&gt; application @Inject CustomerRepository customerRepository; def setup() { CountDownLatch latch = new CountDownLatch(1) customerRepository.deleteAll() .doOnTerminate(_ -&gt; latch.countDown()) .subscribe(it -&gt; log.debug &quot;deleted customers: {}&quot;, it) latch.await(1000, TimeUnit.MILLISECONDS) } void &#39;application is not running&#39;() { expect: !application.running } void &#39;test findAll&#39;() { given: this.customerRepository.insertMany(List.of(Customer.of(&quot;Jack&quot;, 40, null))) .block(Duration.ofMillis(5000L)) when: def result = this.customerRepository.findAll() then: StepVerifier.create(result) .expectNextMatches(it -&gt; it.name == &quot;Jack&quot;) .expectComplete() .verify() }} To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation. Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten. In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams. If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification. @Shared@AutoCleanupGenericContainer mongo = new GenericContainer(&quot;mongo&quot;) .withExposedPorts(27017) def setupSpec() { mongo.start()} Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose. @Singleton@Requires(notEnv = &quot;mock&quot;)@Slf4j@RequiredArgsConstructorpublic class DataInitializer { private final CustomerRepository customerRepository; @EventListener public void onStart(ServerStartupEvent event) { log.debug(&quot;starting data initialization...&quot;); this.customerRepository.init(); }} Try to create a controller to expose the RESTful APIs. @Controller(&quot;/customers&quot;)@RequiredArgsConstructor@Slf4jpublic class CustomerController { private final CustomerRepository customerRepository; @Get(uri = &quot;/&quot;, produces = {MediaType.APPLICATION_JSON}) public Flux&lt;?&gt; all() { return this.customerRepository.findAll(); } @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_JSON}) public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) { return this.customerRepository.findById(id) .map(HttpResponse::ok) .switchIfEmpty(Mono.just(notFound())); } @Post(uri = &quot;/&quot;, consumes = {MediaType.APPLICATION_JSON}) public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) { return this.customerRepository.insertOne(data) .map(id -&gt; created(URI.create(&quot;/customers/&quot; + id.toHexString()))); } @Delete(uri = &quot;/{id}&quot;) public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) { return this.customerRepository.deleteById(id) .map(deleted -&gt; { if (deleted &gt; 0) { return noContent(); } else { return notFound(); } }); }} To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId. @Singletonpublic class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; { @Override public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) { return Optional.of(new ObjectId(object)); }} In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object. @Singletonpublic class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; { @Override public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeString(value.toHexString()); }} Create a test for the CustomerController. @MicronautTest(environments = [&quot;mock&quot;])class CustomerControllerSpec extends Specification { @Inject EmbeddedApplication&lt;?&gt; application @Inject @Client(&quot;/&quot;) ReactorHttpClient client @Inject CustomerRepository customerRepository def &#39;test it works&#39;() { expect: application.running } void &#39;get all customers&#39;() { given: 1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null)) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers&quot;), String).log() then: //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null)) StepVerifier.create(resFlux) //.expectNextCount(1) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&#39;Jack&#39;) }) .expectComplete() .verify() } void &#39;create a new customer&#39;() { given: def objId = ObjectId.get() 1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId) when: def body = Customer.of(null, &quot;Jack&quot;, 40, null) Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST(&quot;/customers&quot;, body), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.CREATED assert s.header(&quot;Location&quot;) == &#39;/customers/&#39; + objId.toHexString() }) .expectComplete() .verify() } void &#39;get customer by id &#39;() { given: 1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null)) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&#39;Jack&#39;) }) .expectComplete() .verify() } void &#39;get customer by none-existing id &#39;() { given: 1 * customerRepository.findById(_) &gt;&gt; Mono.empty() when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } void &#39;delete customer by id &#39;() { given: 1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.NO_CONTENT }) .expectComplete() .verify() } void &#39;delete customer by none-existing id &#39;() { given: 1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } @MockBean(CustomerRepository) CustomerRepository mockedCustomerRepository() {// must use explicit type declaration Mock(CustomerRepository) }} In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place. Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service. Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage. Firstly declare a GridFSBucket bean. @Factorypublic class GridFSConfig { @Bean GridFSBucket gridFSBucket(MongoClient client) { return GridFSBuckets.create(client.getDatabase(&quot;photos&quot;)) .withChunkSizeBytes(4096) //.withReadConcern(ReadConcern.MAJORITY) .withWriteConcern(WriteConcern.MAJORITY); }} Now create a controller to handle the file upload and download. @Controller(&quot;/photos&quot;)@RequiredArgsConstructor@Slf4jpublic class PhotoController { private final GridFSBucket bucket; @Post(uri = &quot;/&quot;, consumes = {MediaType.MULTIPART_FORM_DATA}) public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) { var filename = file.getFilename(); var name = file.getName(); var contentType = file.getContentType(); var size = file.getSize(); log.debug(&quot;uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} &quot;, filename, name, contentType, size); var options = new GridFSUploadOptions(); contentType.ifPresent(c -&gt; options.metadata(new Document(&quot;contentType&quot;, c))); return Mono.from(this.bucket.uploadFromPublisher( filename, Mono.from(file).mapNotNull(partData -&gt; { try { return partData.getByteBuffer(); } catch (IOException e) { e.printStackTrace(); } return null; }), options ) ) .map(ObjectId::toHexString) .map(id -&gt; ok(Map.of(&quot;id&quot;, id))); } @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_OCTET_STREAM}) public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) { return Mono.from(this.bucket.downloadToPublisher(id)) .map(HttpResponse::ok); } @Delete(uri = &quot;/{id}&quot;) public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) { return Mono.from(this.bucket.delete(id)) .map(v -&gt; noContent()); }} To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method. Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Mongo Reative was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties. Photo by Fabian Mardi on Unsplash Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: JavaBuild tool: GradleTest framework: SpockIncluded Features: mongo-reactive etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests. Create a Mongo document entity class. @Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)public class Customer { private ObjectId id; private String name; private int age; private Address address; public static Customer of(String name, int age, Address address) { return Customer.of(null, name, age, address); }} The Address is an embedded Document in a Customer Document. @Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)public class Address { private String street; private String city; private String zip;} Create a Repository class to perform CRUD operations on Customer. @Singleton@RequiredArgsConstructor@Slf4jpublic class CustomerRepository { private final MongoClient mongoClient; private final DefaultMongoConfiguration mongoConfiguration; public Flux&lt;Customer&gt; findAll() { return Flux.from(customersCollection().find()); } public Mono&lt;Customer&gt; findById(ObjectId id) { return Mono.from(customersCollection().find(Filters.eq(id))); } public Mono&lt;ObjectId&gt; insertOne(Customer data) { return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false))) .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue()); } public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) { return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true))) .map(InsertManyResult::getInsertedIds); } public Mono&lt;Long&gt; deleteById(ObjectId id) { return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } public void init() { var people = List.of( Customer.of(&quot;Charles Babbage&quot;, 45, Address.of(&quot;5 Devonshire Street&quot;, &quot;London&quot;, &quot;W11&quot;)), Customer.of(&quot;Alan Turing&quot;, 28, Address.of(&quot;Bletchley Hall&quot;, &quot;Bletchley Park&quot;, &quot;MK12&quot;)), Customer.of(&quot;Timothy Berners-Lee&quot;, 61, Address.of(&quot;Colehill&quot;, &quot;Wimborne&quot;, null)) ); Mono.from(customersCollection().drop()) .then() .thenMany(this.insertMany(people)) .subscribe( result -&gt; result.forEach((key, value) -&gt; log.debug(&quot;saved key: {}, value: {}&quot;, key, value)), error -&gt; log.debug(&quot;initialization failed: {}&quot;, error), () -&gt; log.debug(&quot;done&quot;) ); } public Mono&lt;Long&gt; deleteAll() { return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } private MongoCollection&lt;Customer&gt; customersCollection() { return mongoClient .getDatabase(&quot;userdb&quot;) .getCollection(&quot;customers&quot;, Customer.class); } } When a mongo.uri is set in the application.yml, there is a reactive MongoClient bean is available. In the above codes: The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the customers document _id in MongoDB automatically.The MongoClient provides methods for CRUD operations, but it is based on the Reactive Streams APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs. Now let’s create a test to test the CustomerRepository. @MicronautTest(startApplication = false)@Slf4jclass CustomerRepositorySpec extends Specification { @Inject EmbeddedApplication&lt;?&gt; application @Inject CustomerRepository customerRepository; def setup() { CountDownLatch latch = new CountDownLatch(1) customerRepository.deleteAll() .doOnTerminate(_ -&gt; latch.countDown()) .subscribe(it -&gt; log.debug &quot;deleted customers: {}&quot;, it) latch.await(1000, TimeUnit.MILLISECONDS) } void &#39;application is not running&#39;() { expect: !application.running } void &#39;test findAll&#39;() { given: this.customerRepository.insertMany(List.of(Customer.of(&quot;Jack&quot;, 40, null))) .block(Duration.ofMillis(5000L)) when: def result = this.customerRepository.findAll() then: StepVerifier.create(result) .expectNextMatches(it -&gt; it.name == &quot;Jack&quot;) .expectComplete() .verify() }} To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation. Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten. In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams. If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification. @Shared@AutoCleanupGenericContainer mongo = new GenericContainer(&quot;mongo&quot;) .withExposedPorts(27017) def setupSpec() { mongo.start()} Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose. @Singleton@Requires(notEnv = &quot;mock&quot;)@Slf4j@RequiredArgsConstructorpublic class DataInitializer { private final CustomerRepository customerRepository; @EventListener public void onStart(ServerStartupEvent event) { log.debug(&quot;starting data initialization...&quot;); this.customerRepository.init(); }} Try to create a controller to expose the RESTful APIs. @Controller(&quot;/customers&quot;)@RequiredArgsConstructor@Slf4jpublic class CustomerController { private final CustomerRepository customerRepository; @Get(uri = &quot;/&quot;, produces = {MediaType.APPLICATION_JSON}) public Flux&lt;?&gt; all() { return this.customerRepository.findAll(); } @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_JSON}) public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) { return this.customerRepository.findById(id) .map(HttpResponse::ok) .switchIfEmpty(Mono.just(notFound())); } @Post(uri = &quot;/&quot;, consumes = {MediaType.APPLICATION_JSON}) public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) { return this.customerRepository.insertOne(data) .map(id -&gt; created(URI.create(&quot;/customers/&quot; + id.toHexString()))); } @Delete(uri = &quot;/{id}&quot;) public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) { return this.customerRepository.deleteById(id) .map(deleted -&gt; { if (deleted &gt; 0) { return noContent(); } else { return notFound(); } }); }} To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId. @Singletonpublic class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; { @Override public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) { return Optional.of(new ObjectId(object)); }} In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object. @Singletonpublic class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; { @Override public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeString(value.toHexString()); }} Create a test for the CustomerController. @MicronautTest(environments = [&quot;mock&quot;])class CustomerControllerSpec extends Specification { @Inject EmbeddedApplication&lt;?&gt; application @Inject @Client(&quot;/&quot;) ReactorHttpClient client @Inject CustomerRepository customerRepository def &#39;test it works&#39;() { expect: application.running } void &#39;get all customers&#39;() { given: 1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null)) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers&quot;), String).log() then: //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null)) StepVerifier.create(resFlux) //.expectNextCount(1) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&#39;Jack&#39;) }) .expectComplete() .verify() } void &#39;create a new customer&#39;() { given: def objId = ObjectId.get() 1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId) when: def body = Customer.of(null, &quot;Jack&quot;, 40, null) Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST(&quot;/customers&quot;, body), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.CREATED assert s.header(&quot;Location&quot;) == &#39;/customers/&#39; + objId.toHexString() }) .expectComplete() .verify() } void &#39;get customer by id &#39;() { given: 1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null)) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&#39;Jack&#39;) }) .expectComplete() .verify() } void &#39;get customer by none-existing id &#39;() { given: 1 * customerRepository.findById(_) &gt;&gt; Mono.empty() when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } void &#39;delete customer by id &#39;() { given: 1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.NO_CONTENT }) .expectComplete() .verify() } void &#39;delete customer by none-existing id &#39;() { given: 1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } @MockBean(CustomerRepository) CustomerRepository mockedCustomerRepository() {// must use explicit type declaration Mock(CustomerRepository) }} In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place. Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service. Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage. Firstly declare a GridFSBucket bean. @Factorypublic class GridFSConfig { @Bean GridFSBucket gridFSBucket(MongoClient client) { return GridFSBuckets.create(client.getDatabase(&quot;photos&quot;)) .withChunkSizeBytes(4096) //.withReadConcern(ReadConcern.MAJORITY) .withWriteConcern(WriteConcern.MAJORITY); }} Now create a controller to handle the file upload and download. @Controller(&quot;/photos&quot;)@RequiredArgsConstructor@Slf4jpublic class PhotoController { private final GridFSBucket bucket; @Post(uri = &quot;/&quot;, consumes = {MediaType.MULTIPART_FORM_DATA}) public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) { var filename = file.getFilename(); var name = file.getName(); var contentType = file.getContentType(); var size = file.getSize(); log.debug(&quot;uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} &quot;, filename, name, contentType, size); var options = new GridFSUploadOptions(); contentType.ifPresent(c -&gt; options.metadata(new Document(&quot;contentType&quot;, c))); return Mono.from(this.bucket.uploadFromPublisher( filename, Mono.from(file).mapNotNull(partData -&gt; { try { return partData.getByteBuffer(); } catch (IOException e) { e.printStackTrace(); } return null; }), options ) ) .map(ObjectId::toHexString) .map(id -&gt; ok(Map.of(&quot;id&quot;, id))); } @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_OCTET_STREAM}) public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) { return Mono.from(this.bucket.downloadToPublisher(id)) .map(HttpResponse::ok); } @Delete(uri = &quot;/{id}&quot;) public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) { return Mono.from(this.bucket.delete(id)) .map(v -&gt; noContent()); }} To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method. Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Mongo Reative was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-05T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building Micronaut applications with Micronaut Mongo Reative" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-05T00:00:00+00:00","datePublished":"2022-02-05T00:00:00+00:00","description":"In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties. Photo by Fabian Mardi on Unsplash Getting Started Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page. Java version: 17Language: JavaBuild tool: GradleTest framework: SpockIncluded Features: mongo-reactive etc. Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA. In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests. Create a Mongo document entity class. @Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)public class Customer { private ObjectId id; private String name; private int age; private Address address; public static Customer of(String name, int age, Address address) { return Customer.of(null, name, age, address); }} The Address is an embedded Document in a Customer Document. @Data@Builder@NoArgsConstructor@AllArgsConstructor(staticName = &quot;of&quot;)public class Address { private String street; private String city; private String zip;} Create a Repository class to perform CRUD operations on Customer. @Singleton@RequiredArgsConstructor@Slf4jpublic class CustomerRepository { private final MongoClient mongoClient; private final DefaultMongoConfiguration mongoConfiguration; public Flux&lt;Customer&gt; findAll() { return Flux.from(customersCollection().find()); } public Mono&lt;Customer&gt; findById(ObjectId id) { return Mono.from(customersCollection().find(Filters.eq(id))); } public Mono&lt;ObjectId&gt; insertOne(Customer data) { return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false))) .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue()); } public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) { return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true))) .map(InsertManyResult::getInsertedIds); } public Mono&lt;Long&gt; deleteById(ObjectId id) { return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } public void init() { var people = List.of( Customer.of(&quot;Charles Babbage&quot;, 45, Address.of(&quot;5 Devonshire Street&quot;, &quot;London&quot;, &quot;W11&quot;)), Customer.of(&quot;Alan Turing&quot;, 28, Address.of(&quot;Bletchley Hall&quot;, &quot;Bletchley Park&quot;, &quot;MK12&quot;)), Customer.of(&quot;Timothy Berners-Lee&quot;, 61, Address.of(&quot;Colehill&quot;, &quot;Wimborne&quot;, null)) ); Mono.from(customersCollection().drop()) .then() .thenMany(this.insertMany(people)) .subscribe( result -&gt; result.forEach((key, value) -&gt; log.debug(&quot;saved key: {}, value: {}&quot;, key, value)), error -&gt; log.debug(&quot;initialization failed: {}&quot;, error), () -&gt; log.debug(&quot;done&quot;) ); } public Mono&lt;Long&gt; deleteAll() { return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions())) .map(DeleteResult::getDeletedCount); } private MongoCollection&lt;Customer&gt; customersCollection() { return mongoClient .getDatabase(&quot;userdb&quot;) .getCollection(&quot;customers&quot;, Customer.class); } } When a mongo.uri is set in the application.yml, there is a reactive MongoClient bean is available. In the above codes: The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the customers document _id in MongoDB automatically.The MongoClient provides methods for CRUD operations, but it is based on the Reactive Streams APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs. Now let’s create a test to test the CustomerRepository. @MicronautTest(startApplication = false)@Slf4jclass CustomerRepositorySpec extends Specification { @Inject EmbeddedApplication&lt;?&gt; application @Inject CustomerRepository customerRepository; def setup() { CountDownLatch latch = new CountDownLatch(1) customerRepository.deleteAll() .doOnTerminate(_ -&gt; latch.countDown()) .subscribe(it -&gt; log.debug &quot;deleted customers: {}&quot;, it) latch.await(1000, TimeUnit.MILLISECONDS) } void &#39;application is not running&#39;() { expect: !application.running } void &#39;test findAll&#39;() { given: this.customerRepository.insertMany(List.of(Customer.of(&quot;Jack&quot;, 40, null))) .block(Duration.ofMillis(5000L)) when: def result = this.customerRepository.findAll() then: StepVerifier.create(result) .expectNextMatches(it -&gt; it.name == &quot;Jack&quot;) .expectComplete() .verify() }} To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation. Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten. In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams. If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification. @Shared@AutoCleanupGenericContainer mongo = new GenericContainer(&quot;mongo&quot;) .withExposedPorts(27017) def setupSpec() { mongo.start()} Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose. @Singleton@Requires(notEnv = &quot;mock&quot;)@Slf4j@RequiredArgsConstructorpublic class DataInitializer { private final CustomerRepository customerRepository; @EventListener public void onStart(ServerStartupEvent event) { log.debug(&quot;starting data initialization...&quot;); this.customerRepository.init(); }} Try to create a controller to expose the RESTful APIs. @Controller(&quot;/customers&quot;)@RequiredArgsConstructor@Slf4jpublic class CustomerController { private final CustomerRepository customerRepository; @Get(uri = &quot;/&quot;, produces = {MediaType.APPLICATION_JSON}) public Flux&lt;?&gt; all() { return this.customerRepository.findAll(); } @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_JSON}) public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) { return this.customerRepository.findById(id) .map(HttpResponse::ok) .switchIfEmpty(Mono.just(notFound())); } @Post(uri = &quot;/&quot;, consumes = {MediaType.APPLICATION_JSON}) public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) { return this.customerRepository.insertOne(data) .map(id -&gt; created(URI.create(&quot;/customers/&quot; + id.toHexString()))); } @Delete(uri = &quot;/{id}&quot;) public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) { return this.customerRepository.deleteById(id) .map(deleted -&gt; { if (deleted &gt; 0) { return noContent(); } else { return notFound(); } }); }} To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId. @Singletonpublic class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; { @Override public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) { return Optional.of(new ObjectId(object)); }} In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object. @Singletonpublic class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; { @Override public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeString(value.toHexString()); }} Create a test for the CustomerController. @MicronautTest(environments = [&quot;mock&quot;])class CustomerControllerSpec extends Specification { @Inject EmbeddedApplication&lt;?&gt; application @Inject @Client(&quot;/&quot;) ReactorHttpClient client @Inject CustomerRepository customerRepository def &#39;test it works&#39;() { expect: application.running } void &#39;get all customers&#39;() { given: 1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null)) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers&quot;), String).log() then: //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null)) StepVerifier.create(resFlux) //.expectNextCount(1) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&#39;Jack&#39;) }) .expectComplete() .verify() } void &#39;create a new customer&#39;() { given: def objId = ObjectId.get() 1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId) when: def body = Customer.of(null, &quot;Jack&quot;, 40, null) Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST(&quot;/customers&quot;, body), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.CREATED assert s.header(&quot;Location&quot;) == &#39;/customers/&#39; + objId.toHexString() }) .expectComplete() .verify() } void &#39;get customer by id &#39;() { given: 1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null)) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.OK assert s.body().contains(&#39;Jack&#39;) }) .expectComplete() .verify() } void &#39;get customer by none-existing id &#39;() { given: 1 * customerRepository.findById(_) &gt;&gt; Mono.empty() when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } void &#39;delete customer by id &#39;() { given: 1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeNextWith(s -&gt; { assert s.getStatus() == HttpStatus.NO_CONTENT }) .expectComplete() .verify() } void &#39;delete customer by none-existing id &#39;() { given: 1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L) when: Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log() then: StepVerifier.create(resFlux) .consumeErrorWith(error -&gt; { assert error instanceof HttpClientResponseException assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND }) .verify() } @MockBean(CustomerRepository) CustomerRepository mockedCustomerRepository() {// must use explicit type declaration Mock(CustomerRepository) }} In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place. Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service. Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage. Firstly declare a GridFSBucket bean. @Factorypublic class GridFSConfig { @Bean GridFSBucket gridFSBucket(MongoClient client) { return GridFSBuckets.create(client.getDatabase(&quot;photos&quot;)) .withChunkSizeBytes(4096) //.withReadConcern(ReadConcern.MAJORITY) .withWriteConcern(WriteConcern.MAJORITY); }} Now create a controller to handle the file upload and download. @Controller(&quot;/photos&quot;)@RequiredArgsConstructor@Slf4jpublic class PhotoController { private final GridFSBucket bucket; @Post(uri = &quot;/&quot;, consumes = {MediaType.MULTIPART_FORM_DATA}) public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) { var filename = file.getFilename(); var name = file.getName(); var contentType = file.getContentType(); var size = file.getSize(); log.debug(&quot;uploading file...\\n filename:{},\\n name:{},\\n contentType: {},\\n size: {} &quot;, filename, name, contentType, size); var options = new GridFSUploadOptions(); contentType.ifPresent(c -&gt; options.metadata(new Document(&quot;contentType&quot;, c))); return Mono.from(this.bucket.uploadFromPublisher( filename, Mono.from(file).mapNotNull(partData -&gt; { try { return partData.getByteBuffer(); } catch (IOException e) { e.printStackTrace(); } return null; }), options ) ) .map(ObjectId::toHexString) .map(id -&gt; ok(Map.of(&quot;id&quot;, id))); } @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_OCTET_STREAM}) public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) { return Mono.from(this.bucket.downloadToPublisher(id)) .map(HttpResponse::ok); } @Delete(uri = &quot;/{id}&quot;) public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) { return Mono.from(this.bucket.delete(id)) .map(v -&gt; noContent()); }} To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method. Get the complete source codes from my Github. &lt;hr&gt;&lt;p&gt;Building Micronaut applications with Micronaut Mongo Reative was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building Micronaut applications with Micronaut Mongo Reative","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/building-micronaut-applications-with-micronaut-mongo-reative/"},"url":"/blog/2022/building-micronaut-applications-with-micronaut-mongo-reative/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building Micronaut applications with Micronaut Mongo Reative</h1>
    <p class="post-meta">February 5, 2022</p>
  </header>

  <article class="post-content">
    <p>In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties.</p><figure><img alt="Photo by &lt;a href=”https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Fabian Mardi&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;" src="https://cdn-images-1.medium.com/max/1024/1*HcHUQFoIAU88lHg24zJINA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Fabian Mardi</a> on <a href="https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h3>Getting Started</h3><p>Open your browser and navigate to <a href="https://micronaut.io/launch">Micronaut Launch</a> to generate a new project skeleton for this post. Select the following items on this page.</p><ul><li>Java version: <strong>17</strong></li><li>Language: <strong>Java</strong></li><li>Build tool: <strong>Gradle</strong></li><li>Test framework: <strong>Spock</strong></li><li>Included Features: <strong>mongo-reactive</strong> etc.</li></ul><p>Click <strong>GENERATE PROJECT</strong> button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p><p>In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests.</p><p>Create a Mongo document entity class.</p><pre>@Data<br>@Builder<br>@NoArgsConstructor<br>@AllArgsConstructor(staticName = &quot;of&quot;)<br>public class Customer {<br>    private ObjectId id;<br>    private String name;<br>    private int age;<br>    private Address address;</pre><pre>    public static Customer of(String name, int age, Address address) {<br>        return Customer.of(null, name, age, address);<br>    }<br>}</pre><p>The Address is an embedded Document in a Customer Document.</p><pre>@Data<br>@Builder<br>@NoArgsConstructor<br>@AllArgsConstructor(staticName = &quot;of&quot;)<br>public class Address {<br>    private String street;<br>    private String city;<br>    private String zip;<br>}</pre><p>Create a Repository class to perform CRUD operations on Customer.</p><pre>@Singleton<br>@RequiredArgsConstructor<br>@Slf4j<br>public class CustomerRepository {<br>    private final MongoClient mongoClient;<br>    private final DefaultMongoConfiguration mongoConfiguration;</pre><pre>    public Flux&lt;Customer&gt; findAll() {<br>        return Flux.from(customersCollection().find());<br>    }</pre><pre>    public Mono&lt;Customer&gt; findById(ObjectId id) {<br>        return Mono.from(customersCollection().find(Filters.eq(id)));<br>    }</pre><pre>    public Mono&lt;ObjectId&gt; insertOne(Customer data) {<br>        return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false)))<br>                .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue());<br>    }</pre><pre>    public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) {<br>        return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true)))<br>                .map(InsertManyResult::getInsertedIds);<br>    }</pre><pre>    public Mono&lt;Long&gt; deleteById(ObjectId id) {<br>        return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions()))<br>                .map(DeleteResult::getDeletedCount);<br>    }</pre><pre>    public void init() {<br>        var people = List.of(<br>                Customer.of(&quot;Charles Babbage&quot;, 45, Address.of(&quot;5 Devonshire Street&quot;, &quot;London&quot;, &quot;W11&quot;)),<br>                Customer.of(&quot;Alan Turing&quot;, 28, Address.of(&quot;Bletchley Hall&quot;, &quot;Bletchley Park&quot;, &quot;MK12&quot;)),<br>                Customer.of(&quot;Timothy Berners-Lee&quot;, 61, Address.of(&quot;Colehill&quot;, &quot;Wimborne&quot;, null))<br>        );<br>        Mono.from(customersCollection().drop())<br>                .then()<br>                .thenMany(this.insertMany(people))<br>                .subscribe(<br>                        result -&gt; result.forEach((key, value) -&gt; log.debug(&quot;saved key: {}, value: {}&quot;, key, value)),<br>                        error -&gt; log.debug(&quot;initialization failed: {}&quot;, error),<br>                        () -&gt; log.debug(&quot;done&quot;)<br>                );<br>    }</pre><pre>    public Mono&lt;Long&gt; deleteAll() {<br>        return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions()))<br>                .map(DeleteResult::getDeletedCount);<br>    }</pre><pre>    private MongoCollection&lt;Customer&gt; customersCollection() {<br>        return mongoClient<br>                .getDatabase(&quot;userdb&quot;)<br>                .getCollection(&quot;customers&quot;, Customer.class);<br>    }</pre><pre>}</pre><p>When a mongo.uri is set in the <em>application.yml</em>, there is a <strong>reactive</strong> MongoClient bean is available.</p><p>In the above codes:</p><ul><li>The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the <em>customers</em> document _id in MongoDB automatically.</li><li>The MongoClient provides methods for CRUD operations, but it is based on the <em>Reactive Streams</em> APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs.</li></ul><p>Now let’s create a test to test the CustomerRepository.</p><pre>@MicronautTest(startApplication = false)<br>@Slf4j<br>class CustomerRepositorySpec extends Specification {</pre><pre>    @Inject<br>    EmbeddedApplication&lt;?&gt; application</pre><pre>    @Inject<br>    CustomerRepository customerRepository;</pre><pre>    def setup() {<br>        CountDownLatch latch = new CountDownLatch(1)<br>        customerRepository.deleteAll()<br>                .doOnTerminate(_ -&gt; latch.countDown())<br>                .subscribe(it -&gt; log.debug &quot;deleted customers: {}&quot;, it)<br>        latch.await(1000, TimeUnit.MILLISECONDS)<br>    }</pre><pre>    void &#39;application is not running&#39;() {<br>        expect:<br>        !application.running<br>    }</pre><pre>    void &#39;test findAll&#39;() {<br>        given:<br>        this.customerRepository.insertMany(List.of(Customer.of(&quot;Jack&quot;, 40, null)))<br>                .block(Duration.ofMillis(5000L))</pre><pre>        when:<br>        def result = this.customerRepository.findAll()</pre><pre>        then:<br>        StepVerifier.create(result)<br>                .expectNextMatches(it -&gt; it.name == &quot;Jack&quot;)<br>                .expectComplete()<br>                .verify()<br>    }<br>}</pre><p>To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation.</p><p>Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten.</p><p>In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams.</p><p>If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification.</p><pre>@Shared<br>@AutoCleanup<br>GenericContainer mongo = new GenericContainer(&quot;mongo&quot;)<br>    .withExposedPorts(27017)</pre><pre>def setupSpec() {        <br>    mongo.start()<br>}</pre><p>Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose.</p><pre>@Singleton<br>@Requires(notEnv = &quot;mock&quot;)<br>@Slf4j<br>@RequiredArgsConstructor<br>public class DataInitializer {<br>    private final CustomerRepository customerRepository;</pre><pre>    @EventListener<br>    public void onStart(ServerStartupEvent event) {<br>        log.debug(&quot;starting data initialization...&quot;);<br>        this.customerRepository.init();<br>    }<br>}</pre><p>Try to create a controller to expose the RESTful APIs.</p><pre>@Controller(&quot;/customers&quot;)<br>@RequiredArgsConstructor<br>@Slf4j<br>public class CustomerController {<br>    private final CustomerRepository customerRepository;</pre><pre>    @Get(uri = &quot;/&quot;, produces = {MediaType.APPLICATION_JSON})<br>    public Flux&lt;?&gt; all() {<br>        return this.customerRepository.findAll();<br>    }</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_JSON})<br>    public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) {<br>        return this.customerRepository.findById(id)<br>                .map(HttpResponse::ok)<br>                .switchIfEmpty(Mono.just(notFound()));<br>    }</pre><pre>    @Post(uri = &quot;/&quot;, consumes = {MediaType.APPLICATION_JSON})<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) {<br>        return this.customerRepository.insertOne(data)<br>                .map(id -&gt; created(URI.create(&quot;/customers/&quot; + id.toHexString())));<br>    }</pre><pre>    @Delete(uri = &quot;/{id}&quot;)<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {<br>        return this.customerRepository.deleteById(id)<br>                .map(deleted -&gt; {<br>                    if (deleted &gt; 0) {<br>                        return noContent();<br>                    } else {<br>                        return notFound();<br>                    }<br>                });<br>    }<br>}</pre><p>To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId.</p><pre>@Singleton<br>public class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; {</pre><pre>    @Override<br>    public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) {<br>        return Optional.of(new ObjectId(object));<br>    }<br>}</pre><p>In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object.</p><pre>@Singleton<br>public class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; {<br>    <br>    @Override<br>    public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException {<br>        gen.writeString(value.toHexString());<br>    }<br>}</pre><p>Create a test for the CustomerController.</p><pre>@MicronautTest(environments = [&quot;mock&quot;])<br>class CustomerControllerSpec extends Specification {</pre><pre>    @Inject<br>    EmbeddedApplication&lt;?&gt; application</pre><pre>    @Inject<br>    @Client(&quot;/&quot;)<br>    ReactorHttpClient client</pre><pre>    @Inject<br>    CustomerRepository customerRepository</pre><pre>    def &#39;test it works&#39;() {<br>        expect:<br>        application.running<br>    }</pre><pre>    void &#39;get all customers&#39;() {<br>        given:<br>        1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null))</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers&quot;), String).log()</pre><pre>        then:<br>        //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null))<br>        StepVerifier.create(resFlux)<br>        //.expectNextCount(1)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.OK<br>                    assert s.body().contains(&#39;Jack&#39;)<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;create a new customer&#39;() {<br>        given:<br>        def objId = ObjectId.get()<br>        1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId)</pre><pre>        when:<br>        def body = Customer.of(null, &quot;Jack&quot;, 40, null)<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST(&quot;/customers&quot;, body), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.CREATED<br>                    assert s.header(&quot;Location&quot;) == &#39;/customers/&#39; + objId.toHexString()<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;get customer by id &#39;() {<br>        given:<br>        1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null))</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.OK<br>                    assert s.body().contains(&#39;Jack&#39;)<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;get customer by none-existing id &#39;() {<br>        given:<br>        1 * customerRepository.findById(_) &gt;&gt; Mono.empty()</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeErrorWith(error -&gt; {<br>                    assert error instanceof HttpClientResponseException<br>                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND<br>                })<br>                .verify()<br>    }</pre><pre>    void &#39;delete customer by id &#39;() {<br>        given:<br>        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L)</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.NO_CONTENT<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;delete customer by none-existing id &#39;() {<br>        given:<br>        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L)</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeErrorWith(error -&gt; {<br>                    assert error instanceof HttpClientResponseException<br>                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND<br>                })<br>                .verify()<br>    }</pre><pre>    @MockBean(CustomerRepository)<br>    CustomerRepository mockedCustomerRepository() {// must use explicit type declaration<br>        Mock(CustomerRepository)<br>    }<br>}</pre><p>In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place.</p><p>Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service.</p><p>Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage.</p><p>Firstly declare a GridFSBucket bean.</p><pre>@Factory<br>public class GridFSConfig {</pre><pre>    @Bean<br>    GridFSBucket gridFSBucket(MongoClient client) {<br>        return GridFSBuckets.create(client.getDatabase(&quot;photos&quot;))<br>                .withChunkSizeBytes(4096)<br>                //.withReadConcern(ReadConcern.MAJORITY)<br>                .withWriteConcern(WriteConcern.MAJORITY);<br>    }<br>}</pre><p>Now create a controller to handle the file upload and download.</p><pre>@Controller(&quot;/photos&quot;)<br>@RequiredArgsConstructor<br>@Slf4j<br>public class PhotoController {</pre><pre>    private final GridFSBucket bucket;</pre><pre>    @Post(uri = &quot;/&quot;, consumes = {MediaType.MULTIPART_FORM_DATA})<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) {<br>        var filename = file.getFilename();<br>        var name = file.getName();<br>        var contentType = file.getContentType();<br>        var size = file.getSize();<br>        log.debug(&quot;uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} &quot;, filename, name, contentType, size);<br>        var options = new GridFSUploadOptions();<br>        contentType.ifPresent(c -&gt; options.metadata(new Document(&quot;contentType&quot;, c)));<br>        return Mono.from(this.bucket.uploadFromPublisher(<br>                                filename,<br>                                Mono.from(file).mapNotNull(partData -&gt; {<br>                                    try {<br>                                        return partData.getByteBuffer();<br>                                    } catch (IOException e) {<br>                                        e.printStackTrace();<br>                                    }<br>                                    return null;<br>                                }),<br>                                options<br>                        )<br>                )<br>                .map(ObjectId::toHexString)<br>                .map(id -&gt; ok(Map.of(&quot;id&quot;, id)));<br>    }</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_OCTET_STREAM})<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) {<br>        return Mono.from(this.bucket.downloadToPublisher(id))<br>                .map(HttpResponse::ok);<br>    }</pre><pre>    @Delete(uri = &quot;/{id}&quot;)<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {<br>        return Mono.from(this.bucket.delete(id))<br>                .map(v -&gt; noContent());<br>    }<br>}</pre><p>To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method.</p><h4>Get the complete <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/album-service">source codes</a> from my Github.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9c418b403bc1" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-micronaut-applications-with-micronaut-mongo-reative-9c418b403bc1">Building Micronaut applications with Micronaut Mongo Reative</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
