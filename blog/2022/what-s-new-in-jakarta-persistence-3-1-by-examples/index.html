<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | What’s New in Jakarta Persistence 3.1 By Examples
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2022/what-s-new-in-jakarta-persistence-3-1-by-examples/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="What’s New in Jakarta Persistence 3.1 By Examples" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Jakarta Persistence(aka JPA) 3.1 brings a collection of improvements. The UUID class now is treated as Basic Java Type. To support UUID type ID in Entity class, JPA introduces a new UUID generator.Several numeric functions and date/time specific functions are added in JPQL and type-safe Criteria API. More details please read What’s New in Jakarta Persistence 3.1. Next let’s explore these features by writing some real example codes. Photo by &lt;a href=”https://unsplash.com/@lin_alessio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Alessio Lin&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/china-building?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt; Hibernate 6.1 Generate a simple Java application project via Maven Quickstart archetype. mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 There are some interactive steps to guide you setup the project info, such as groupId, artifact, version etc. In this example project, we use com.example as groupId, and demo as artifactId. Then confirm and begin to generate the project source codes. After it is done, open the project in a Java IDE such as IntelliJ IDEA(Community Edition is free), or Eclipse Java/Java EE bundle, or NetBeans IDE, or a simple text editor, eg. VS Code. Modify the pom.xml in the project root folder, add Hibernate 6.1, and JUnit etc. into project dependencies, and setup Maven compiler plugin to use Java 17 to compile the source codes. The final pom.xml looks like the following. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;hibernate6&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;/parent&gt; &lt;name&gt;hibernate6&lt;/name&gt; &lt;description&gt;Jakarta EE 10 Sandbox: Hibernate 6/JPA 3.1 example&lt;/description&gt; &lt;properties&gt; &lt;maven.compiler.release&gt;17&lt;/maven.compiler.release&gt; &lt;!-- requires 6.1.2.Final or higher --&gt; &lt;hibernate.version&gt;6.1.4.Final&lt;/hibernate.version&gt; &lt;h2.version&gt;2.1.214&lt;/h2.version&gt; &lt;!-- test deps --&gt; &lt;junit-jupiter.version&gt;5.9.1&lt;/junit-jupiter.version&gt; &lt;assertj-core.version&gt;3.23.1&lt;/assertj-core.version&gt; &lt;slf4j.version&gt;2.0.3&lt;/slf4j.version&gt; &lt;logback.version&gt;1.4.4&lt;/logback.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt; &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- H2 Database --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;${h2.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logging with logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- test dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;${junit-jupiter.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;version&gt;${assertj-core.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt; &lt;artifactId&gt;hibernate-testing&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; NOTE: To share common resources for all feature-based projects, create a parent POM to centralize the common configurations in one place, check the parent pom.xml file. In this example project, we use H2 embedded database for test purpose. Hibernate 6.1 implements the features of Jakarta Persistence 3.1, but it includes a Jakarta Persistence 3.0 API in the transitive dependency tree. To use Jakarta Persistence 3.1 API, we have to add jakarta.persistence:jakarta.persistence-api 3.1 explicitly. In the src/main/resources/META-INF, add a new file named persistence.xml. &lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;description&gt;Hibernate test case template Persistence Unit&lt;/description&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;property name=&quot;hibernate.archive.autodetection&quot; value=&quot;class, hbm&quot;/&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt; &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1&quot;/&gt; &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create-drop&quot;/&gt; &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;hibernate.cache.region_prefix&quot; value=&quot;hibernate.test&quot;/&gt; &lt;property name=&quot;hibernate.cache.region.factory_class&quot; value=&quot;org.hibernate.testing.cache.CachingRegionFactory&quot;/&gt; &lt;!--NOTE: hibernate.jdbc.batch_versioned_data should be set to false when testing with Oracle--&gt; &lt;property name=&quot;hibernate.jdbc.batch_versioned_data&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;jakarta.persistence.validation.mode&quot; value=&quot;NONE&quot;/&gt; &lt;property name=&quot;hibernate.service.allow_crawling&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;hibernate.session.events.log&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; We use logback as the logging framework in this project. In the src/main/resources, add a logback.xml to configure logback. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt; %green(%d{ISO8601}) %highlight(%-5level) [%blue(%t)] %yellow(%C{1.}): %msg%n%throwable &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;${LOGS}/app.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt; &lt;fileNamePattern&gt;${LOGS}/archived/app-%d{yyyy-MM-dd}.%i.log &lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- LOG everything at INFO level --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;!-- Debug hibernate SQL, see: https://thorben-janssen.com/hibernate-logging-guide/ --&gt; &lt;logger name=&quot;org.hibernate.SQL&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;org.hibernate.type.descriptor.sql&quot; level=&quot;trace&quot;/&gt; &lt;!-- Custom debug level for the application code --&gt; &lt;logger name=&quot;com.example&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt;&lt;/configuration&gt; We set org.hibernate.SQL logging level to DEBUG and org.hibernate.type.descriptor.sql to trace, it will help you to dig into the Hibernate generated sql at runtime. UUID Basic Type Support JPA 3.1 allows to use UUID as basic Java type, especially it add a UUID ID generator. Create a simple Entity. @Entitypublic class Person { @Id @Column(name = &quot;id&quot;, nullable = false) @GeneratedValue(strategy = GenerationType.UUID) private UUID id; private String name; private int age = 30; public Person() { } public Person(String name, int age) { assert age &gt; 0; this.name = name; this.age = age; this.birthDate = LocalDateTime.now().minusYears(this.age); } // getters and setters // override equals and hashCode} An entity class is annotated with an @Entity, optionally you can specify the entity name and add table definition with an extra @Table annotation. Here we defined a UUID type ID, and use a UUID generation strategy. JPA requires an Entity should includes a no-arguments constructor, if you declare another constructor with a few arguments, you should declare this no-arguments constructor explicitly. Create a simple JUnit test to verify if the UUID type working as expected. class PersonUUIDTest { private static final Logger log = LoggerFactory.getLogger(PersonUUIDTest.class); private EntityManagerFactory entityManagerFactory; @BeforeEach void setUp() { entityManagerFactory = Persistence.createEntityManagerFactory(&quot;defaultPU&quot;); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); var deleteFromPerson = entityManager.createQuery(&quot;DELETE FROM Person&quot;).executeUpdate(); log.debug(&quot;Deleted {} persons&quot;, deleteFromPerson); entityManager.getTransaction().commit(); entityManager.close(); } @Test @DisplayName(&quot;insert person and verify person&quot;) public void testInsertAndFindPerson() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var foundPerson = entityManager.find(Person.class, id); assertThat(foundPerson.getId()).isNotNull(); assertThat(foundPerson.getName()).isEqualTo(&quot;John&quot;); assertThat(foundPerson.getAge()).isEqualTo(30); } catch (Exception ex) { ex.printStackTrace(); } } @AfterEach void tearDown() { entityManagerFactory.close(); }} In the @BeforeEach method, we will create an EntityManagerFactory instance. And in the @AfterEach we call the EntityManagerFactory.close to release the resource. In the @BeforeEach we try to clean up the Person data. Now in the testInsertAndFindPerson test, we insert a new person, then utilize entityManager.find to find the inserted person. The person id is annotated with @ID and @GeneratedValue, when inserting a person into table, hibernate will generate an ID automatically. After it is persisted, the returned instance is filled with the generated id, it should not be a null. Numeric Functions JPA 3.1 adds a collection of new numeric functions in literal JPQL query and type-safe Criteria Builder API. Add some extra properties in the above Person class. public class Person{ private Integer yearsWorked = 2; private LocalDateTime birthDate = LocalDateTime.now().minusYears(30); private BigDecimal salary = new BigDecimal(&quot;12345.678&quot;); private BigDecimal hourlyRate = new BigDecimal(&quot;34.56&quot;); // setters and getters} Create a new test to verify the new numeric functions: ceiling, floor, round, exp, ln, power, sign. @Test@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, CEILING(p.salary) as ceiling, FLOOR(p.salary) as floor, ROUND(p.salary, 1) as round, EXP(p.yearsWorked) as exp, LN(p.yearsWorked) as ln, POWER(p.yearsWorked,2) as power, SIGN(p.yearsWorked) as sign FROM Person p WHERE p.id=:id &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); query.setParameter(&quot;id&quot;, id); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} Next, let’s have a look at how to use them in the Criteria APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { // see: https://hibernate.zulipchat.com/#narrow/stream/132096-hibernate-user/topic/New.20functions.20in.20JPA.203.2E1/near/289429903 var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.ceiling(root.get(&quot;salary&quot;)), cb.floor(root.get(&quot;salary&quot;)), cb.round(root.get(&quot;salary&quot;), 1), cb.exp(root.get(&quot;yearsWorked&quot;)), cb.ln(root.get(&quot;yearsWorked&quot;)), // see: https://hibernate.atlassian.net/browse/HHH-15395 cb.power(root.get(&quot;yearsWorked&quot;), 2), cb.sign(root.get(&quot;yearsWorked&quot;)) ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = entityManager.createQuery(query).getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug( &quot;result: ({},{},{},{},{},{},{},{})&quot;, result.get(0, String.class), result.get(1, BigDecimal.class), result.get(2, BigDecimal.class), result.get(3, BigDecimal.class), result.get(4, Double.class), result.get(5, Double.class), result.get(6, Double.class), result.get(7, Integer.class) ) ); } catch (Exception ex) { fail(ex); }} Note, when using Hibernate 6.1, we have to cast CriteriaBuilder to HibernateCriteriaBuilder to experience the new numeric functions. Hibernate 6.2 will align to JPA 3.1 and fix the issue. DateTime Functions JPA 3.1 add a series of datetime functions and ease the usage of Java 8 DateTime APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, LOCAL TIME as localTime, LOCAL DATETIME as localDateTime, LOCAL DATE as localDate FROM Person p &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} The LOCAL TIME, LOCAL DATETIME, LOCAL DATE query result will be treated as Java 8 LocalTime, LocalDateTime, LocalDate directly. Let’s have a look at the usage in the CriteriaBuilder APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.localTime(), cb.localDateTime(), cb.localDate() ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = entityManager.createQuery(query).getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug( &quot;result: ({},{},{},{})&quot;, result.get(0, String.class), result.get(1, LocalTime.class), result.get(2, LocalDateTime.class), result.get(3, LocalDate.class) ) ); } catch (Exception ex) { fail(ex); }} EXTRACT function JPA 3.1 introduces a extract function to decode fragments from a datetime value. @Test@DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;)public void testExtractFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, EXTRACT(YEAR FROM p.birthDate) as year, EXTRACT(QUARTER FROM p.birthDate) as quarter, EXTRACT(MONTH FROM p.birthDate) as month, EXTRACT(WEEK FROM p.birthDate) as week, EXTRACT(DAY FROM p.birthDate) as day, EXTRACT(HOUR FROM p.birthDate) as hour, EXTRACT(MINUTE FROM p.birthDate) as minute, EXTRACT(SECOND FROM p.birthDate) as second FROM Person p &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} Use the new extract function, we can read the year, quarter, month, week, day, hour, minute, second values from a Java 8 DateTime type property in the JPQL query. Note, there is no mapped extract function in the CriteriaBuilder APIs, for more details, check issue: jakartaee/persistence#356 JakartaEE Runtime Next let’s go to the Jakarta EE 10 compatible products to experience the new features of JPA 3.1. Firstly we will prepare a Jakarta EE 10 web application. Simply generate a web application skeleton via Maven Webapp Archetype. mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4 Then add Jakarta EE 10 dependency into the project pom.xml. Let’s have a look at the modified pom.xml. &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jpa-examples&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;/parent&gt; &lt;name&gt;jpa-examples&lt;/name&gt; &lt;description&gt;Jakarta EE 10 Sandbox: Persistence 3.1 Examples&lt;/description&gt; &lt;properties&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.persistence.jpa.modelgen.processor&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.junit5&lt;/groupId&gt; &lt;artifactId&gt;arquillian-junit5-container&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- see: https://github.com/arquillian/arquillian-core/issues/248 --&gt; &lt;!-- and https://github.com/arquillian/arquillian-core/pull/246/files --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt; &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; In the above pom.xml, we also add JUnit 5 and Arquillian related dependencies in test scope. Through the container specific Aquillian adapter, we can run the tests in Jakarta EE application servers. In this project, we reuse the the Person entity we have introduced in the Hibernate section. Now let’s move to persistence configuration. Create a persistence.xml in the src/main/resources/META-INFO folder. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence version=&quot;3.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd&quot;&gt; &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;JTA&quot;&gt; &lt;jta-data-source&gt;java:comp/DefaultDataSource&lt;/jta-data-source&gt; &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;property name=&quot;jakarta.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- for Glassfish/Payara/EclipseLink --&gt; &lt;property name=&quot;eclipselink.logging.level.sql&quot; value=&quot;FINE&quot;/&gt; &lt;property name=&quot;eclipselink.logging.level&quot; value=&quot;FINE&quot;/&gt; &lt;property name=&quot;eclipselink.logging.parameters&quot; value=&quot;true&quot;/&gt; &lt;!-- for WildFly/Hibernate --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; The configuration is a little different from the one we introduced in the Hibernate section. In a container environment, we would like choose JTA as transaction-type.We do not setup database connection info, instead we configure a built-in DataSource. The java:comp/DefaultDataSource is the default DataSource for all Jakarta EE compatible products. Creating Jakarta EE Sample Application To interact with our backend database, we will create a simple complete JAXRS application, including: A EJB @Stateless bean to read data from databaseAnd expose data via a simple JAXRS resource OK, let’s create class PersonRepository which is annotated with @Stateless. In this class, inject a EntityManager bean with an annotation @PersistenceContext, and add a new method getAllResource to execute a JPQL query to retrieve all persons. @Statelesspublic class PersonRepository { @PersistenceContext EntityManager entityManager; public List&lt;Person&gt; getAllPersons() { return entityManager.createQuery(&quot;select p from Person p&quot;, Person.class) .getResultList(); }} Next, create a PersonResource to expose persons to client. @RequestScoped@Path(&quot;/persons&quot;)public class PersonResource { @Inject PersonRepository personRepository; @Path(&quot;&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response allPersons() { var data = personRepository.getAllPersons(); return Response.ok(data).build(); }} The PersonResource is annotated with RequestScoped, it is a CDI bean, the @Path on the class define the root path of all subresources in this class. The allPersons will produces all persons to client in JSON format when HTTP Client request matches HTTP GET method, and URI is /persons and HTTP Header Accept is compatible with application/json. To activate JAXRS feature, create a class to extend the JAXRS Application, add @ApplicationPath to specify the root context path of all JAXRS resources. @ApplicationPath(&quot;/rest&quot;)public class RestActivator extends Application {} Let’s create a bean to add some sample data at the application startup. @Startup@Singletonpublic class DataInitializer { @PersistenceContext EntityManager entityManager; @PostConstruct public void init() { List .of( new Person(&quot;Jack&quot;, 20), new Person(&quot;Rose&quot;, 18) ) .forEach(entityManager::persist); }} Deploying to Jakarta EE Containers Build and package the application into a war archive. Open a terminal, switch to the project root folder, and execute the following command. mvn clean package -DskipTests -D&quot;maven.test.skip=true&quot; When it is done, there is war package is ready in the path target/jpa-examples.war. GlassFish 7.0 Download the latest GlassFish 7.0, extract files to a location, eg. D:\glassfish7, mark as GlassFish_install.To start GlassFish and Derby, open a terminal, enter GlassFish_install/bin, run asadmin start-database and asadmin start-domain domain1.Copy the above war package to Glassfish_install/glassfish/domains/domain1/autodeploy folder.Open GlassFish_install/glassfish/domains/domain1/logs/server.log, and wait the deployment is completed.Open another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons. You will the following response in the console. [{“age”:18,”birthDate”:”2004–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”d8552d71-ff7f-4650-b5a0-ce1c5fb3fe0b”,”name”:”Rose”,”salary”:12345.678,”yearsWorked”:2},{“age”:20,”birthDate”:”2002–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”cdf94cdc-21b3–492c-b1b5–06bc8cae9947&quot;,”name”:”Jack”,”salary”:12345.678,”yearsWorked”:2}] To stop GlassFish and Derby, run asadmin stop-database and asadmin stop-domain domain1 WildFly Preview 27 Download the latest WildFly Preview, extract files to a location, eg. D:\wildfly-preview-27.0.0.Beta1, mark as WildFly_install.Open a terminal, enter WildFly_install/bin, run standalone to start WildFly with the default standalone profile configuration.Copy the built war to WildFly_install/standalone/deployments.Wait the deployment progress is done, you can use the curl in GlassFish section to verify the application.Send a CTLR+C keys combination in the original WildFly startup console to stop WildFly. Deploying Application via Maven Plugin Deploying to GlassFish via Cargo Plugin The GlassFish project does not include an official Maven plugin to manage GlassFish server. There is a Maven plugin named cargo-maven3-plugin which can be used to manage all popular Jakarta EE application servers and web servers. Add the following profile section to use cargo plugin to manage the lifecycle of GlassFish server. &lt;profile&gt; &lt;id&gt;glassfish&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;cargo.zipUrlInstaller.downloadDir&gt;${project.basedir}/../installs&lt;/cargo.zipUrlInstaller.downloadDir&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;glassfish7x&lt;/containerId&gt; &lt;!-- &lt;artifactInstaller&gt; &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt; &lt;artifactId&gt;glassfish&lt;/artifactId&gt; &lt;version&gt;${glassfish.version}&lt;/version&gt; &lt;/artifactInstaller&gt; --&gt; &lt;zipUrlInstaller&gt; &lt;url&gt;https://github.com/eclipse-ee4j/glassfish/releases/download/${glassfish.version}/glassfish-${glassfish.version}.zip&lt;/url&gt; &lt;downloadDir&gt;${cargo.zipUrlInstaller.downloadDir}&lt;/downloadDir&gt; &lt;/zipUrlInstaller&gt; &lt;/container&gt; &lt;configuration&gt; &lt;!-- the configuration used to deploy --&gt; &lt;home&gt;${project.build.directory}/glassfish7x-home&lt;/home&gt; &lt;properties&gt; &lt;cargo.remote.password&gt;&lt;/cargo.remote.password&gt; &lt;cargo.glassfish.removeDefaultDatasource&gt;true&lt;/cargo.glassfish.removeDefaultDatasource&gt; &lt;/properties&gt; &lt;datasources&gt; &lt;datasource&gt; &lt;driverClass&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/driverClass&gt; &lt;url&gt;jdbc:derby:derbyDB;create=true&lt;/url&gt; &lt;jndiName&gt;jdbc/__default&lt;/jndiName&gt; &lt;username&gt;APP&lt;/username&gt; &lt;password&gt;nonemptypassword&lt;/password&gt; &lt;/datasource&gt; &lt;/datasources&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; Unlike the approach in NetBeans IDE or Eclipse IDE with GlassFish Pack, where starting GlassFish it will start the built-in Derby at the same time. Cargo does not start the built-in Derby as expected, to use the default DataSource in our project, clear the default DataSource and add a new default DataSource based on the embedded Derby. Run the following command. It will compile the project source codes and package the application into a war archive, then start the managed GlassFish server(with a new cargo-domain), and then deploy the package into this running server. mvn clean package cargo:run -DskipTests -Dmaven.test.skip=true Note, when you run this command at the first time, it will spend some time to download a copy of the GlassFish redistribution, and extract the files into the build folder. In another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons to verify the endpoint. To stop the server, just send a CTRL+C in the original GlassFish running console. Deploying to WildFly via WildFly Plugin The WildFly project itself provides an official WildFly Maven plugin, we will configure it in a new Maven profile. Cargo maven plugin also supports WildFly, check Cargo WildFly docs. &lt;profile&gt; &lt;id&gt;wildfly&lt;/id&gt; &lt;properties&gt; &lt;!-- Wildfly server --&gt; &lt;wildfly.artifactId&gt;wildfly-preview-dist&lt;/wildfly.artifactId&gt; &lt;jboss-as.home&gt;${project.build.directory}/wildfly-preview-${wildfly.version}&lt;/jboss-as.home&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- unpack a copy of WildFly--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.wildfly&lt;/groupId&gt; &lt;artifactId&gt;${wildfly.artifactId}&lt;/artifactId&gt; &lt;version&gt;${wildfly.version}&lt;/version&gt; &lt;type&gt;zip&lt;/type&gt; &lt;overWrite&gt;false&lt;/overWrite&gt; &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- The WildFly plugin deploys your war to a local running WildFly container --&gt; &lt;!-- To use, run: mvn package wildfly:deploy --&gt; &lt;!-- For Jakarta EE 9, use `wildfly-preview-dist` as artifactId instead to start and deploy applications--&gt; &lt;!-- Run: mvn clean wildfly:run -PWildfly -Dwildfly.artifactId=wildfly-preview-dist -Dwildfly.version=22.0.0.Alpha1 --&gt; &lt;!-- or set the `jboss-as.home` to run: mvn clean wildfly:run -PWildfly -Djboss-as.home=D:\appsvr\wildfly-preview-22.0.0.Alpha1--&gt; &lt;plugin&gt; &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt; &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${wildfly-maven-plugin.version}&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;opensaml&lt;/id&gt; &lt;url&gt;https://build.shibboleth.net/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/profile&gt; With the WildFly plugin, we can deploy applications into an embedded WildFly, a managed WildFly server or a remote running WildFly server. mvn clean wildfly:run -Pwildfly -DskipTests -Dmaven.test.skip=true By default, if we do not setup a jboss-as.home or remote host connection info, it will bootstrap an embedded WildFly and run the application with the embedded server. Here we configure Maven dependency plugin to download a copy of WildFly, extract the files to the project build directory, and setup a jboss-as.home property, the value is the WildFly location. The WildFly plugin will manage the whole WildFly lifecycle - start the WildFly server, deploy applications into the running server, (use CTRL+C hotkey) stop the server. Testing JPA Features Here I assume you are familiar with JUnit and Arquillian before. For the developers new to Arqullian framework, please read the official Arquillian Guides to start your first step. Note, these tutorials are available in several languages, including Simplified Chinese. Go to my Jakarta EE 8 starter boilerplate project and Jakarta EE 9 starter boilerplate project to update your Arquilian knowledge. Since Jakarta EE 9, it uses the new jakarta namespace, Arquillian 1.7.0.x starts to support these changes. In the next steps, we will configure a managed GlassFish Arquillian Adapter to run the testing codes. &lt;profile&gt; &lt;id&gt;arq-glassfish-managed&lt;/id&gt; &lt;properties&gt; &lt;skip.unit.tests&gt;true&lt;/skip.unit.tests&gt; &lt;skip.integration.tests&gt;false&lt;/skip.integration.tests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Jersey --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.hantsy.arquillian-container-glassfish-jakarta&lt;/groupId&gt; &lt;artifactId&gt;arquillian-glassfish-managed-jakarta&lt;/artifactId&gt; &lt;version&gt;${arquillian-glassfish-jakarta.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;testResource&gt; &lt;directory&gt;src/test/arq-glassfish-managed&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt; &lt;artifactId&gt;glassfish&lt;/artifactId&gt; &lt;version&gt;${glassfish.version}&lt;/version&gt; &lt;type&gt;zip&lt;/type&gt; &lt;overWrite&gt;false&lt;/overWrite&gt; &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;environmentVariables&gt; &lt;GLASSFISH_HOME&gt;${project.build.directory}/glassfish7&lt;/GLASSFISH_HOME&gt; &lt;/environmentVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; In the above configuration, we add com.github.hantsy.arquillian-container-glassfish-jakarta:arquillian-glassfish-managed-jakarta, which is my fork of the official Arquillian Container GlassFish project. We preapre a copy of the latest GlassFish 7.0 in the pre-integration-test phase. The Arquillian tests will be exectued in the integretion-test phase. Let’s create a simple Arquillian tests to verify the UUID basic type feature in JPA 3.1. @ExtendWith(ArquillianExtension.class)public class UUIDStrategyTest { private final static Logger LOGGER = Logger.getLogger(UUIDStrategyTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { startTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { try { if( ux.getStatus() == Status.STATUS_ACTIVE ) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test public void testPersistingPersons() throws Exception { final Person person = new Person(); person.setName(&quot;Hantsy Bai&quot;); em.persist(person); endTx(); startTx(); final Person foundPerson = em.find(Person.class, person.getId()); assertNotNull(foundPerson.getId()); LOGGER.log(Level.INFO, &quot;Found person: {0}&quot;, foundPerson); }} The @ExtendWith(ArquillianExtension.class) annotation on a test class to support Arquillian test lifecycle. The @Deployment annotated static method defines the resources that will be packaged into the test archive and deployed into the manged GlassFish server. It is easy to use shrinkwrap to create a fine-grined deploymen unit. You can inject EntityManager and UserTransaction beans in an Arquillian test like what you do in a simple CDI bean. In this test class, we setup @BeforeEach and @AfterEach hooks to start a transacation and end the transaction. The test method testPersistingPersons looks no difference from a plain JUnit test. Firstly we persist a person entity, and commit the transaction to ensure it will be flushed into the database as expected. Then exectuing a simple JPA query to verify the persisted data. Execute the following command to run the tests. mvn clean verify -Parq-glassfish-managed Similiarly, create a test to verify the new numeric functions and datetime functions in Jakarta rumtimes. @ExtendWith(ArquillianExtension.class)public class JPQLFunctionsTest { private final static Logger LOGGER = Logger.getLogger(JPQLFunctionsTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { clearPersons(); startTx(); } private void clearPersons() throws Exception { startTx(); var builder = em.getCriteriaBuilder(); var deletePersonQuery = builder.createCriteriaDelete(Person.class); var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate(); LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons); endTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus()); try { if (ux.getStatus() == Status.STATUS_ACTIVE) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;) public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name, CEILING(p.salary), FLOOR(p.salary), ROUND(p.salary, 1), EXP(p.yearsWorked), LN(p.yearsWorked), POWER(p.yearsWorked,2), SIGN(p.yearsWorked) FROM Person p WHERE p.id=:id &quot;&quot;&quot;; var query = em.createQuery(queryString); query.setParameter(&quot;id&quot;, id); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;) public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); assertNotNull(person.getId()); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, LOCAL TIME as localTime, LOCAL DATETIME as localDateTime, LOCAL DATE as localDate FROM Person p &quot;&quot;&quot;; // for EclipseLinks var query = em.createQuery(queryString); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;) public void testExtractFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); assertNotNull(person.getId()); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, EXTRACT(YEAR FROM p.birthDate) as year, EXTRACT(QUARTER FROM p.birthDate) as quarter, EXTRACT(MONTH FROM p.birthDate) as month, EXTRACT(WEEK FROM p.birthDate) as week, EXTRACT(DAY FROM p.birthDate) as day, EXTRACT(HOUR FROM p.birthDate) as hour, EXTRACT(MINUTE FROM p.birthDate) as minute, EXTRACT(SECOND FROM p.birthDate) as second FROM Person p &quot;&quot;&quot;; var query = em.createQuery(queryString); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } }} Alternatively, create a test to verify the Criteria APIs. @ExtendWith(ArquillianExtension.class)public class JPQLCriteriaBuilderTest { private final static Logger LOGGER = Logger.getLogger(JPQLCriteriaBuilderTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { clearPersons(); startTx(); } private void clearPersons() throws Exception { startTx(); var builder = em.getCriteriaBuilder(); var deletePersonQuery = builder.createCriteriaDelete(Person.class); var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate(); LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons); endTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus()); try { if (ux.getStatus() == Status.STATUS_ACTIVE) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;) public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var cb = em.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.ceiling(root.get(&quot;salary&quot;)), cb.floor(root.get(&quot;salary&quot;)), cb.round(root.get(&quot;salary&quot;), 1), cb.exp(root.get(&quot;yearsWorked&quot;)), cb.ln(root.get(&quot;yearsWorked&quot;)), cb.power(root.get(&quot;yearsWorked&quot;), 2), cb.sign(root.get(&quot;yearsWorked&quot;)) ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = em.createQuery(query).getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(result -&gt; LOGGER.log( Level.INFO, // see: https://github.com/eclipse-ee4j/eclipselink/issues/1593 // John,12,345,12,345,12,345,7.389,0.693,4,1 &quot;tuple data :{0},{1},{2},{3},{4},{5},{6},{7}&quot;, new Object[]{ result.get(0, String.class), result.get(1, BigDecimal.class), // it should return BigDecimal result.get(2, BigDecimal.class), result.get(3, BigDecimal.class), result.get(4, Double.class), result.get(5, Double.class), result.get(6, Double.class), result.get(7, Integer.class) } ) ); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;) public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var cb = em.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.localTime(), cb.localDateTime(), cb.localDate() ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = em.createQuery(query).getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; LOGGER.log( Level.INFO, &quot;tuple data :{0},{1},{2},{3}&quot;, new Object[]{ data.get(0, String.class), data.get(1, java.time.LocalTime.class), data.get(2, java.time.LocalDateTime.class), data.get(3, java.time.LocalDate.class) } ) ); } catch (Exception ex) { fail(ex); } }} But unfortunately, there is a bug in the GlassFish 7.0.0-M9 will fail the test JPQLFunctionsTest, more details please check Github issues GlassFish #24120. Check the sample codes of Hibernate and Jakarta Persistence from my github. &lt;hr&gt;&lt;p&gt;What’s New in Jakarta Persistence 3.1 By Examples was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Jakarta Persistence(aka JPA) 3.1 brings a collection of improvements. The UUID class now is treated as Basic Java Type. To support UUID type ID in Entity class, JPA introduces a new UUID generator.Several numeric functions and date/time specific functions are added in JPQL and type-safe Criteria API. More details please read What’s New in Jakarta Persistence 3.1. Next let’s explore these features by writing some real example codes. Photo by &lt;a href=”https://unsplash.com/@lin_alessio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Alessio Lin&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/china-building?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt; Hibernate 6.1 Generate a simple Java application project via Maven Quickstart archetype. mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 There are some interactive steps to guide you setup the project info, such as groupId, artifact, version etc. In this example project, we use com.example as groupId, and demo as artifactId. Then confirm and begin to generate the project source codes. After it is done, open the project in a Java IDE such as IntelliJ IDEA(Community Edition is free), or Eclipse Java/Java EE bundle, or NetBeans IDE, or a simple text editor, eg. VS Code. Modify the pom.xml in the project root folder, add Hibernate 6.1, and JUnit etc. into project dependencies, and setup Maven compiler plugin to use Java 17 to compile the source codes. The final pom.xml looks like the following. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;hibernate6&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;/parent&gt; &lt;name&gt;hibernate6&lt;/name&gt; &lt;description&gt;Jakarta EE 10 Sandbox: Hibernate 6/JPA 3.1 example&lt;/description&gt; &lt;properties&gt; &lt;maven.compiler.release&gt;17&lt;/maven.compiler.release&gt; &lt;!-- requires 6.1.2.Final or higher --&gt; &lt;hibernate.version&gt;6.1.4.Final&lt;/hibernate.version&gt; &lt;h2.version&gt;2.1.214&lt;/h2.version&gt; &lt;!-- test deps --&gt; &lt;junit-jupiter.version&gt;5.9.1&lt;/junit-jupiter.version&gt; &lt;assertj-core.version&gt;3.23.1&lt;/assertj-core.version&gt; &lt;slf4j.version&gt;2.0.3&lt;/slf4j.version&gt; &lt;logback.version&gt;1.4.4&lt;/logback.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt; &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- H2 Database --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;${h2.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logging with logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- test dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;${junit-jupiter.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;version&gt;${assertj-core.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt; &lt;artifactId&gt;hibernate-testing&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; NOTE: To share common resources for all feature-based projects, create a parent POM to centralize the common configurations in one place, check the parent pom.xml file. In this example project, we use H2 embedded database for test purpose. Hibernate 6.1 implements the features of Jakarta Persistence 3.1, but it includes a Jakarta Persistence 3.0 API in the transitive dependency tree. To use Jakarta Persistence 3.1 API, we have to add jakarta.persistence:jakarta.persistence-api 3.1 explicitly. In the src/main/resources/META-INF, add a new file named persistence.xml. &lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;description&gt;Hibernate test case template Persistence Unit&lt;/description&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;property name=&quot;hibernate.archive.autodetection&quot; value=&quot;class, hbm&quot;/&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt; &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1&quot;/&gt; &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create-drop&quot;/&gt; &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;hibernate.cache.region_prefix&quot; value=&quot;hibernate.test&quot;/&gt; &lt;property name=&quot;hibernate.cache.region.factory_class&quot; value=&quot;org.hibernate.testing.cache.CachingRegionFactory&quot;/&gt; &lt;!--NOTE: hibernate.jdbc.batch_versioned_data should be set to false when testing with Oracle--&gt; &lt;property name=&quot;hibernate.jdbc.batch_versioned_data&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;jakarta.persistence.validation.mode&quot; value=&quot;NONE&quot;/&gt; &lt;property name=&quot;hibernate.service.allow_crawling&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;hibernate.session.events.log&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; We use logback as the logging framework in this project. In the src/main/resources, add a logback.xml to configure logback. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt; %green(%d{ISO8601}) %highlight(%-5level) [%blue(%t)] %yellow(%C{1.}): %msg%n%throwable &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;${LOGS}/app.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt; &lt;fileNamePattern&gt;${LOGS}/archived/app-%d{yyyy-MM-dd}.%i.log &lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- LOG everything at INFO level --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;!-- Debug hibernate SQL, see: https://thorben-janssen.com/hibernate-logging-guide/ --&gt; &lt;logger name=&quot;org.hibernate.SQL&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;org.hibernate.type.descriptor.sql&quot; level=&quot;trace&quot;/&gt; &lt;!-- Custom debug level for the application code --&gt; &lt;logger name=&quot;com.example&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt;&lt;/configuration&gt; We set org.hibernate.SQL logging level to DEBUG and org.hibernate.type.descriptor.sql to trace, it will help you to dig into the Hibernate generated sql at runtime. UUID Basic Type Support JPA 3.1 allows to use UUID as basic Java type, especially it add a UUID ID generator. Create a simple Entity. @Entitypublic class Person { @Id @Column(name = &quot;id&quot;, nullable = false) @GeneratedValue(strategy = GenerationType.UUID) private UUID id; private String name; private int age = 30; public Person() { } public Person(String name, int age) { assert age &gt; 0; this.name = name; this.age = age; this.birthDate = LocalDateTime.now().minusYears(this.age); } // getters and setters // override equals and hashCode} An entity class is annotated with an @Entity, optionally you can specify the entity name and add table definition with an extra @Table annotation. Here we defined a UUID type ID, and use a UUID generation strategy. JPA requires an Entity should includes a no-arguments constructor, if you declare another constructor with a few arguments, you should declare this no-arguments constructor explicitly. Create a simple JUnit test to verify if the UUID type working as expected. class PersonUUIDTest { private static final Logger log = LoggerFactory.getLogger(PersonUUIDTest.class); private EntityManagerFactory entityManagerFactory; @BeforeEach void setUp() { entityManagerFactory = Persistence.createEntityManagerFactory(&quot;defaultPU&quot;); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); var deleteFromPerson = entityManager.createQuery(&quot;DELETE FROM Person&quot;).executeUpdate(); log.debug(&quot;Deleted {} persons&quot;, deleteFromPerson); entityManager.getTransaction().commit(); entityManager.close(); } @Test @DisplayName(&quot;insert person and verify person&quot;) public void testInsertAndFindPerson() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var foundPerson = entityManager.find(Person.class, id); assertThat(foundPerson.getId()).isNotNull(); assertThat(foundPerson.getName()).isEqualTo(&quot;John&quot;); assertThat(foundPerson.getAge()).isEqualTo(30); } catch (Exception ex) { ex.printStackTrace(); } } @AfterEach void tearDown() { entityManagerFactory.close(); }} In the @BeforeEach method, we will create an EntityManagerFactory instance. And in the @AfterEach we call the EntityManagerFactory.close to release the resource. In the @BeforeEach we try to clean up the Person data. Now in the testInsertAndFindPerson test, we insert a new person, then utilize entityManager.find to find the inserted person. The person id is annotated with @ID and @GeneratedValue, when inserting a person into table, hibernate will generate an ID automatically. After it is persisted, the returned instance is filled with the generated id, it should not be a null. Numeric Functions JPA 3.1 adds a collection of new numeric functions in literal JPQL query and type-safe Criteria Builder API. Add some extra properties in the above Person class. public class Person{ private Integer yearsWorked = 2; private LocalDateTime birthDate = LocalDateTime.now().minusYears(30); private BigDecimal salary = new BigDecimal(&quot;12345.678&quot;); private BigDecimal hourlyRate = new BigDecimal(&quot;34.56&quot;); // setters and getters} Create a new test to verify the new numeric functions: ceiling, floor, round, exp, ln, power, sign. @Test@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, CEILING(p.salary) as ceiling, FLOOR(p.salary) as floor, ROUND(p.salary, 1) as round, EXP(p.yearsWorked) as exp, LN(p.yearsWorked) as ln, POWER(p.yearsWorked,2) as power, SIGN(p.yearsWorked) as sign FROM Person p WHERE p.id=:id &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); query.setParameter(&quot;id&quot;, id); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} Next, let’s have a look at how to use them in the Criteria APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { // see: https://hibernate.zulipchat.com/#narrow/stream/132096-hibernate-user/topic/New.20functions.20in.20JPA.203.2E1/near/289429903 var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.ceiling(root.get(&quot;salary&quot;)), cb.floor(root.get(&quot;salary&quot;)), cb.round(root.get(&quot;salary&quot;), 1), cb.exp(root.get(&quot;yearsWorked&quot;)), cb.ln(root.get(&quot;yearsWorked&quot;)), // see: https://hibernate.atlassian.net/browse/HHH-15395 cb.power(root.get(&quot;yearsWorked&quot;), 2), cb.sign(root.get(&quot;yearsWorked&quot;)) ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = entityManager.createQuery(query).getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug( &quot;result: ({},{},{},{},{},{},{},{})&quot;, result.get(0, String.class), result.get(1, BigDecimal.class), result.get(2, BigDecimal.class), result.get(3, BigDecimal.class), result.get(4, Double.class), result.get(5, Double.class), result.get(6, Double.class), result.get(7, Integer.class) ) ); } catch (Exception ex) { fail(ex); }} Note, when using Hibernate 6.1, we have to cast CriteriaBuilder to HibernateCriteriaBuilder to experience the new numeric functions. Hibernate 6.2 will align to JPA 3.1 and fix the issue. DateTime Functions JPA 3.1 add a series of datetime functions and ease the usage of Java 8 DateTime APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, LOCAL TIME as localTime, LOCAL DATETIME as localDateTime, LOCAL DATE as localDate FROM Person p &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} The LOCAL TIME, LOCAL DATETIME, LOCAL DATE query result will be treated as Java 8 LocalTime, LocalDateTime, LocalDate directly. Let’s have a look at the usage in the CriteriaBuilder APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.localTime(), cb.localDateTime(), cb.localDate() ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = entityManager.createQuery(query).getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug( &quot;result: ({},{},{},{})&quot;, result.get(0, String.class), result.get(1, LocalTime.class), result.get(2, LocalDateTime.class), result.get(3, LocalDate.class) ) ); } catch (Exception ex) { fail(ex); }} EXTRACT function JPA 3.1 introduces a extract function to decode fragments from a datetime value. @Test@DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;)public void testExtractFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, EXTRACT(YEAR FROM p.birthDate) as year, EXTRACT(QUARTER FROM p.birthDate) as quarter, EXTRACT(MONTH FROM p.birthDate) as month, EXTRACT(WEEK FROM p.birthDate) as week, EXTRACT(DAY FROM p.birthDate) as day, EXTRACT(HOUR FROM p.birthDate) as hour, EXTRACT(MINUTE FROM p.birthDate) as minute, EXTRACT(SECOND FROM p.birthDate) as second FROM Person p &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} Use the new extract function, we can read the year, quarter, month, week, day, hour, minute, second values from a Java 8 DateTime type property in the JPQL query. Note, there is no mapped extract function in the CriteriaBuilder APIs, for more details, check issue: jakartaee/persistence#356 JakartaEE Runtime Next let’s go to the Jakarta EE 10 compatible products to experience the new features of JPA 3.1. Firstly we will prepare a Jakarta EE 10 web application. Simply generate a web application skeleton via Maven Webapp Archetype. mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4 Then add Jakarta EE 10 dependency into the project pom.xml. Let’s have a look at the modified pom.xml. &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jpa-examples&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;/parent&gt; &lt;name&gt;jpa-examples&lt;/name&gt; &lt;description&gt;Jakarta EE 10 Sandbox: Persistence 3.1 Examples&lt;/description&gt; &lt;properties&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.persistence.jpa.modelgen.processor&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.junit5&lt;/groupId&gt; &lt;artifactId&gt;arquillian-junit5-container&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- see: https://github.com/arquillian/arquillian-core/issues/248 --&gt; &lt;!-- and https://github.com/arquillian/arquillian-core/pull/246/files --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt; &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; In the above pom.xml, we also add JUnit 5 and Arquillian related dependencies in test scope. Through the container specific Aquillian adapter, we can run the tests in Jakarta EE application servers. In this project, we reuse the the Person entity we have introduced in the Hibernate section. Now let’s move to persistence configuration. Create a persistence.xml in the src/main/resources/META-INFO folder. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence version=&quot;3.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd&quot;&gt; &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;JTA&quot;&gt; &lt;jta-data-source&gt;java:comp/DefaultDataSource&lt;/jta-data-source&gt; &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;property name=&quot;jakarta.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- for Glassfish/Payara/EclipseLink --&gt; &lt;property name=&quot;eclipselink.logging.level.sql&quot; value=&quot;FINE&quot;/&gt; &lt;property name=&quot;eclipselink.logging.level&quot; value=&quot;FINE&quot;/&gt; &lt;property name=&quot;eclipselink.logging.parameters&quot; value=&quot;true&quot;/&gt; &lt;!-- for WildFly/Hibernate --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; The configuration is a little different from the one we introduced in the Hibernate section. In a container environment, we would like choose JTA as transaction-type.We do not setup database connection info, instead we configure a built-in DataSource. The java:comp/DefaultDataSource is the default DataSource for all Jakarta EE compatible products. Creating Jakarta EE Sample Application To interact with our backend database, we will create a simple complete JAXRS application, including: A EJB @Stateless bean to read data from databaseAnd expose data via a simple JAXRS resource OK, let’s create class PersonRepository which is annotated with @Stateless. In this class, inject a EntityManager bean with an annotation @PersistenceContext, and add a new method getAllResource to execute a JPQL query to retrieve all persons. @Statelesspublic class PersonRepository { @PersistenceContext EntityManager entityManager; public List&lt;Person&gt; getAllPersons() { return entityManager.createQuery(&quot;select p from Person p&quot;, Person.class) .getResultList(); }} Next, create a PersonResource to expose persons to client. @RequestScoped@Path(&quot;/persons&quot;)public class PersonResource { @Inject PersonRepository personRepository; @Path(&quot;&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response allPersons() { var data = personRepository.getAllPersons(); return Response.ok(data).build(); }} The PersonResource is annotated with RequestScoped, it is a CDI bean, the @Path on the class define the root path of all subresources in this class. The allPersons will produces all persons to client in JSON format when HTTP Client request matches HTTP GET method, and URI is /persons and HTTP Header Accept is compatible with application/json. To activate JAXRS feature, create a class to extend the JAXRS Application, add @ApplicationPath to specify the root context path of all JAXRS resources. @ApplicationPath(&quot;/rest&quot;)public class RestActivator extends Application {} Let’s create a bean to add some sample data at the application startup. @Startup@Singletonpublic class DataInitializer { @PersistenceContext EntityManager entityManager; @PostConstruct public void init() { List .of( new Person(&quot;Jack&quot;, 20), new Person(&quot;Rose&quot;, 18) ) .forEach(entityManager::persist); }} Deploying to Jakarta EE Containers Build and package the application into a war archive. Open a terminal, switch to the project root folder, and execute the following command. mvn clean package -DskipTests -D&quot;maven.test.skip=true&quot; When it is done, there is war package is ready in the path target/jpa-examples.war. GlassFish 7.0 Download the latest GlassFish 7.0, extract files to a location, eg. D:\glassfish7, mark as GlassFish_install.To start GlassFish and Derby, open a terminal, enter GlassFish_install/bin, run asadmin start-database and asadmin start-domain domain1.Copy the above war package to Glassfish_install/glassfish/domains/domain1/autodeploy folder.Open GlassFish_install/glassfish/domains/domain1/logs/server.log, and wait the deployment is completed.Open another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons. You will the following response in the console. [{“age”:18,”birthDate”:”2004–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”d8552d71-ff7f-4650-b5a0-ce1c5fb3fe0b”,”name”:”Rose”,”salary”:12345.678,”yearsWorked”:2},{“age”:20,”birthDate”:”2002–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”cdf94cdc-21b3–492c-b1b5–06bc8cae9947&quot;,”name”:”Jack”,”salary”:12345.678,”yearsWorked”:2}] To stop GlassFish and Derby, run asadmin stop-database and asadmin stop-domain domain1 WildFly Preview 27 Download the latest WildFly Preview, extract files to a location, eg. D:\wildfly-preview-27.0.0.Beta1, mark as WildFly_install.Open a terminal, enter WildFly_install/bin, run standalone to start WildFly with the default standalone profile configuration.Copy the built war to WildFly_install/standalone/deployments.Wait the deployment progress is done, you can use the curl in GlassFish section to verify the application.Send a CTLR+C keys combination in the original WildFly startup console to stop WildFly. Deploying Application via Maven Plugin Deploying to GlassFish via Cargo Plugin The GlassFish project does not include an official Maven plugin to manage GlassFish server. There is a Maven plugin named cargo-maven3-plugin which can be used to manage all popular Jakarta EE application servers and web servers. Add the following profile section to use cargo plugin to manage the lifecycle of GlassFish server. &lt;profile&gt; &lt;id&gt;glassfish&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;cargo.zipUrlInstaller.downloadDir&gt;${project.basedir}/../installs&lt;/cargo.zipUrlInstaller.downloadDir&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;glassfish7x&lt;/containerId&gt; &lt;!-- &lt;artifactInstaller&gt; &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt; &lt;artifactId&gt;glassfish&lt;/artifactId&gt; &lt;version&gt;${glassfish.version}&lt;/version&gt; &lt;/artifactInstaller&gt; --&gt; &lt;zipUrlInstaller&gt; &lt;url&gt;https://github.com/eclipse-ee4j/glassfish/releases/download/${glassfish.version}/glassfish-${glassfish.version}.zip&lt;/url&gt; &lt;downloadDir&gt;${cargo.zipUrlInstaller.downloadDir}&lt;/downloadDir&gt; &lt;/zipUrlInstaller&gt; &lt;/container&gt; &lt;configuration&gt; &lt;!-- the configuration used to deploy --&gt; &lt;home&gt;${project.build.directory}/glassfish7x-home&lt;/home&gt; &lt;properties&gt; &lt;cargo.remote.password&gt;&lt;/cargo.remote.password&gt; &lt;cargo.glassfish.removeDefaultDatasource&gt;true&lt;/cargo.glassfish.removeDefaultDatasource&gt; &lt;/properties&gt; &lt;datasources&gt; &lt;datasource&gt; &lt;driverClass&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/driverClass&gt; &lt;url&gt;jdbc:derby:derbyDB;create=true&lt;/url&gt; &lt;jndiName&gt;jdbc/__default&lt;/jndiName&gt; &lt;username&gt;APP&lt;/username&gt; &lt;password&gt;nonemptypassword&lt;/password&gt; &lt;/datasource&gt; &lt;/datasources&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; Unlike the approach in NetBeans IDE or Eclipse IDE with GlassFish Pack, where starting GlassFish it will start the built-in Derby at the same time. Cargo does not start the built-in Derby as expected, to use the default DataSource in our project, clear the default DataSource and add a new default DataSource based on the embedded Derby. Run the following command. It will compile the project source codes and package the application into a war archive, then start the managed GlassFish server(with a new cargo-domain), and then deploy the package into this running server. mvn clean package cargo:run -DskipTests -Dmaven.test.skip=true Note, when you run this command at the first time, it will spend some time to download a copy of the GlassFish redistribution, and extract the files into the build folder. In another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons to verify the endpoint. To stop the server, just send a CTRL+C in the original GlassFish running console. Deploying to WildFly via WildFly Plugin The WildFly project itself provides an official WildFly Maven plugin, we will configure it in a new Maven profile. Cargo maven plugin also supports WildFly, check Cargo WildFly docs. &lt;profile&gt; &lt;id&gt;wildfly&lt;/id&gt; &lt;properties&gt; &lt;!-- Wildfly server --&gt; &lt;wildfly.artifactId&gt;wildfly-preview-dist&lt;/wildfly.artifactId&gt; &lt;jboss-as.home&gt;${project.build.directory}/wildfly-preview-${wildfly.version}&lt;/jboss-as.home&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- unpack a copy of WildFly--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.wildfly&lt;/groupId&gt; &lt;artifactId&gt;${wildfly.artifactId}&lt;/artifactId&gt; &lt;version&gt;${wildfly.version}&lt;/version&gt; &lt;type&gt;zip&lt;/type&gt; &lt;overWrite&gt;false&lt;/overWrite&gt; &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- The WildFly plugin deploys your war to a local running WildFly container --&gt; &lt;!-- To use, run: mvn package wildfly:deploy --&gt; &lt;!-- For Jakarta EE 9, use `wildfly-preview-dist` as artifactId instead to start and deploy applications--&gt; &lt;!-- Run: mvn clean wildfly:run -PWildfly -Dwildfly.artifactId=wildfly-preview-dist -Dwildfly.version=22.0.0.Alpha1 --&gt; &lt;!-- or set the `jboss-as.home` to run: mvn clean wildfly:run -PWildfly -Djboss-as.home=D:\appsvr\wildfly-preview-22.0.0.Alpha1--&gt; &lt;plugin&gt; &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt; &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${wildfly-maven-plugin.version}&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;opensaml&lt;/id&gt; &lt;url&gt;https://build.shibboleth.net/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/profile&gt; With the WildFly plugin, we can deploy applications into an embedded WildFly, a managed WildFly server or a remote running WildFly server. mvn clean wildfly:run -Pwildfly -DskipTests -Dmaven.test.skip=true By default, if we do not setup a jboss-as.home or remote host connection info, it will bootstrap an embedded WildFly and run the application with the embedded server. Here we configure Maven dependency plugin to download a copy of WildFly, extract the files to the project build directory, and setup a jboss-as.home property, the value is the WildFly location. The WildFly plugin will manage the whole WildFly lifecycle - start the WildFly server, deploy applications into the running server, (use CTRL+C hotkey) stop the server. Testing JPA Features Here I assume you are familiar with JUnit and Arquillian before. For the developers new to Arqullian framework, please read the official Arquillian Guides to start your first step. Note, these tutorials are available in several languages, including Simplified Chinese. Go to my Jakarta EE 8 starter boilerplate project and Jakarta EE 9 starter boilerplate project to update your Arquilian knowledge. Since Jakarta EE 9, it uses the new jakarta namespace, Arquillian 1.7.0.x starts to support these changes. In the next steps, we will configure a managed GlassFish Arquillian Adapter to run the testing codes. &lt;profile&gt; &lt;id&gt;arq-glassfish-managed&lt;/id&gt; &lt;properties&gt; &lt;skip.unit.tests&gt;true&lt;/skip.unit.tests&gt; &lt;skip.integration.tests&gt;false&lt;/skip.integration.tests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Jersey --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.hantsy.arquillian-container-glassfish-jakarta&lt;/groupId&gt; &lt;artifactId&gt;arquillian-glassfish-managed-jakarta&lt;/artifactId&gt; &lt;version&gt;${arquillian-glassfish-jakarta.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;testResource&gt; &lt;directory&gt;src/test/arq-glassfish-managed&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt; &lt;artifactId&gt;glassfish&lt;/artifactId&gt; &lt;version&gt;${glassfish.version}&lt;/version&gt; &lt;type&gt;zip&lt;/type&gt; &lt;overWrite&gt;false&lt;/overWrite&gt; &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;environmentVariables&gt; &lt;GLASSFISH_HOME&gt;${project.build.directory}/glassfish7&lt;/GLASSFISH_HOME&gt; &lt;/environmentVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; In the above configuration, we add com.github.hantsy.arquillian-container-glassfish-jakarta:arquillian-glassfish-managed-jakarta, which is my fork of the official Arquillian Container GlassFish project. We preapre a copy of the latest GlassFish 7.0 in the pre-integration-test phase. The Arquillian tests will be exectued in the integretion-test phase. Let’s create a simple Arquillian tests to verify the UUID basic type feature in JPA 3.1. @ExtendWith(ArquillianExtension.class)public class UUIDStrategyTest { private final static Logger LOGGER = Logger.getLogger(UUIDStrategyTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { startTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { try { if( ux.getStatus() == Status.STATUS_ACTIVE ) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test public void testPersistingPersons() throws Exception { final Person person = new Person(); person.setName(&quot;Hantsy Bai&quot;); em.persist(person); endTx(); startTx(); final Person foundPerson = em.find(Person.class, person.getId()); assertNotNull(foundPerson.getId()); LOGGER.log(Level.INFO, &quot;Found person: {0}&quot;, foundPerson); }} The @ExtendWith(ArquillianExtension.class) annotation on a test class to support Arquillian test lifecycle. The @Deployment annotated static method defines the resources that will be packaged into the test archive and deployed into the manged GlassFish server. It is easy to use shrinkwrap to create a fine-grined deploymen unit. You can inject EntityManager and UserTransaction beans in an Arquillian test like what you do in a simple CDI bean. In this test class, we setup @BeforeEach and @AfterEach hooks to start a transacation and end the transaction. The test method testPersistingPersons looks no difference from a plain JUnit test. Firstly we persist a person entity, and commit the transaction to ensure it will be flushed into the database as expected. Then exectuing a simple JPA query to verify the persisted data. Execute the following command to run the tests. mvn clean verify -Parq-glassfish-managed Similiarly, create a test to verify the new numeric functions and datetime functions in Jakarta rumtimes. @ExtendWith(ArquillianExtension.class)public class JPQLFunctionsTest { private final static Logger LOGGER = Logger.getLogger(JPQLFunctionsTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { clearPersons(); startTx(); } private void clearPersons() throws Exception { startTx(); var builder = em.getCriteriaBuilder(); var deletePersonQuery = builder.createCriteriaDelete(Person.class); var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate(); LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons); endTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus()); try { if (ux.getStatus() == Status.STATUS_ACTIVE) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;) public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name, CEILING(p.salary), FLOOR(p.salary), ROUND(p.salary, 1), EXP(p.yearsWorked), LN(p.yearsWorked), POWER(p.yearsWorked,2), SIGN(p.yearsWorked) FROM Person p WHERE p.id=:id &quot;&quot;&quot;; var query = em.createQuery(queryString); query.setParameter(&quot;id&quot;, id); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;) public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); assertNotNull(person.getId()); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, LOCAL TIME as localTime, LOCAL DATETIME as localDateTime, LOCAL DATE as localDate FROM Person p &quot;&quot;&quot;; // for EclipseLinks var query = em.createQuery(queryString); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;) public void testExtractFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); assertNotNull(person.getId()); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, EXTRACT(YEAR FROM p.birthDate) as year, EXTRACT(QUARTER FROM p.birthDate) as quarter, EXTRACT(MONTH FROM p.birthDate) as month, EXTRACT(WEEK FROM p.birthDate) as week, EXTRACT(DAY FROM p.birthDate) as day, EXTRACT(HOUR FROM p.birthDate) as hour, EXTRACT(MINUTE FROM p.birthDate) as minute, EXTRACT(SECOND FROM p.birthDate) as second FROM Person p &quot;&quot;&quot;; var query = em.createQuery(queryString); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } }} Alternatively, create a test to verify the Criteria APIs. @ExtendWith(ArquillianExtension.class)public class JPQLCriteriaBuilderTest { private final static Logger LOGGER = Logger.getLogger(JPQLCriteriaBuilderTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { clearPersons(); startTx(); } private void clearPersons() throws Exception { startTx(); var builder = em.getCriteriaBuilder(); var deletePersonQuery = builder.createCriteriaDelete(Person.class); var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate(); LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons); endTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus()); try { if (ux.getStatus() == Status.STATUS_ACTIVE) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;) public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var cb = em.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.ceiling(root.get(&quot;salary&quot;)), cb.floor(root.get(&quot;salary&quot;)), cb.round(root.get(&quot;salary&quot;), 1), cb.exp(root.get(&quot;yearsWorked&quot;)), cb.ln(root.get(&quot;yearsWorked&quot;)), cb.power(root.get(&quot;yearsWorked&quot;), 2), cb.sign(root.get(&quot;yearsWorked&quot;)) ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = em.createQuery(query).getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(result -&gt; LOGGER.log( Level.INFO, // see: https://github.com/eclipse-ee4j/eclipselink/issues/1593 // John,12,345,12,345,12,345,7.389,0.693,4,1 &quot;tuple data :{0},{1},{2},{3},{4},{5},{6},{7}&quot;, new Object[]{ result.get(0, String.class), result.get(1, BigDecimal.class), // it should return BigDecimal result.get(2, BigDecimal.class), result.get(3, BigDecimal.class), result.get(4, Double.class), result.get(5, Double.class), result.get(6, Double.class), result.get(7, Integer.class) } ) ); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;) public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var cb = em.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.localTime(), cb.localDateTime(), cb.localDate() ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = em.createQuery(query).getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; LOGGER.log( Level.INFO, &quot;tuple data :{0},{1},{2},{3}&quot;, new Object[]{ data.get(0, String.class), data.get(1, java.time.LocalTime.class), data.get(2, java.time.LocalDateTime.class), data.get(3, java.time.LocalDate.class) } ) ); } catch (Exception ex) { fail(ex); } }} But unfortunately, there is a bug in the GlassFish 7.0.0-M9 will fail the test JPQLFunctionsTest, more details please check Github issues GlassFish #24120. Check the sample codes of Hibernate and Jakarta Persistence from my github. &lt;hr&gt;&lt;p&gt;What’s New in Jakarta Persistence 3.1 By Examples was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-13T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="What’s New in Jakarta Persistence 3.1 By Examples" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-13T00:00:00+00:00","datePublished":"2022-11-13T00:00:00+00:00","description":"Jakarta Persistence(aka JPA) 3.1 brings a collection of improvements. The UUID class now is treated as Basic Java Type. To support UUID type ID in Entity class, JPA introduces a new UUID generator.Several numeric functions and date/time specific functions are added in JPQL and type-safe Criteria API. More details please read What’s New in Jakarta Persistence 3.1. Next let’s explore these features by writing some real example codes. Photo by &lt;a href=”https://unsplash.com/@lin_alessio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Alessio Lin&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/china-building?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt; Hibernate 6.1 Generate a simple Java application project via Maven Quickstart archetype. mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 There are some interactive steps to guide you setup the project info, such as groupId, artifact, version etc. In this example project, we use com.example as groupId, and demo as artifactId. Then confirm and begin to generate the project source codes. After it is done, open the project in a Java IDE such as IntelliJ IDEA(Community Edition is free), or Eclipse Java/Java EE bundle, or NetBeans IDE, or a simple text editor, eg. VS Code. Modify the pom.xml in the project root folder, add Hibernate 6.1, and JUnit etc. into project dependencies, and setup Maven compiler plugin to use Java 17 to compile the source codes. The final pom.xml looks like the following. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;hibernate6&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;/parent&gt; &lt;name&gt;hibernate6&lt;/name&gt; &lt;description&gt;Jakarta EE 10 Sandbox: Hibernate 6/JPA 3.1 example&lt;/description&gt; &lt;properties&gt; &lt;maven.compiler.release&gt;17&lt;/maven.compiler.release&gt; &lt;!-- requires 6.1.2.Final or higher --&gt; &lt;hibernate.version&gt;6.1.4.Final&lt;/hibernate.version&gt; &lt;h2.version&gt;2.1.214&lt;/h2.version&gt; &lt;!-- test deps --&gt; &lt;junit-jupiter.version&gt;5.9.1&lt;/junit-jupiter.version&gt; &lt;assertj-core.version&gt;3.23.1&lt;/assertj-core.version&gt; &lt;slf4j.version&gt;2.0.3&lt;/slf4j.version&gt; &lt;logback.version&gt;1.4.4&lt;/logback.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt; &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- H2 Database --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;${h2.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logging with logback --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;${logback.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- test dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;${junit-jupiter.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;version&gt;${assertj-core.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt; &lt;artifactId&gt;hibernate-testing&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M7&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; NOTE: To share common resources for all feature-based projects, create a parent POM to centralize the common configurations in one place, check the parent pom.xml file. In this example project, we use H2 embedded database for test purpose. Hibernate 6.1 implements the features of Jakarta Persistence 3.1, but it includes a Jakarta Persistence 3.0 API in the transitive dependency tree. To use Jakarta Persistence 3.1 API, we have to add jakarta.persistence:jakarta.persistence-api 3.1 explicitly. In the src/main/resources/META-INF, add a new file named persistence.xml. &lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt; &lt;description&gt;Hibernate test case template Persistence Unit&lt;/description&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;property name=&quot;hibernate.archive.autodetection&quot; value=&quot;class, hbm&quot;/&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt; &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1&quot;/&gt; &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt; &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create-drop&quot;/&gt; &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;hibernate.cache.region_prefix&quot; value=&quot;hibernate.test&quot;/&gt; &lt;property name=&quot;hibernate.cache.region.factory_class&quot; value=&quot;org.hibernate.testing.cache.CachingRegionFactory&quot;/&gt; &lt;!--NOTE: hibernate.jdbc.batch_versioned_data should be set to false when testing with Oracle--&gt; &lt;property name=&quot;hibernate.jdbc.batch_versioned_data&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;jakarta.persistence.validation.mode&quot; value=&quot;NONE&quot;/&gt; &lt;property name=&quot;hibernate.service.allow_crawling&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;hibernate.session.events.log&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; We use logback as the logging framework in this project. In the src/main/resources, add a logback.xml to configure logback. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;property name=&quot;LOGS&quot; value=&quot;./logs&quot;/&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt; %green(%d{ISO8601}) %highlight(%-5level) [%blue(%t)] %yellow(%C{1.}): %msg%n%throwable &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;${LOGS}/app.log&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt; &lt;fileNamePattern&gt;${LOGS}/archived/app-%d{yyyy-MM-dd}.%i.log &lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- LOG everything at INFO level --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;!-- Debug hibernate SQL, see: https://thorben-janssen.com/hibernate-logging-guide/ --&gt; &lt;logger name=&quot;org.hibernate.SQL&quot; level=&quot;DEBUG&quot;/&gt; &lt;logger name=&quot;org.hibernate.type.descriptor.sql&quot; level=&quot;trace&quot;/&gt; &lt;!-- Custom debug level for the application code --&gt; &lt;logger name=&quot;com.example&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt;&lt;/configuration&gt; We set org.hibernate.SQL logging level to DEBUG and org.hibernate.type.descriptor.sql to trace, it will help you to dig into the Hibernate generated sql at runtime. UUID Basic Type Support JPA 3.1 allows to use UUID as basic Java type, especially it add a UUID ID generator. Create a simple Entity. @Entitypublic class Person { @Id @Column(name = &quot;id&quot;, nullable = false) @GeneratedValue(strategy = GenerationType.UUID) private UUID id; private String name; private int age = 30; public Person() { } public Person(String name, int age) { assert age &gt; 0; this.name = name; this.age = age; this.birthDate = LocalDateTime.now().minusYears(this.age); } // getters and setters // override equals and hashCode} An entity class is annotated with an @Entity, optionally you can specify the entity name and add table definition with an extra @Table annotation. Here we defined a UUID type ID, and use a UUID generation strategy. JPA requires an Entity should includes a no-arguments constructor, if you declare another constructor with a few arguments, you should declare this no-arguments constructor explicitly. Create a simple JUnit test to verify if the UUID type working as expected. class PersonUUIDTest { private static final Logger log = LoggerFactory.getLogger(PersonUUIDTest.class); private EntityManagerFactory entityManagerFactory; @BeforeEach void setUp() { entityManagerFactory = Persistence.createEntityManagerFactory(&quot;defaultPU&quot;); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); var deleteFromPerson = entityManager.createQuery(&quot;DELETE FROM Person&quot;).executeUpdate(); log.debug(&quot;Deleted {} persons&quot;, deleteFromPerson); entityManager.getTransaction().commit(); entityManager.close(); } @Test @DisplayName(&quot;insert person and verify person&quot;) public void testInsertAndFindPerson() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var foundPerson = entityManager.find(Person.class, id); assertThat(foundPerson.getId()).isNotNull(); assertThat(foundPerson.getName()).isEqualTo(&quot;John&quot;); assertThat(foundPerson.getAge()).isEqualTo(30); } catch (Exception ex) { ex.printStackTrace(); } } @AfterEach void tearDown() { entityManagerFactory.close(); }} In the @BeforeEach method, we will create an EntityManagerFactory instance. And in the @AfterEach we call the EntityManagerFactory.close to release the resource. In the @BeforeEach we try to clean up the Person data. Now in the testInsertAndFindPerson test, we insert a new person, then utilize entityManager.find to find the inserted person. The person id is annotated with @ID and @GeneratedValue, when inserting a person into table, hibernate will generate an ID automatically. After it is persisted, the returned instance is filled with the generated id, it should not be a null. Numeric Functions JPA 3.1 adds a collection of new numeric functions in literal JPQL query and type-safe Criteria Builder API. Add some extra properties in the above Person class. public class Person{ private Integer yearsWorked = 2; private LocalDateTime birthDate = LocalDateTime.now().minusYears(30); private BigDecimal salary = new BigDecimal(&quot;12345.678&quot;); private BigDecimal hourlyRate = new BigDecimal(&quot;34.56&quot;); // setters and getters} Create a new test to verify the new numeric functions: ceiling, floor, round, exp, ln, power, sign. @Test@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, CEILING(p.salary) as ceiling, FLOOR(p.salary) as floor, ROUND(p.salary, 1) as round, EXP(p.yearsWorked) as exp, LN(p.yearsWorked) as ln, POWER(p.yearsWorked,2) as power, SIGN(p.yearsWorked) as sign FROM Person p WHERE p.id=:id &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); query.setParameter(&quot;id&quot;, id); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} Next, let’s have a look at how to use them in the Criteria APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { // see: https://hibernate.zulipchat.com/#narrow/stream/132096-hibernate-user/topic/New.20functions.20in.20JPA.203.2E1/near/289429903 var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.ceiling(root.get(&quot;salary&quot;)), cb.floor(root.get(&quot;salary&quot;)), cb.round(root.get(&quot;salary&quot;), 1), cb.exp(root.get(&quot;yearsWorked&quot;)), cb.ln(root.get(&quot;yearsWorked&quot;)), // see: https://hibernate.atlassian.net/browse/HHH-15395 cb.power(root.get(&quot;yearsWorked&quot;), 2), cb.sign(root.get(&quot;yearsWorked&quot;)) ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = entityManager.createQuery(query).getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug( &quot;result: ({},{},{},{},{},{},{},{})&quot;, result.get(0, String.class), result.get(1, BigDecimal.class), result.get(2, BigDecimal.class), result.get(3, BigDecimal.class), result.get(4, Double.class), result.get(5, Double.class), result.get(6, Double.class), result.get(7, Integer.class) ) ); } catch (Exception ex) { fail(ex); }} Note, when using Hibernate 6.1, we have to cast CriteriaBuilder to HibernateCriteriaBuilder to experience the new numeric functions. Hibernate 6.2 will align to JPA 3.1 and fix the issue. DateTime Functions JPA 3.1 add a series of datetime functions and ease the usage of Java 8 DateTime APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, LOCAL TIME as localTime, LOCAL DATETIME as localDateTime, LOCAL DATE as localDate FROM Person p &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} The LOCAL TIME, LOCAL DATETIME, LOCAL DATE query result will be treated as Java 8 LocalTime, LocalDateTime, LocalDate directly. Let’s have a look at the usage in the CriteriaBuilder APIs. @Test@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.localTime(), cb.localDateTime(), cb.localDate() ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = entityManager.createQuery(query).getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug( &quot;result: ({},{},{},{})&quot;, result.get(0, String.class), result.get(1, LocalTime.class), result.get(2, LocalDateTime.class), result.get(3, LocalDate.class) ) ); } catch (Exception ex) { fail(ex); }} EXTRACT function JPA 3.1 introduces a extract function to decode fragments from a datetime value. @Test@DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;)public void testExtractFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); var entityManager = entityManagerFactory.createEntityManager(); entityManager.getTransaction().begin(); entityManager.persist(person); entityManager.getTransaction().commit(); var id = person.getId(); assertNotNull(id); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, EXTRACT(YEAR FROM p.birthDate) as year, EXTRACT(QUARTER FROM p.birthDate) as quarter, EXTRACT(MONTH FROM p.birthDate) as month, EXTRACT(WEEK FROM p.birthDate) as week, EXTRACT(DAY FROM p.birthDate) as day, EXTRACT(HOUR FROM p.birthDate) as hour, EXTRACT(MINUTE FROM p.birthDate) as minute, EXTRACT(SECOND FROM p.birthDate) as second FROM Person p &quot;&quot;&quot;; var query = entityManager.createQuery(queryString); var resultList = query.getResultList(); log.debug(&quot;Result list: {}&quot;, resultList); resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result)); } catch (Exception ex) { ex.printStackTrace(); }} Use the new extract function, we can read the year, quarter, month, week, day, hour, minute, second values from a Java 8 DateTime type property in the JPQL query. Note, there is no mapped extract function in the CriteriaBuilder APIs, for more details, check issue: jakartaee/persistence#356 JakartaEE Runtime Next let’s go to the Jakarta EE 10 compatible products to experience the new features of JPA 3.1. Firstly we will prepare a Jakarta EE 10 web application. Simply generate a web application skeleton via Maven Webapp Archetype. mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4 Then add Jakarta EE 10 dependency into the project pom.xml. Let’s have a look at the modified pom.xml. &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jpa-examples&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;/parent&gt; &lt;name&gt;jpa-examples&lt;/name&gt; &lt;description&gt;Jakarta EE 10 Sandbox: Persistence 3.1 Examples&lt;/description&gt; &lt;properties&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.persistence.jpa.modelgen.processor&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.junit5&lt;/groupId&gt; &lt;artifactId&gt;arquillian-junit5-container&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- see: https://github.com/arquillian/arquillian-core/issues/248 --&gt; &lt;!-- and https://github.com/arquillian/arquillian-core/pull/246/files --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt; &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; In the above pom.xml, we also add JUnit 5 and Arquillian related dependencies in test scope. Through the container specific Aquillian adapter, we can run the tests in Jakarta EE application servers. In this project, we reuse the the Person entity we have introduced in the Hibernate section. Now let’s move to persistence configuration. Create a persistence.xml in the src/main/resources/META-INFO folder. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;persistence version=&quot;3.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd&quot;&gt; &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;JTA&quot;&gt; &lt;jta-data-source&gt;java:comp/DefaultDataSource&lt;/jta-data-source&gt; &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt; &lt;properties&gt; &lt;property name=&quot;jakarta.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt; &lt;!-- for Glassfish/Payara/EclipseLink --&gt; &lt;property name=&quot;eclipselink.logging.level.sql&quot; value=&quot;FINE&quot;/&gt; &lt;property name=&quot;eclipselink.logging.level&quot; value=&quot;FINE&quot;/&gt; &lt;property name=&quot;eclipselink.logging.parameters&quot; value=&quot;true&quot;/&gt; &lt;!-- for WildFly/Hibernate --&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; The configuration is a little different from the one we introduced in the Hibernate section. In a container environment, we would like choose JTA as transaction-type.We do not setup database connection info, instead we configure a built-in DataSource. The java:comp/DefaultDataSource is the default DataSource for all Jakarta EE compatible products. Creating Jakarta EE Sample Application To interact with our backend database, we will create a simple complete JAXRS application, including: A EJB @Stateless bean to read data from databaseAnd expose data via a simple JAXRS resource OK, let’s create class PersonRepository which is annotated with @Stateless. In this class, inject a EntityManager bean with an annotation @PersistenceContext, and add a new method getAllResource to execute a JPQL query to retrieve all persons. @Statelesspublic class PersonRepository { @PersistenceContext EntityManager entityManager; public List&lt;Person&gt; getAllPersons() { return entityManager.createQuery(&quot;select p from Person p&quot;, Person.class) .getResultList(); }} Next, create a PersonResource to expose persons to client. @RequestScoped@Path(&quot;/persons&quot;)public class PersonResource { @Inject PersonRepository personRepository; @Path(&quot;&quot;) @GET @Produces(MediaType.APPLICATION_JSON) public Response allPersons() { var data = personRepository.getAllPersons(); return Response.ok(data).build(); }} The PersonResource is annotated with RequestScoped, it is a CDI bean, the @Path on the class define the root path of all subresources in this class. The allPersons will produces all persons to client in JSON format when HTTP Client request matches HTTP GET method, and URI is /persons and HTTP Header Accept is compatible with application/json. To activate JAXRS feature, create a class to extend the JAXRS Application, add @ApplicationPath to specify the root context path of all JAXRS resources. @ApplicationPath(&quot;/rest&quot;)public class RestActivator extends Application {} Let’s create a bean to add some sample data at the application startup. @Startup@Singletonpublic class DataInitializer { @PersistenceContext EntityManager entityManager; @PostConstruct public void init() { List .of( new Person(&quot;Jack&quot;, 20), new Person(&quot;Rose&quot;, 18) ) .forEach(entityManager::persist); }} Deploying to Jakarta EE Containers Build and package the application into a war archive. Open a terminal, switch to the project root folder, and execute the following command. mvn clean package -DskipTests -D&quot;maven.test.skip=true&quot; When it is done, there is war package is ready in the path target/jpa-examples.war. GlassFish 7.0 Download the latest GlassFish 7.0, extract files to a location, eg. D:\\glassfish7, mark as GlassFish_install.To start GlassFish and Derby, open a terminal, enter GlassFish_install/bin, run asadmin start-database and asadmin start-domain domain1.Copy the above war package to Glassfish_install/glassfish/domains/domain1/autodeploy folder.Open GlassFish_install/glassfish/domains/domain1/logs/server.log, and wait the deployment is completed.Open another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons. You will the following response in the console. [{“age”:18,”birthDate”:”2004–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”d8552d71-ff7f-4650-b5a0-ce1c5fb3fe0b”,”name”:”Rose”,”salary”:12345.678,”yearsWorked”:2},{“age”:20,”birthDate”:”2002–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”cdf94cdc-21b3–492c-b1b5–06bc8cae9947&quot;,”name”:”Jack”,”salary”:12345.678,”yearsWorked”:2}] To stop GlassFish and Derby, run asadmin stop-database and asadmin stop-domain domain1 WildFly Preview 27 Download the latest WildFly Preview, extract files to a location, eg. D:\\wildfly-preview-27.0.0.Beta1, mark as WildFly_install.Open a terminal, enter WildFly_install/bin, run standalone to start WildFly with the default standalone profile configuration.Copy the built war to WildFly_install/standalone/deployments.Wait the deployment progress is done, you can use the curl in GlassFish section to verify the application.Send a CTLR+C keys combination in the original WildFly startup console to stop WildFly. Deploying Application via Maven Plugin Deploying to GlassFish via Cargo Plugin The GlassFish project does not include an official Maven plugin to manage GlassFish server. There is a Maven plugin named cargo-maven3-plugin which can be used to manage all popular Jakarta EE application servers and web servers. Add the following profile section to use cargo plugin to manage the lifecycle of GlassFish server. &lt;profile&gt; &lt;id&gt;glassfish&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;cargo.zipUrlInstaller.downloadDir&gt;${project.basedir}/../installs&lt;/cargo.zipUrlInstaller.downloadDir&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;glassfish7x&lt;/containerId&gt; &lt;!-- &lt;artifactInstaller&gt; &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt; &lt;artifactId&gt;glassfish&lt;/artifactId&gt; &lt;version&gt;${glassfish.version}&lt;/version&gt; &lt;/artifactInstaller&gt; --&gt; &lt;zipUrlInstaller&gt; &lt;url&gt;https://github.com/eclipse-ee4j/glassfish/releases/download/${glassfish.version}/glassfish-${glassfish.version}.zip&lt;/url&gt; &lt;downloadDir&gt;${cargo.zipUrlInstaller.downloadDir}&lt;/downloadDir&gt; &lt;/zipUrlInstaller&gt; &lt;/container&gt; &lt;configuration&gt; &lt;!-- the configuration used to deploy --&gt; &lt;home&gt;${project.build.directory}/glassfish7x-home&lt;/home&gt; &lt;properties&gt; &lt;cargo.remote.password&gt;&lt;/cargo.remote.password&gt; &lt;cargo.glassfish.removeDefaultDatasource&gt;true&lt;/cargo.glassfish.removeDefaultDatasource&gt; &lt;/properties&gt; &lt;datasources&gt; &lt;datasource&gt; &lt;driverClass&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/driverClass&gt; &lt;url&gt;jdbc:derby:derbyDB;create=true&lt;/url&gt; &lt;jndiName&gt;jdbc/__default&lt;/jndiName&gt; &lt;username&gt;APP&lt;/username&gt; &lt;password&gt;nonemptypassword&lt;/password&gt; &lt;/datasource&gt; &lt;/datasources&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; Unlike the approach in NetBeans IDE or Eclipse IDE with GlassFish Pack, where starting GlassFish it will start the built-in Derby at the same time. Cargo does not start the built-in Derby as expected, to use the default DataSource in our project, clear the default DataSource and add a new default DataSource based on the embedded Derby. Run the following command. It will compile the project source codes and package the application into a war archive, then start the managed GlassFish server(with a new cargo-domain), and then deploy the package into this running server. mvn clean package cargo:run -DskipTests -Dmaven.test.skip=true Note, when you run this command at the first time, it will spend some time to download a copy of the GlassFish redistribution, and extract the files into the build folder. In another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons to verify the endpoint. To stop the server, just send a CTRL+C in the original GlassFish running console. Deploying to WildFly via WildFly Plugin The WildFly project itself provides an official WildFly Maven plugin, we will configure it in a new Maven profile. Cargo maven plugin also supports WildFly, check Cargo WildFly docs. &lt;profile&gt; &lt;id&gt;wildfly&lt;/id&gt; &lt;properties&gt; &lt;!-- Wildfly server --&gt; &lt;wildfly.artifactId&gt;wildfly-preview-dist&lt;/wildfly.artifactId&gt; &lt;jboss-as.home&gt;${project.build.directory}/wildfly-preview-${wildfly.version}&lt;/jboss-as.home&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- unpack a copy of WildFly--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;process-classes&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.wildfly&lt;/groupId&gt; &lt;artifactId&gt;${wildfly.artifactId}&lt;/artifactId&gt; &lt;version&gt;${wildfly.version}&lt;/version&gt; &lt;type&gt;zip&lt;/type&gt; &lt;overWrite&gt;false&lt;/overWrite&gt; &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- The WildFly plugin deploys your war to a local running WildFly container --&gt; &lt;!-- To use, run: mvn package wildfly:deploy --&gt; &lt;!-- For Jakarta EE 9, use `wildfly-preview-dist` as artifactId instead to start and deploy applications--&gt; &lt;!-- Run: mvn clean wildfly:run -PWildfly -Dwildfly.artifactId=wildfly-preview-dist -Dwildfly.version=22.0.0.Alpha1 --&gt; &lt;!-- or set the `jboss-as.home` to run: mvn clean wildfly:run -PWildfly -Djboss-as.home=D:\\appsvr\\wildfly-preview-22.0.0.Alpha1--&gt; &lt;plugin&gt; &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt; &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${wildfly-maven-plugin.version}&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;opensaml&lt;/id&gt; &lt;url&gt;https://build.shibboleth.net/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/profile&gt; With the WildFly plugin, we can deploy applications into an embedded WildFly, a managed WildFly server or a remote running WildFly server. mvn clean wildfly:run -Pwildfly -DskipTests -Dmaven.test.skip=true By default, if we do not setup a jboss-as.home or remote host connection info, it will bootstrap an embedded WildFly and run the application with the embedded server. Here we configure Maven dependency plugin to download a copy of WildFly, extract the files to the project build directory, and setup a jboss-as.home property, the value is the WildFly location. The WildFly plugin will manage the whole WildFly lifecycle - start the WildFly server, deploy applications into the running server, (use CTRL+C hotkey) stop the server. Testing JPA Features Here I assume you are familiar with JUnit and Arquillian before. For the developers new to Arqullian framework, please read the official Arquillian Guides to start your first step. Note, these tutorials are available in several languages, including Simplified Chinese. Go to my Jakarta EE 8 starter boilerplate project and Jakarta EE 9 starter boilerplate project to update your Arquilian knowledge. Since Jakarta EE 9, it uses the new jakarta namespace, Arquillian 1.7.0.x starts to support these changes. In the next steps, we will configure a managed GlassFish Arquillian Adapter to run the testing codes. &lt;profile&gt; &lt;id&gt;arq-glassfish-managed&lt;/id&gt; &lt;properties&gt; &lt;skip.unit.tests&gt;true&lt;/skip.unit.tests&gt; &lt;skip.integration.tests&gt;false&lt;/skip.integration.tests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Jersey --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.hantsy.arquillian-container-glassfish-jakarta&lt;/groupId&gt; &lt;artifactId&gt;arquillian-glassfish-managed-jakarta&lt;/artifactId&gt; &lt;version&gt;${arquillian-glassfish-jakarta.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;directory&gt;src/test/resources&lt;/directory&gt; &lt;/testResource&gt; &lt;testResource&gt; &lt;directory&gt;src/test/arq-glassfish-managed&lt;/directory&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;unpack&lt;/id&gt; &lt;phase&gt;pre-integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;unpack&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;artifactItems&gt; &lt;artifactItem&gt; &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt; &lt;artifactId&gt;glassfish&lt;/artifactId&gt; &lt;version&gt;${glassfish.version}&lt;/version&gt; &lt;type&gt;zip&lt;/type&gt; &lt;overWrite&gt;false&lt;/overWrite&gt; &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt; &lt;/artifactItem&gt; &lt;/artifactItems&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;environmentVariables&gt; &lt;GLASSFISH_HOME&gt;${project.build.directory}/glassfish7&lt;/GLASSFISH_HOME&gt; &lt;/environmentVariables&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; In the above configuration, we add com.github.hantsy.arquillian-container-glassfish-jakarta:arquillian-glassfish-managed-jakarta, which is my fork of the official Arquillian Container GlassFish project. We preapre a copy of the latest GlassFish 7.0 in the pre-integration-test phase. The Arquillian tests will be exectued in the integretion-test phase. Let’s create a simple Arquillian tests to verify the UUID basic type feature in JPA 3.1. @ExtendWith(ArquillianExtension.class)public class UUIDStrategyTest { private final static Logger LOGGER = Logger.getLogger(UUIDStrategyTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { startTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { try { if( ux.getStatus() == Status.STATUS_ACTIVE ) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test public void testPersistingPersons() throws Exception { final Person person = new Person(); person.setName(&quot;Hantsy Bai&quot;); em.persist(person); endTx(); startTx(); final Person foundPerson = em.find(Person.class, person.getId()); assertNotNull(foundPerson.getId()); LOGGER.log(Level.INFO, &quot;Found person: {0}&quot;, foundPerson); }} The @ExtendWith(ArquillianExtension.class) annotation on a test class to support Arquillian test lifecycle. The @Deployment annotated static method defines the resources that will be packaged into the test archive and deployed into the manged GlassFish server. It is easy to use shrinkwrap to create a fine-grined deploymen unit. You can inject EntityManager and UserTransaction beans in an Arquillian test like what you do in a simple CDI bean. In this test class, we setup @BeforeEach and @AfterEach hooks to start a transacation and end the transaction. The test method testPersistingPersons looks no difference from a plain JUnit test. Firstly we persist a person entity, and commit the transaction to ensure it will be flushed into the database as expected. Then exectuing a simple JPA query to verify the persisted data. Execute the following command to run the tests. mvn clean verify -Parq-glassfish-managed Similiarly, create a test to verify the new numeric functions and datetime functions in Jakarta rumtimes. @ExtendWith(ArquillianExtension.class)public class JPQLFunctionsTest { private final static Logger LOGGER = Logger.getLogger(JPQLFunctionsTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { clearPersons(); startTx(); } private void clearPersons() throws Exception { startTx(); var builder = em.getCriteriaBuilder(); var deletePersonQuery = builder.createCriteriaDelete(Person.class); var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate(); LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons); endTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus()); try { if (ux.getStatus() == Status.STATUS_ACTIVE) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;) public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name, CEILING(p.salary), FLOOR(p.salary), ROUND(p.salary, 1), EXP(p.yearsWorked), LN(p.yearsWorked), POWER(p.yearsWorked,2), SIGN(p.yearsWorked) FROM Person p WHERE p.id=:id &quot;&quot;&quot;; var query = em.createQuery(queryString); query.setParameter(&quot;id&quot;, id); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;) public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); assertNotNull(person.getId()); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, LOCAL TIME as localTime, LOCAL DATETIME as localDateTime, LOCAL DATE as localDate FROM Person p &quot;&quot;&quot;; // for EclipseLinks var query = em.createQuery(queryString); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;) public void testExtractFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); assertNotNull(person.getId()); endTx(); startTx(); try { var queryString = &quot;&quot;&quot; SELECT p.name as name, EXTRACT(YEAR FROM p.birthDate) as year, EXTRACT(QUARTER FROM p.birthDate) as quarter, EXTRACT(MONTH FROM p.birthDate) as month, EXTRACT(WEEK FROM p.birthDate) as week, EXTRACT(DAY FROM p.birthDate) as day, EXTRACT(HOUR FROM p.birthDate) as hour, EXTRACT(MINUTE FROM p.birthDate) as minute, EXTRACT(SECOND FROM p.birthDate) as second FROM Person p &quot;&quot;&quot;; var query = em.createQuery(queryString); // for EclipseLinks query.setHint(QueryHints.RESULT_TYPE, ResultType.Map); List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; { data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v})); }); } catch (Exception ex) { fail(ex); } }} Alternatively, create a test to verify the Criteria APIs. @ExtendWith(ArquillianExtension.class)public class JPQLCriteriaBuilderTest { private final static Logger LOGGER = Logger.getLogger(JPQLCriteriaBuilderTest.class.getName()); @Deployment public static WebArchive createDeployment() { return ShrinkWrap.create(WebArchive.class) .addClasses(Person.class, Gender.class) .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;); } @PersistenceContext private EntityManager em; @Inject UserTransaction ux; @BeforeEach public void before() throws Exception { clearPersons(); startTx(); } private void clearPersons() throws Exception { startTx(); var builder = em.getCriteriaBuilder(); var deletePersonQuery = builder.createCriteriaDelete(Person.class); var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate(); LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons); endTx(); } private void startTx() throws Exception { ux.begin(); em.joinTransaction(); } @AfterEach public void after() throws Exception { endTx(); } private void endTx() throws Exception { LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus()); try { if (ux.getStatus() == Status.STATUS_ACTIVE) { ux.commit(); } } catch (Exception e) { ux.rollback(); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;) public void testNumericFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var cb = em.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.ceiling(root.get(&quot;salary&quot;)), cb.floor(root.get(&quot;salary&quot;)), cb.round(root.get(&quot;salary&quot;), 1), cb.exp(root.get(&quot;yearsWorked&quot;)), cb.ln(root.get(&quot;yearsWorked&quot;)), cb.power(root.get(&quot;yearsWorked&quot;), 2), cb.sign(root.get(&quot;yearsWorked&quot;)) ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = em.createQuery(query).getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(result -&gt; LOGGER.log( Level.INFO, // see: https://github.com/eclipse-ee4j/eclipselink/issues/1593 // John,12,345,12,345,12,345,7.389,0.693,4,1 &quot;tuple data :{0},{1},{2},{3},{4},{5},{6},{7}&quot;, new Object[]{ result.get(0, String.class), result.get(1, BigDecimal.class), // it should return BigDecimal result.get(2, BigDecimal.class), result.get(3, BigDecimal.class), result.get(4, Double.class), result.get(5, Double.class), result.get(6, Double.class), result.get(7, Integer.class) } ) ); } catch (Exception ex) { fail(ex); } } @Test @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;) public void testDateTimeFunctions() throws Exception { var person = new Person(&quot;John&quot;, 30); em.persist(person); var id = person.getId(); assertNotNull(id); endTx(); startTx(); try { var cb = em.getCriteriaBuilder(); var query = cb.createTupleQuery(); var root = query.from(Person.class); query.multiselect(root.get(&quot;name&quot;), cb.localTime(), cb.localDateTime(), cb.localDate() ); query.where(cb.equal(root.get(&quot;id&quot;), id)); var resultList = em.createQuery(query).getResultList(); LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size()); resultList.forEach(data -&gt; LOGGER.log( Level.INFO, &quot;tuple data :{0},{1},{2},{3}&quot;, new Object[]{ data.get(0, String.class), data.get(1, java.time.LocalTime.class), data.get(2, java.time.LocalDateTime.class), data.get(3, java.time.LocalDate.class) } ) ); } catch (Exception ex) { fail(ex); } }} But unfortunately, there is a bug in the GlassFish 7.0.0-M9 will fail the test JPQLFunctionsTest, more details please check Github issues GlassFish #24120. Check the sample codes of Hibernate and Jakarta Persistence from my github. &lt;hr&gt;&lt;p&gt;What’s New in Jakarta Persistence 3.1 By Examples was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"What’s New in Jakarta Persistence 3.1 By Examples","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/what-s-new-in-jakarta-persistence-3-1-by-examples/"},"url":"/blog/2022/what-s-new-in-jakarta-persistence-3-1-by-examples/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">What’s New in Jakarta Persistence 3.1 By Examples</h1>
    <p class="post-meta">November 13, 2022</p>
  </header>

  <article class="post-content">
    <p>Jakarta Persistence(aka JPA) 3.1 brings a collection of improvements.</p><ul><li>The UUID class now is treated as Basic Java Type. To support UUID type ID in Entity class, JPA introduces a new UUID generator.</li><li>Several numeric functions and date/time specific functions are added in JPQL and type-safe Criteria API.</li></ul><p>More details please read <a href="https://newsroom.eclipse.org/eclipse-newsletter/2022/march/what%E2%80%99s-new-jakarta-persistence-31">What’s New in Jakarta Persistence 3.1</a>.</p><p>Next let’s explore these features by writing some real example codes.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gFXKiQoL1Di8pJaVGxvxgQ.jpeg" /><figcaption>Photo by &lt;a href=”<a href="https://unsplash.com/@lin_alessio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">https://unsplash.com/@lin_alessio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText</a>&quot;&gt;Alessio Lin&lt;/a&gt; on &lt;a href=”<a href="https://unsplash.com/s/photos/china-building?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">https://unsplash.com/s/photos/china-building?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText</a>&quot;&gt;Unsplash&lt;/a&gt;</figcaption></figure><h3>Hibernate 6.1</h3><p>Generate a simple <strong>Java application</strong> project via <a href="https://maven.apache.org/archetypes/maven-archetype-quickstart/">Maven Quickstart archetype</a>.</p><pre>mvn archetype:generate<br>    -DarchetypeGroupId=org.apache.maven.archetypes<br>    -DarchetypeArtifactId=maven-archetype-quickstart<br>    -DarchetypeVersion=1.4</pre><p>There are some interactive steps to guide you setup the project info, such as groupId, artifact, version etc. In this example project, we use com.example as groupId, and demo as artifactId. Then confirm and begin to generate the project source codes.</p><p>After it is done, open the project in a Java IDE such as IntelliJ IDEA(Community Edition is free), or Eclipse Java/Java EE bundle, or NetBeans IDE, or a simple text editor, eg. VS Code.</p><p>Modify the <em>pom.xml</em> in the project root folder, add Hibernate 6.1, and JUnit etc. into project dependencies, and setup Maven compiler plugin to use Java 17 to compile the source codes.</p><p>The final <em>pom.xml</em> looks like the following.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</pre><pre>    &lt;groupId&gt;org.example&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate6&lt;/artifactId&gt;<br>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br>    &lt;parent&gt;<br>        &lt;groupId&gt;com.example&lt;/groupId&gt;<br>        &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt;<br>        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br>        &lt;relativePath&gt;..&lt;/relativePath&gt;<br>    &lt;/parent&gt;</pre><pre>    &lt;name&gt;hibernate6&lt;/name&gt;<br>    &lt;description&gt;Jakarta EE 10 Sandbox: Hibernate 6/JPA 3.1 example&lt;/description&gt;</pre><pre>    &lt;properties&gt;<br>        &lt;maven.compiler.release&gt;17&lt;/maven.compiler.release&gt;</pre><pre>        &lt;!-- requires 6.1.2.Final or higher --&gt;<br>        &lt;hibernate.version&gt;6.1.4.Final&lt;/hibernate.version&gt;<br>        &lt;h2.version&gt;2.1.214&lt;/h2.version&gt;</pre><pre>        &lt;!-- test deps --&gt;<br>        &lt;junit-jupiter.version&gt;5.9.1&lt;/junit-jupiter.version&gt;<br>        &lt;assertj-core.version&gt;3.23.1&lt;/assertj-core.version&gt;</pre><pre>        &lt;slf4j.version&gt;2.0.3&lt;/slf4j.version&gt;<br>        &lt;logback.version&gt;1.4.4&lt;/logback.version&gt;<br>    &lt;/properties&gt;</pre><pre>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;jakarta.persistence&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.persistence-api&lt;/artifactId&gt;<br>            &lt;version&gt;3.1.0&lt;/version&gt;<br>        &lt;/dependency&gt;</pre><pre>        &lt;!-- H2 Database --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br>            &lt;artifactId&gt;h2&lt;/artifactId&gt;<br>            &lt;version&gt;${h2.version}&lt;/version&gt;<br>        &lt;/dependency&gt;</pre><pre>        &lt;!-- logging with logback --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;<br>            &lt;version&gt;${slf4j.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;<br>            &lt;version&gt;${slf4j.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br>            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;<br>            &lt;version&gt;${logback.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br>            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;<br>            &lt;version&gt;${logback.version}&lt;/version&gt;<br>        &lt;/dependency&gt;</pre><pre>        &lt;!-- test dependencies --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;<br>            &lt;version&gt;${junit-jupiter.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.assertj&lt;/groupId&gt;<br>            &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;<br>            &lt;version&gt;${assertj-core.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.hibernate.orm&lt;/groupId&gt;<br>            &lt;artifactId&gt;hibernate-testing&lt;/artifactId&gt;<br>            &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>            &lt;exclusions&gt;<br>                &lt;exclusion&gt;<br>                    &lt;groupId&gt;junit&lt;/groupId&gt;<br>                    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>                &lt;/exclusion&gt;<br>            &lt;/exclusions&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;</pre><pre>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;3.10.1&lt;/version&gt;<br>            &lt;/plugin&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;3.0.0-M7&lt;/version&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>&lt;/project&gt;</pre><p>NOTE: To share common resources for all feature-based projects, create a parent POM to centralize the common configurations in one place, check <a href="https://github.com/hantsy/jakartaee10-sandbox/blob/master/pom.xml">the parent pom.xml file</a>.</p><p>In this example project, we use H2 embedded database for test purpose. Hibernate 6.1 implements the features of Jakarta Persistence 3.1, but it includes a Jakarta Persistence 3.0 API in the transitive dependency tree.</p><p>To use Jakarta Persistence 3.1 API, we have to add jakarta.persistence:jakarta.persistence-api 3.1 explicitly.</p><p>In the <em>src/main/resources/META-INF</em>, add a new file named <em>persistence.xml</em>.</p><pre>&lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot;<br>             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>             xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_1.xsd&quot;<br>             version=&quot;3.1&quot;&gt;</pre><pre>    &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;</pre><pre>        &lt;description&gt;Hibernate test case template Persistence Unit&lt;/description&gt;<br>        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;</pre><pre>        &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;</pre><pre>        &lt;properties&gt;<br>            &lt;property name=&quot;hibernate.archive.autodetection&quot; value=&quot;class, hbm&quot;/&gt;</pre><pre>            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.H2Dialect&quot;/&gt;<br>            &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;org.h2.Driver&quot;/&gt;<br>            &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1&quot;/&gt;<br>            &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;sa&quot;/&gt;</pre><pre>            &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;5&quot;/&gt;</pre><pre>            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create-drop&quot;/&gt;</pre><pre>            &lt;property name=&quot;hibernate.max_fetch_depth&quot; value=&quot;5&quot;/&gt;</pre><pre>            &lt;property name=&quot;hibernate.cache.region_prefix&quot; value=&quot;hibernate.test&quot;/&gt;<br>            &lt;property name=&quot;hibernate.cache.region.factory_class&quot;<br>                      value=&quot;org.hibernate.testing.cache.CachingRegionFactory&quot;/&gt;</pre><pre>            &lt;!--NOTE: hibernate.jdbc.batch_versioned_data should be set to false when testing with Oracle--&gt;<br>            &lt;property name=&quot;hibernate.jdbc.batch_versioned_data&quot; value=&quot;true&quot;/&gt;</pre><pre>            &lt;property name=&quot;jakarta.persistence.validation.mode&quot; value=&quot;NONE&quot;/&gt;<br>            &lt;property name=&quot;hibernate.service.allow_crawling&quot; value=&quot;false&quot;/&gt;<br>            &lt;property name=&quot;hibernate.session.events.log&quot; value=&quot;true&quot;/&gt;<br>        &lt;/properties&gt;</pre><pre>    &lt;/persistence-unit&gt;<br>&lt;/persistence&gt;</pre><p>We use logback as the logging framework in this project. In the <em>src/main/resources</em>, add a <em>logback.xml</em> to configure logback.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;configuration&gt;</pre><pre>    &lt;property name=&quot;LOGS&quot; value=&quot;./logs&quot;/&gt;</pre><pre>    &lt;appender name=&quot;Console&quot;<br>              class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;<br>        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;<br>            &lt;Pattern&gt;<br>                %green(%d{ISO8601}) %highlight(%-5level) [%blue(%t)] %yellow(%C{1.}): %msg%n%throwable<br>            &lt;/Pattern&gt;<br>        &lt;/layout&gt;<br>    &lt;/appender&gt;</pre><pre>    &lt;appender name=&quot;RollingFile&quot;<br>              class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;<br>        &lt;file&gt;${LOGS}/app.log&lt;/file&gt;<br>        &lt;encoder<br>                class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt;<br>            &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt;<br>        &lt;/encoder&gt;</pre><pre>        &lt;rollingPolicy<br>                class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;<br>            &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt;<br>            &lt;fileNamePattern&gt;${LOGS}/archived/app-%d{yyyy-MM-dd}.%i.log<br>            &lt;/fileNamePattern&gt;<br>            &lt;timeBasedFileNamingAndTriggeringPolicy<br>                    class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;<br>                &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;<br>            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;<br>        &lt;/rollingPolicy&gt;<br>    &lt;/appender&gt;</pre><pre>    &lt;!-- LOG everything at INFO level --&gt;<br>    &lt;root level=&quot;info&quot;&gt;<br>        &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;<br>        &lt;appender-ref ref=&quot;Console&quot;/&gt;<br>    &lt;/root&gt;</pre><pre>    &lt;!-- Debug hibernate SQL,  see: <a href="https://thorben-janssen.com/hibernate-logging-guide/">https://thorben-janssen.com/hibernate-logging-guide/</a> --&gt;<br>    &lt;logger name=&quot;org.hibernate.SQL&quot; level=&quot;DEBUG&quot;/&gt;<br>    &lt;logger name=&quot;org.hibernate.type.descriptor.sql&quot; level=&quot;trace&quot;/&gt;</pre><pre>    &lt;!-- Custom debug level for the application code --&gt;<br>    &lt;logger name=&quot;com.example&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;<br>        &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;<br>        &lt;appender-ref ref=&quot;Console&quot;/&gt;<br>    &lt;/logger&gt;<br>&lt;/configuration&gt;</pre><p>We set org.hibernate.SQL logging level to DEBUG and org.hibernate.type.descriptor.sql to trace, it will help you to dig into the Hibernate generated sql at runtime.</p><h3>UUID Basic Type Support</h3><p>JPA 3.1 allows to use UUID as basic Java type, especially it add a UUID ID generator.</p><p>Create a simple Entity.</p><pre>@Entity<br>public class Person {<br>    @Id<br>    @Column(name = &quot;id&quot;, nullable = false)<br>    @GeneratedValue(strategy = GenerationType.UUID)<br>    private UUID id;<br>    private String name;<br>    private int age = 30;</pre><pre>    public Person() {<br>    }</pre><pre>    public Person(String name, int age) {<br>        assert age &gt; 0;<br>        this.name = name;<br>        this.age = age;<br>        this.birthDate = LocalDateTime.now().minusYears(this.age);<br>    }</pre><pre>    // getters and setters<br>    // override equals and hashCode<br>}</pre><p>An entity class is annotated with an @Entity, optionally you can specify the entity name and add table definition with an extra @Table annotation.</p><p>Here we defined a UUID type ID, and use a UUID generation strategy.</p><p>JPA requires an Entity should includes a no-arguments constructor, if you declare another constructor with a few arguments, you should declare this no-arguments constructor explicitly.</p><p>Create a simple JUnit test to verify if the UUID type working as expected.</p><pre>class PersonUUIDTest {<br>    private static final Logger log = LoggerFactory.getLogger(PersonUUIDTest.class);</pre><pre>    private EntityManagerFactory entityManagerFactory;</pre><pre>    @BeforeEach<br>    void setUp() {<br>        entityManagerFactory = Persistence.createEntityManagerFactory(&quot;defaultPU&quot;);<br>        var entityManager = entityManagerFactory.createEntityManager();<br>        entityManager.getTransaction().begin();<br>        var deleteFromPerson = entityManager.createQuery(&quot;DELETE FROM Person&quot;).executeUpdate();<br>        log.debug(&quot;Deleted {} persons&quot;, deleteFromPerson);<br>        entityManager.getTransaction().commit();<br>        entityManager.close();<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;insert person and verify person&quot;)<br>    public void testInsertAndFindPerson() throws Exception {<br>        var person = new Person(&quot;John&quot;, 30);<br>        var entityManager = entityManagerFactory.createEntityManager();<br>        entityManager.getTransaction().begin();<br>        entityManager.persist(person);<br>        entityManager.getTransaction().commit();<br>        var id = person.getId();<br>        assertNotNull(id);</pre><pre>        try {<br>            var foundPerson = entityManager.find(Person.class, id);<br>            assertThat(foundPerson.getId()).isNotNull();<br>            assertThat(foundPerson.getName()).isEqualTo(&quot;John&quot;);<br>            assertThat(foundPerson.getAge()).isEqualTo(30);<br>        } catch (Exception ex) {<br>            ex.printStackTrace();<br>        }<br>    }</pre><pre>    @AfterEach<br>    void tearDown() {<br>        entityManagerFactory.close();<br>    }<br>}</pre><p>In the @BeforeEach method, we will create an EntityManagerFactory instance. And in the @AfterEach we call the EntityManagerFactory.close to release the resource.</p><p>In the @BeforeEach we try to clean up the Person data.</p><p>Now in the testInsertAndFindPerson test, we insert a new person, then utilize entityManager.find to find the inserted person.</p><p>The person id is annotated with @ID and @GeneratedValue, when inserting a person into table, hibernate will generate an ID automatically. After it is persisted, the returned instance is filled with the generated id, it should not be a null.</p><h3>Numeric Functions</h3><p>JPA 3.1 adds a collection of new numeric functions in literal JPQL query and type-safe Criteria Builder API.</p><p>Add some extra properties in the above Person class.</p><pre>public class Person{<br>    private Integer yearsWorked = 2;<br>    private LocalDateTime birthDate = LocalDateTime.now().minusYears(30);<br>    private BigDecimal salary = new BigDecimal(&quot;12345.678&quot;);<br>    private BigDecimal hourlyRate = new BigDecimal(&quot;34.56&quot;);</pre><pre>    // setters and getters<br>}</pre><p>Create a new test to verify the new numeric functions: ceiling, floor, round, exp, ln, power, sign.</p><pre>@Test<br>@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)<br>public void testNumericFunctions() throws Exception {<br>    var person = new Person(&quot;John&quot;, 30);<br>    var entityManager = entityManagerFactory.createEntityManager();<br>    entityManager.getTransaction().begin();<br>    entityManager.persist(person);<br>    entityManager.getTransaction().commit();<br>    var id = person.getId();<br>    assertNotNull(id);</pre><pre>    try {<br>        var queryString = &quot;&quot;&quot;<br>                SELECT p.name as name,<br>                CEILING(p.salary) as ceiling,<br>                FLOOR(p.salary) as floor,<br>                ROUND(p.salary, 1) as round,<br>                EXP(p.yearsWorked) as exp,<br>                LN(p.yearsWorked) as ln,<br>                POWER(p.yearsWorked,2) as power,<br>                SIGN(p.yearsWorked) as sign<br>                FROM Person p<br>                WHERE p.id=:id<br>                &quot;&quot;&quot;;<br>        var query = entityManager.createQuery(queryString);<br>        query.setParameter(&quot;id&quot;, id);<br>        var resultList = query.getResultList();<br>        log.debug(&quot;Result list: {}&quot;, resultList);<br>        resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result));<br>    } catch (Exception ex) {<br>        ex.printStackTrace();<br>    }<br>}</pre><p>Next, let’s have a look at how to use them in the Criteria APIs.</p><pre>@Test<br>@DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)<br>public void testNumericFunctions() throws Exception {<br>    var person = new Person(&quot;John&quot;, 30);<br>    var entityManager = entityManagerFactory.createEntityManager();<br>    entityManager.getTransaction().begin();<br>    entityManager.persist(person);<br>    entityManager.getTransaction().commit();<br>    var id = person.getId();<br>    assertNotNull(id);</pre><pre>    try {<br>        // see: <a href="https://hibernate.zulipchat.com/#narrow/stream/132096-hibernate-user/topic/New.20functions.20in.20JPA.203.2E1/near/289429903">https://hibernate.zulipchat.com/#narrow/stream/132096-hibernate-user/topic/New.20functions.20in.20JPA.203.2E1/near/289429903</a><br>        var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder();<br>        var query = cb.createTupleQuery();<br>        var root = query.from(Person.class);</pre><pre>        query.multiselect(root.get(&quot;name&quot;),<br>                cb.ceiling(root.get(&quot;salary&quot;)),<br>                cb.floor(root.get(&quot;salary&quot;)),<br>                cb.round(root.get(&quot;salary&quot;), 1),<br>                cb.exp(root.get(&quot;yearsWorked&quot;)),<br>                cb.ln(root.get(&quot;yearsWorked&quot;)),<br>                // see: <a href="https://hibernate.atlassian.net/browse/HHH-15395">https://hibernate.atlassian.net/browse/HHH-15395</a><br>                cb.power(root.get(&quot;yearsWorked&quot;), 2),<br>                cb.sign(root.get(&quot;yearsWorked&quot;))<br>        );<br>        query.where(cb.equal(root.get(&quot;id&quot;), id));<br>        var resultList = entityManager.createQuery(query).getResultList();<br>        log.debug(&quot;Result list: {}&quot;, resultList);</pre><pre>        resultList.forEach(result -&gt;<br>                log.debug(<br>                        &quot;result: ({},{},{},{},{},{},{},{})&quot;,<br>                        result.get(0, String.class),<br>                        result.get(1, BigDecimal.class),<br>                        result.get(2, BigDecimal.class),<br>                        result.get(3, BigDecimal.class),<br>                        result.get(4, Double.class),<br>                        result.get(5, Double.class),<br>                        result.get(6, Double.class),<br>                        result.get(7, Integer.class)<br>                )<br>        );<br>    } catch (Exception ex) {<br>        fail(ex);<br>    }<br>}</pre><p>Note, when using Hibernate 6.1, we have to cast CriteriaBuilder to HibernateCriteriaBuilder to experience the new numeric functions. Hibernate 6.2 will align to JPA 3.1 and fix the issue.</p><h3>DateTime Functions</h3><p>JPA 3.1 add a series of datetime functions and ease the usage of Java 8 DateTime APIs.</p><pre>@Test<br>@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)<br>public void testDateTimeFunctions() throws Exception {<br>    var person = new Person(&quot;John&quot;, 30);<br>    var entityManager = entityManagerFactory.createEntityManager();<br>    entityManager.getTransaction().begin();<br>    entityManager.persist(person);<br>    entityManager.getTransaction().commit();<br>    var id = person.getId();<br>    assertNotNull(id);</pre><pre>    try {<br>        var queryString = &quot;&quot;&quot;<br>                SELECT p.name as name,<br>                LOCAL TIME as localTime,<br>                LOCAL DATETIME as localDateTime,<br>                LOCAL DATE as localDate<br>                FROM Person p<br>                &quot;&quot;&quot;;</pre><pre>        var query = entityManager.createQuery(queryString);<br>        var resultList = query.getResultList();<br>        log.debug(&quot;Result list: {}&quot;, resultList);<br>        resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result));<br>    } catch (Exception ex) {<br>        ex.printStackTrace();<br>    }<br>}</pre><p>The LOCAL TIME, LOCAL DATETIME, LOCAL DATE query result will be treated as Java 8 LocalTime, LocalDateTime, LocalDate directly.</p><p>Let’s have a look at the usage in the CriteriaBuilder APIs.</p><pre>@Test<br>@DisplayName(&quot;&gt;&gt;&gt; test datetime functions&quot;)<br>public void testDateTimeFunctions() throws Exception {<br>    var person = new Person(&quot;John&quot;, 30);<br>    var entityManager = entityManagerFactory.createEntityManager();<br>    entityManager.getTransaction().begin();<br>    entityManager.persist(person);<br>    entityManager.getTransaction().commit();<br>    var id = person.getId();<br>    assertNotNull(id);</pre><pre>    try {<br>        var cb = (HibernateCriteriaBuilder) entityManager.getCriteriaBuilder();<br>        var query = cb.createTupleQuery();<br>        var root = query.from(Person.class);</pre><pre>        query.multiselect(root.get(&quot;name&quot;),<br>                cb.localTime(),<br>                cb.localDateTime(),<br>                cb.localDate()<br>        );<br>        query.where(cb.equal(root.get(&quot;id&quot;), id));</pre><pre>        var resultList = entityManager.createQuery(query).getResultList();<br>        log.debug(&quot;Result list: {}&quot;, resultList);<br>        resultList.forEach(result -&gt;<br>                log.debug(<br>                        &quot;result: ({},{},{},{})&quot;,<br>                        result.get(0, String.class),<br>                        result.get(1, LocalTime.class),<br>                        result.get(2, LocalDateTime.class),<br>                        result.get(3, LocalDate.class)<br>                )<br>        );<br>    } catch (Exception ex) {<br>        fail(ex);<br>    }<br>}</pre><h3>EXTRACT function</h3><p>JPA 3.1 introduces a extract function to decode fragments from a datetime value.</p><pre>@Test<br>@DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;)<br>public void testExtractFunctions() throws Exception {<br>    var person = new Person(&quot;John&quot;, 30);<br>    var entityManager = entityManagerFactory.createEntityManager();<br>    entityManager.getTransaction().begin();<br>    entityManager.persist(person);<br>    entityManager.getTransaction().commit();<br>    var id = person.getId();<br>    assertNotNull(id);</pre><pre>    try {<br>        var queryString = &quot;&quot;&quot;<br>                SELECT p.name as name,<br>                EXTRACT(YEAR FROM p.birthDate) as year,<br>                EXTRACT(QUARTER FROM p.birthDate) as quarter,<br>                EXTRACT(MONTH FROM p.birthDate) as month,<br>                EXTRACT(WEEK FROM p.birthDate) as week,<br>                EXTRACT(DAY FROM p.birthDate) as day,<br>                EXTRACT(HOUR FROM p.birthDate) as hour,<br>                EXTRACT(MINUTE FROM p.birthDate) as minute,<br>                EXTRACT(SECOND FROM p.birthDate) as second<br>                FROM Person p<br>                &quot;&quot;&quot;;<br>        var query = entityManager.createQuery(queryString);</pre><pre>        var resultList = query.getResultList();<br>        log.debug(&quot;Result list: {}&quot;, resultList);<br>        resultList.forEach(result -&gt; log.debug(&quot;result: {}&quot;, result));<br>    } catch (Exception ex) {<br>        ex.printStackTrace();<br>    }<br>}</pre><p>Use the new extract function, we can read the year, quarter, month, week, day, hour, minute, second values from a Java 8 DateTime type property in the JPQL query.</p><p>Note, there is no mapped extract function in the CriteriaBuilder APIs, for more details, check issue: <a href="https://github.com/jakartaee/persistence/pull/356">jakartaee/persistence#356</a></p><h3>JakartaEE Runtime</h3><p>Next let’s go to the Jakarta EE 10 compatible products to experience the new features of JPA 3.1.</p><p>Firstly we will prepare a Jakarta EE 10 web application.</p><p>Simply generate a web application skeleton via <a href="https://maven.apache.org/archetypes/maven-archetype-webapp/">Maven Webapp Archetype</a>.</p><pre>mvn archetype:generate<br>    -DarchetypeGroupId=org.apache.maven.archetypes<br>    -DarchetypeArtifactId=maven-archetype-webapp<br>    -DarchetypeVersion=1.4</pre><p>Then add Jakarta EE 10 dependency into the project pom.xml. Let’s have a look at the modified pom.xml.</p><pre>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>    &lt;groupId&gt;com.example&lt;/groupId&gt;<br>    &lt;artifactId&gt;jpa-examples&lt;/artifactId&gt;<br>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br>    &lt;packaging&gt;war&lt;/packaging&gt;<br>    &lt;parent&gt;<br>        &lt;groupId&gt;com.example&lt;/groupId&gt;<br>        &lt;artifactId&gt;jakartaee10-sandbox-parent&lt;/artifactId&gt;<br>        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br>        &lt;relativePath&gt;..&lt;/relativePath&gt;<br>    &lt;/parent&gt;</pre><pre>    &lt;name&gt;jpa-examples&lt;/name&gt;<br>    &lt;description&gt;Jakarta EE 10 Sandbox: Persistence 3.1 Examples&lt;/description&gt;<br>    &lt;properties&gt;<br>    &lt;/properties&gt;</pre><pre>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.jakartaee-api&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;<br>            &lt;artifactId&gt;org.eclipse.persistence.jpa.modelgen.processor&lt;/artifactId&gt;<br>            &lt;version&gt;4.0.0&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian.junit5&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-junit5-container&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- see: <a href="https://github.com/arquillian/arquillian-core/issues/248">https://github.com/arquillian/arquillian-core/issues/248</a> --&gt;<br>        &lt;!-- and <a href="https://github.com/arquillian/arquillian-core/pull/246/files">https://github.com/arquillian/arquillian-core/pull/246/files</a> --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;</pre><p>In the above pom.xml, we also add JUnit 5 and <a href="https://arquillian.org">Arquillian</a> related dependencies in test scope. Through the container specific Aquillian adapter, we can run the tests in Jakarta EE application servers.</p><p>In this project, we reuse the the Person entity we have introduced in the Hibernate section.</p><p>Now let’s move to persistence configuration. Create a <em>persistence.xml</em> in the <em>src/main/resources/META-INFO</em> folder.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;persistence version=&quot;3.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot;<br>             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>             xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/persistence https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd&quot;&gt;<br>    &lt;persistence-unit name=&quot;defaultPU&quot; transaction-type=&quot;JTA&quot;&gt;<br>        &lt;jta-data-source&gt;java:comp/DefaultDataSource&lt;/jta-data-source&gt;<br>        &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;<br>        &lt;properties&gt;<br>            &lt;property name=&quot;jakarta.persistence.schema-generation.database.action&quot; value=&quot;drop-and-create&quot;/&gt;</pre><pre>            &lt;!-- for  Glassfish/Payara/EclipseLink --&gt;<br>            &lt;property name=&quot;eclipselink.logging.level.sql&quot; value=&quot;FINE&quot;/&gt;<br>            &lt;property name=&quot;eclipselink.logging.level&quot; value=&quot;FINE&quot;/&gt;<br>            &lt;property name=&quot;eclipselink.logging.parameters&quot; value=&quot;true&quot;/&gt;</pre><pre>            &lt;!-- for WildFly/Hibernate --&gt;<br>            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;<br>        &lt;/properties&gt;<br>    &lt;/persistence-unit&gt;<br>&lt;/persistence&gt;</pre><p>The configuration is a little different from the one we introduced in the Hibernate section.</p><ul><li>In a container environment, we would like choose JTA as transaction-type.</li><li>We do not setup database connection info, instead we configure a built-in DataSource. The java:comp/DefaultDataSource is the default DataSource for all Jakarta EE compatible products.</li></ul><h3>Creating Jakarta EE Sample Application</h3><p>To interact with our backend database, we will create a simple complete JAXRS application, including:</p><ul><li>A EJB @Stateless bean to read data from database</li><li>And expose data via a simple JAXRS resource</li></ul><p>OK, let’s create class PersonRepository which is annotated with @Stateless. In this class, inject a EntityManager bean with an annotation @PersistenceContext, and add a new method getAllResource to execute a JPQL query to retrieve all persons.</p><pre>@Stateless<br>public class PersonRepository {</pre><pre>    @PersistenceContext<br>    EntityManager entityManager;</pre><pre>    public List&lt;Person&gt; getAllPersons() {<br>        return entityManager.createQuery(&quot;select p from Person p&quot;, Person.class)<br>                .getResultList();<br>    }<br>}</pre><p>Next, create a PersonResource to expose persons to client.</p><pre>@RequestScoped<br>@Path(&quot;/persons&quot;)<br>public class PersonResource {</pre><pre>    @Inject<br>    PersonRepository personRepository;</pre><pre>    @Path(&quot;&quot;)<br>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response allPersons() {<br>        var data = personRepository.getAllPersons();<br>        return Response.ok(data).build();<br>    }<br>}</pre><p>The PersonResource is annotated with RequestScoped, it is a CDI bean, the @Path on the class define the root path of all subresources in this class. The allPersons will produces all persons to client in JSON format when HTTP Client request matches HTTP GET method, and URI is /persons and HTTP Header Accept is compatible with application/json.</p><p>To activate JAXRS feature, create a class to extend the JAXRS Application, add @ApplicationPath to specify the root context path of all JAXRS resources.</p><pre>@ApplicationPath(&quot;/rest&quot;)<br>public class RestActivator extends Application {<br>}</pre><p>Let’s create a bean to add some sample data at the application startup.</p><pre>@Startup<br>@Singleton<br>public class DataInitializer {</pre><pre>    @PersistenceContext<br>    EntityManager entityManager;</pre><pre>    @PostConstruct<br>    public void init() {<br>        List<br>                .of(<br>                        new Person(&quot;Jack&quot;, 20),<br>                        new Person(&quot;Rose&quot;, 18)<br>                )<br>                .forEach(entityManager::persist);<br>    }<br>}</pre><h3>Deploying to Jakarta EE Containers</h3><p>Build and package the application into a war archive. Open a terminal, switch to the project root folder, and execute the following command.</p><pre>mvn clean package -DskipTests -D&quot;maven.test.skip=true&quot;</pre><p>When it is done, there is war package is ready in the path <em>target/jpa-examples.war</em>.</p><h4>GlassFish 7.0</h4><ol><li>Download the <a href="https://github.com/eclipse-ee4j/glassfish/releases">latest GlassFish 7.0</a>, extract files to a location, eg. D:\glassfish7, mark as <em>GlassFish_install</em>.</li><li>To start GlassFish and Derby, open a terminal, enter <em>GlassFish_install/bin</em>, run asadmin start-database and asadmin start-domain domain1.</li><li>Copy the above war package to <em>Glassfish_install/glassfish/domains/domain1/autodeploy</em> folder.</li><li>Open <em>GlassFish_install/glassfish/domains/domain1/logs/server.log</em>, and wait the deployment is completed.</li><li>Open another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons. You will the following response in the console.</li></ol><ul><li>[{“age”:18,”birthDate”:”2004–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”d8552d71-ff7f-4650-b5a0-ce1c5fb3fe0b”,”name”:”Rose”,”salary”:12345.678,”yearsWorked”:2},{“age”:20,”birthDate”:”2002–11–06T14:54:05.4504678&quot;,”gender”:”MALE”,”hourlyRate”:34.56,”id”:”cdf94cdc-21b3–492c-b1b5–06bc8cae9947&quot;,”name”:”Jack”,”salary”:12345.678,”yearsWorked”:2}]</li></ul><ol><li>To stop GlassFish and Derby, run asadmin stop-database and asadmin stop-domain domain1</li></ol><h4>WildFly Preview 27</h4><ol><li>Download the latest <a href="https://wildfly.org">WildFly Preview</a>, extract files to a location, eg. D:\wildfly-preview-27.0.0.Beta1, mark as <em>WildFly_install</em>.</li><li>Open a terminal, enter <em>WildFly_install/bin</em>, run standalone to start WildFly with the default standalone profile configuration.</li><li>Copy the built war to <em>WildFly_install/standalone/deployments</em>.</li><li>Wait the deployment progress is done, you can use the curl in GlassFish section to verify the application.</li><li>Send a CTLR+C keys combination in the original WildFly startup console to stop WildFly.</li></ol><h3>Deploying Application via Maven Plugin</h3><h4>Deploying to GlassFish via Cargo Plugin</h4><p>The GlassFish project does not include an official Maven plugin to manage GlassFish server. There is a Maven plugin named cargo-maven3-plugin which can be used to manage all popular Jakarta EE application servers and web servers.</p><p>Add the following profile section to use cargo plugin to manage the lifecycle of GlassFish server.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;glassfish&lt;/id&gt;<br>    &lt;activation&gt;<br>        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;<br>    &lt;/activation&gt;<br>    &lt;properties&gt;<br>        &lt;cargo.zipUrlInstaller.downloadDir&gt;${project.basedir}/../installs&lt;/cargo.zipUrlInstaller.downloadDir&gt;<br>    &lt;/properties&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;<br>                &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;container&gt;<br>                        &lt;containerId&gt;glassfish7x&lt;/containerId&gt;<br>                        &lt;!-- &lt;artifactInstaller&gt;<br>                            &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt;<br>                            &lt;artifactId&gt;glassfish&lt;/artifactId&gt;<br>                            &lt;version&gt;${glassfish.version}&lt;/version&gt;<br>                        &lt;/artifactInstaller&gt; --&gt;<br>                        &lt;zipUrlInstaller&gt;<br>                            &lt;url&gt;https://github.com/eclipse-ee4j/glassfish/releases/download/${glassfish.version}/glassfish-${glassfish.version}.zip&lt;/url&gt;<br>                            &lt;downloadDir&gt;${cargo.zipUrlInstaller.downloadDir}&lt;/downloadDir&gt;<br>                        &lt;/zipUrlInstaller&gt;<br>                    &lt;/container&gt;<br>                    &lt;configuration&gt;<br>                        &lt;!-- the configuration used to deploy --&gt;<br>                        &lt;home&gt;${project.build.directory}/glassfish7x-home&lt;/home&gt;<br>                        &lt;properties&gt;<br>                            &lt;cargo.remote.password&gt;&lt;/cargo.remote.password&gt;<br>                            &lt;cargo.glassfish.removeDefaultDatasource&gt;true&lt;/cargo.glassfish.removeDefaultDatasource&gt;<br>                        &lt;/properties&gt;<br>                        &lt;datasources&gt;<br>                            &lt;datasource&gt;<br>                                &lt;driverClass&gt;org.apache.derby.jdbc.EmbeddedDriver&lt;/driverClass&gt;<br>                                &lt;url&gt;jdbc:derby:derbyDB;create=true&lt;/url&gt;<br>                                &lt;jndiName&gt;jdbc/__default&lt;/jndiName&gt;<br>                                &lt;username&gt;APP&lt;/username&gt;<br>                                &lt;password&gt;nonemptypassword&lt;/password&gt;<br>                            &lt;/datasource&gt;<br>                        &lt;/datasources&gt;<br>                    &lt;/configuration&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>&lt;/profile&gt;</pre><p>Unlike the approach in NetBeans IDE or Eclipse IDE with GlassFish Pack, where starting GlassFish it will start the built-in Derby at the same time. Cargo does not start the built-in Derby as expected, to use the default DataSource in our project, clear the default DataSource and add a new default DataSource based on the embedded Derby.</p><p>Run the following command. It will compile the project source codes and package the application into a war archive, then start the managed GlassFish server(with a new cargo-domain), and then deploy the package into this running server.</p><pre>mvn clean package cargo:run -DskipTests -Dmaven.test.skip=true</pre><p>Note, when you run this command at the first time, it will spend some time to download a copy of the GlassFish redistribution, and extract the files into the build folder.</p><p>In another terminal window, execute curl http://localhost:8080/jpa-examples/rest/persons to verify the endpoint.</p><p>To stop the server, just send a CTRL+C in the original GlassFish running console.</p><h4>Deploying to WildFly via WildFly Plugin</h4><p>The WildFly project itself provides an official WildFly Maven plugin, we will configure it in a new Maven profile.</p><blockquote><em>Cargo maven plugin also supports WildFly, check </em><a href="https://codehaus-cargo.github.io/cargo/WildFly+27.x.html"><em>Cargo WildFly docs</em></a><em>.</em></blockquote><pre>&lt;profile&gt;<br>    &lt;id&gt;wildfly&lt;/id&gt;<br>    &lt;properties&gt;<br>        &lt;!-- Wildfly server --&gt;<br>        &lt;wildfly.artifactId&gt;wildfly-preview-dist&lt;/wildfly.artifactId&gt;<br>        &lt;jboss-as.home&gt;${project.build.directory}/wildfly-preview-${wildfly.version}&lt;/jboss-as.home&gt;<br>    &lt;/properties&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;</pre><pre>            &lt;!-- unpack a copy of WildFly--&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt;<br>                &lt;executions&gt;<br>                    &lt;execution&gt;<br>                        &lt;id&gt;unpack&lt;/id&gt;<br>                        &lt;phase&gt;process-classes&lt;/phase&gt;<br>                        &lt;goals&gt;<br>                            &lt;goal&gt;unpack&lt;/goal&gt;<br>                        &lt;/goals&gt;<br>                        &lt;configuration&gt;<br>                            &lt;artifactItems&gt;<br>                                &lt;artifactItem&gt;<br>                                    &lt;groupId&gt;org.wildfly&lt;/groupId&gt;<br>                                    &lt;artifactId&gt;${wildfly.artifactId}&lt;/artifactId&gt;<br>                                    &lt;version&gt;${wildfly.version}&lt;/version&gt;<br>                                    &lt;type&gt;zip&lt;/type&gt;<br>                                    &lt;overWrite&gt;false&lt;/overWrite&gt;<br>                                    &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;<br>                                &lt;/artifactItem&gt;<br>                            &lt;/artifactItems&gt;<br>                        &lt;/configuration&gt;<br>                    &lt;/execution&gt;<br>                &lt;/executions&gt;<br>            &lt;/plugin&gt;</pre><pre>            &lt;!-- The WildFly plugin deploys your war to a local running WildFly container --&gt;<br>            &lt;!-- To use, run: mvn package wildfly:deploy --&gt;<br>            &lt;!-- For Jakarta EE 9, use `wildfly-preview-dist` as artifactId instead to start and deploy applications--&gt;<br>            &lt;!-- Run: mvn clean wildfly:run -PWildfly -Dwildfly.artifactId=wildfly-preview-dist -Dwildfly.version=22.0.0.Alpha1 --&gt;<br>            &lt;!-- or set the `jboss-as.home` to run: mvn clean wildfly:run -PWildfly -Djboss-as.home=D:\appsvr\wildfly-preview-22.0.0.Alpha1--&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;${wildfly-maven-plugin.version}&lt;/version&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>    &lt;repositories&gt;<br>        &lt;repository&gt;<br>            &lt;id&gt;opensaml&lt;/id&gt;<br>            &lt;url&gt;https://build.shibboleth.net/nexus/content/repositories/releases/&lt;/url&gt;<br>        &lt;/repository&gt;<br>    &lt;/repositories&gt;<br>&lt;/profile&gt;</pre><p>With the WildFly plugin, we can deploy applications into an embedded WildFly, a managed WildFly server or a remote running WildFly server.</p><pre>mvn clean wildfly:run -Pwildfly -DskipTests -Dmaven.test.skip=true</pre><p>By default, if we do not setup a jboss-as.home or remote host connection info, it will bootstrap an embedded WildFly and run the application with the embedded server.</p><p>Here we configure Maven dependency plugin to download a copy of WildFly, extract the files to the project build directory, and setup a jboss-as.home property, the value is the WildFly location. The WildFly plugin will manage the whole WildFly lifecycle - start the WildFly server, deploy applications into the running server, (use CTRL+C hotkey) stop the server.</p><h3>Testing JPA Features</h3><p>Here I assume you are familiar with <a href="https://www.junit.org">JUnit</a> and <a href="https://arquillian.org">Arquillian</a> before.</p><blockquote><em>For the developers new to Arqullian framework, please read the official </em><a href="https://arquillian.org/guides"><em>Arquillian Guides</em></a><em> to start your first step. Note, these tutorials are available in several languages, including Simplified Chinese.</em></blockquote><blockquote><em>Go to my </em><a href="https://github.com/hantsy/jakartaee8-starter-boilerplate"><em>Jakarta EE 8 starter boilerplate project</em></a><em> and </em><a href="https://github.com/hantsy/jakartaee9-starter-boilerplate"><em>Jakarta EE 9 starter boilerplate project</em></a><em> to update your Arquilian knowledge.</em></blockquote><p>Since Jakarta EE 9, it uses the new jakarta namespace, Arquillian 1.7.0.x starts to support these changes.</p><p>In the next steps, we will configure a managed GlassFish Arquillian Adapter to run the testing codes.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;arq-glassfish-managed&lt;/id&gt;<br>    &lt;properties&gt;<br>        &lt;skip.unit.tests&gt;true&lt;/skip.unit.tests&gt;<br>        &lt;skip.integration.tests&gt;false&lt;/skip.integration.tests&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;!-- Jersey --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;<br>            &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;<br>            &lt;version&gt;${jersey.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;<br>            &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;<br>            &lt;version&gt;${jersey.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt;<br>            &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;<br>            &lt;version&gt;${jersey.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;<br>            &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;<br>            &lt;version&gt;${jersey.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.github.hantsy.arquillian-container-glassfish-jakarta&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-glassfish-managed-jakarta&lt;/artifactId&gt;<br>            &lt;version&gt;${arquillian-glassfish-jakarta.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>    &lt;build&gt;<br>        &lt;testResources&gt;<br>            &lt;testResource&gt;<br>                &lt;directory&gt;src/test/resources&lt;/directory&gt;<br>            &lt;/testResource&gt;<br>            &lt;testResource&gt;<br>                &lt;directory&gt;src/test/arq-glassfish-managed&lt;/directory&gt;<br>            &lt;/testResource&gt;<br>        &lt;/testResources&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;${maven-dependency-plugin.version}&lt;/version&gt;<br>                &lt;executions&gt;<br>                    &lt;execution&gt;<br>                        &lt;id&gt;unpack&lt;/id&gt;<br>                        &lt;phase&gt;pre-integration-test&lt;/phase&gt;<br>                        &lt;goals&gt;<br>                            &lt;goal&gt;unpack&lt;/goal&gt;<br>                        &lt;/goals&gt;<br>                        &lt;configuration&gt;<br>                            &lt;artifactItems&gt;<br>                                &lt;artifactItem&gt;<br>                                    &lt;groupId&gt;org.glassfish.main.distributions&lt;/groupId&gt;<br>                                    &lt;artifactId&gt;glassfish&lt;/artifactId&gt;<br>                                    &lt;version&gt;${glassfish.version}&lt;/version&gt;<br>                                    &lt;type&gt;zip&lt;/type&gt;<br>                                    &lt;overWrite&gt;false&lt;/overWrite&gt;<br>                                    &lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;<br>                                &lt;/artifactItem&gt;<br>                            &lt;/artifactItems&gt;<br>                        &lt;/configuration&gt;<br>                    &lt;/execution&gt;<br>                &lt;/executions&gt;<br>            &lt;/plugin&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt;<br>                &lt;configuration&gt;<br>                    &lt;environmentVariables&gt;<br>                        &lt;GLASSFISH_HOME&gt;${project.build.directory}/glassfish7&lt;/GLASSFISH_HOME&gt;<br>                    &lt;/environmentVariables&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>&lt;/profile&gt;</pre><p>In the above configuration, we add com.github.hantsy.arquillian-container-glassfish-jakarta:arquillian-glassfish-managed-jakarta, which is my <a href="https://github.com/hantsy/arquillian-container-glassfish-jakarta">fork</a> of the official <a href="https://github.com/arquillian/arquillian-container-glassfish6">Arquillian Container GlassFish project</a>.</p><p>We preapre a copy of the latest GlassFish 7.0 in the pre-integration-test phase. The Arquillian tests will be exectued in the integretion-test phase.</p><p>Let’s create a simple Arquillian tests to verify the UUID basic type feature in JPA 3.1.</p><pre>@ExtendWith(ArquillianExtension.class)<br>public class UUIDStrategyTest {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(UUIDStrategyTest.class.getName());</pre><pre>    @Deployment<br>    public static WebArchive createDeployment() {<br>        return ShrinkWrap.create(WebArchive.class)<br>                .addClasses(Person.class, Gender.class)<br>                .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;)<br>                .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;);<br>    }</pre><pre>    @PersistenceContext<br>    private EntityManager em;</pre><pre>    @Inject<br>    UserTransaction ux;</pre><pre>    @BeforeEach<br>    public void before() throws Exception {<br>        startTx();<br>    }</pre><pre>    private void startTx() throws Exception {<br>        ux.begin();<br>        em.joinTransaction();<br>    }</pre><pre>    @AfterEach<br>    public void after() throws Exception {<br>        endTx();<br>    }</pre><pre>    private void endTx() throws Exception {<br>        try {<br>            if( ux.getStatus() == Status.STATUS_ACTIVE ) {<br>                ux.commit();<br>            }<br>        } catch (Exception e) {<br>            ux.rollback();<br>        }<br>    }</pre><pre>    @Test<br>    public void testPersistingPersons() throws Exception {<br>        final Person person = new Person();<br>        person.setName(&quot;Hantsy Bai&quot;);<br>        em.persist(person);<br>        endTx();</pre><pre>        startTx();<br>        final Person foundPerson = em.find(Person.class, person.getId());<br>        assertNotNull(foundPerson.getId());<br>        LOGGER.log(Level.INFO, &quot;Found person: {0}&quot;, foundPerson);<br>    }<br>}</pre><p>The @ExtendWith(ArquillianExtension.class) annotation on a test class to support Arquillian test lifecycle.</p><p>The @Deployment annotated static method defines the resources that will be packaged into the test archive and deployed into the manged GlassFish server. It is easy to use shrinkwrap to create a fine-grined deploymen unit.</p><p>You can inject EntityManager and UserTransaction beans in an Arquillian test like what you do in a simple CDI bean.</p><p>In this test class, we setup @BeforeEach and @AfterEach hooks to start a transacation and end the transaction.</p><p>The test method testPersistingPersons looks no difference from a plain JUnit test. Firstly we persist a person entity, and commit the transaction to ensure it will be flushed into the database as expected. Then exectuing a simple JPA query to verify the persisted data.</p><p>Execute the following command to run the tests.</p><pre>mvn clean verify -Parq-glassfish-managed</pre><p>Similiarly, create a test to verify the new numeric functions and datetime functions in Jakarta rumtimes.</p><pre>@ExtendWith(ArquillianExtension.class)<br>public class JPQLFunctionsTest {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(JPQLFunctionsTest.class.getName());</pre><pre>    @Deployment<br>    public static WebArchive createDeployment() {<br>        return ShrinkWrap.create(WebArchive.class)<br>                .addClasses(Person.class, Gender.class)<br>                .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;)<br>                .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;);<br>    }</pre><pre>    @PersistenceContext<br>    private EntityManager em;</pre><pre>    @Inject<br>    UserTransaction ux;</pre><pre>    @BeforeEach<br>    public void before() throws Exception {<br>        clearPersons();<br>        startTx();<br>    }</pre><pre>    private void clearPersons() throws Exception {<br>        startTx();<br>        var builder = em.getCriteriaBuilder();<br>        var deletePersonQuery = builder.createCriteriaDelete(Person.class);<br>        var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate();<br>        LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons);<br>        endTx();<br>    }</pre><pre>    private void startTx() throws Exception {<br>        ux.begin();<br>        em.joinTransaction();<br>    }</pre><pre>    @AfterEach<br>    public void after() throws Exception {<br>        endTx();<br>    }</pre><pre>    private void endTx() throws Exception {<br>        LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus());<br>        try {<br>            if (ux.getStatus() == Status.STATUS_ACTIVE) {<br>                ux.commit();<br>            }<br>        } catch (Exception e) {<br>            ux.rollback();<br>        }<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)<br>    public void testNumericFunctions() throws Exception {<br>        var person = new Person(&quot;John&quot;, 30);<br>        em.persist(person);<br>        var id = person.getId();<br>        assertNotNull(id);<br>        endTx();</pre><pre>        startTx();<br>        try {<br>            var queryString = &quot;&quot;&quot;<br>                    SELECT p.name,<br>                    CEILING(p.salary),<br>                    FLOOR(p.salary),<br>                    ROUND(p.salary, 1),<br>                    EXP(p.yearsWorked),<br>                    LN(p.yearsWorked),<br>                    POWER(p.yearsWorked,2),<br>                    SIGN(p.yearsWorked)<br>                    FROM Person p<br>                    WHERE p.id=:id<br>                    &quot;&quot;&quot;;<br>            var query = em.createQuery(queryString);</pre><pre>            query.setParameter(&quot;id&quot;, id);<br>            // for EclipseLinks<br>            query.setHint(QueryHints.RESULT_TYPE, ResultType.Map);<br>            List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList();<br>            LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size());<br>            resultList.forEach(data -&gt; {<br>                data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v}));<br>            });<br>        } catch (Exception ex) {<br>            fail(ex);<br>        }<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;)<br>    public void testDateTimeFunctions() throws Exception {<br>        var person = new Person(&quot;John&quot;, 30);<br>        em.persist(person);<br>        assertNotNull(person.getId());<br>        endTx();</pre><pre>        startTx();<br>        try {<br>            var queryString = &quot;&quot;&quot;<br>                    SELECT p.name as name,<br>                    LOCAL TIME as localTime,<br>                    LOCAL DATETIME as localDateTime,<br>                    LOCAL DATE as localDate<br>                    FROM Person p<br>                    &quot;&quot;&quot;;<br>            // for EclipseLinks<br>            var query = em.createQuery(queryString);<br>            // for EclipseLinks<br>            query.setHint(QueryHints.RESULT_TYPE, ResultType.Map);<br>            List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList();<br>            LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size());<br>            resultList.forEach(data -&gt; {<br>                data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v}));<br>            });<br>        } catch (Exception ex) {<br>            fail(ex);<br>        }<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;&gt;&gt;&gt; test `EXTRACT` functions&quot;)<br>    public void testExtractFunctions() throws Exception {<br>        var person = new Person(&quot;John&quot;, 30);<br>        em.persist(person);<br>        assertNotNull(person.getId());<br>        endTx();</pre><pre>        startTx();<br>        try {<br>            var queryString = &quot;&quot;&quot;<br>                    SELECT p.name as name,<br>                    EXTRACT(YEAR FROM p.birthDate) as year,<br>                    EXTRACT(QUARTER FROM p.birthDate) as quarter,<br>                    EXTRACT(MONTH FROM p.birthDate) as month,<br>                    EXTRACT(WEEK FROM p.birthDate) as week,<br>                    EXTRACT(DAY FROM p.birthDate) as day,<br>                    EXTRACT(HOUR FROM p.birthDate) as hour,<br>                    EXTRACT(MINUTE FROM p.birthDate) as minute,<br>                    EXTRACT(SECOND FROM p.birthDate) as second<br>                    FROM Person p<br>                    &quot;&quot;&quot;;<br>            var query = em.createQuery(queryString);<br>            // for EclipseLinks<br>            query.setHint(QueryHints.RESULT_TYPE, ResultType.Map);<br>            List&lt;Map&lt;String, Object&gt;&gt; resultList = query.getResultList();<br>            LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size());<br>            resultList.forEach(data -&gt; {<br>                data.forEach((k, v) -&gt; LOGGER.log(Level.INFO, &quot;field:{0}, value: {1}&quot;, new Object[]{k, v}));<br>            });<br>        } catch (Exception ex) {<br>            fail(ex);<br>        }<br>    }<br>}</pre><p>Alternatively, create a test to verify the Criteria APIs.</p><pre>@ExtendWith(ArquillianExtension.class)<br>public class JPQLCriteriaBuilderTest {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(JPQLCriteriaBuilderTest.class.getName());</pre><pre>    @Deployment<br>    public static WebArchive createDeployment() {<br>        return ShrinkWrap.create(WebArchive.class)<br>                .addClasses(Person.class, Gender.class)<br>                .addAsResource(&quot;test-persistence.xml&quot;, &quot;META-INF/persistence.xml&quot;)<br>                .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;);<br>    }</pre><pre>    @PersistenceContext<br>    private EntityManager em;</pre><pre>    @Inject<br>    UserTransaction ux;</pre><pre>    @BeforeEach<br>    public void before() throws Exception {<br>        clearPersons();<br>        startTx();<br>    }</pre><pre>    private void clearPersons() throws Exception {<br>        startTx();<br>        var builder = em.getCriteriaBuilder();<br>        var deletePersonQuery = builder.createCriteriaDelete(Person.class);<br>        var deletedPersons = em.createQuery(deletePersonQuery).executeUpdate();<br>        LOGGER.log(Level.INFO, &quot;Deleted {0} persons&quot;, deletedPersons);<br>        endTx();<br>    }</pre><pre>    private void startTx() throws Exception {<br>        ux.begin();<br>        em.joinTransaction();<br>    }</pre><pre>    @AfterEach<br>    public void after() throws Exception {<br>        endTx();<br>    }</pre><pre>    private void endTx() throws Exception {<br>        LOGGER.log(Level.INFO, &quot;Transaction status: {0}&quot;, ux.getStatus());<br>        try {<br>            if (ux.getStatus() == Status.STATUS_ACTIVE) {<br>                ux.commit();<br>            }<br>        } catch (Exception e) {<br>            ux.rollback();<br>        }<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;&gt;&gt;&gt; test numeric functions&quot;)<br>    public void testNumericFunctions() throws Exception {<br>        var person = new Person(&quot;John&quot;, 30);<br>        em.persist(person);<br>        var id = person.getId();<br>        assertNotNull(id);<br>        endTx();</pre><pre>        startTx();<br>        try {<br>            var cb = em.getCriteriaBuilder();<br>            var query = cb.createTupleQuery();<br>            var root = query.from(Person.class);</pre><pre>            query.multiselect(root.get(&quot;name&quot;),<br>                    cb.ceiling(root.get(&quot;salary&quot;)),<br>                    cb.floor(root.get(&quot;salary&quot;)),<br>                    cb.round(root.get(&quot;salary&quot;), 1),<br>                    cb.exp(root.get(&quot;yearsWorked&quot;)),<br>                    cb.ln(root.get(&quot;yearsWorked&quot;)),<br>                    cb.power(root.get(&quot;yearsWorked&quot;), 2),<br>                    cb.sign(root.get(&quot;yearsWorked&quot;))<br>            );<br>            query.where(cb.equal(root.get(&quot;id&quot;), id));</pre><pre>            var resultList = em.createQuery(query).getResultList();<br>            LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size());<br>            resultList.forEach(result -&gt;<br>                    LOGGER.log(<br>                            Level.INFO,<br>                            // see: <a href="https://github.com/eclipse-ee4j/eclipselink/issues/1593">https://github.com/eclipse-ee4j/eclipselink/issues/1593</a><br>                            // John,12,345,12,345,12,345,7.389,0.693,4,1<br>                            &quot;tuple data :{0},{1},{2},{3},{4},{5},{6},{7}&quot;,<br>                            new Object[]{<br>                                    result.get(0, String.class),<br>                                    result.get(1, BigDecimal.class), // it should return BigDecimal<br>                                    result.get(2, BigDecimal.class),<br>                                    result.get(3, BigDecimal.class),<br>                                    result.get(4, Double.class),<br>                                    result.get(5, Double.class),<br>                                    result.get(6, Double.class),<br>                                    result.get(7, Integer.class)<br>                            }<br>                    )<br>            );<br>        } catch (Exception ex) {<br>            fail(ex);<br>        }<br>    }</pre><pre>    @Test<br>    @DisplayName(&quot;&gt;&gt;&gt; test nen datetime functions&quot;)<br>    public void testDateTimeFunctions() throws Exception {<br>        var person = new Person(&quot;John&quot;, 30);<br>        em.persist(person);<br>        var id = person.getId();<br>        assertNotNull(id);<br>        endTx();</pre><pre>        startTx();<br>        try {<br>            var cb = em.getCriteriaBuilder();<br>            var query = cb.createTupleQuery();<br>            var root = query.from(Person.class);</pre><pre>            query.multiselect(root.get(&quot;name&quot;),<br>                    cb.localTime(),<br>                    cb.localDateTime(),<br>                    cb.localDate()<br>            );<br>            query.where(cb.equal(root.get(&quot;id&quot;), id));</pre><pre>            var resultList = em.createQuery(query).getResultList();<br>            LOGGER.log(Level.INFO, &quot;result size:{0}&quot;, resultList.size());<br>            resultList.forEach(data -&gt;<br>                    LOGGER.log(<br>                            Level.INFO,<br>                            &quot;tuple data :{0},{1},{2},{3}&quot;,<br>                            new Object[]{<br>                                    data.get(0, String.class),<br>                                    data.get(1, java.time.LocalTime.class),<br>                                    data.get(2, java.time.LocalDateTime.class),<br>                                    data.get(3, java.time.LocalDate.class)<br>                            }<br>                    )<br>            );<br>        } catch (Exception ex) {<br>            fail(ex);<br>        }<br>    }<br>}</pre><p>But unfortunately, there is a bug in the GlassFish 7.0.0-M9 will fail the test JPQLFunctionsTest, more details please check Github issues <a href="https://github.com/eclipse-ee4j/glassfish/issues/24120">GlassFish #24120</a>.</p><p>Check the sample codes of <a href="https://github.com/hantsy/jakartaee10-sandbox/tree/master/hibernate">Hibernate</a> and <a href="https://github.com/hantsy/jakartaee10-sandbox/tree/master/jpa">Jakarta Persistence</a> from my github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=81b292e8b3a4" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/whats-new-in-jakarta-persistence-3-1-by-examples-81b292e8b3a4">What’s New in Jakarta Persistence 3.1 By Examples</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
