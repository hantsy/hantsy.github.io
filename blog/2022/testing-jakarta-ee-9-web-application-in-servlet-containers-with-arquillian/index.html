<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2022/testing-jakarta-ee-9-web-application-in-servlet-containers-with-arquillian/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Photo by &lt;a href=”https://unsplash.com/@whiterainforest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;White.Rainforest ∙ 易雨白林.&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt; In the last post Building JakartaEE 9 Web Applicaiton with Servlet Container, we have described how to start a Jakarta EE 9 web application with the core Jakarta EE components, including CDI, Jakarta Faces, Jakarta Servlet, Jakarta Pages, Jakarta REST, etc and run it in a Jakarta EE 9 compatible Servlet container. In this post, we will discuss how to test these components in a Servlet Container with the Arquillian testing framework. The Arquillian project provides official support for Apache Tomcat and Eclipse Jetty, for more information please go to Arquillian Container Tomcat and Arquillian Container Jetty. Currently, both projects provide an embedded container adapter that supports the latest Apache Tomcat 10 and Eclipse Jetty 11, but there is no managed and remote adapters available. If you are new to Arquillian, please read the official Getting Started Guides firstly, or explore my previous Arquillian articles on testing Jakarta EE 8 applications and Jakarta EE 9 applications to get to know the basic knowledge of Arquillian. Configuring Arquillian Firstly add Arquillian Core and JUnit BOM to the dependencyManagement section of the project pom.xml file. &lt;dependencyManagement&gt; // ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian&lt;/groupId&gt; &lt;artifactId&gt;arquillian-bom&lt;/artifactId&gt; &lt;version&gt;${arquillian-bom.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit&lt;/groupId&gt; &lt;artifactId&gt;junit-bom&lt;/artifactId&gt; &lt;version&gt;${junit-jupiter.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Add the following dependencies in the project dependencies section. &lt;dependencies&gt; //... &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt; &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.shrinkwrap.resolver&lt;/groupId&gt; &lt;artifactId&gt;shrinkwrap-resolver-impl-maven&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; You can also add the following testing utility libs to improve your testing codes. &lt;dependencies&gt; //.... &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-params&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Next, we will configure Arquillian Tomcat Embedded Adapter to run the testing codes against an embedded Apache Tomcat container. Configuring Arquillian Tomcat Embedded Adapter Create a new Maven profile to centralize all configurations of the Arquillian tomcat embedded adapter. &lt;profile&gt; &lt;id&gt;arq-tomcat-embedded&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-tomcat-embedded-10&lt;/artifactId&gt; &lt;version&gt;${arquillian-tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; Now we will write some testing codes. Testing Jakarta Components For simple POJOs, you can write a simple JUnit test to verify the functionality. For example, GreetingMessage is a simple POJO used to assemble a readable greeting message. We can write a simple JUnit test to check if it is working as expected. public class GreetingMessageTest { @Test public void testGreetingMessage() { var message = GreetingMessage.of(&quot;Say Hello to JatartaEE&quot;); assertThat(message.getMessage()).isEqualTo(&quot;Say Hello to JatartaEE&quot;); }} The GreetingService bean itself is just implementing a simple functionality that is used to build a greeting message using the buildGreetingMessage method that accepts an argument to set up the target of greeting. Just like the previous testing example, create a simple JUnit test to verify if it is functional as expected. public class GreetingServiceUnitTest { GreetingService service; @BeforeEach public void setup() { service = new GreetingService(); } @Test public void testGreeting() { var message = service.buildGreetingMessage(&quot;JakartaEE&quot;); assertThat(message.getMessage()).startsWith(&quot;Say Hello to JakartaEE&quot;); }} The Hello bean depends on the GreetingService bean. To test the functionality of Hello in a Unit Test, we can use Mockito to isolate the dependency - GreetingService. In the following HelloTest, we created a mocked object of GreetingService in the tests. public class HelloTest { @ParameterizedTest @MethodSource(&quot;provideQueryCriteria&quot;) public void testCreateMessage(String name, String result) { var service = mock(GreetingService.class); given(service.buildGreetingMessage(name)).willReturn(GreetingMessage.of(&quot;Say Hello to &quot; + name)); var hello = new Hello(service); hello.setName(name); hello.createMessage(); assertThat(hello.getName()).isEqualTo(name); assertThat(hello.getMessage().getMessage()).isEqualTo(result); verify(service, times(1)).buildGreetingMessage(anyString()); verifyNoMoreInteractions(service); } static Stream&lt;Arguments&gt; provideQueryCriteria() { return Stream.of( Arguments.of(&quot;Tomcat&quot;, &quot;Say Hello to Tomcat&quot;), Arguments.of(&quot;JakartaEE&quot;, &quot;Say Hello to JakartaEE&quot;) ); }} We have tested the simple POJOs in unit tests, for other Jakarta EE components, such as Servlet, Jakarta Pages, etc, we have to verify the functionality in a Servlet container, we will write integration tests using Arquillian for this scenario. To run unit tests and integration tests in different phases, we can configure maven-surefire-plugin and maven-failsafe-plugin as the following, and make sure integration tests run in the integration-test phase. &lt;plugins&gt; //... &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-surefire-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;${skipTests}&lt;/skipTests&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;default-test&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt;**/it/**&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;skipITs&gt;${skipTests}&lt;/skipITs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;integration-test&lt;/id&gt; &lt;phase&gt;integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;integration-test&lt;/goal&gt; &lt;goal&gt;verify&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/it/**&lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt; Firstly, let’s have a look at the GreetingServiceTest that is used for testing the simple CDI bean GreetingService. @ExtendWith(ArquillianExtension.class)public class GreetingServiceTest { private final static Logger LOGGER = Logger.getLogger(GreetingServiceTest.class.getName()); @Deployment public static WebArchive createDeployment() { var war = ShrinkWrap.create(WebArchive.class) .addClass(GreetingMessage.class) .addClass(GreetingService.class) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;) .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;) .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;); Deployments.addExtraJars(war); LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true)); return war; } @Inject GreetingService service; @Test @DisplayName(&quot;testing buildGreetingMessage&quot;) public void should_create_greeting() { LOGGER.log(Level.INFO, &quot; Running test:: GreetingServiceTest#should_create_greeting ... &quot;); var message = service.buildGreetingMessage(&quot;Jakarta EE&quot;); assertTrue(message.getMessage().startsWith(&quot;Say Hello to Jakarta EE at &quot;), &quot;message should start with \&quot;Say Hello to Jakarta EE at \&quot;&quot;); }} As you see, an Arquillian integration test is annotated with @ExtendWith(ArquillianExtension.class), which is a standard JUnit 5 extension. In an Arquillian test, you have to create a minimal deployment archive via a static @Deployment annotated method. In the @Deployment method, you can prepare the resource that will be packaged and deployed to the target runtime before running test cases. In the test class, you can inject available beans like a CDI bean, for example, we inject GreetingService here, then in the test method, use the GreetingService bean to verify the functionality. Open your terminal, and execute the following command to run GreetingServiceTest. mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingServiceTest When running an Arquillian test, it will package the deployment resources into a deployable archive, and deploy it to the target container, then run the test in the container, the JUnit client agent will gather the running result through a proxy that interacts with tests in the container. Let’s move to test GreetingResource. @ExtendWith(ArquillianExtension.class)public class GreetingResourceTest { private final static Logger LOGGER = Logger.getLogger(GreetingResourceTest.class.getName()); @Deployment(testable = false) public static WebArchive createDeployment() { var war = ShrinkWrap.create(WebArchive.class) .addClass(GreetingMessage.class) .addClass(GreetingService.class) .addClasses(GreetingResource.class) .addClasses(RestActivator.class) // Enable CDI (Optional since Java EE 7.0) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;) .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;) .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;); Deployments.addExtraJars(war); LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true)); return war; } @ArquillianResource private URL base; private Client client; @BeforeEach public void setup() { LOGGER.info(&quot;call BeforeEach&quot;); this.client = ClientBuilder.newClient(); } @AfterEach public void teardown() { LOGGER.info(&quot;call AfterEach&quot;); if (this.client != null) { this.client.close(); } } @Test @DisplayName(&quot;Given a name:`JakartaEE` should return `Say Hello to JakartaEE`&quot;) public void should_create_greeting() throws MalformedURLException { LOGGER.log(Level.INFO, &quot; client: {0}, baseURL: {1}&quot;, new Object[]{client, base}); final var greetingTarget = this.client.target(new URL(this.base, &quot;api/greeting/JakartaEE&quot;).toExternalForm()); try (final Response greetingGetResponse = greetingTarget.request() .accept(MediaType.APPLICATION_JSON) .get()) { assertThat(greetingGetResponse.getStatus()).isEqualTo(200); assertThat(greetingGetResponse.readEntity(GreetingMessage.class).getMessage()) .startsWith(&quot;Say Hello to JakartaEE&quot;); } }} Unlike GreetingServiceTest, to test the functionality of `GreetingResource``, we use Jakarta REST Client API to interact with the HTTP APIs in a client view. Adding a testable=false attribute in the @Deployment annotation means all tests will be run in client mode. Alternatively, you can also add a single @RunAsClient on the test method to run it locally. The @ArquillianResource will inject the base URL of the deployment archive in the container after it is deployed. Execute the following command to run GreetingServiceTest. mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingResourceTest If a @Deployment(testable=true) is applied on the deployment method, thus all tests run as client mode, we can NOT inject beans in the test class as the previous example. Similarly, we can create client mode tests to verify the functionalities of simple Jakarta Servlet, Jakarta Faces, Jakarta Pages, etc. The complete codes can be found here. To verify the HTML elements and Ajax interactions in the rendered HTML pages, please check Arquillian Extension Drone and Arquillian Graphene. Configuring Jetty Embedded Adapter Add a new Maven profile for configuring Arquillian Jetty Embedded Adapter. &lt;profile&gt; &lt;id&gt;arq-jetty-embedded&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-jetty-embedded-11&lt;/artifactId&gt; &lt;version&gt;${arquillian-jetty.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-deploy&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- to remove when 11.0.10 released --&gt; &lt;!-- see https://github.com/eclipse/jetty.project/pull/7991 --&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty.websocket&lt;/groupId&gt; &lt;artifactId&gt;websocket-jakarta-server&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- see: https://github.com/arquillian/arquillian-container-jetty/pull/108 --&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.testenricher&lt;/groupId&gt; &lt;artifactId&gt;arquillian-testenricher-cdi-jakarta&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/profile&gt; Run the previous tests against the arq-jetty-embedded profile, for example. mvn clean verify -Parq-jetty-embeded -Dit.test=GreetingResourceTest Configuring Arquillian Weld Embedded Arquillian project provides an official extension to test CDI beans in an embedded Weld container. Create a new Maven profile to configure Arquillian Weld Embedded Adapter, and use maven-failsafe-plugin to filter out the tests of Jakarta Servlet, Jakarta Faces, etc. &lt;profile&gt; &lt;id&gt;arq-weld&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-weld-embedded&lt;/artifactId&gt; &lt;version&gt;${arquillian-weld-embedded.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt; &lt;artifactId&gt;weld-core-impl&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;systemPropertyVariables&gt; &lt;arquillian.launch&gt;arq-weld&lt;/arquillian.launch&gt; &lt;/systemPropertyVariables&gt; &lt;excludes&gt; &lt;exclude&gt;**/it/GreetingResourceTest*&lt;/exclude&gt; &lt;exclude&gt;**/it/GreetingServletTest*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; Execute the following command to run the GreetingServiceTest. mvn clean verify -Parq-weld -Dit.test=GreetingServiceTest The testing codes of Jakarta Servlet, Jakarta Pages and Jakarta Faces require a Servlet container. Get the complete source codes from my Github account. &lt;hr&gt;&lt;p&gt;Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="Photo by &lt;a href=”https://unsplash.com/@whiterainforest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;White.Rainforest ∙ 易雨白林.&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt; In the last post Building JakartaEE 9 Web Applicaiton with Servlet Container, we have described how to start a Jakarta EE 9 web application with the core Jakarta EE components, including CDI, Jakarta Faces, Jakarta Servlet, Jakarta Pages, Jakarta REST, etc and run it in a Jakarta EE 9 compatible Servlet container. In this post, we will discuss how to test these components in a Servlet Container with the Arquillian testing framework. The Arquillian project provides official support for Apache Tomcat and Eclipse Jetty, for more information please go to Arquillian Container Tomcat and Arquillian Container Jetty. Currently, both projects provide an embedded container adapter that supports the latest Apache Tomcat 10 and Eclipse Jetty 11, but there is no managed and remote adapters available. If you are new to Arquillian, please read the official Getting Started Guides firstly, or explore my previous Arquillian articles on testing Jakarta EE 8 applications and Jakarta EE 9 applications to get to know the basic knowledge of Arquillian. Configuring Arquillian Firstly add Arquillian Core and JUnit BOM to the dependencyManagement section of the project pom.xml file. &lt;dependencyManagement&gt; // ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian&lt;/groupId&gt; &lt;artifactId&gt;arquillian-bom&lt;/artifactId&gt; &lt;version&gt;${arquillian-bom.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit&lt;/groupId&gt; &lt;artifactId&gt;junit-bom&lt;/artifactId&gt; &lt;version&gt;${junit-jupiter.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Add the following dependencies in the project dependencies section. &lt;dependencies&gt; //... &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt; &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.shrinkwrap.resolver&lt;/groupId&gt; &lt;artifactId&gt;shrinkwrap-resolver-impl-maven&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; You can also add the following testing utility libs to improve your testing codes. &lt;dependencies&gt; //.... &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-params&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Next, we will configure Arquillian Tomcat Embedded Adapter to run the testing codes against an embedded Apache Tomcat container. Configuring Arquillian Tomcat Embedded Adapter Create a new Maven profile to centralize all configurations of the Arquillian tomcat embedded adapter. &lt;profile&gt; &lt;id&gt;arq-tomcat-embedded&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-tomcat-embedded-10&lt;/artifactId&gt; &lt;version&gt;${arquillian-tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; Now we will write some testing codes. Testing Jakarta Components For simple POJOs, you can write a simple JUnit test to verify the functionality. For example, GreetingMessage is a simple POJO used to assemble a readable greeting message. We can write a simple JUnit test to check if it is working as expected. public class GreetingMessageTest { @Test public void testGreetingMessage() { var message = GreetingMessage.of(&quot;Say Hello to JatartaEE&quot;); assertThat(message.getMessage()).isEqualTo(&quot;Say Hello to JatartaEE&quot;); }} The GreetingService bean itself is just implementing a simple functionality that is used to build a greeting message using the buildGreetingMessage method that accepts an argument to set up the target of greeting. Just like the previous testing example, create a simple JUnit test to verify if it is functional as expected. public class GreetingServiceUnitTest { GreetingService service; @BeforeEach public void setup() { service = new GreetingService(); } @Test public void testGreeting() { var message = service.buildGreetingMessage(&quot;JakartaEE&quot;); assertThat(message.getMessage()).startsWith(&quot;Say Hello to JakartaEE&quot;); }} The Hello bean depends on the GreetingService bean. To test the functionality of Hello in a Unit Test, we can use Mockito to isolate the dependency - GreetingService. In the following HelloTest, we created a mocked object of GreetingService in the tests. public class HelloTest { @ParameterizedTest @MethodSource(&quot;provideQueryCriteria&quot;) public void testCreateMessage(String name, String result) { var service = mock(GreetingService.class); given(service.buildGreetingMessage(name)).willReturn(GreetingMessage.of(&quot;Say Hello to &quot; + name)); var hello = new Hello(service); hello.setName(name); hello.createMessage(); assertThat(hello.getName()).isEqualTo(name); assertThat(hello.getMessage().getMessage()).isEqualTo(result); verify(service, times(1)).buildGreetingMessage(anyString()); verifyNoMoreInteractions(service); } static Stream&lt;Arguments&gt; provideQueryCriteria() { return Stream.of( Arguments.of(&quot;Tomcat&quot;, &quot;Say Hello to Tomcat&quot;), Arguments.of(&quot;JakartaEE&quot;, &quot;Say Hello to JakartaEE&quot;) ); }} We have tested the simple POJOs in unit tests, for other Jakarta EE components, such as Servlet, Jakarta Pages, etc, we have to verify the functionality in a Servlet container, we will write integration tests using Arquillian for this scenario. To run unit tests and integration tests in different phases, we can configure maven-surefire-plugin and maven-failsafe-plugin as the following, and make sure integration tests run in the integration-test phase. &lt;plugins&gt; //... &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-surefire-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;${skipTests}&lt;/skipTests&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;default-test&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt;**/it/**&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;skipITs&gt;${skipTests}&lt;/skipITs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;integration-test&lt;/id&gt; &lt;phase&gt;integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;integration-test&lt;/goal&gt; &lt;goal&gt;verify&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/it/**&lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt; Firstly, let’s have a look at the GreetingServiceTest that is used for testing the simple CDI bean GreetingService. @ExtendWith(ArquillianExtension.class)public class GreetingServiceTest { private final static Logger LOGGER = Logger.getLogger(GreetingServiceTest.class.getName()); @Deployment public static WebArchive createDeployment() { var war = ShrinkWrap.create(WebArchive.class) .addClass(GreetingMessage.class) .addClass(GreetingService.class) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;) .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;) .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;); Deployments.addExtraJars(war); LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true)); return war; } @Inject GreetingService service; @Test @DisplayName(&quot;testing buildGreetingMessage&quot;) public void should_create_greeting() { LOGGER.log(Level.INFO, &quot; Running test:: GreetingServiceTest#should_create_greeting ... &quot;); var message = service.buildGreetingMessage(&quot;Jakarta EE&quot;); assertTrue(message.getMessage().startsWith(&quot;Say Hello to Jakarta EE at &quot;), &quot;message should start with \&quot;Say Hello to Jakarta EE at \&quot;&quot;); }} As you see, an Arquillian integration test is annotated with @ExtendWith(ArquillianExtension.class), which is a standard JUnit 5 extension. In an Arquillian test, you have to create a minimal deployment archive via a static @Deployment annotated method. In the @Deployment method, you can prepare the resource that will be packaged and deployed to the target runtime before running test cases. In the test class, you can inject available beans like a CDI bean, for example, we inject GreetingService here, then in the test method, use the GreetingService bean to verify the functionality. Open your terminal, and execute the following command to run GreetingServiceTest. mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingServiceTest When running an Arquillian test, it will package the deployment resources into a deployable archive, and deploy it to the target container, then run the test in the container, the JUnit client agent will gather the running result through a proxy that interacts with tests in the container. Let’s move to test GreetingResource. @ExtendWith(ArquillianExtension.class)public class GreetingResourceTest { private final static Logger LOGGER = Logger.getLogger(GreetingResourceTest.class.getName()); @Deployment(testable = false) public static WebArchive createDeployment() { var war = ShrinkWrap.create(WebArchive.class) .addClass(GreetingMessage.class) .addClass(GreetingService.class) .addClasses(GreetingResource.class) .addClasses(RestActivator.class) // Enable CDI (Optional since Java EE 7.0) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;) .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;) .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;); Deployments.addExtraJars(war); LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true)); return war; } @ArquillianResource private URL base; private Client client; @BeforeEach public void setup() { LOGGER.info(&quot;call BeforeEach&quot;); this.client = ClientBuilder.newClient(); } @AfterEach public void teardown() { LOGGER.info(&quot;call AfterEach&quot;); if (this.client != null) { this.client.close(); } } @Test @DisplayName(&quot;Given a name:`JakartaEE` should return `Say Hello to JakartaEE`&quot;) public void should_create_greeting() throws MalformedURLException { LOGGER.log(Level.INFO, &quot; client: {0}, baseURL: {1}&quot;, new Object[]{client, base}); final var greetingTarget = this.client.target(new URL(this.base, &quot;api/greeting/JakartaEE&quot;).toExternalForm()); try (final Response greetingGetResponse = greetingTarget.request() .accept(MediaType.APPLICATION_JSON) .get()) { assertThat(greetingGetResponse.getStatus()).isEqualTo(200); assertThat(greetingGetResponse.readEntity(GreetingMessage.class).getMessage()) .startsWith(&quot;Say Hello to JakartaEE&quot;); } }} Unlike GreetingServiceTest, to test the functionality of `GreetingResource``, we use Jakarta REST Client API to interact with the HTTP APIs in a client view. Adding a testable=false attribute in the @Deployment annotation means all tests will be run in client mode. Alternatively, you can also add a single @RunAsClient on the test method to run it locally. The @ArquillianResource will inject the base URL of the deployment archive in the container after it is deployed. Execute the following command to run GreetingServiceTest. mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingResourceTest If a @Deployment(testable=true) is applied on the deployment method, thus all tests run as client mode, we can NOT inject beans in the test class as the previous example. Similarly, we can create client mode tests to verify the functionalities of simple Jakarta Servlet, Jakarta Faces, Jakarta Pages, etc. The complete codes can be found here. To verify the HTML elements and Ajax interactions in the rendered HTML pages, please check Arquillian Extension Drone and Arquillian Graphene. Configuring Jetty Embedded Adapter Add a new Maven profile for configuring Arquillian Jetty Embedded Adapter. &lt;profile&gt; &lt;id&gt;arq-jetty-embedded&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-jetty-embedded-11&lt;/artifactId&gt; &lt;version&gt;${arquillian-jetty.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-deploy&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- to remove when 11.0.10 released --&gt; &lt;!-- see https://github.com/eclipse/jetty.project/pull/7991 --&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty.websocket&lt;/groupId&gt; &lt;artifactId&gt;websocket-jakarta-server&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- see: https://github.com/arquillian/arquillian-container-jetty/pull/108 --&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.testenricher&lt;/groupId&gt; &lt;artifactId&gt;arquillian-testenricher-cdi-jakarta&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/profile&gt; Run the previous tests against the arq-jetty-embedded profile, for example. mvn clean verify -Parq-jetty-embeded -Dit.test=GreetingResourceTest Configuring Arquillian Weld Embedded Arquillian project provides an official extension to test CDI beans in an embedded Weld container. Create a new Maven profile to configure Arquillian Weld Embedded Adapter, and use maven-failsafe-plugin to filter out the tests of Jakarta Servlet, Jakarta Faces, etc. &lt;profile&gt; &lt;id&gt;arq-weld&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-weld-embedded&lt;/artifactId&gt; &lt;version&gt;${arquillian-weld-embedded.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt; &lt;artifactId&gt;weld-core-impl&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;systemPropertyVariables&gt; &lt;arquillian.launch&gt;arq-weld&lt;/arquillian.launch&gt; &lt;/systemPropertyVariables&gt; &lt;excludes&gt; &lt;exclude&gt;**/it/GreetingResourceTest*&lt;/exclude&gt; &lt;exclude&gt;**/it/GreetingServletTest*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; Execute the following command to run the GreetingServiceTest. mvn clean verify -Parq-weld -Dit.test=GreetingServiceTest The testing codes of Jakarta Servlet, Jakarta Pages and Jakarta Faces require a Servlet container. Get the complete source codes from my Github account. &lt;hr&gt;&lt;p&gt;Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-01T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-01T00:00:00+00:00","datePublished":"2022-08-01T00:00:00+00:00","description":"Photo by &lt;a href=”https://unsplash.com/@whiterainforest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;White.Rainforest ∙ 易雨白林.&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt; In the last post Building JakartaEE 9 Web Applicaiton with Servlet Container, we have described how to start a Jakarta EE 9 web application with the core Jakarta EE components, including CDI, Jakarta Faces, Jakarta Servlet, Jakarta Pages, Jakarta REST, etc and run it in a Jakarta EE 9 compatible Servlet container. In this post, we will discuss how to test these components in a Servlet Container with the Arquillian testing framework. The Arquillian project provides official support for Apache Tomcat and Eclipse Jetty, for more information please go to Arquillian Container Tomcat and Arquillian Container Jetty. Currently, both projects provide an embedded container adapter that supports the latest Apache Tomcat 10 and Eclipse Jetty 11, but there is no managed and remote adapters available. If you are new to Arquillian, please read the official Getting Started Guides firstly, or explore my previous Arquillian articles on testing Jakarta EE 8 applications and Jakarta EE 9 applications to get to know the basic knowledge of Arquillian. Configuring Arquillian Firstly add Arquillian Core and JUnit BOM to the dependencyManagement section of the project pom.xml file. &lt;dependencyManagement&gt; // ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian&lt;/groupId&gt; &lt;artifactId&gt;arquillian-bom&lt;/artifactId&gt; &lt;version&gt;${arquillian-bom.version}&lt;/version&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit&lt;/groupId&gt; &lt;artifactId&gt;junit-bom&lt;/artifactId&gt; &lt;version&gt;${junit-jupiter.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; Add the following dependencies in the project dependencies section. &lt;dependencies&gt; //... &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt; &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.shrinkwrap.resolver&lt;/groupId&gt; &lt;artifactId&gt;shrinkwrap-resolver-impl-maven&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; You can also add the following testing utility libs to improve your testing codes. &lt;dependencies&gt; //.... &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-params&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.assertj&lt;/groupId&gt; &lt;artifactId&gt;assertj-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Next, we will configure Arquillian Tomcat Embedded Adapter to run the testing codes against an embedded Apache Tomcat container. Configuring Arquillian Tomcat Embedded Adapter Create a new Maven profile to centralize all configurations of the Arquillian tomcat embedded adapter. &lt;profile&gt; &lt;id&gt;arq-tomcat-embedded&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-tomcat-embedded-10&lt;/artifactId&gt; &lt;version&gt;${arquillian-tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; Now we will write some testing codes. Testing Jakarta Components For simple POJOs, you can write a simple JUnit test to verify the functionality. For example, GreetingMessage is a simple POJO used to assemble a readable greeting message. We can write a simple JUnit test to check if it is working as expected. public class GreetingMessageTest { @Test public void testGreetingMessage() { var message = GreetingMessage.of(&quot;Say Hello to JatartaEE&quot;); assertThat(message.getMessage()).isEqualTo(&quot;Say Hello to JatartaEE&quot;); }} The GreetingService bean itself is just implementing a simple functionality that is used to build a greeting message using the buildGreetingMessage method that accepts an argument to set up the target of greeting. Just like the previous testing example, create a simple JUnit test to verify if it is functional as expected. public class GreetingServiceUnitTest { GreetingService service; @BeforeEach public void setup() { service = new GreetingService(); } @Test public void testGreeting() { var message = service.buildGreetingMessage(&quot;JakartaEE&quot;); assertThat(message.getMessage()).startsWith(&quot;Say Hello to JakartaEE&quot;); }} The Hello bean depends on the GreetingService bean. To test the functionality of Hello in a Unit Test, we can use Mockito to isolate the dependency - GreetingService. In the following HelloTest, we created a mocked object of GreetingService in the tests. public class HelloTest { @ParameterizedTest @MethodSource(&quot;provideQueryCriteria&quot;) public void testCreateMessage(String name, String result) { var service = mock(GreetingService.class); given(service.buildGreetingMessage(name)).willReturn(GreetingMessage.of(&quot;Say Hello to &quot; + name)); var hello = new Hello(service); hello.setName(name); hello.createMessage(); assertThat(hello.getName()).isEqualTo(name); assertThat(hello.getMessage().getMessage()).isEqualTo(result); verify(service, times(1)).buildGreetingMessage(anyString()); verifyNoMoreInteractions(service); } static Stream&lt;Arguments&gt; provideQueryCriteria() { return Stream.of( Arguments.of(&quot;Tomcat&quot;, &quot;Say Hello to Tomcat&quot;), Arguments.of(&quot;JakartaEE&quot;, &quot;Say Hello to JakartaEE&quot;) ); }} We have tested the simple POJOs in unit tests, for other Jakarta EE components, such as Servlet, Jakarta Pages, etc, we have to verify the functionality in a Servlet container, we will write integration tests using Arquillian for this scenario. To run unit tests and integration tests in different phases, we can configure maven-surefire-plugin and maven-failsafe-plugin as the following, and make sure integration tests run in the integration-test phase. &lt;plugins&gt; //... &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-surefire-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;${skipTests}&lt;/skipTests&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;default-test&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt;**/it/**&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;skipITs&gt;${skipTests}&lt;/skipITs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;integration-test&lt;/id&gt; &lt;phase&gt;integration-test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;integration-test&lt;/goal&gt; &lt;goal&gt;verify&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/it/**&lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;&lt;/plugins&gt; Firstly, let’s have a look at the GreetingServiceTest that is used for testing the simple CDI bean GreetingService. @ExtendWith(ArquillianExtension.class)public class GreetingServiceTest { private final static Logger LOGGER = Logger.getLogger(GreetingServiceTest.class.getName()); @Deployment public static WebArchive createDeployment() { var war = ShrinkWrap.create(WebArchive.class) .addClass(GreetingMessage.class) .addClass(GreetingService.class) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;) .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;) .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;); Deployments.addExtraJars(war); LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true)); return war; } @Inject GreetingService service; @Test @DisplayName(&quot;testing buildGreetingMessage&quot;) public void should_create_greeting() { LOGGER.log(Level.INFO, &quot; Running test:: GreetingServiceTest#should_create_greeting ... &quot;); var message = service.buildGreetingMessage(&quot;Jakarta EE&quot;); assertTrue(message.getMessage().startsWith(&quot;Say Hello to Jakarta EE at &quot;), &quot;message should start with \\&quot;Say Hello to Jakarta EE at \\&quot;&quot;); }} As you see, an Arquillian integration test is annotated with @ExtendWith(ArquillianExtension.class), which is a standard JUnit 5 extension. In an Arquillian test, you have to create a minimal deployment archive via a static @Deployment annotated method. In the @Deployment method, you can prepare the resource that will be packaged and deployed to the target runtime before running test cases. In the test class, you can inject available beans like a CDI bean, for example, we inject GreetingService here, then in the test method, use the GreetingService bean to verify the functionality. Open your terminal, and execute the following command to run GreetingServiceTest. mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingServiceTest When running an Arquillian test, it will package the deployment resources into a deployable archive, and deploy it to the target container, then run the test in the container, the JUnit client agent will gather the running result through a proxy that interacts with tests in the container. Let’s move to test GreetingResource. @ExtendWith(ArquillianExtension.class)public class GreetingResourceTest { private final static Logger LOGGER = Logger.getLogger(GreetingResourceTest.class.getName()); @Deployment(testable = false) public static WebArchive createDeployment() { var war = ShrinkWrap.create(WebArchive.class) .addClass(GreetingMessage.class) .addClass(GreetingService.class) .addClasses(GreetingResource.class) .addClasses(RestActivator.class) // Enable CDI (Optional since Java EE 7.0) .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;) .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;) .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;); Deployments.addExtraJars(war); LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true)); return war; } @ArquillianResource private URL base; private Client client; @BeforeEach public void setup() { LOGGER.info(&quot;call BeforeEach&quot;); this.client = ClientBuilder.newClient(); } @AfterEach public void teardown() { LOGGER.info(&quot;call AfterEach&quot;); if (this.client != null) { this.client.close(); } } @Test @DisplayName(&quot;Given a name:`JakartaEE` should return `Say Hello to JakartaEE`&quot;) public void should_create_greeting() throws MalformedURLException { LOGGER.log(Level.INFO, &quot; client: {0}, baseURL: {1}&quot;, new Object[]{client, base}); final var greetingTarget = this.client.target(new URL(this.base, &quot;api/greeting/JakartaEE&quot;).toExternalForm()); try (final Response greetingGetResponse = greetingTarget.request() .accept(MediaType.APPLICATION_JSON) .get()) { assertThat(greetingGetResponse.getStatus()).isEqualTo(200); assertThat(greetingGetResponse.readEntity(GreetingMessage.class).getMessage()) .startsWith(&quot;Say Hello to JakartaEE&quot;); } }} Unlike GreetingServiceTest, to test the functionality of `GreetingResource``, we use Jakarta REST Client API to interact with the HTTP APIs in a client view. Adding a testable=false attribute in the @Deployment annotation means all tests will be run in client mode. Alternatively, you can also add a single @RunAsClient on the test method to run it locally. The @ArquillianResource will inject the base URL of the deployment archive in the container after it is deployed. Execute the following command to run GreetingServiceTest. mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingResourceTest If a @Deployment(testable=true) is applied on the deployment method, thus all tests run as client mode, we can NOT inject beans in the test class as the previous example. Similarly, we can create client mode tests to verify the functionalities of simple Jakarta Servlet, Jakarta Faces, Jakarta Pages, etc. The complete codes can be found here. To verify the HTML elements and Ajax interactions in the rendered HTML pages, please check Arquillian Extension Drone and Arquillian Graphene. Configuring Jetty Embedded Adapter Add a new Maven profile for configuring Arquillian Jetty Embedded Adapter. &lt;profile&gt; &lt;id&gt;arq-jetty-embedded&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-jetty-embedded-11&lt;/artifactId&gt; &lt;version&gt;${arquillian-jetty.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-deploy&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- to remove when 11.0.10 released --&gt; &lt;!-- see https://github.com/eclipse/jetty.project/pull/7991 --&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty.websocket&lt;/groupId&gt; &lt;artifactId&gt;websocket-jakarta-server&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- see: https://github.com/arquillian/arquillian-container-jetty/pull/108 --&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.testenricher&lt;/groupId&gt; &lt;artifactId&gt;arquillian-testenricher-cdi-jakarta&lt;/artifactId&gt; &lt;/dependency&gt;--&gt; &lt;/dependencies&gt;&lt;/profile&gt; Run the previous tests against the arq-jetty-embedded profile, for example. mvn clean verify -Parq-jetty-embeded -Dit.test=GreetingResourceTest Configuring Arquillian Weld Embedded Arquillian project provides an official extension to test CDI beans in an embedded Weld container. Create a new Maven profile to configure Arquillian Weld Embedded Adapter, and use maven-failsafe-plugin to filter out the tests of Jakarta Servlet, Jakarta Faces, etc. &lt;profile&gt; &lt;id&gt;arq-weld&lt;/id&gt; &lt;properties&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt; &lt;artifactId&gt;arquillian-weld-embedded&lt;/artifactId&gt; &lt;version&gt;${arquillian-weld-embedded.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt; &lt;artifactId&gt;weld-core-impl&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt; &lt;configuration&gt; &lt;systemPropertyVariables&gt; &lt;arquillian.launch&gt;arq-weld&lt;/arquillian.launch&gt; &lt;/systemPropertyVariables&gt; &lt;excludes&gt; &lt;exclude&gt;**/it/GreetingResourceTest*&lt;/exclude&gt; &lt;exclude&gt;**/it/GreetingServletTest*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/profile&gt; Execute the following command to run the GreetingServiceTest. mvn clean verify -Parq-weld -Dit.test=GreetingServiceTest The testing codes of Jakarta Servlet, Jakarta Pages and Jakarta Faces require a Servlet container. Get the complete source codes from my Github account. &lt;hr&gt;&lt;p&gt;Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/testing-jakarta-ee-9-web-application-in-servlet-containers-with-arquillian/"},"url":"/blog/2022/testing-jakarta-ee-9-web-application-in-servlet-containers-with-arquillian/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian</h1>
    <p class="post-meta">August 1, 2022</p>
  </header>

  <article class="post-content">
    <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dY00LOwrPkshDVnjDP-XwA.jpeg" /><figcaption>Photo by &lt;a href=”<a href="https://unsplash.com/@whiterainforest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">https://unsplash.com/@whiterainforest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText</a>&quot;&gt;White.Rainforest ∙ 易雨白林.&lt;/a&gt; on &lt;a href=”<a href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText</a>&quot;&gt;Unsplash&lt;/a&gt;</figcaption></figure><p>In the last post <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate/blob/master/docs/build.md">Building JakartaEE 9 Web Applicaiton with Servlet Container</a>, we have described how to start a Jakarta EE 9 web application with the core Jakarta EE components, including CDI, Jakarta Faces, Jakarta Servlet, Jakarta Pages, Jakarta REST, etc and run it in a Jakarta EE 9 compatible Servlet container. In this post, we will discuss how to test these components in a Servlet Container with the Arquillian testing framework.</p><p>The Arquillian project provides official support for Apache Tomcat and Eclipse Jetty, for more information please go to <a href="https://github.com/arquillian/arquillian-container-tomcat">Arquillian Container Tomcat</a> and <a href="https://github.com/arquillian/arquillian-container-jetty">Arquillian Container Jetty</a>. Currently, both projects provide an <em>embedded</em> container adapter that supports the latest Apache Tomcat 10 and Eclipse Jetty 11, but there is no managed and remote adapters available.</p><p>If you are new to Arquillian, please read the official <a href="https://arquillian.org/guides/">Getting Started Guides</a> firstly, or explore my previous Arquillian articles on <a href="https://hantsy.github.io/jakartaee8-starter-boilerplate/">testing Jakarta EE 8 applications</a> and <a href="https://hantsy.github.io/jakartaee9-starter-boilerplate/">Jakarta EE 9 applications</a> to get to know the basic knowledge of Arquillian.</p><h3>Configuring Arquillian</h3><p>Firstly add Arquillian Core and JUnit <em>BOM</em> to the <em>dependencyManagement</em> section of the project <em>pom.xml</em> file.</p><pre>&lt;dependencyManagement&gt;<br>    // ... <br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-bom&lt;/artifactId&gt;<br>            &lt;version&gt;${arquillian-bom.version}&lt;/version&gt;<br>            &lt;scope&gt;import&lt;/scope&gt;<br>            &lt;type&gt;pom&lt;/type&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.junit&lt;/groupId&gt;<br>            &lt;artifactId&gt;junit-bom&lt;/artifactId&gt;<br>            &lt;version&gt;${junit-jupiter.version}&lt;/version&gt;<br>            &lt;type&gt;pom&lt;/type&gt;<br>            &lt;scope&gt;import&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/dependencyManagement&gt;</pre><p>Add the following dependencies in the project <em>dependencies</em> section.</p><pre>&lt;dependencies&gt;<br>    //...<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.jboss.arquillian.protocol&lt;/groupId&gt;<br>        &lt;artifactId&gt;arquillian-protocol-servlet-jakarta&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.jboss.shrinkwrap.resolver&lt;/groupId&gt;<br>        &lt;artifactId&gt;shrinkwrap-resolver-impl-maven&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>        &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><p>You can also add the following testing utility libs to improve your testing codes.</p><pre>&lt;dependencies&gt;<br>    //....<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;<br>        &lt;artifactId&gt;junit-jupiter-params&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.mockito&lt;/groupId&gt;<br>        &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;<br>        &lt;artifactId&gt;hamcrest&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.assertj&lt;/groupId&gt;<br>        &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;<br>        &lt;scope&gt;test&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><p>Next, we will configure Arquillian Tomcat Embedded Adapter to run the testing codes against an embedded Apache Tomcat container.</p><h3>Configuring Arquillian Tomcat Embedded Adapter</h3><p>Create a new Maven profile to centralize all configurations of the Arquillian tomcat embedded adapter.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;arq-tomcat-embedded&lt;/id&gt;<br>    &lt;properties&gt;<br>        &lt;skipTests&gt;false&lt;/skipTests&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-tomcat-embedded-10&lt;/artifactId&gt;<br>            &lt;version&gt;${arquillian-tomcat.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;<br>            &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;<br>            &lt;version&gt;${tomcat.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;<br>            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;<br>            &lt;version&gt;${tomcat.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;<br>            &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt;<br>            &lt;version&gt;${tomcat.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/profile&gt;</pre><p>Now we will write some testing codes.</p><h3>Testing Jakarta Components</h3><p>For simple POJOs, you can write a simple JUnit test to verify the functionality. For example, GreetingMessage is a simple POJO used to assemble a readable greeting message. We can write a simple JUnit test to check if it is working as expected.</p><pre>public class GreetingMessageTest {</pre><pre>    @Test<br>    public void testGreetingMessage() {<br>        var message = GreetingMessage.of(&quot;Say Hello to JatartaEE&quot;);<br>        assertThat(message.getMessage()).isEqualTo(&quot;Say Hello to JatartaEE&quot;);<br>    }<br>}</pre><p>The GreetingService bean itself is just implementing a simple functionality that is used to build a greeting message using the buildGreetingMessage method that accepts an argument to set up the target of greeting. Just like the previous testing example, create a simple JUnit test to verify if it is functional as expected.</p><pre>public class GreetingServiceUnitTest {</pre><pre>    GreetingService service;</pre><pre>    @BeforeEach<br>    public void setup() {<br>        service = new GreetingService();<br>    }</pre><pre>    @Test<br>    public void testGreeting() {<br>        var message = service.buildGreetingMessage(&quot;JakartaEE&quot;);<br>        assertThat(message.getMessage()).startsWith(&quot;Say Hello to JakartaEE&quot;);<br>    }<br>}</pre><p>The Hello bean depends on the GreetingService bean. To test the functionality of Hello in a Unit Test, we can use Mockito to isolate the dependency - GreetingService. In the following HelloTest, we created a mocked object of GreetingService in the tests.</p><pre>public class HelloTest {</pre><pre>    @ParameterizedTest<br>    @MethodSource(&quot;provideQueryCriteria&quot;)<br>    public void testCreateMessage(String name, String result) {<br>        var service = mock(GreetingService.class);<br>        given(service.buildGreetingMessage(name)).willReturn(GreetingMessage.of(&quot;Say Hello to &quot; + name));<br>        <br>        var hello = new Hello(service);<br>        <br>        hello.setName(name);<br>        hello.createMessage();<br>        assertThat(hello.getName()).isEqualTo(name);<br>        assertThat(hello.getMessage().getMessage()).isEqualTo(result);<br>        verify(service, times(1)).buildGreetingMessage(anyString());<br>        verifyNoMoreInteractions(service);<br>    }<br>    <br>    static Stream&lt;Arguments&gt; provideQueryCriteria() {<br>        return Stream.of(<br>                Arguments.of(&quot;Tomcat&quot;, &quot;Say Hello to Tomcat&quot;),<br>                Arguments.of(&quot;JakartaEE&quot;, &quot;Say Hello to JakartaEE&quot;)<br>        );<br>    }<br>}</pre><p>We have tested the simple POJOs in unit tests, for other Jakarta EE components, such as Servlet, Jakarta Pages, etc, we have to verify the functionality in a Servlet container, we will write integration tests using Arquillian for this scenario.</p><p>To run unit tests and integration tests in different phases, we can configure maven-surefire-plugin and maven-failsafe-plugin as the following, and make sure integration tests run in the integration-test phase.</p><pre>&lt;plugins&gt;<br>    //...<br>    &lt;plugin&gt;<br>        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;<br>        &lt;version&gt;${maven-surefire-plugin.version}&lt;/version&gt;<br>        &lt;configuration&gt;<br>            &lt;skipTests&gt;${skipTests}&lt;/skipTests&gt;<br>        &lt;/configuration&gt;<br>        &lt;executions&gt;<br>            &lt;execution&gt;<br>                &lt;id&gt;default-test&lt;/id&gt;<br>                &lt;phase&gt;test&lt;/phase&gt;<br>                &lt;goals&gt;<br>                    &lt;goal&gt;test&lt;/goal&gt;<br>                &lt;/goals&gt;<br>                &lt;configuration&gt;<br>                    &lt;excludes&gt;<br>                        &lt;exclude&gt;**/it/**&lt;/exclude&gt;<br>                    &lt;/excludes&gt;<br>                &lt;/configuration&gt;<br>            &lt;/execution&gt;<br>        &lt;/executions&gt;<br>    &lt;/plugin&gt;<br>    &lt;plugin&gt;<br>        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>        &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;<br>        &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt;<br>        &lt;configuration&gt;<br>            &lt;skipITs&gt;${skipTests}&lt;/skipITs&gt;<br>        &lt;/configuration&gt;<br>        &lt;executions&gt;<br>            &lt;execution&gt;<br>                &lt;id&gt;integration-test&lt;/id&gt;<br>                &lt;phase&gt;integration-test&lt;/phase&gt;<br>                &lt;goals&gt;<br>                    &lt;goal&gt;integration-test&lt;/goal&gt;<br>                    &lt;goal&gt;verify&lt;/goal&gt;<br>                &lt;/goals&gt;<br>                &lt;configuration&gt;<br>                    &lt;includes&gt;<br>                        &lt;include&gt;**/it/**&lt;/include&gt;<br>                    &lt;/includes&gt;<br>                &lt;/configuration&gt;<br>            &lt;/execution&gt;<br>        &lt;/executions&gt;<br>    &lt;/plugin&gt;<br>&lt;/plugins&gt;</pre><p>Firstly, let’s have a look at the GreetingServiceTest that is used for testing the simple CDI bean GreetingService.</p><pre>@ExtendWith(ArquillianExtension.class)<br>public class GreetingServiceTest {<br>    <br>    private final static Logger LOGGER = Logger.getLogger(GreetingServiceTest.class.getName());<br>    <br>    @Deployment<br>    public static WebArchive createDeployment() {<br>        var war = ShrinkWrap.create(WebArchive.class)<br>                .addClass(GreetingMessage.class)<br>                .addClass(GreetingService.class)<br>                .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;)<br>                .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;)<br>                .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;);<br>        <br>        Deployments.addExtraJars(war);<br>        <br>        LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true));<br>        return war;<br>    }<br>    <br>    @Inject<br>    GreetingService service;<br>    <br>    @Test<br>    @DisplayName(&quot;testing buildGreetingMessage&quot;)<br>    public void should_create_greeting() {<br>        LOGGER.log(Level.INFO, &quot; Running test:: GreetingServiceTest#should_create_greeting ... &quot;);<br>        var message = service.buildGreetingMessage(&quot;Jakarta EE&quot;);<br>        assertTrue(message.getMessage().startsWith(&quot;Say Hello to Jakarta EE at &quot;),<br>                &quot;message should start with \&quot;Say Hello to Jakarta EE at \&quot;&quot;);<br>    }<br>}</pre><p>As you see, an Arquillian integration test is annotated with @ExtendWith(ArquillianExtension.class), which is a standard JUnit 5 extension.</p><p>In an Arquillian test, you have to create a minimal deployment archive via a static @Deployment annotated method. In the @Deployment method, you can prepare the resource that will be packaged and deployed to the target runtime before running test cases.</p><p>In the test class, you can inject available beans like a CDI bean, for example, we inject GreetingService here, then in the test method, use the GreetingService bean to verify the functionality.</p><p>Open your terminal, and execute the following command to run GreetingServiceTest.</p><pre>mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingServiceTest</pre><p>When running an Arquillian test, it will package the deployment resources into a deployable archive, and deploy it to the target container, then run the test in the container, the JUnit client agent will gather the running result through a proxy that interacts with tests in the container.</p><p>Let’s move to test GreetingResource.</p><pre>@ExtendWith(ArquillianExtension.class)<br>public class GreetingResourceTest {<br>    <br>    private final static Logger LOGGER = Logger.getLogger(GreetingResourceTest.class.getName());<br>    <br>    @Deployment(testable = false)<br>    public static WebArchive createDeployment() {<br>        var war = ShrinkWrap.create(WebArchive.class)<br>                .addClass(GreetingMessage.class)<br>                .addClass(GreetingService.class)<br>                .addClasses(GreetingResource.class)<br>                .addClasses(RestActivator.class)<br>                // Enable CDI (Optional since Java EE 7.0)<br>                .addAsWebInfResource(EmptyAsset.INSTANCE, &quot;beans.xml&quot;)<br>                .addAsWebInfResource(&quot;test-web.xml&quot;, &quot;web.xml&quot;)<br>                .addAsWebInfResource(new File(&quot;src/main/webapp/WEB-INF/jetty-env.xml&quot;), &quot;jetty-env.xml&quot;);<br>        <br>        Deployments.addExtraJars(war);<br>        <br>        LOGGER.log(Level.INFO, &quot;war deployment: {0}&quot;, war.toString(true));<br>        return war;<br>    }<br>    <br>    @ArquillianResource<br>    private URL base;<br>    <br>    private Client client;<br>    <br>    @BeforeEach<br>    public void setup() {<br>        LOGGER.info(&quot;call BeforeEach&quot;);<br>        this.client = ClientBuilder.newClient();<br>    }<br>    <br>    @AfterEach<br>    public void teardown() {<br>        LOGGER.info(&quot;call AfterEach&quot;);<br>        if (this.client != null) {<br>            this.client.close();<br>        }<br>    }<br>    <br>    @Test<br>    @DisplayName(&quot;Given a name:`JakartaEE` should return `Say Hello to JakartaEE`&quot;)<br>    public void should_create_greeting() throws MalformedURLException {<br>        LOGGER.log(Level.INFO, &quot; client: {0}, baseURL: {1}&quot;, new Object[]{client, base});<br>        final var greetingTarget = this.client.target(new URL(this.base, &quot;api/greeting/JakartaEE&quot;).toExternalForm());<br>        try (final Response greetingGetResponse = greetingTarget.request()<br>                .accept(MediaType.APPLICATION_JSON)<br>                .get()) {<br>            assertThat(greetingGetResponse.getStatus()).isEqualTo(200);<br>            assertThat(greetingGetResponse.readEntity(GreetingMessage.class).getMessage())<br>                    .startsWith(&quot;Say Hello to JakartaEE&quot;);<br>        }<br>    }<br>}</pre><p>Unlike GreetingServiceTest, to test the functionality of `GreetingResource``, we use Jakarta REST Client API to interact with the HTTP APIs in a client view.</p><p>Adding a testable=false attribute in the @Deployment annotation means all tests will be run in client mode.</p><p>Alternatively, you can also add a single @RunAsClient on the test method to run it locally.</p><p>The @ArquillianResource will inject the base URL of the deployment archive in the container after it is deployed.</p><p>Execute the following command to run GreetingServiceTest.</p><pre>mvn clean verify -Parq-tomcat-embeded -Dit.test=GreetingResourceTest</pre><blockquote><em>If a </em><em>@Deployment(testable=true) is applied on the deployment method, thus all tests run as client mode, we can NOT inject beans in the test class as the previous example.</em></blockquote><p>Similarly, we can create <em>client mode</em> tests to verify the functionalities of simple Jakarta Servlet, Jakarta Faces, Jakarta Pages, etc. The complete codes can be found <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate">here</a>.</p><blockquote><em>To verify the HTML elements and Ajax interactions in the rendered HTML pages, please check </em><a href="https://github.com/arquillian/arquillian-extension-drone"><em>Arquillian Extension Drone</em></a><em> and </em><a href="https://github.com/arquillian/arquillian-graphene"><em>Arquillian Graphene</em></a><em>.</em></blockquote><h3>Configuring Jetty Embedded Adapter</h3><p>Add a new Maven profile for configuring Arquillian Jetty Embedded Adapter.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;arq-jetty-embedded&lt;/id&gt;<br>    &lt;properties&gt;<br>        &lt;skipTests&gt;false&lt;/skipTests&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-jetty-embedded-11&lt;/artifactId&gt;<br>            &lt;version&gt;${arquillian-jetty.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-deploy&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>            &lt;!-- to remove when 11.0.10 released --&gt;<br>            &lt;!-- see <a href="https://github.com/eclipse/jetty.project/pull/7991">https://github.com/eclipse/jetty.project/pull/7991</a> --&gt;<br>            &lt;version&gt;${jetty.version}&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty.websocket&lt;/groupId&gt;<br>            &lt;artifactId&gt;websocket-jakarta-server&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;<br>            &lt;version&gt;1.7.36&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- see: <a href="https://github.com/arquillian/arquillian-container-jetty/pull/108">https://github.com/arquillian/arquillian-container-jetty/pull/108</a> --&gt;<br>        &lt;!--&lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian.testenricher&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-testenricher-cdi-jakarta&lt;/artifactId&gt;<br>        &lt;/dependency&gt;--&gt;<br>    &lt;/dependencies&gt;<br>&lt;/profile&gt;</pre><p>Run the previous tests against the arq-jetty-embedded profile, for example.</p><pre>mvn clean verify -Parq-jetty-embeded -Dit.test=GreetingResourceTest</pre><h3>Configuring Arquillian Weld Embedded</h3><p>Arquillian project provides an official extension to test CDI beans in an embedded Weld container.</p><p>Create a new Maven profile to configure Arquillian Weld Embedded Adapter, and use maven-failsafe-plugin to filter out the tests of Jakarta Servlet, Jakarta Faces, etc.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;arq-weld&lt;/id&gt;<br>    &lt;properties&gt;<br>        &lt;skipTests&gt;false&lt;/skipTests&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;<br>            &lt;artifactId&gt;arquillian-weld-embedded&lt;/artifactId&gt;<br>            &lt;version&gt;${arquillian-weld-embedded.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.jboss.weld&lt;/groupId&gt;<br>            &lt;artifactId&gt;weld-core-impl&lt;/artifactId&gt;<br>            &lt;version&gt;${weld.version}&lt;/version&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;${maven-failsafe-plugin.version}&lt;/version&gt;<br>                &lt;configuration&gt;<br>                    &lt;systemPropertyVariables&gt;<br>                        &lt;arquillian.launch&gt;arq-weld&lt;/arquillian.launch&gt;<br>                    &lt;/systemPropertyVariables&gt;<br>                    &lt;excludes&gt;<br>                        &lt;exclude&gt;**/it/GreetingResourceTest*&lt;/exclude&gt;<br>                        &lt;exclude&gt;**/it/GreetingServletTest*&lt;/exclude&gt;<br>                    &lt;/excludes&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>&lt;/profile&gt;</pre><p>Execute the following command to run the GreetingServiceTest.</p><pre>mvn clean verify -Parq-weld -Dit.test=GreetingServiceTest</pre><blockquote><em>The testing codes of Jakarta Servlet, Jakarta Pages and Jakarta Faces require a Servlet container.</em></blockquote><p>Get the <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate">complete source codes</a> from my Github account.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ec2d42947cd" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/testing-jakarta-ee-9-web-application-in-a-servlet-container-with-arquillian-ec2d42947cd">Testing Jakarta EE 9 Web Application in Servlet Containers with Arquillian</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
