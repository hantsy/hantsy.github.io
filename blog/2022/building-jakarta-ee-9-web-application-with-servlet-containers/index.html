<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>
  Hantsy
  
  Bai
  
  
  | Building Jakarta EE 9 Web application with Servlet Containers
  
</title>
<meta name="description" content="My personal website focusing on Java EE/Jakarta EE and Spring.
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
  rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css"
  integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css"
  integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet"
  href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">

<link rel="canonical" href="/blog/2022/building-jakarta-ee-9-web-application-with-servlet-containers/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-18SZ2W3GXD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-18SZ2W3GXD');
</script>




  
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  <link type="application/atom+xml" rel="alternate" href="/feed.xml" title="blank" />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Building Jakarta EE 9 Web application with Servlet Containers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In Jakarta EE world, a lot of Java developers have built Java Web applications, but instead of using a full-fledged Application Servers, such as Payara, WildFly and WebLogic as production environments, they preferred to deploy into and run on a light-weight Servlet container, such as Apache Tomcat, Eclipse Jetty. In the past years I have prepared jakartaee8-starter-boilerplate and jakartaee9-starter-boilerplate to help develpers to start a new Jakarta EE project and deploy into the popular application servers. The newly created jakartaee9-servlet-starter-boilerplate project provides a template to create Jakarta EE web applications and deploy to the popular Servlet containers, esp. Apache Tomcat 10.x and Eclipse Jetty 11.x. In this project, I have integrated the following popular Jakarta EE compoenents. CDI 3.0 (Weld 4.0)Jakarta REST 3.0(Jersey 3.0)Jakarta Server Faces 3.0(Mojarra 3.0)And transitive dependencies of above features, incuding Jakarta EL, Jarkarta Json Processing, Jakarta Json Binding, Jakarta Validation(Hibernate Validator), etc. Nowadays the most popular Servlet containers, such as Apache Tomcat, Eclipse Jetty, etc. have built-in Jakarta Servlet, Jakarta Server Pages, JSTL, Jakarta EL and Jakarta WebSocket supports. Prerequisites Make sure you have installed the following softwares. JDK 11 or 17Apache Maven 3.8Apache Tomcat 10.x and Eclipse Jetty 11.xIntellij IDEA Communnity Edition or VSCode + Java Pack Let’s explore the integrated features in the jakartaee9-servlet-starter-boilerplate repository. Configuration To prepare a project used in the next stpes, clone the source codes of jakartaee9-servlet-starter-boilerplate repository or create a new Maven webapp through Maven Webapp Archetype. Jakarta Servlet 5.0 Apache Tomcat and Eclipse Jetty has built-in Jakarta Servlet, Jakarta Pages, Jakarta WebSocket implementation in the distribution bundle. But in the development stage, you could use these APIs in your project codes. Delcare jakarta.jakartaee-bom in the the dependencyManagement section. &lt;!-- https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-bom --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-bom&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; And add the following dependencies in the project dependencies section. &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt; &lt;version&gt;${jakarta.el.version}&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Optional, only when &lt;f:websocket&gt; is used. --&gt;&lt;!-- dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt;&lt;/dependency --&gt; &lt;dependency&gt; &lt;!-- Optional, only when &lt;f:validateBean&gt; or &lt;f:validateWholeBean&gt; is used. --&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;&lt;/dependency&gt; The jakarta.json and hibernate-validator are optional, add them when they are required. Create an empty src/main/webapp/WEB-INF/web.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;5.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;&gt;&lt;/web-app&gt; Note the XML namespace are updated to use [https://jakarta.ee/xml/ns/jakartaee](https://jakarta.ee/xml/ns/jakartaee) in Jakarta EE 9. CDI 3.0 Weld 4.0 is compatable with CDI 3.0 specification, and Weld works with Apache Tomcat and Eclipse Jetty. Add the following dependency. &lt;!-- Weld for CDI support --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss.weld.servlet&lt;/groupId&gt; &lt;artifactId&gt;weld-servlet-core&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Create an empty src/main/webapp/WEB-INF/beans.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;/beans&gt; To make BeanManager avaiable via JNDI lookup. For Apache Tomcat, create a Resource in the application context.xml. Create a src/main/webapp/META-INF/context.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context path=&quot;/jakartaee9-servlet-starter-boilerplate&quot;&gt; &lt;Resource name=&quot;BeanManager&quot; auth=&quot;Container&quot; type=&quot;jakarta.enterprise.inject.spi.BeanManager&quot; factory=&quot;org.jboss.weld.resources.ManagerObjectFactory&quot;/&gt;&lt;/Context&gt; The path is the application context path at runtime. Here it creates a Resource BeanManager. For Eclipse Jetty, create a src/main/webapp/WEB-INF/jetty-env.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;https://www.eclipse.org/jetty/configure_10_0.dtd&quot;&gt;&lt;Configure id=&quot;wac&quot; class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt; &lt;New id=&quot;BeanManager&quot; class=&quot;org.eclipse.jetty.plus.jndi.Resource&quot;&gt; &lt;Arg&gt; &lt;Ref refid=&quot;wac&quot;/&gt; &lt;/Arg&gt; &lt;Arg&gt;BeanManager&lt;/Arg&gt; &lt;Arg&gt; &lt;New class=&quot;javax.naming.Reference&quot;&gt; &lt;Arg&gt;jakarta.enterprise.inject.spi.BeanManager&lt;/Arg&gt; &lt;Arg&gt;org.jboss.weld.resources.ManagerObjectFactory&lt;/Arg&gt; &lt;Arg/&gt; &lt;/New&gt; &lt;/Arg&gt; &lt;/New&gt;&lt;/Configure&gt; Add resource reference in the web.xml. &lt;resource-env-ref&gt; &lt;resource-env-ref-name&gt;BeanManager&lt;/resource-env-ref-name&gt; &lt;resource-env-ref-type&gt; jakarta.enterprise.inject.spi.BeanManager &lt;/resource-env-ref-type&gt;&lt;/resource-env-ref&gt; Jakarta Rest(Jaxrs) 3.0 Jersey was the default JAX-RS implementation in Glassfish, now it is a standalone projet under Eclipse EE4J project. Besides, other popular JAX-RS implementations including Apache CXF, JBoss RestEasy, etc. Add jersey-bom in the dependencyManagement section. &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; Add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt; &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- see: https://github.com/eclipse-ee4j/jersey/blob/3.x/examples/cdi-webapp/pom.xml#L142 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x-servlet&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x-ban-custom-hk2-binding&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;&lt;/dependency&gt; Jersey 3.0 is still dependent on HK2 which a small IOC container, and jersey-media-json-binding provides JSON searialzation and desearialization through Jakarta JSON binding. The Jersey support will be initialized when the Servlet container is starting up. Similar to a general Jakarta EE application, add a simple Application class to activate Jakarta REST. @ApplicationPath(&quot;/api&quot;)public class RestActivator extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of(GreetingResource.class); }} Jakarta Server Faces 4.0 Mojarra is the most popular JSF implementation, another popular one is Apache MyFaces. &lt;!-- Jakarta Faces --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.faces&lt;/artifactId&gt; &lt;version&gt;${jakarta.faces.version}&lt;/version&gt;&lt;/dependency&gt; Add an empty /src/main/webapp/WEB-INF/faces-config.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;faces-config xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-facesconfig_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;!-- Put any faces config here. --&gt;&lt;/faces-config&gt; Since JSF 2.3, it add some CDI compatible features, such as the new scopes, etc. To enable the new features, create a simple configuration class to activate it. @FacesConfig(version = Version.JSF_2_3)@ApplicationScopedpublic class FacesCdiActivator {} Examples Next let’s explore some examples of these specifications. Jakarta CDI Example The following example is a simple CDI bean to build a greeting messsage. @ApplicationScopedpublic class GreetingService { private static final Logger LOGGER = Logger.getLogger(GreetingService.class.getName()); public GreetingMessage buildGreetingMessage(String name) { var message = GreetingMessage.of(&quot;Say Hello to &quot; + name + &quot; at &quot; + LocalDateTime.now()); LOGGER.log(Level.INFO, &quot;build message: {0}&quot;, message); return message; }} The GreetingMessage is a POJO class. @SuppressWarnings(&quot;serial&quot;)public class GreetingMessage implements Serializable { private String message; public static GreetingMessage of(String s) { final var message = new GreetingMessage(); message.setMessage(s); return message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } @Override public String toString() { return &quot;GreetingMessage{&quot; + &quot;message=&#39;&quot; + message + &#39;\&#39;&#39; + &#39;}&#39;; }} Jakarta Servlet Example In this Servlet class, we injected the existing GreetingService to handle the message. @WebServlet(urlPatterns = &quot;/GreetingServlet&quot;)public class GreetingServlet extends HttpServlet { private static final String PAGE_HEADER = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Jakarta Servlet Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;; private static final String PAGE_FOOTER = &quot;&lt;/body&gt;&lt;/html&gt;&quot;; @Inject private GreetingService greetingService; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { var name = req.getParameter(&quot;name&quot;); resp.setContentType(&quot;text/html&quot;); var writer = resp.getWriter(); writer.println(PAGE_HEADER); // write message to http response writer.println(&quot;&lt;h1&gt; Hello Servlet &lt;/h1&gt;&quot;); writer.println(&quot;&lt;p&gt;&quot; + greetingService.buildGreetingMessage(name) + &quot;&lt;/p&gt;&quot;); writer.println(PAGE_FOOTER); writer.close(); } } Jakarta Servlet and Pages Example Refactor the above the example, split page view part into a standalone Pages file. @WebServlet(urlPatterns = &quot;/GreetingPagesServlet&quot;)public class GreetingPagesServlet extends HttpServlet { @Inject private GreetingService greetingService; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException { var name = req.getParameter(&quot;name&quot;); var message = greetingService.buildGreetingMessage(name); req.setAttribute(&quot;hello&quot;, message); req.getRequestDispatcher(&quot;/hello-pages.jspx&quot;).forward(req, resp); } } Put the message object into request attribute, in the pages view, it can be read from requestScope directive. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; version=&quot;2.0&quot;&gt; &lt;jsp:directive.page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; session=&quot;false&quot;/&gt; &lt;jsp:output omit-xml-declaration=&quot;true&quot;/&gt; &lt;!-- make it HTML 5 declaration compatiable --&gt; &lt;![CDATA[&lt;!DOCTYPE html&gt;]]&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Jakarta Server Pages Example&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Pages&lt;/h1&gt; &lt;p&gt;${requestScope.hello.message}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;&lt;/jsp:root&gt; Jakarta Faces Example Create a Jakarta Faces backend bean, it is a CDI bean. @Named@RequestScopedpublic class Hello { private String name; private GreetingMessage message; @Inject private GreetingService greetingService; public Hello() { } public Hello(GreetingService greetingService) { this.greetingService = greetingService; } public void createMessage() { message = greetingService.buildGreetingMessage(name); } public String getName() { return name; } public void setName(String name) { this.name = name; } public GreetingMessage getMessage() { return message; } } Let’s have a look at the hello.xhtml. &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot; xmlns:jsf=&quot;http://xmlns.jcp.org/jsf&quot; xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;&gt;&lt;f:view&gt; &lt;h:head&gt; &lt;title&gt;Hello, World!&lt;/title&gt; &lt;/h:head&gt; &lt;h:body&gt; &lt;h:form prependId=&quot;false&quot;&gt; &lt;label jsf:for=&quot;name&quot; jsf:required=&quot;true&quot;&gt;Enter your name:&lt;/label&gt; &lt;input type=&quot;text&quot; jsf:id=&quot;name&quot; jsf:value=&quot;#{hello.name}&quot; jsf:required=&quot;true&quot; jsf:requiredMessage=&quot;Name is required.&quot; placeholder=&quot;Type your name here...&quot; /&gt; &lt;h:message for=&quot;name&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; jsf:id=&quot;submit&quot; value=&quot;Say Hello&quot; jsf:action=&quot;#{hello.createMessage()}&quot;&gt; &lt;f:ajax execute=&quot;@form&quot; render=&quot;@form&quot;/&gt; &lt;/input&gt; &lt;br/&gt; &lt;p id=&quot;message&quot;&gt;#{hello.message}&lt;/p&gt; &lt;/h:form&gt; &lt;/h:body&gt;&lt;/f:view&gt;&lt;/html&gt; Jakarta REST Example In this example, we reuse the GreetingService bean to handle the greeting message. @Path(&quot;greeting&quot;)@RequestScopedpublic class GreetingResource { @Inject private GreetingService greetingService; @GET @Path(&quot;{name}&quot;) @Produces(MediaType.APPLICATION_JSON) public Response greeting(@PathParam(&quot;name&quot;) String name) { return ok(this.greetingService.buildGreetingMessage(name)).build(); }} Deploy and Run the application To deploy an application to the production environment, firstly we can package the built files into a war archive, and put it into a deployable folder under the servlet container. Then start up the servlet container, the war file will be detected and deployed into the servlet container. To simplify the deployment in the development stage, we use maven plugins to complete the work. Deploying to Apache Tomcat To deploy the application into Apache Tomcat, we use cargo-maven3-plugin. &lt;build&gt; &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;tomcat10x&lt;/containerId&gt; &lt;artifactInstaller&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;/artifactInstaller&gt; &lt;/container&gt; &lt;configuration&gt; &lt;properties&gt; &lt;!-- &lt;cargo.servlet.port&gt;8080&lt;/cargo.servlet.port&gt;--&gt; &lt;cargo.logging&gt;low&lt;/cargo.logging&gt; &lt;/properties&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; The cargo-maven3-plugin controls the lifecyle of Tomcat starting and stopping. Run the following command to run application on Tomcat. mvn clean package cargo:run When it is started, open your browser, check the examples we have created above. Go to http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingServlet?name=Hantsy to view the Servlet example. Open http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingPagesServlet?name=Hantsy to see the result of Jakarta Server Pages. Navigate to http://localhost:8080/jakartaee9-servlet-starter-boilerplate/hello.xhtml and input name, and click the Greeting button, you will see the following result. Access http://localhost:8080/jakartaee9-servlet-starter-boilerplate/api/greeting/Hantsy in your browser or using curl command, you will see the following result. Similarly, we can also configure cargo to use Eclipse Jetty as servlet container. But Eclipse Jetty provides an official maven plugin for deploying applications into Jetty servers. Deploying to Eclipse Jetty In Jetty 11.x, Jetty maven plugin was refactored, and provides 3 deploy modes in the new pluign. EMBEDFORKEDEXTERNAL The default mode is EMBED which is similar to running the simplest jetty:run goal in the previous version. The FORKED mode uses a forked thread to run the application. The EXTERNAL mode runs the application on an external standalone Jetty server. Deploying to an Embedded Jetty Server Configure jetty maven plugin and use EMBED mode. &lt;profile&gt; &lt;id&gt;jetty-embed&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;deployMode&gt;EMBED&lt;/deployMode&gt; &lt;useProvidedScope&gt;true&lt;/useProvidedScope&gt; &lt;httpConnector&gt; &lt;port&gt;9090&lt;/port&gt; &lt;/httpConnector&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; There is useProvidedScope option. When it is true, it will add Maven provided scoped dependencies to the container classpath and run the application, else it will use a isolated application classpath to run the application. Here we have to set it to true, if it is false, it will fail to run our application. Run the following command to deploy the application into an embedded Jetty. mvn clean jetty:run -Pjetty-embed You will see a lot of warning of duplicated classes, due to some duplicated artifacts in the containter classpath. Deploying to an External Jetty Server Create a new Maven profile for this purpose. &lt;profile&gt; &lt;id&gt;jetty-external&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;deployMode&gt;EXTERNAL&lt;/deployMode&gt; &lt;webApp&gt; &lt;contextPath&gt;/${project.artifactId}&lt;/contextPath&gt; &lt;/webApp&gt; &lt;jettyHome&gt;${env.JETTY_HOME}&lt;/jettyHome&gt; &lt;modules&gt;jdni,jsp,servlet,glassfish-jstl,websocket-jakarta,cdi-decorate&lt;/modules&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; Make sure you have downloaded a copy of Eclipse Jetty, and create an system environment variable JETTY_HOME and set it to the location of Eclipse Jetty root folder. Run the following command to deploy the application into the standalone Jetty server. mvn clean jetty:run -Pjetty-external Check the complete example codes from My Github. &lt;hr&gt;&lt;p&gt;Building Jakarta EE 9 Web application with Servlet Containers was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:description" content="In Jakarta EE world, a lot of Java developers have built Java Web applications, but instead of using a full-fledged Application Servers, such as Payara, WildFly and WebLogic as production environments, they preferred to deploy into and run on a light-weight Servlet container, such as Apache Tomcat, Eclipse Jetty. In the past years I have prepared jakartaee8-starter-boilerplate and jakartaee9-starter-boilerplate to help develpers to start a new Jakarta EE project and deploy into the popular application servers. The newly created jakartaee9-servlet-starter-boilerplate project provides a template to create Jakarta EE web applications and deploy to the popular Servlet containers, esp. Apache Tomcat 10.x and Eclipse Jetty 11.x. In this project, I have integrated the following popular Jakarta EE compoenents. CDI 3.0 (Weld 4.0)Jakarta REST 3.0(Jersey 3.0)Jakarta Server Faces 3.0(Mojarra 3.0)And transitive dependencies of above features, incuding Jakarta EL, Jarkarta Json Processing, Jakarta Json Binding, Jakarta Validation(Hibernate Validator), etc. Nowadays the most popular Servlet containers, such as Apache Tomcat, Eclipse Jetty, etc. have built-in Jakarta Servlet, Jakarta Server Pages, JSTL, Jakarta EL and Jakarta WebSocket supports. Prerequisites Make sure you have installed the following softwares. JDK 11 or 17Apache Maven 3.8Apache Tomcat 10.x and Eclipse Jetty 11.xIntellij IDEA Communnity Edition or VSCode + Java Pack Let’s explore the integrated features in the jakartaee9-servlet-starter-boilerplate repository. Configuration To prepare a project used in the next stpes, clone the source codes of jakartaee9-servlet-starter-boilerplate repository or create a new Maven webapp through Maven Webapp Archetype. Jakarta Servlet 5.0 Apache Tomcat and Eclipse Jetty has built-in Jakarta Servlet, Jakarta Pages, Jakarta WebSocket implementation in the distribution bundle. But in the development stage, you could use these APIs in your project codes. Delcare jakarta.jakartaee-bom in the the dependencyManagement section. &lt;!-- https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-bom --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-bom&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; And add the following dependencies in the project dependencies section. &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt; &lt;version&gt;${jakarta.el.version}&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Optional, only when &lt;f:websocket&gt; is used. --&gt;&lt;!-- dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt;&lt;/dependency --&gt; &lt;dependency&gt; &lt;!-- Optional, only when &lt;f:validateBean&gt; or &lt;f:validateWholeBean&gt; is used. --&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;&lt;/dependency&gt; The jakarta.json and hibernate-validator are optional, add them when they are required. Create an empty src/main/webapp/WEB-INF/web.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;5.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;&gt;&lt;/web-app&gt; Note the XML namespace are updated to use [https://jakarta.ee/xml/ns/jakartaee](https://jakarta.ee/xml/ns/jakartaee) in Jakarta EE 9. CDI 3.0 Weld 4.0 is compatable with CDI 3.0 specification, and Weld works with Apache Tomcat and Eclipse Jetty. Add the following dependency. &lt;!-- Weld for CDI support --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss.weld.servlet&lt;/groupId&gt; &lt;artifactId&gt;weld-servlet-core&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Create an empty src/main/webapp/WEB-INF/beans.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;/beans&gt; To make BeanManager avaiable via JNDI lookup. For Apache Tomcat, create a Resource in the application context.xml. Create a src/main/webapp/META-INF/context.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context path=&quot;/jakartaee9-servlet-starter-boilerplate&quot;&gt; &lt;Resource name=&quot;BeanManager&quot; auth=&quot;Container&quot; type=&quot;jakarta.enterprise.inject.spi.BeanManager&quot; factory=&quot;org.jboss.weld.resources.ManagerObjectFactory&quot;/&gt;&lt;/Context&gt; The path is the application context path at runtime. Here it creates a Resource BeanManager. For Eclipse Jetty, create a src/main/webapp/WEB-INF/jetty-env.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;https://www.eclipse.org/jetty/configure_10_0.dtd&quot;&gt;&lt;Configure id=&quot;wac&quot; class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt; &lt;New id=&quot;BeanManager&quot; class=&quot;org.eclipse.jetty.plus.jndi.Resource&quot;&gt; &lt;Arg&gt; &lt;Ref refid=&quot;wac&quot;/&gt; &lt;/Arg&gt; &lt;Arg&gt;BeanManager&lt;/Arg&gt; &lt;Arg&gt; &lt;New class=&quot;javax.naming.Reference&quot;&gt; &lt;Arg&gt;jakarta.enterprise.inject.spi.BeanManager&lt;/Arg&gt; &lt;Arg&gt;org.jboss.weld.resources.ManagerObjectFactory&lt;/Arg&gt; &lt;Arg/&gt; &lt;/New&gt; &lt;/Arg&gt; &lt;/New&gt;&lt;/Configure&gt; Add resource reference in the web.xml. &lt;resource-env-ref&gt; &lt;resource-env-ref-name&gt;BeanManager&lt;/resource-env-ref-name&gt; &lt;resource-env-ref-type&gt; jakarta.enterprise.inject.spi.BeanManager &lt;/resource-env-ref-type&gt;&lt;/resource-env-ref&gt; Jakarta Rest(Jaxrs) 3.0 Jersey was the default JAX-RS implementation in Glassfish, now it is a standalone projet under Eclipse EE4J project. Besides, other popular JAX-RS implementations including Apache CXF, JBoss RestEasy, etc. Add jersey-bom in the dependencyManagement section. &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; Add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt; &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- see: https://github.com/eclipse-ee4j/jersey/blob/3.x/examples/cdi-webapp/pom.xml#L142 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x-servlet&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x-ban-custom-hk2-binding&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;&lt;/dependency&gt; Jersey 3.0 is still dependent on HK2 which a small IOC container, and jersey-media-json-binding provides JSON searialzation and desearialization through Jakarta JSON binding. The Jersey support will be initialized when the Servlet container is starting up. Similar to a general Jakarta EE application, add a simple Application class to activate Jakarta REST. @ApplicationPath(&quot;/api&quot;)public class RestActivator extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of(GreetingResource.class); }} Jakarta Server Faces 4.0 Mojarra is the most popular JSF implementation, another popular one is Apache MyFaces. &lt;!-- Jakarta Faces --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.faces&lt;/artifactId&gt; &lt;version&gt;${jakarta.faces.version}&lt;/version&gt;&lt;/dependency&gt; Add an empty /src/main/webapp/WEB-INF/faces-config.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;faces-config xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-facesconfig_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;!-- Put any faces config here. --&gt;&lt;/faces-config&gt; Since JSF 2.3, it add some CDI compatible features, such as the new scopes, etc. To enable the new features, create a simple configuration class to activate it. @FacesConfig(version = Version.JSF_2_3)@ApplicationScopedpublic class FacesCdiActivator {} Examples Next let’s explore some examples of these specifications. Jakarta CDI Example The following example is a simple CDI bean to build a greeting messsage. @ApplicationScopedpublic class GreetingService { private static final Logger LOGGER = Logger.getLogger(GreetingService.class.getName()); public GreetingMessage buildGreetingMessage(String name) { var message = GreetingMessage.of(&quot;Say Hello to &quot; + name + &quot; at &quot; + LocalDateTime.now()); LOGGER.log(Level.INFO, &quot;build message: {0}&quot;, message); return message; }} The GreetingMessage is a POJO class. @SuppressWarnings(&quot;serial&quot;)public class GreetingMessage implements Serializable { private String message; public static GreetingMessage of(String s) { final var message = new GreetingMessage(); message.setMessage(s); return message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } @Override public String toString() { return &quot;GreetingMessage{&quot; + &quot;message=&#39;&quot; + message + &#39;\&#39;&#39; + &#39;}&#39;; }} Jakarta Servlet Example In this Servlet class, we injected the existing GreetingService to handle the message. @WebServlet(urlPatterns = &quot;/GreetingServlet&quot;)public class GreetingServlet extends HttpServlet { private static final String PAGE_HEADER = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Jakarta Servlet Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;; private static final String PAGE_FOOTER = &quot;&lt;/body&gt;&lt;/html&gt;&quot;; @Inject private GreetingService greetingService; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { var name = req.getParameter(&quot;name&quot;); resp.setContentType(&quot;text/html&quot;); var writer = resp.getWriter(); writer.println(PAGE_HEADER); // write message to http response writer.println(&quot;&lt;h1&gt; Hello Servlet &lt;/h1&gt;&quot;); writer.println(&quot;&lt;p&gt;&quot; + greetingService.buildGreetingMessage(name) + &quot;&lt;/p&gt;&quot;); writer.println(PAGE_FOOTER); writer.close(); } } Jakarta Servlet and Pages Example Refactor the above the example, split page view part into a standalone Pages file. @WebServlet(urlPatterns = &quot;/GreetingPagesServlet&quot;)public class GreetingPagesServlet extends HttpServlet { @Inject private GreetingService greetingService; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException { var name = req.getParameter(&quot;name&quot;); var message = greetingService.buildGreetingMessage(name); req.setAttribute(&quot;hello&quot;, message); req.getRequestDispatcher(&quot;/hello-pages.jspx&quot;).forward(req, resp); } } Put the message object into request attribute, in the pages view, it can be read from requestScope directive. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; version=&quot;2.0&quot;&gt; &lt;jsp:directive.page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; session=&quot;false&quot;/&gt; &lt;jsp:output omit-xml-declaration=&quot;true&quot;/&gt; &lt;!-- make it HTML 5 declaration compatiable --&gt; &lt;![CDATA[&lt;!DOCTYPE html&gt;]]&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Jakarta Server Pages Example&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Pages&lt;/h1&gt; &lt;p&gt;${requestScope.hello.message}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;&lt;/jsp:root&gt; Jakarta Faces Example Create a Jakarta Faces backend bean, it is a CDI bean. @Named@RequestScopedpublic class Hello { private String name; private GreetingMessage message; @Inject private GreetingService greetingService; public Hello() { } public Hello(GreetingService greetingService) { this.greetingService = greetingService; } public void createMessage() { message = greetingService.buildGreetingMessage(name); } public String getName() { return name; } public void setName(String name) { this.name = name; } public GreetingMessage getMessage() { return message; } } Let’s have a look at the hello.xhtml. &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot; xmlns:jsf=&quot;http://xmlns.jcp.org/jsf&quot; xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;&gt;&lt;f:view&gt; &lt;h:head&gt; &lt;title&gt;Hello, World!&lt;/title&gt; &lt;/h:head&gt; &lt;h:body&gt; &lt;h:form prependId=&quot;false&quot;&gt; &lt;label jsf:for=&quot;name&quot; jsf:required=&quot;true&quot;&gt;Enter your name:&lt;/label&gt; &lt;input type=&quot;text&quot; jsf:id=&quot;name&quot; jsf:value=&quot;#{hello.name}&quot; jsf:required=&quot;true&quot; jsf:requiredMessage=&quot;Name is required.&quot; placeholder=&quot;Type your name here...&quot; /&gt; &lt;h:message for=&quot;name&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; jsf:id=&quot;submit&quot; value=&quot;Say Hello&quot; jsf:action=&quot;#{hello.createMessage()}&quot;&gt; &lt;f:ajax execute=&quot;@form&quot; render=&quot;@form&quot;/&gt; &lt;/input&gt; &lt;br/&gt; &lt;p id=&quot;message&quot;&gt;#{hello.message}&lt;/p&gt; &lt;/h:form&gt; &lt;/h:body&gt;&lt;/f:view&gt;&lt;/html&gt; Jakarta REST Example In this example, we reuse the GreetingService bean to handle the greeting message. @Path(&quot;greeting&quot;)@RequestScopedpublic class GreetingResource { @Inject private GreetingService greetingService; @GET @Path(&quot;{name}&quot;) @Produces(MediaType.APPLICATION_JSON) public Response greeting(@PathParam(&quot;name&quot;) String name) { return ok(this.greetingService.buildGreetingMessage(name)).build(); }} Deploy and Run the application To deploy an application to the production environment, firstly we can package the built files into a war archive, and put it into a deployable folder under the servlet container. Then start up the servlet container, the war file will be detected and deployed into the servlet container. To simplify the deployment in the development stage, we use maven plugins to complete the work. Deploying to Apache Tomcat To deploy the application into Apache Tomcat, we use cargo-maven3-plugin. &lt;build&gt; &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;tomcat10x&lt;/containerId&gt; &lt;artifactInstaller&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;/artifactInstaller&gt; &lt;/container&gt; &lt;configuration&gt; &lt;properties&gt; &lt;!-- &lt;cargo.servlet.port&gt;8080&lt;/cargo.servlet.port&gt;--&gt; &lt;cargo.logging&gt;low&lt;/cargo.logging&gt; &lt;/properties&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; The cargo-maven3-plugin controls the lifecyle of Tomcat starting and stopping. Run the following command to run application on Tomcat. mvn clean package cargo:run When it is started, open your browser, check the examples we have created above. Go to http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingServlet?name=Hantsy to view the Servlet example. Open http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingPagesServlet?name=Hantsy to see the result of Jakarta Server Pages. Navigate to http://localhost:8080/jakartaee9-servlet-starter-boilerplate/hello.xhtml and input name, and click the Greeting button, you will see the following result. Access http://localhost:8080/jakartaee9-servlet-starter-boilerplate/api/greeting/Hantsy in your browser or using curl command, you will see the following result. Similarly, we can also configure cargo to use Eclipse Jetty as servlet container. But Eclipse Jetty provides an official maven plugin for deploying applications into Jetty servers. Deploying to Eclipse Jetty In Jetty 11.x, Jetty maven plugin was refactored, and provides 3 deploy modes in the new pluign. EMBEDFORKEDEXTERNAL The default mode is EMBED which is similar to running the simplest jetty:run goal in the previous version. The FORKED mode uses a forked thread to run the application. The EXTERNAL mode runs the application on an external standalone Jetty server. Deploying to an Embedded Jetty Server Configure jetty maven plugin and use EMBED mode. &lt;profile&gt; &lt;id&gt;jetty-embed&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;deployMode&gt;EMBED&lt;/deployMode&gt; &lt;useProvidedScope&gt;true&lt;/useProvidedScope&gt; &lt;httpConnector&gt; &lt;port&gt;9090&lt;/port&gt; &lt;/httpConnector&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; There is useProvidedScope option. When it is true, it will add Maven provided scoped dependencies to the container classpath and run the application, else it will use a isolated application classpath to run the application. Here we have to set it to true, if it is false, it will fail to run our application. Run the following command to deploy the application into an embedded Jetty. mvn clean jetty:run -Pjetty-embed You will see a lot of warning of duplicated classes, due to some duplicated artifacts in the containter classpath. Deploying to an External Jetty Server Create a new Maven profile for this purpose. &lt;profile&gt; &lt;id&gt;jetty-external&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;deployMode&gt;EXTERNAL&lt;/deployMode&gt; &lt;webApp&gt; &lt;contextPath&gt;/${project.artifactId}&lt;/contextPath&gt; &lt;/webApp&gt; &lt;jettyHome&gt;${env.JETTY_HOME}&lt;/jettyHome&gt; &lt;modules&gt;jdni,jsp,servlet,glassfish-jstl,websocket-jakarta,cdi-decorate&lt;/modules&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; Make sure you have downloaded a copy of Eclipse Jetty, and create an system environment variable JETTY_HOME and set it to the location of Eclipse Jetty root folder. Run the following command to deploy the application into the standalone Jetty server. mvn clean jetty:run -Pjetty-external Check the complete example codes from My Github. &lt;hr&gt;&lt;p&gt;Building Jakarta EE 9 Web application with Servlet Containers was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;" />
<meta property="og:site_name" content="blank" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-06-12T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building Jakarta EE 9 Web application with Servlet Containers" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-12T00:00:00+00:00","datePublished":"2022-06-12T00:00:00+00:00","description":"In Jakarta EE world, a lot of Java developers have built Java Web applications, but instead of using a full-fledged Application Servers, such as Payara, WildFly and WebLogic as production environments, they preferred to deploy into and run on a light-weight Servlet container, such as Apache Tomcat, Eclipse Jetty. In the past years I have prepared jakartaee8-starter-boilerplate and jakartaee9-starter-boilerplate to help develpers to start a new Jakarta EE project and deploy into the popular application servers. The newly created jakartaee9-servlet-starter-boilerplate project provides a template to create Jakarta EE web applications and deploy to the popular Servlet containers, esp. Apache Tomcat 10.x and Eclipse Jetty 11.x. In this project, I have integrated the following popular Jakarta EE compoenents. CDI 3.0 (Weld 4.0)Jakarta REST 3.0(Jersey 3.0)Jakarta Server Faces 3.0(Mojarra 3.0)And transitive dependencies of above features, incuding Jakarta EL, Jarkarta Json Processing, Jakarta Json Binding, Jakarta Validation(Hibernate Validator), etc. Nowadays the most popular Servlet containers, such as Apache Tomcat, Eclipse Jetty, etc. have built-in Jakarta Servlet, Jakarta Server Pages, JSTL, Jakarta EL and Jakarta WebSocket supports. Prerequisites Make sure you have installed the following softwares. JDK 11 or 17Apache Maven 3.8Apache Tomcat 10.x and Eclipse Jetty 11.xIntellij IDEA Communnity Edition or VSCode + Java Pack Let’s explore the integrated features in the jakartaee9-servlet-starter-boilerplate repository. Configuration To prepare a project used in the next stpes, clone the source codes of jakartaee9-servlet-starter-boilerplate repository or create a new Maven webapp through Maven Webapp Archetype. Jakarta Servlet 5.0 Apache Tomcat and Eclipse Jetty has built-in Jakarta Servlet, Jakarta Pages, Jakarta WebSocket implementation in the distribution bundle. But in the development stage, you could use these APIs in your project codes. Delcare jakarta.jakartaee-bom in the the dependencyManagement section. &lt;!-- https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-bom --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-bom&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; And add the following dependencies in the project dependencies section. &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt; &lt;version&gt;${jakarta.el.version}&lt;/version&gt;&lt;/dependency&gt; &lt;!-- Optional, only when &lt;f:websocket&gt; is used. --&gt;&lt;!-- dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt;&lt;/dependency --&gt; &lt;dependency&gt; &lt;!-- Optional, only when &lt;f:validateBean&gt; or &lt;f:validateWholeBean&gt; is used. --&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;&lt;/dependency&gt; The jakarta.json and hibernate-validator are optional, add them when they are required. Create an empty src/main/webapp/WEB-INF/web.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;5.0&quot; xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;&gt;&lt;/web-app&gt; Note the XML namespace are updated to use [https://jakarta.ee/xml/ns/jakartaee](https://jakarta.ee/xml/ns/jakartaee) in Jakarta EE 9. CDI 3.0 Weld 4.0 is compatable with CDI 3.0 specification, and Weld works with Apache Tomcat and Eclipse Jetty. Add the following dependency. &lt;!-- Weld for CDI support --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jboss.weld.servlet&lt;/groupId&gt; &lt;artifactId&gt;weld-servlet-core&lt;/artifactId&gt; &lt;version&gt;${weld.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; Create an empty src/main/webapp/WEB-INF/beans.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;/beans&gt; To make BeanManager avaiable via JNDI lookup. For Apache Tomcat, create a Resource in the application context.xml. Create a src/main/webapp/META-INF/context.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context path=&quot;/jakartaee9-servlet-starter-boilerplate&quot;&gt; &lt;Resource name=&quot;BeanManager&quot; auth=&quot;Container&quot; type=&quot;jakarta.enterprise.inject.spi.BeanManager&quot; factory=&quot;org.jboss.weld.resources.ManagerObjectFactory&quot;/&gt;&lt;/Context&gt; The path is the application context path at runtime. Here it creates a Resource BeanManager. For Eclipse Jetty, create a src/main/webapp/WEB-INF/jetty-env.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;https://www.eclipse.org/jetty/configure_10_0.dtd&quot;&gt;&lt;Configure id=&quot;wac&quot; class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt; &lt;New id=&quot;BeanManager&quot; class=&quot;org.eclipse.jetty.plus.jndi.Resource&quot;&gt; &lt;Arg&gt; &lt;Ref refid=&quot;wac&quot;/&gt; &lt;/Arg&gt; &lt;Arg&gt;BeanManager&lt;/Arg&gt; &lt;Arg&gt; &lt;New class=&quot;javax.naming.Reference&quot;&gt; &lt;Arg&gt;jakarta.enterprise.inject.spi.BeanManager&lt;/Arg&gt; &lt;Arg&gt;org.jboss.weld.resources.ManagerObjectFactory&lt;/Arg&gt; &lt;Arg/&gt; &lt;/New&gt; &lt;/Arg&gt; &lt;/New&gt;&lt;/Configure&gt; Add resource reference in the web.xml. &lt;resource-env-ref&gt; &lt;resource-env-ref-name&gt;BeanManager&lt;/resource-env-ref-name&gt; &lt;resource-env-ref-type&gt; jakarta.enterprise.inject.spi.BeanManager &lt;/resource-env-ref-type&gt;&lt;/resource-env-ref&gt; Jakarta Rest(Jaxrs) 3.0 Jersey was the default JAX-RS implementation in Glassfish, now it is a standalone projet under Eclipse EE4J project. Besides, other popular JAX-RS implementations including Apache CXF, JBoss RestEasy, etc. Add jersey-bom in the dependencyManagement section. &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt; &lt;version&gt;${jersey.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; Add the following dependencies. &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt; &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt; &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- see: https://github.com/eclipse-ee4j/jersey/blob/3.x/examples/cdi-webapp/pom.xml#L142 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x-servlet&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt; &lt;artifactId&gt;jersey-cdi1x-ban-custom-hk2-binding&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt; &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;&lt;/dependency&gt; Jersey 3.0 is still dependent on HK2 which a small IOC container, and jersey-media-json-binding provides JSON searialzation and desearialization through Jakarta JSON binding. The Jersey support will be initialized when the Servlet container is starting up. Similar to a general Jakarta EE application, add a simple Application class to activate Jakarta REST. @ApplicationPath(&quot;/api&quot;)public class RestActivator extends Application { @Override public Set&lt;Class&lt;?&gt;&gt; getClasses() { return Set.of(GreetingResource.class); }} Jakarta Server Faces 4.0 Mojarra is the most popular JSF implementation, another popular one is Apache MyFaces. &lt;!-- Jakarta Faces --&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.faces&lt;/artifactId&gt; &lt;version&gt;${jakarta.faces.version}&lt;/version&gt;&lt;/dependency&gt; Add an empty /src/main/webapp/WEB-INF/faces-config.xml. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;faces-config xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-facesconfig_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;!-- Put any faces config here. --&gt;&lt;/faces-config&gt; Since JSF 2.3, it add some CDI compatible features, such as the new scopes, etc. To enable the new features, create a simple configuration class to activate it. @FacesConfig(version = Version.JSF_2_3)@ApplicationScopedpublic class FacesCdiActivator {} Examples Next let’s explore some examples of these specifications. Jakarta CDI Example The following example is a simple CDI bean to build a greeting messsage. @ApplicationScopedpublic class GreetingService { private static final Logger LOGGER = Logger.getLogger(GreetingService.class.getName()); public GreetingMessage buildGreetingMessage(String name) { var message = GreetingMessage.of(&quot;Say Hello to &quot; + name + &quot; at &quot; + LocalDateTime.now()); LOGGER.log(Level.INFO, &quot;build message: {0}&quot;, message); return message; }} The GreetingMessage is a POJO class. @SuppressWarnings(&quot;serial&quot;)public class GreetingMessage implements Serializable { private String message; public static GreetingMessage of(String s) { final var message = new GreetingMessage(); message.setMessage(s); return message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } @Override public String toString() { return &quot;GreetingMessage{&quot; + &quot;message=&#39;&quot; + message + &#39;\\&#39;&#39; + &#39;}&#39;; }} Jakarta Servlet Example In this Servlet class, we injected the existing GreetingService to handle the message. @WebServlet(urlPatterns = &quot;/GreetingServlet&quot;)public class GreetingServlet extends HttpServlet { private static final String PAGE_HEADER = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Jakarta Servlet Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;; private static final String PAGE_FOOTER = &quot;&lt;/body&gt;&lt;/html&gt;&quot;; @Inject private GreetingService greetingService; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { var name = req.getParameter(&quot;name&quot;); resp.setContentType(&quot;text/html&quot;); var writer = resp.getWriter(); writer.println(PAGE_HEADER); // write message to http response writer.println(&quot;&lt;h1&gt; Hello Servlet &lt;/h1&gt;&quot;); writer.println(&quot;&lt;p&gt;&quot; + greetingService.buildGreetingMessage(name) + &quot;&lt;/p&gt;&quot;); writer.println(PAGE_FOOTER); writer.close(); } } Jakarta Servlet and Pages Example Refactor the above the example, split page view part into a standalone Pages file. @WebServlet(urlPatterns = &quot;/GreetingPagesServlet&quot;)public class GreetingPagesServlet extends HttpServlet { @Inject private GreetingService greetingService; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException { var name = req.getParameter(&quot;name&quot;); var message = greetingService.buildGreetingMessage(name); req.setAttribute(&quot;hello&quot;, message); req.getRequestDispatcher(&quot;/hello-pages.jspx&quot;).forward(req, resp); } } Put the message object into request attribute, in the pages view, it can be read from requestScope directive. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; version=&quot;2.0&quot;&gt; &lt;jsp:directive.page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; session=&quot;false&quot;/&gt; &lt;jsp:output omit-xml-declaration=&quot;true&quot;/&gt; &lt;!-- make it HTML 5 declaration compatiable --&gt; &lt;![CDATA[&lt;!DOCTYPE html&gt;]]&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Jakarta Server Pages Example&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Pages&lt;/h1&gt; &lt;p&gt;${requestScope.hello.message}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;&lt;/jsp:root&gt; Jakarta Faces Example Create a Jakarta Faces backend bean, it is a CDI bean. @Named@RequestScopedpublic class Hello { private String name; private GreetingMessage message; @Inject private GreetingService greetingService; public Hello() { } public Hello(GreetingService greetingService) { this.greetingService = greetingService; } public void createMessage() { message = greetingService.buildGreetingMessage(name); } public String getName() { return name; } public void setName(String name) { this.name = name; } public GreetingMessage getMessage() { return message; } } Let’s have a look at the hello.xhtml. &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot; xmlns:jsf=&quot;http://xmlns.jcp.org/jsf&quot; xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;&gt;&lt;f:view&gt; &lt;h:head&gt; &lt;title&gt;Hello, World!&lt;/title&gt; &lt;/h:head&gt; &lt;h:body&gt; &lt;h:form prependId=&quot;false&quot;&gt; &lt;label jsf:for=&quot;name&quot; jsf:required=&quot;true&quot;&gt;Enter your name:&lt;/label&gt; &lt;input type=&quot;text&quot; jsf:id=&quot;name&quot; jsf:value=&quot;#{hello.name}&quot; jsf:required=&quot;true&quot; jsf:requiredMessage=&quot;Name is required.&quot; placeholder=&quot;Type your name here...&quot; /&gt; &lt;h:message for=&quot;name&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; jsf:id=&quot;submit&quot; value=&quot;Say Hello&quot; jsf:action=&quot;#{hello.createMessage()}&quot;&gt; &lt;f:ajax execute=&quot;@form&quot; render=&quot;@form&quot;/&gt; &lt;/input&gt; &lt;br/&gt; &lt;p id=&quot;message&quot;&gt;#{hello.message}&lt;/p&gt; &lt;/h:form&gt; &lt;/h:body&gt;&lt;/f:view&gt;&lt;/html&gt; Jakarta REST Example In this example, we reuse the GreetingService bean to handle the greeting message. @Path(&quot;greeting&quot;)@RequestScopedpublic class GreetingResource { @Inject private GreetingService greetingService; @GET @Path(&quot;{name}&quot;) @Produces(MediaType.APPLICATION_JSON) public Response greeting(@PathParam(&quot;name&quot;) String name) { return ok(this.greetingService.buildGreetingMessage(name)).build(); }} Deploy and Run the application To deploy an application to the production environment, firstly we can package the built files into a war archive, and put it into a deployable folder under the servlet container. Then start up the servlet container, the war file will be detected and deployed into the servlet container. To simplify the deployment in the development stage, we use maven plugins to complete the work. Deploying to Apache Tomcat To deploy the application into Apache Tomcat, we use cargo-maven3-plugin. &lt;build&gt; &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt; &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;container&gt; &lt;containerId&gt;tomcat10x&lt;/containerId&gt; &lt;artifactInstaller&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat&lt;/artifactId&gt; &lt;version&gt;${tomcat.version}&lt;/version&gt; &lt;/artifactInstaller&gt; &lt;/container&gt; &lt;configuration&gt; &lt;properties&gt; &lt;!-- &lt;cargo.servlet.port&gt;8080&lt;/cargo.servlet.port&gt;--&gt; &lt;cargo.logging&gt;low&lt;/cargo.logging&gt; &lt;/properties&gt; &lt;/configuration&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; The cargo-maven3-plugin controls the lifecyle of Tomcat starting and stopping. Run the following command to run application on Tomcat. mvn clean package cargo:run When it is started, open your browser, check the examples we have created above. Go to http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingServlet?name=Hantsy to view the Servlet example. Open http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingPagesServlet?name=Hantsy to see the result of Jakarta Server Pages. Navigate to http://localhost:8080/jakartaee9-servlet-starter-boilerplate/hello.xhtml and input name, and click the Greeting button, you will see the following result. Access http://localhost:8080/jakartaee9-servlet-starter-boilerplate/api/greeting/Hantsy in your browser or using curl command, you will see the following result. Similarly, we can also configure cargo to use Eclipse Jetty as servlet container. But Eclipse Jetty provides an official maven plugin for deploying applications into Jetty servers. Deploying to Eclipse Jetty In Jetty 11.x, Jetty maven plugin was refactored, and provides 3 deploy modes in the new pluign. EMBEDFORKEDEXTERNAL The default mode is EMBED which is similar to running the simplest jetty:run goal in the previous version. The FORKED mode uses a forked thread to run the application. The EXTERNAL mode runs the application on an external standalone Jetty server. Deploying to an Embedded Jetty Server Configure jetty maven plugin and use EMBED mode. &lt;profile&gt; &lt;id&gt;jetty-embed&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;deployMode&gt;EMBED&lt;/deployMode&gt; &lt;useProvidedScope&gt;true&lt;/useProvidedScope&gt; &lt;httpConnector&gt; &lt;port&gt;9090&lt;/port&gt; &lt;/httpConnector&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.36&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; There is useProvidedScope option. When it is true, it will add Maven provided scoped dependencies to the container classpath and run the application, else it will use a isolated application classpath to run the application. Here we have to set it to true, if it is false, it will fail to run our application. Run the following command to deploy the application into an embedded Jetty. mvn clean jetty:run -Pjetty-embed You will see a lot of warning of duplicated classes, due to some duplicated artifacts in the containter classpath. Deploying to an External Jetty Server Create a new Maven profile for this purpose. &lt;profile&gt; &lt;id&gt;jetty-external&lt;/id&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;deployMode&gt;EXTERNAL&lt;/deployMode&gt; &lt;webApp&gt; &lt;contextPath&gt;/${project.artifactId}&lt;/contextPath&gt; &lt;/webApp&gt; &lt;jettyHome&gt;${env.JETTY_HOME}&lt;/jettyHome&gt; &lt;modules&gt;jdni,jsp,servlet,glassfish-jstl,websocket-jakarta,cdi-decorate&lt;/modules&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt; &lt;version&gt;${jakarta.json.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.el&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/profile&gt; Make sure you have downloaded a copy of Eclipse Jetty, and create an system environment variable JETTY_HOME and set it to the location of Eclipse Jetty root folder. Run the following command to deploy the application into the standalone Jetty server. mvn clean jetty:run -Pjetty-external Check the complete example codes from My Github. &lt;hr&gt;&lt;p&gt;Building Jakarta EE 9 Web application with Servlet Containers was originally published in ITNEXT on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;","headline":"Building Jakarta EE 9 Web application with Servlet Containers","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/2022/building-jakarta-ee-9-web-application-with-servlet-containers/"},"url":"/blog/2022/building-jakarta-ee-9-web-application-with-servlet-containers/"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body
  class="fixed-top-nav ">

  <!-- Header -->

  <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Hantsy</span>   Bai
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/service/">
                service
                
              </a>
          </li>
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


  <!-- Content -->

  <div class="container mt-5">
    

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Building Jakarta EE 9 Web application with Servlet Containers</h1>
    <p class="post-meta">June 12, 2022</p>
  </header>

  <article class="post-content">
    <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HVdOerzrVL2J9vXxELre0w.jpeg" /></figure><p>In Jakarta EE world, a lot of Java developers have built Java Web applications, but instead of using a full-fledged Application Servers, such as Payara, WildFly and WebLogic as production environments, they preferred to deploy into and run on a light-weight Servlet container, such as Apache Tomcat, Eclipse Jetty.</p><p>In the past years I have prepared <a href="https://github.com/hantsy/jakartaee8-starter-boilerplate">jakartaee8-starter-boilerplate</a> and <a href="https://github.com/hantsy/jakartaee9-starter-boilerplate">jakartaee9-starter-boilerplate</a> to help develpers to start a new Jakarta EE project and deploy into the popular application servers. The newly created <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate">jakartaee9-servlet-starter-boilerplate</a> project provides a template to create Jakarta EE web applications and deploy to the popular Servlet containers, esp. Apache Tomcat 10.x and Eclipse Jetty 11.x. In this project, I have integrated the following popular Jakarta EE compoenents.</p><ul><li>CDI 3.0 (Weld 4.0)</li><li>Jakarta REST 3.0(Jersey 3.0)</li><li>Jakarta Server Faces 3.0(Mojarra 3.0)</li><li>And transitive dependencies of above features, incuding Jakarta EL, Jarkarta Json Processing, Jakarta Json Binding, Jakarta Validation(Hibernate Validator), etc.</li></ul><p>Nowadays the most popular Servlet containers, such as Apache Tomcat, Eclipse Jetty, etc. have built-in Jakarta Servlet, Jakarta Server Pages, JSTL, Jakarta EL and Jakarta WebSocket supports.</p><h3>Prerequisites</h3><p>Make sure you have installed the following softwares.</p><ul><li>JDK 11 or 17</li><li>Apache Maven 3.8</li><li>Apache Tomcat 10.x and Eclipse Jetty 11.x</li><li>Intellij IDEA Communnity Edition or VSCode + Java Pack</li></ul><p>Let’s explore the integrated features in the <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate">jakartaee9-servlet-starter-boilerplate</a> repository.</p><h3>Configuration</h3><p>To prepare a project used in the next stpes, clone the source codes of <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate">jakartaee9-servlet-starter-boilerplate</a> repository or create a new Maven webapp through <a href="https://maven.apache.org/archetypes/maven-archetype-webapp/">Maven Webapp Archetype</a>.</p><h3>Jakarta Servlet 5.0</h3><p>Apache Tomcat and Eclipse Jetty has built-in Jakarta Servlet, Jakarta Pages, Jakarta WebSocket implementation in the distribution bundle.</p><p>But in the development stage, you could use these APIs in your project codes.</p><p>Delcare jakarta.jakartaee-bom in the the dependencyManagement section.</p><pre>&lt;!-- <a href="https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-bom">https://mvnrepository.com/artifact/jakarta.platform/jakarta.jakartaee-bom</a> --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.jakartaee-bom&lt;/artifactId&gt;<br>    &lt;version&gt;9.1.0&lt;/version&gt;<br>    &lt;type&gt;pom&lt;/type&gt;<br>&lt;/dependency&gt;</pre><p>And add the following dependencies in the project dependencies section.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;<br>    &lt;version&gt;5.0.0&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;jakarta.el&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt;<br>    &lt;version&gt;4.0.0&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;<br>    &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt;<br>    &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt;<br>    &lt;version&gt;${jakarta.el.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><pre> &lt;!-- Optional, only when &lt;f:websocket&gt; is used. --&gt;<br>&lt;!-- dependency&gt;<br>    &lt;groupId&gt;org.glassfish&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt;<br>    &lt;version&gt;${jakarta.json.version}&lt;/version&gt;<br>&lt;/dependency --&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;!-- Optional, only when &lt;f:validateBean&gt; or &lt;f:validateWholeBean&gt; is used. --&gt;<br>    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>The jakarta.json and hibernate-validator are optional, add them when they are required.</p><p>Create an empty <em>src/main/webapp/WEB-INF/web.xml</em>.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</pre><pre>&lt;web-app version=&quot;5.0&quot;<br>         xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;<br>         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;&gt;<br>&lt;/web-app&gt;</pre><p>Note the XML namespace are updated to use [https://jakarta.ee/xml/ns/jakartaee](https://jakarta.ee/xml/ns/jakartaee) in Jakarta EE 9.</p><h3>CDI 3.0</h3><p>Weld 4.0 is compatable with CDI 3.0 specification, and Weld works with Apache Tomcat and Eclipse Jetty.</p><p>Add the following dependency.</p><pre>&lt;!-- Weld for CDI support --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.jboss.weld.servlet&lt;/groupId&gt;<br>    &lt;artifactId&gt;weld-servlet-core&lt;/artifactId&gt;<br>    &lt;version&gt;${weld.version}&lt;/version&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt;<br>            &lt;groupId&gt;jakarta.el&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt;<br>        &lt;/exclusion&gt;<br>    &lt;/exclusions&gt;<br>&lt;/dependency&gt;</pre><p>Create an empty <em>src/main/webapp/WEB-INF/beans.xml</em>.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;<br>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>       xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd&quot;<br>       version=&quot;3.0&quot;&gt;<br>&lt;/beans&gt;</pre><p>To make BeanManager avaiable via JNDI lookup. For Apache Tomcat, create a Resource in the application <em>context.xml</em>.</p><p>Create a src/main/webapp/META-INF/context.xml.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;Context path=&quot;/jakartaee9-servlet-starter-boilerplate&quot;&gt;<br>    &lt;Resource name=&quot;BeanManager&quot;<br>            auth=&quot;Container&quot;<br>            type=&quot;jakarta.enterprise.inject.spi.BeanManager&quot;<br>            factory=&quot;org.jboss.weld.resources.ManagerObjectFactory&quot;/&gt;<br>&lt;/Context&gt;</pre><p>The path is the application context path at runtime. Here it creates a Resource BeanManager.</p><p>For Eclipse Jetty, create a <em>src/main/webapp/WEB-INF/jetty-env.xml</em>.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE Configure PUBLIC &quot;-//Jetty//Configure//EN&quot; &quot;https://www.eclipse.org/jetty/configure_10_0.dtd&quot;&gt;<br>&lt;Configure id=&quot;wac&quot; class=&quot;org.eclipse.jetty.webapp.WebAppContext&quot;&gt;<br>    &lt;New id=&quot;BeanManager&quot; class=&quot;org.eclipse.jetty.plus.jndi.Resource&quot;&gt;<br>        &lt;Arg&gt;<br>            &lt;Ref refid=&quot;wac&quot;/&gt;<br>        &lt;/Arg&gt;<br>        &lt;Arg&gt;BeanManager&lt;/Arg&gt;<br>        &lt;Arg&gt;<br>            &lt;New class=&quot;javax.naming.Reference&quot;&gt;<br>                &lt;Arg&gt;jakarta.enterprise.inject.spi.BeanManager&lt;/Arg&gt;<br>                &lt;Arg&gt;org.jboss.weld.resources.ManagerObjectFactory&lt;/Arg&gt;<br>                &lt;Arg/&gt;<br>            &lt;/New&gt;<br>        &lt;/Arg&gt;<br>    &lt;/New&gt;<br>&lt;/Configure&gt;</pre><p>Add resource reference in the <em>web.xml</em>.</p><pre>&lt;resource-env-ref&gt;<br>    &lt;resource-env-ref-name&gt;BeanManager&lt;/resource-env-ref-name&gt;<br>    &lt;resource-env-ref-type&gt;<br>        jakarta.enterprise.inject.spi.BeanManager<br>    &lt;/resource-env-ref-type&gt;<br>&lt;/resource-env-ref&gt;</pre><h3>Jakarta Rest(Jaxrs) 3.0</h3><p>Jersey was the default JAX-RS implementation in Glassfish, now it is a standalone projet under Eclipse EE4J project. Besides, other popular JAX-RS implementations including Apache CXF, JBoss RestEasy, etc.</p><p>Add jersey-bom in the dependencyManagement section.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt;<br>    &lt;version&gt;${jersey.version}&lt;/version&gt;<br>    &lt;type&gt;pom&lt;/type&gt;<br>    &lt;scope&gt;import&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>Add the following dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- see: <a href="https://github.com/eclipse-ee4j/jersey/blob/3.x/examples/cdi-webapp/pom.xml#L142">https://github.com/eclipse-ee4j/jersey/blob/3.x/examples/cdi-webapp/pom.xml#L142</a> --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-cdi1x&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-cdi1x-servlet&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-cdi1x-ban-custom-hk2-binding&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;<br>    &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Jersey 3.0 is still dependent on HK2 which a small IOC container, and jersey-media-json-binding provides JSON searialzation and desearialization through Jakarta JSON binding.</p><p>The Jersey support will be initialized when the Servlet container is starting up.</p><p>Similar to a general Jakarta EE application, add a simple Application class to activate Jakarta REST.</p><pre>@ApplicationPath(&quot;/api&quot;)<br>public class RestActivator extends Application {<br>    @Override<br>    public Set&lt;Class&lt;?&gt;&gt; getClasses() {<br>        return Set.of(GreetingResource.class);<br>    }<br>}</pre><h3>Jakarta Server Faces 4.0</h3><p>Mojarra is the most popular JSF implementation, another popular one is Apache MyFaces.</p><pre>&lt;!-- Jakarta Faces --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.glassfish&lt;/groupId&gt;<br>    &lt;artifactId&gt;jakarta.faces&lt;/artifactId&gt;<br>    &lt;version&gt;${jakarta.faces.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>Add an empty <em>/src/main/webapp/WEB-INF/faces-config.xml</em>.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;faces-config<br>        xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;<br>        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>        xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-facesconfig_3_0.xsd&quot;<br>        version=&quot;3.0&quot;&gt;<br>    &lt;!-- Put any faces config here. --&gt;<br>&lt;/faces-config&gt;</pre><p>Since JSF 2.3, it add some CDI compatible features, such as the new scopes, etc. To enable the new features, create a simple configuration class to activate it.</p><pre>@FacesConfig(version = Version.JSF_2_3)<br>@ApplicationScoped<br>public class FacesCdiActivator {<br>}</pre><h3>Examples</h3><p>Next let’s explore some examples of these specifications.</p><h3>Jakarta CDI Example</h3><p>The following example is a simple CDI bean to build a greeting messsage.</p><pre>@ApplicationScoped<br>public class GreetingService {<br>    private static final Logger LOGGER = Logger.getLogger(GreetingService.class.getName());<br>    <br>    public GreetingMessage buildGreetingMessage(String name) {<br>        var message = GreetingMessage.of(&quot;Say Hello to &quot; + name + &quot; at &quot; + LocalDateTime.now());<br>        LOGGER.log(Level.INFO, &quot;build message: {0}&quot;, message);<br>        return message;<br>    }<br>}</pre><p>The GreetingMessage is a POJO class.</p><pre>@SuppressWarnings(&quot;serial&quot;)<br>public class GreetingMessage implements Serializable {</pre><pre>    private String message;</pre><pre>    public static GreetingMessage of(String s) {<br>        final var message = new GreetingMessage();<br>        message.setMessage(s);<br>        return message;<br>    }</pre><pre>    public String getMessage() {<br>        return message;<br>    }</pre><pre>    public void setMessage(String message) {<br>        this.message = message;<br>    }<br>    <br>    @Override<br>    public String toString() {<br>        return &quot;GreetingMessage{&quot; +<br>                &quot;message=&#39;&quot; + message + &#39;\&#39;&#39; +<br>                &#39;}&#39;;<br>    }<br>}</pre><h3>Jakarta Servlet Example</h3><p>In this Servlet class, we injected the existing GreetingService to handle the message.</p><pre>@WebServlet(urlPatterns = &quot;/GreetingServlet&quot;)<br>public class GreetingServlet extends HttpServlet {<br>    private static final String PAGE_HEADER = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Jakarta Servlet Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;;<br>    private static final String PAGE_FOOTER = &quot;&lt;/body&gt;&lt;/html&gt;&quot;;<br>    <br>    @Inject<br>    private GreetingService greetingService;<br>    <br>    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {<br>        var name = req.getParameter(&quot;name&quot;);<br>        resp.setContentType(&quot;text/html&quot;);<br>        var writer = resp.getWriter();<br>        writer.println(PAGE_HEADER);<br>        <br>        // write message to http response<br>        writer.println(&quot;&lt;h1&gt; Hello Servlet &lt;/h1&gt;&quot;);<br>        writer.println(&quot;&lt;p&gt;&quot; + greetingService.buildGreetingMessage(name) + &quot;&lt;/p&gt;&quot;);<br>        <br>        writer.println(PAGE_FOOTER);<br>        writer.close();<br>    }<br>    <br>}</pre><h3>Jakarta Servlet and Pages Example</h3><p>Refactor the above the example, split page view part into a standalone Pages file.</p><pre>@WebServlet(urlPatterns = &quot;/GreetingPagesServlet&quot;)<br>public class GreetingPagesServlet extends HttpServlet {</pre><pre>    @Inject<br>    private GreetingService greetingService;</pre><pre>    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {<br>        var name = req.getParameter(&quot;name&quot;);<br>        var message = greetingService.buildGreetingMessage(name);<br>        req.setAttribute(&quot;hello&quot;, message);<br>        req.getRequestDispatcher(&quot;/hello-pages.jspx&quot;).forward(req, resp);<br>    }</pre><pre>}</pre><p>Put the message object into request attribute, in the pages view, it can be read from requestScope directive.</p><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;<br>&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot;<br>          xmlns=&quot;http://www.w3.org/1999/xhtml&quot;<br>          version=&quot;2.0&quot;&gt;<br>    &lt;jsp:directive.page contentType=&quot;text/html; charset=UTF-8&quot;<br>                        pageEncoding=&quot;UTF-8&quot;<br>                        session=&quot;false&quot;/&gt;<br>    &lt;jsp:output omit-xml-declaration=&quot;true&quot;/&gt;<br>    &lt;!-- make it HTML 5 declaration compatiable --&gt;<br>    &lt;![CDATA[&lt;!DOCTYPE html&gt;]]&gt;<br>    &lt;html&gt;<br>    &lt;head&gt;&lt;title&gt;Jakarta Server Pages Example&lt;/title&gt;&lt;/head&gt;<br>    &lt;body&gt;<br>        &lt;h1&gt;Hello Pages&lt;/h1&gt;<br>        &lt;p&gt;${requestScope.hello.message}&lt;/p&gt;<br>    &lt;/body&gt;<br>    &lt;/html&gt;<br>&lt;/jsp:root&gt;</pre><h3>Jakarta Faces Example</h3><p>Create a Jakarta Faces backend bean, it is a CDI bean.</p><pre>@Named<br>@RequestScoped<br>public class Hello {<br>    <br>    private String name;<br>    private GreetingMessage message;<br>    <br>    @Inject<br>    private GreetingService greetingService;<br>    <br>    public Hello() {<br>    }<br>    <br>    public Hello(GreetingService greetingService) {<br>        this.greetingService = greetingService;<br>    }<br>    <br>    public void createMessage() {<br>        message = greetingService.buildGreetingMessage(name);<br>    }<br>    <br>    public String getName() {<br>        return name;<br>    }<br>    <br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    <br>    public GreetingMessage getMessage() {<br>        return message;<br>    }<br>    <br>}</pre><p>Let’s have a look at the <em>hello.xhtml</em>.</p><pre>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;<br>      xmlns=&quot;http://www.w3.org/1999/xhtml&quot;<br>      xmlns:f=&quot;http://xmlns.jcp.org/jsf/core&quot;<br>      xmlns:jsf=&quot;http://xmlns.jcp.org/jsf&quot;<br>      xmlns:h=&quot;http://xmlns.jcp.org/jsf/html&quot;&gt;<br>&lt;f:view&gt;<br>    &lt;h:head&gt;<br>        &lt;title&gt;Hello, World!&lt;/title&gt;<br>    &lt;/h:head&gt;<br>    &lt;h:body&gt;<br>        &lt;h:form prependId=&quot;false&quot;&gt;<br>            &lt;label jsf:for=&quot;name&quot; jsf:required=&quot;true&quot;&gt;Enter your name:&lt;/label&gt;<br>            &lt;input type=&quot;text&quot;<br>                   jsf:id=&quot;name&quot;<br>                   jsf:value=&quot;#{hello.name}&quot;<br>                   jsf:required=&quot;true&quot;<br>                   jsf:requiredMessage=&quot;Name is required.&quot;<br>                   placeholder=&quot;Type your name here...&quot;<br>            /&gt;<br>            &lt;h:message for=&quot;name&quot;/&gt;<br>            &lt;br/&gt;<br>            &lt;input type=&quot;submit&quot; jsf:id=&quot;submit&quot; value=&quot;Say Hello&quot;  jsf:action=&quot;#{hello.createMessage()}&quot;&gt;<br>                &lt;f:ajax execute=&quot;@form&quot; render=&quot;@form&quot;/&gt;<br>            &lt;/input&gt;<br>            &lt;br/&gt;<br>            &lt;p id=&quot;message&quot;&gt;#{hello.message}&lt;/p&gt;<br>        &lt;/h:form&gt;<br>    &lt;/h:body&gt;<br>&lt;/f:view&gt;<br>&lt;/html&gt;</pre><h3>Jakarta REST Example</h3><p>In this example, we reuse the GreetingService bean to handle the greeting message.</p><pre>@Path(&quot;greeting&quot;)<br>@RequestScoped<br>public class GreetingResource {</pre><pre>    @Inject<br>    private GreetingService greetingService;</pre><pre>    @GET<br>    @Path(&quot;{name}&quot;)<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response greeting(@PathParam(&quot;name&quot;) String name) {<br>        return ok(this.greetingService.buildGreetingMessage(name)).build();<br>    }<br>}</pre><h3>Deploy and Run the application</h3><p>To deploy an application to the production environment, firstly we can package the built files into a war archive, and put it into a deployable folder under the servlet container. Then start up the servlet container, the war file will be detected and deployed into the servlet container.</p><p>To simplify the deployment in the development stage, we use maven plugins to complete the work.</p><h3>Deploying to Apache Tomcat</h3><p>To deploy the application into Apache Tomcat, we use cargo-maven3-plugin.</p><pre>&lt;build&gt;<br>    &lt;plugins&gt;<br>        ...<br>        &lt;plugin&gt;<br>            &lt;groupId&gt;org.codehaus.cargo&lt;/groupId&gt;<br>            &lt;artifactId&gt;cargo-maven3-plugin&lt;/artifactId&gt;<br>            &lt;configuration&gt;<br>                &lt;container&gt;<br>                    &lt;containerId&gt;tomcat10x&lt;/containerId&gt;<br>                    &lt;artifactInstaller&gt;<br>                        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;<br>                        &lt;artifactId&gt;tomcat&lt;/artifactId&gt;<br>                        &lt;version&gt;${tomcat.version}&lt;/version&gt;<br>                    &lt;/artifactInstaller&gt;<br>                &lt;/container&gt;</pre><pre>                &lt;configuration&gt;<br>                    &lt;properties&gt;<br>                        &lt;!-- &lt;cargo.servlet.port&gt;8080&lt;/cargo.servlet.port&gt;--&gt;<br>                        &lt;cargo.logging&gt;low&lt;/cargo.logging&gt;<br>                    &lt;/properties&gt;<br>                &lt;/configuration&gt;<br>            &lt;/configuration&gt;<br>        &lt;/plugin&gt;<br>    &lt;/plugins&gt;<br>&lt;/build&gt;</pre><p>The cargo-maven3-plugin controls the lifecyle of Tomcat starting and stopping.</p><p>Run the following command to run application on Tomcat.</p><pre>mvn clean package cargo:run</pre><p>When it is started, open your browser, check the examples we have created above.</p><p>Go to <a href="http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingServlet?name=Hantsy">http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingServlet?name=Hantsy</a> to view the Servlet example.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/863/0*fm3DjmDLkCHgu4GI.png" /></figure><p>Open <a href="http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingPagesServlet?name=Hantsy">http://localhost:8080/jakartaee9-servlet-starter-boilerplate/GreetingPagesServlet?name=Hantsy</a> to see the result of Jakarta Server Pages.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/930/0*B3rCzV3FDWT9Md1Z.png" /></figure><p>Navigate to <a href="http://localhost:8080/jakartaee9-servlet-starter-boilerplate/hello.xhtml">http://localhost:8080/jakartaee9-servlet-starter-boilerplate/hello.xhtml</a> and input name, and click the Greeting button, you will see the following result.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/773/0*7dItPMcjb1WayHOG.png" /></figure><p>Access <a href="http://localhost:8080/jakartaee9-servlet-starter-boilerplate/api/greeting/Hantsy">http://localhost:8080/jakartaee9-servlet-starter-boilerplate/api/greeting/Hantsy</a> in your browser or using curl command, you will see the following result.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/755/0*ptupU9sXJxnmKUQq.png" /></figure><p>Similarly, we can also configure cargo to use Eclipse Jetty as servlet container. But Eclipse Jetty provides an official maven plugin for deploying applications into Jetty servers.</p><h3>Deploying to Eclipse Jetty</h3><p>In Jetty 11.x, Jetty maven plugin was refactored, and provides 3 deploy modes in the new pluign.</p><ul><li>EMBED</li><li>FORKED</li><li>EXTERNAL</li></ul><p>The default mode is EMBED which is similar to running the simplest jetty:run goal in the previous version.</p><p>The FORKED mode uses a forked thread to run the application.</p><p>The EXTERNAL mode runs the application on an external standalone Jetty server.</p><h4>Deploying to an Embedded Jetty Server</h4><p>Configure jetty maven plugin and use EMBED mode.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;jetty-embed&lt;/id&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;deployMode&gt;EMBED&lt;/deployMode&gt;<br>                    &lt;useProvidedScope&gt;true&lt;/useProvidedScope&gt;<br>                    &lt;httpConnector&gt;<br>                        &lt;port&gt;9090&lt;/port&gt;<br>                    &lt;/httpConnector&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt;<br>            &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt;<br>            &lt;version&gt;${jakarta.json.version}&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;jakarta.el&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt;<br>            &lt;version&gt;4.0.0&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;</pre><pre>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-plus&lt;/artifactId&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>            &lt;artifactId&gt;jetty-cdi&lt;/artifactId&gt;<br>            &lt;version&gt;${jetty.version}&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;<br>            &lt;version&gt;1.7.36&lt;/version&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/profile&gt;</pre><p>There is useProvidedScope option. When it is true, it will add Maven <em>provided</em> scoped dependencies to the container classpath and run the application, else it will use a isolated application classpath to run the application.</p><blockquote><em>Here we have to set it to true, if it is false, it will fail to run our application.</em></blockquote><p>Run the following command to deploy the application into an embedded Jetty.</p><pre>mvn clean jetty:run -Pjetty-embed</pre><p>You will see a lot of warning of duplicated classes, due to some duplicated artifacts in the containter classpath.</p><h4>Deploying to an External Jetty Server</h4><p>Create a new Maven profile for this purpose.</p><pre>&lt;profile&gt;<br>    &lt;id&gt;jetty-external&lt;/id&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br>                &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;deployMode&gt;EXTERNAL&lt;/deployMode&gt;<br>                    &lt;webApp&gt;<br>                        &lt;contextPath&gt;/${project.artifactId}&lt;/contextPath&gt;<br>                    &lt;/webApp&gt;<br>                    &lt;jettyHome&gt;${env.JETTY_HOME}&lt;/jettyHome&gt;<br>                    &lt;modules&gt;jdni,jsp,servlet,glassfish-jstl,websocket-jakarta,cdi-decorate&lt;/modules&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt;<br>            &lt;version&gt;${jakarta.servlet.jsp.jstl.version}&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.glassfish&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.json&lt;/artifactId&gt;<br>            &lt;version&gt;${jakarta.json.version}&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;jakarta.el&lt;/groupId&gt;<br>            &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt;<br>            &lt;version&gt;4.0.0&lt;/version&gt;<br>            &lt;scope&gt;provided&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/profile&gt;</pre><p>Make sure you have downloaded a copy of Eclipse Jetty, and create an system environment variable JETTY_HOME and set it to the location of Eclipse Jetty root folder.</p><p>Run the following command to deploy the application into the standalone Jetty server.</p><pre>mvn clean jetty:run -Pjetty-external</pre><p>Check <a href="https://github.com/hantsy/jakartaee9-servlet-starter-boilerplate">the complete example codes</a> from My Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b3acc50c8464" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-jakarta-ee-9-web-application-with-servlet-containers-b3acc50c8464">Building Jakarta EE 9 Web application with Servlet Containers</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>

  </article>

  

</div>

  </div>

  <!-- Footer -->

  
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2022 Hantsy  Bai.
    <span class="mr-auto"></span>
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme.

    
    

  </div>
</footer>



</body>

<!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>


<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>





<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
