---
layout: post
title: Integrating Vertx application with Spring framework
---

<p>As shown in the former we assembled everything manually in the MainVerticle class. We will use Spring IOC to manage the dependencies.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BK5r0YsZvSKWQGD9exxvzQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@hansonluu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Hanson Lu</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>For example, it looks like the following.</p><pre>//Create a PgPool instance<br>var pgPool = pgPool();</pre><pre>//Creating PostRepository<br>var postRepository = PostRepository.create(pgPool);</pre><pre>//Creating PostHandler<br>var postHandlers = PostsHandler.create(postRepository);</pre><pre>// Initializing the sample data<br>var initializer = DataInitializer.create(pgPool);<br>initializer.run();</pre><pre>// Configure routes<br>var router = routes(postHandlers);</pre><pre>// Create the HTTP server<br>vertx.createHttpServer()...</pre><p>In this post, we will introduce Spring framework to manage the dependencies of the above items.</p><p>Add the Spring context dependency into the project <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>The spring-context provides basic IOC functionality which is used for assembling dependencies and providing dependency injection.</p><p>Create a @Configuration class to start Spring application context.</p><pre>@Configuration<br>@ComponentScan<br>public class DemoApplication {</pre><pre>    public static void main(String[] args) {<br>        var context = new AnnotationConfigApplicationContext(DemoApplication.class);<br>        var vertx = context.getBean(Vertx.class);<br>        var factory  = context.getBean(VerticleFactory.class);</pre><pre>        // deploy MainVerticle via verticle identifier name<br>        vertx.deployVerticle(factory.prefix()+&quot;:&quot;+MainVerticle.class.getName());<br>    }</pre><pre>    @Bean<br>    public Vertx vertx(VerticleFactory verticleFactory) {<br>        Vertx vertx = Vertx.vertx();<br>        vertx.registerVerticleFactory(verticleFactory);<br>        return vertx;<br>    }</pre><pre>    @Bean<br>    public PgPool pgPool(Vertx vertx) {<br>        PgConnectOptions connectOptions = new PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;);</pre><pre>        // Pool Options<br>        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>        // Create the pool from the data object<br>        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>        return pool;<br>    }<br>}</pre><p>In the main method, we use a AnnotationConfigApplicationContext to scan Spring components and assemble the dependencies. Then fetch Vertx bean and VerticleFactory bean from the Spring application context, and call vertx.deployVerticle.</p><blockquote><em>The </em><em>VerticleFactory is a Vertx built-in hook for instantiating a Verticle instance.</em></blockquote><p>In this configuration, we also declares beans:</p><ul><li>Vertx which accepts VerticleFactory bean and registers a VerticleFactory in the Vertx bean.</li><li>PgPool is used for accessing Postgres database. You can move the database configuration to a <em>properties</em> file, and load it by Spring @PropertySource annotation.</li></ul><p>Let’s have a look at VerticleFactory bean - a Spring context aware VerticleFactory implementation.</p><pre>@Component<br>public class SpringAwareVerticleFactory implements VerticleFactory, ApplicationContextAware {</pre><pre>    private ApplicationContext applicationContext;</pre><pre>    @Override<br>    public String prefix() {<br>        return &quot;spring&quot;;<br>    }</pre><pre>    @Override<br>    public void createVerticle(String verticleName, ClassLoader classLoader, Promise&lt;Callable&lt;Verticle&gt;&gt; promise) {<br>        String clazz = VerticleFactory.removePrefix(verticleName);<br>        promise.complete(() -&gt; (Verticle) applicationContext.getBean(Class.forName(clazz)));<br>    }</pre><pre>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {<br>        this.applicationContext = applicationContext;<br>    }<br>}</pre><p>When instantiating a Verticle by name, it will call the createVerticle method, which looks up the beans in the Spring application context.</p><p>Let’s have a look at the other classes, which are declared as Spring @Component directly. For the complete source codes, check <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service-spring">vertx-sandbox/post-service-spring</a> from my Github.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class MainVerticle extends AbstractVerticle {<br>    final PostsHandler postHandlers;<br>    <br>    //...<br>}</pre><pre>@Component<br>@RequiredArgsConstructor<br>class PostsHandler {<br>    private final PostRepository posts;<br>    <br>    //...<br>}</pre><pre>@Component<br>@RequiredArgsConstructor<br>public class PostRepository {</pre><pre>    private final PgPool client;<br>    <br>    //...<br>}</pre><pre>@Component<br>@RequiredArgsConstructor<br>public class DataInitializer {</pre><pre>    private  final PgPool client;<br>    <br>    //...<br>}</pre><p>All @Components can be scanned when DemoApplicaiton is running.</p><p>As you see, through Spring IOC container, we erase all manual steps of the assembling the dependencies.</p><p>Now let’s try to start the application.</p><p>In the former application, the application can be run by maven exec plugin and jar file. But it uses a built-in Launcher class to deploy the Verticle. We have configured to use Spring to complete the same work, so change the configuration of maven exec plugin and maven shade plugin to the following.</p><pre>&lt;plugin&gt;<br>    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;${maven-shade-plugin.version}&lt;/version&gt;<br>    &lt;executions&gt;<br>        &lt;execution&gt;<br>            &lt;phase&gt;package&lt;/phase&gt;<br>            &lt;goals&gt;<br>                &lt;goal&gt;shade&lt;/goal&gt;<br>            &lt;/goals&gt;<br>            &lt;configuration&gt;<br>                &lt;transformers&gt;<br>                    &lt;transformer<br>                                 implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;<br>                        &lt;manifestEntries&gt;<br>                            &lt;Main-Class&gt;com.example.demo.DemoApplication&lt;/Main-Class&gt;<br>                        &lt;/manifestEntries&gt;<br>                    &lt;/transformer&gt;<br>                    &lt;transformer<br>                                 implementation=&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;/&gt;<br>                &lt;/transformers&gt;<br>                &lt;artifactSet&gt;<br>                &lt;/artifactSet&gt;<br>                &lt;outputFile&gt;${project.build.directory}/${project.artifactId}-${project.version}-fat.jar<br>                &lt;/outputFile&gt;<br>            &lt;/configuration&gt;<br>        &lt;/execution&gt;<br>    &lt;/executions&gt;<br>&lt;/plugin&gt;<br>&lt;plugin&gt;<br>    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br>    &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;${exec-maven-plugin.version}&lt;/version&gt;<br>    &lt;configuration&gt;<br>        &lt;mainClass&gt;com.example.demo.DemoApplication&lt;/mainClass&gt;<br>    &lt;/configuration&gt;<br>&lt;/plugin&gt;</pre><p>Now run the following command to start the application.</p><pre>mvn clean compile exec:java</pre><pre>//or<br>mvn clean package<br>java -jar target\xxx-fat.jar</pre><p>In the TestMainVerticle, let&#39;s do some modifications to use Spring IOC container, eg. you can get a Vertx instance from the Spring application context.</p><pre>@SpringJUnitConfig(classes = DemoApplication.class)<br>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br>@ExtendWith(VertxExtension.class)<br>public class TestMainVerticle {<br>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());</pre><pre>    @Autowired<br>    ApplicationContext context;</pre><pre>    Vertx vertx;</pre><pre>    @BeforeAll<br>    public void setupAll(VertxTestContext testContext) {<br>        vertx = context.getBean(Vertx.class);<br>        var factory = context.getBean(VerticleFactory.class);<br>        vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName())<br>            .onSuccess(id -&gt; {<br>                LOGGER.info(&quot;deployed:&quot; + id);<br>                testContext.completeNow();<br>            })<br>            .onFailure(testContext::failNow);<br>    }</pre><pre>    @Test<br>    public void testVertx(VertxTestContext testContext) {<br>        assertThat(vertx).isNotNull();<br>        testContext.completeNow();<br>    }<br></pre><pre>    @Test<br>    void testGetAll(VertxTestContext testContext) {<br>        LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;);<br>        var options = new HttpClientOptions()<br>            .setDefaultPort(8888);<br>        var client = vertx.createHttpClient(options);</pre><pre>        client.request(HttpMethod.GET, &quot;/posts&quot;)<br>            .flatMap(req -&gt; req.send().flatMap(HttpClientResponse::body))<br>            .onSuccess(<br>                buffer -&gt; testContext.verify(<br>                    () -&gt; {<br>                        LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()});<br>                        assertThat(buffer.toJsonArray().size()).isGreaterThan(0);<br>                        testContext.completeNow();<br>                    }<br>                )<br>            )<br>            .onFailure(e -&gt; {<br>                LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage());<br>                testContext.failNow(e);<br>            });<br>    }<br>}</pre><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master//post-service-spring">example codes from my github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb8fca81a357" width="1" height="1" alt="">
