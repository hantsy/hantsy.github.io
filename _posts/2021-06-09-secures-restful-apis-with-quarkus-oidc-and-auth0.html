---
layout: post
title: Secures RESTful APIs with Quarkus OIDC and Auth0
---

<p>Quarkus has great support of OAuth 2 and OIDC protocol. In this post, we will explore how to protect RESTful APIs with Quarkus OIDC and Auth0.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*e8eToBkiLUtTgQeiIbxXIQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@linglivestolaugh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Ling Tang</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p><a href="https://www.quarkus.io">Quarkus</a> is well-known as a <em>supersonic subatomic Java framework</em> to build Kubernetes-friendly cloud native applications. In <a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">an earlier post</a> we have discussed how to secure RESTful APIs with Spring Security and Auth0, we will implement the same functionality with Quarkus OIDC extension.</p><p>Go to <a href="https://code.quarkus.io/">Quarkus Start Coding</a> page, make sure you have added these extensions: <em>oidc</em>, <em>resteasy</em>, <em>resteasy-jackson</em>, <em>hibernate-validator</em> , <em>hibernate-orm-panache</em>, <em>jdbc-postgresql</em>. Then generate a project skeleton as usual that we have done in the <a href="https://itnext.io/building-graphql-apis-with-quarkus-dbbf23f897df">former posts</a>. Import the source codes into your IDE.</p><p>Open the project <em>pom.xml</em> file you should see the following dependencies. Add an extra <em>Lombok</em> dependency to clean up the POJOs.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-resteasy-jackson&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-arc&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- Erase getters and setters --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>    &lt;version&gt;1.18.20&lt;/version&gt;<br>    &lt;optional&gt;true&lt;/optional&gt;<br>&lt;/dependency&gt;</pre><p>In this post we will focus on how to integrate Quarkus OIDC and Auth0. We have no plan to explain the development progress of the RESTful APIs, the details of the source codes are very similar to the ones we have discussed in <a href="https://hantsy.medium.com/kickstart-your-first-quarkus-application-cde54f469973">my introduction to Quarkus</a>. Before jumping to the next steps, check out a copy of <a href="https://github.com/hantsy/quarkus-auth0-sample">the source codes of this post from my github</a> and explore them yourself.</p><p>Unlike Spring Security, Quarkus Security does not follow the naming (resourceserver, client and authorizationserver etc.) of OAuth2 roles to categorize the configuration properties. Quarkus binds the OAuth2/OIDC configuration properties to functionality name (eg. quarkus.oidc.xxx, quarkus.oidc-flow.xxx, etc), which are confusing when you are the first time come to Quarkus world.</p><p>And most of the official Quarkus OAuth2 and OIDC examples and guides are dependent on <a href="https://www.keycloak.org/">Keycloak</a> — the open source OAuth2/OIDC compatible authorization server from Redhat. If you know well about the OAuth2/OIDC protocols, it is not diffcult to move on to Auth0.</p><p>To make Quakrus OIDC work with Auth0, add the following configuration in the <em>application.properties</em>.</p><pre># Oidc auth config for resource server<br>quarkus.oidc.client-id=backend-api<br>quarkus.oidc.auth-server-url=https://dev-ese8241b.us.auth0.com/<br>quarkus.oidc.token.audience=https://hantsy.github.io/api<br>#quarkus.oidc.application-type=service</pre><p>The default <em>quarkus.oidc.application-type</em> is <em>service</em>, which is used for identifying the application type, <em>service</em> is equivalent to <em>resourceserver</em> in Spring Security.</p><blockquote><em>Note: The </em>quarkus.oidc.client-id<em> must be provided although this is not an OAuth2 </em>client<em> role.</em></blockquote><p>When parsing the JWT token, Quarkus OIDC also can discover the <em>jwt set url</em> automatically from a base <em>auth-server-url</em> value if the authorization server supports OIDC configuratoin protocol.</p><p>When a token audience is provided, Quarkus will verify it automatically. You can also validate the audience or other items in the JWT token yourself.</p><pre>//@Provider<br>public class AudienceValidator implements ContainerRequestFilter {</pre><pre>    @Inject<br>    OidcConfigurationMetadata configMetadata;</pre><pre>    @Inject<br>    JsonWebToken jwt;</pre><pre>    @Inject<br>    SecurityIdentity identity;</pre><pre>    public void filter(ContainerRequestContext requestContext) {<br>        String aud = configMetadata.get(&quot;audience&quot;);//.replace(&quot;{tenant-id}&quot;, identity.getAttribute(&quot;tenant-id&quot;));<br>        if (!jwt.getAudience().contains(aud)) {<br>            requestContext.abortWith(Response.status(401).build());<br>        }<br>    }<br>}</pre><p>In the above example, the OidcConfigurationMetadata is the OIDC configuration properties of this application. The JsonWebToken is the parsed token claims. The SecurityIdenity is a general-purpose security context object to envelope the user principal and roles, similar to the traditional Jakarta EE SecurityContext API from JaxRS, EJB, etc.</p><p>To protect the APIs and make some APIs only be accessible for the authenticated user, Quarkus Security provides a @Authenticated annotation. The following is a modified version of PostResource in which we added @Authenticated annotations on all <em>write</em> operations to protect the resources.</p><pre>@Path(&quot;/posts&quot;)<br>@RequestScoped<br>public class PostResource {<br>    private final static Logger LOGGER = Logger.getLogger(PostResource.class.getName());</pre><pre>    private final PostRepository posts;</pre><pre>    @Context<br>    UriInfo uriInfo;</pre><pre>    @Inject<br>    public PostResource(PostRepository posts) {<br>        this.posts = posts;<br>    }</pre><pre>    @Path(&quot;count&quot;)<br>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response countAllPosts(@QueryParam(&quot;q&quot;) String q) {<br>        return ok(this.posts.countByKeyword(q)).build();<br>    }</pre><pre>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response getAllPosts(<br>            @QueryParam(&quot;q&quot;) String q,<br>            @QueryParam(&quot;offset&quot;) @DefaultValue(&quot;0&quot;) int offset,<br>            @QueryParam(&quot;limit&quot;) @DefaultValue(&quot;10&quot;) int limit</pre><pre>    ) {<br>        return ok(this.posts.findByKeyword(q, offset, limit)).build();<br>    }</pre><pre>    @POST<br>    @Consumes(MediaType.APPLICATION_JSON)<br>    @Authenticated<br>    public Response savePost(@Valid CreatePostCommand post) {<br>        Post saved = this.posts.save(Post.builder().title(post.title()).content(post.content()).build());<br>        return created(<br>                uriInfo.getBaseUriBuilder()<br>                        .path(&quot;/posts/{id}&quot;)<br>                        .build(saved.getId())<br>        ).build();<br>    }</pre><pre>    @Path(&quot;{id}&quot;)<br>    @GET<br>    @Produces(MediaType.APPLICATION_JSON)<br>    public Response getPostById(@PathParam(&quot;id&quot;) final Long id) {<br>        return this.posts.findByIdOptional(id)<br>                .map(post -&gt; ok(post).build())<br>                .orElse(status(NOT_FOUND).build());<br>    }</pre><pre>    @Path(&quot;{id}&quot;)<br>    @PUT<br>    @Consumes(MediaType.APPLICATION_JSON)<br>    @Authenticated<br>    public Response updatePost(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostCommand post) {<br>        return this.posts.findByIdOptional(id)<br>                .map(existed -&gt; {<br>                    existed.setTitle(post.title());<br>                    existed.setContent(post.content());</pre><pre>                    Post saved = this.posts.save(existed);<br>                    return noContent().build();<br>                })<br>                .orElse(status(NOT_FOUND).build());<br>    }</pre><pre>    @Path(&quot;{id}/status&quot;)<br>    @PUT<br>    @Consumes(MediaType.APPLICATION_JSON)<br>    @Authenticated<br>    public Response updatePostStatus(@PathParam(&quot;id&quot;) final Long id, @Valid UpdatePostStatusCommand status) {<br>        return this.posts.findByIdOptional(id)<br>                .map(existed -&gt; {<br>                    existed.setStatus(status.status());<br>                    Post saved = this.posts.save(existed);<br>                    return noContent().build();<br>                })<br>                .orElse(status(NOT_FOUND).build());<br>    }</pre><pre>    @Path(&quot;{id}&quot;)<br>    @DELETE<br>    @Authenticated<br>    public Response deletePost(@PathParam(&quot;id&quot;) final Long id) {<br>        this.posts.deleteById(id);<br>        return noContent().build();<br>    }</pre><pre>}</pre><p>To test the application manually, log in the auth0 dashboard, follow the steps we have introduced in <a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">the former Spring Security and Auth0 integration post</a> to get a token via the <em>Test Application</em> provided by auth0 and then use curl command or Postman like tools to access the protected APIs.</p><p>In my opinion, Quarkus test framework is not flexible as Spring. In Spring ecosystem, Spring Security provides test utilities to mock MVC and JWT decode in the unit tests, unfortunately Quarkus does not provide such a simple helper. But there are some possible approaches to test the security concern of the <em>service</em> type application.</p><p>Add the following dependencies in the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-test-security&lt;/artifactId&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-elytron-security-properties-file-deployment&lt;/artifactId&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>To focus on testing the business logic in Quarkus applications, you can set up the embedded users in a properties file to replace the real users in the database and enable Http Basic authentication to pass by the JWT token authorization.</p><p>Create a <em>src/test/resources/application-embedded-users.properties</em> file to setup the embedded users and enable <em>basic</em> auth .</p><pre>quarkus.security.users.embedded.enabled=true<br>quarkus.security.users.embedded.plain-text=true<br>quarkus.security.users.embedded.users.alice=password<br>quarkus.security.users.embedded.roles.alice=user<br>quarkus.security.users.embedded.users.admin=password<br>quarkus.security.users.embedded.roles.admin=admin<br>quarkus.http.auth.basic=true<br>quarkus.oidc.enabled=false</pre><p>Create a QuarkusTestProfile to categorize the test resources for some special purpose.</p><pre>public class PropertiesFileEmbeddedUsersProfile implements QuarkusTestProfile {<br>    @Override<br>    public String getConfigProfile() {<br>        return &quot;embedded-users&quot;;<br>    }<br>}</pre><p>Create a simple test to apply this test profile via the @TestProfile annotation.</p><pre>@QuarkusTest<br>@TestHTTPEndpoint(PostResource.class)<br>@TestProfile(PropertiesFileEmbeddedUsersProfile.class)<br>public class TestSecurityLazyAuthTest {<br></pre><pre>    @Test<br>    public void testGetAllPostsWithoutAuth() {<br>        //@formatter:off<br>        given()<br>            .accept(ContentType.JSON)<br>        .when()<br>            .get(&quot;&quot;)<br>        .then()<br>            .statusCode(200);<br>        //@formatter:on<br>    }</pre><pre>    @Test<br>    //@TestSecurity(authorizationEnabled = false)<br>    public void testCreatPostsWithoutAuth() {<br>        //@formatter:off<br>        given()<br>            .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;&quot;)<br>        .then()<br>            .statusCode(401);<br>        //@formatter:on<br>    }</pre><pre>    @Test<br>    @TestSecurity(user = &quot;alice&quot;, roles = &quot;user&quot;)<br>    public void testCreatPostsWithAuth() {<br>        //@formatter:off<br>        given()<br>            .body(Post.builder().title(&quot;test title&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;&quot;)<br>        .then()<br>            .statusCode(201);<br>        //@formatter:on<br>    }<br>}</pre><p>Additionally, you can generate a local RSA public/private key pair to perform the JWT token verification progress.</p><p>Generating Keys with OpenSSL.</p><pre>openssl genrsa -out rsaPrivateKey.pem 2048<br>openssl rsa -pubout -in rsaPrivateKey.pem -out publicKey.pem</pre><p>An additional step is needed for generating the private key for converting it into the PKCS#8 format.</p><pre>openssl pkcs8 -topk8 -nocrypt -inform pem -in rsaPrivateKey.pem -outform pem -out privateKey.pem</pre><p>Create a TestProfile class to setup the properties to use local public key to verify the JWT token.</p><pre>public class InlinedPublicKeyProfile implements QuarkusTestProfile {<br>    @Override<br>    public Map&lt;String, String&gt; getConfigOverrides() {<br>        return Map.of(<br>                &quot;quarkus.oidc.client-id&quot;, &quot;test&quot;,<br>                &quot;quarkus.oidc.public-key&quot;, &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzcAl1DgYnAkpYelL4lxl&quot; +<br>                        &quot;csdX0dHj92g+pMyjzWE3nzSV8i726lTJtg5kxaJyv8epEOAiMcelFk0v+9HMOPla&quot; +<br>                        &quot;6/pgkEHE5PPyaHlgegDIzge2RQLidDwl8IWBksUkfDWjQk+JfrEPJxrES4OXUOyp&quot; +<br>                        &quot;mO/XsNIGcbZfopi1Ook7XIjBPohuiHBcp8Fw1NVzaP7EvyYzxcxoIpa4Y/knF1Sa&quot; +<br>                        &quot;FIBuMmA/lE7PHKlBqcsS1EXkyI1TBGcdH+VWhUvsDVehKSlZoUCE6XrWY3M/xzyb&quot; +<br>                        &quot;gN+C9KPln+fQZ42Fnqo6PpD++NWRo8vgWxsMsqb+nltEQADfd8CFEuLt1BvObh8N&quot; +<br>                        &quot;fQIDAQAB&quot;,<br>                &quot;quarkus.oidc.token.audience&quot;, &quot;https://service.example.com&quot;,<br>                &quot;smallrye.jwt.sign.key-location&quot;, &quot;privateKey.jwk&quot;<br>        );<br>    }</pre><pre>}</pre><p>Now write a test to verify it. The getAccessToken to generate a token using our private key generated in the last step.</p><pre>@QuarkusTest<br>@TestProfile(InlinedPublicKeyProfile.class)<br>public class InlinedPublicKeyAuthorizationTest {</pre><pre>    @Test<br>    public void testBearerToken() {<br>        //@formatter:off<br>        given()<br>            .auth().oauth2(getAccessToken(&quot;alice&quot;, Set.of(&quot;user&quot;)))<br>            .body(new CreatePostCommand(&quot;test title&quot;, &quot;test content&quot;))<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;/posts&quot;)<br>        .then()<br>            .statusCode(201);<br>        //@formatter:on<br>    }</pre><pre>    //<br>    private String getAccessToken(String userName, Set&lt;String&gt; groups) {<br>        return Jwt.preferredUserName(userName)<br>                .claim(&quot;scope&quot;, &quot;write:posts&quot;)<br>                .groups(groups)<br>                .issuer(&quot;https://server.example.com&quot;)<br>                .audience(&quot;https://service.example.com&quot;)<br>                .jws()<br>                .keyId(&quot;1&quot;)<br>                .sign(&quot;privateKey.jwk&quot;);<br>    }<br>}</pre><p>As you see, we used a custom private/public key pair in our tests to pass by fetching the public key via jwk set url from the remote authorization server.</p><p>Let’s put all together and run the application.</p><p>Grab the <a href="https://github.com/hantsy/quarkus-auth0-sample">source codes</a> from github.</p><p>Start the application.</p><pre>docker compose up postgresql<br>mvn clean quarkus:dev</pre><p>Copy the ui codes from <a href="https://github.com/hantsy/spring-security-auth0-sample/tree/master/ui">hantsy/spring-security-auth0-sample</a> that we have done in <a href="https://itnext.io/integrating-auth0-into-your-angular-applications-42fabef31f3e">Integrating Auth0 into your Angular applications</a>. It is a SPA application written in Angular 12.</p><pre>npm install<br>npm run start</pre><p>Open your browser and navigate to <a href="http://localhost:4200">http://localhost:4200</a>. Login and click the <em>Blog</em> menu item, you will see the data from the backend <em>API</em> application.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*rH5z16Wd3GW_F2pX.png" /></figure><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=643475a9710c" width="1" height="1" alt="">
