---
layout: post
title: Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate
  Reactive
---

<p>In the <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/spring.md">Spring integration post</a>, we use Spring to assemble the resources and start up the application.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lBVdgaRt4mrtNwLaEosQ4Q.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@maohaolan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">昊蓝 毛</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In this post, we will reuse the Spring base codes, but:</p><ul><li>Use Hibernate Reactive to replace the raw Postgres Client</li><li>and use SmallRye Mutiny Vertx bindings to replace the original Vertx API, eg. Future etc..</li></ul><p>Add the Hibernate related dependencies into the project <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- <a href="https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen">https://mvnrepository.com/artifact/org.hibernate/hibernate-jpamodelgen</a> --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate.version}&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>In the above codes,</p><ul><li>The hibernate-reactive-core provides Hibernate Reactive which use Vertx Postgres Client, etc to implement reactive APIs, currently it supports Java 8 CompletionStage and SmallRye Mutiny. In this post, we only uses the SmallRye Mutiny APIs.</li><li>The hibernate-jpamodelgen will generate the JPA Entity metadata classes when compiling the project.</li></ul><p>Add a <em>persistence.xml</em> configuration in the <em>main/resources/META-INF</em> folder.</p><pre>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;<br>             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>             xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;<br>             version=&quot;2.2&quot;&gt;</pre><pre>    &lt;persistence-unit name=&quot;blogPU&quot;&gt;<br>        &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt;</pre><pre>        &lt;class&gt;com.example.demo.Post&lt;/class&gt;</pre><pre>        &lt;properties&gt;</pre><pre>            &lt;!-- PostgreSQL --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.url&quot;<br>                      value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt;</pre><pre>            &lt;!-- Credentials --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.user&quot;<br>                      value=&quot;user&quot;/&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.password&quot;<br>                      value=&quot;password&quot;/&gt;</pre><pre>            &lt;!-- The Vert.x SQL Client connection pool size --&gt;<br>            &lt;property name=&quot;hibernate.connection.pool_size&quot;<br>                      value=&quot;10&quot;/&gt;</pre><pre>            &lt;!-- Automatic schema export --&gt;<br>            &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot;<br>                      value=&quot;drop-and-create&quot;/&gt;</pre><pre>            &lt;!-- SQL statement logging --&gt;<br>            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt;</pre><pre>        &lt;/properties&gt;</pre><pre>    &lt;/persistence-unit&gt;</pre><pre>&lt;/persistence&gt;</pre><p>It is a standard JPA configuration, but here we use the specific org.hibernate.reactive.provider.ReactivePersistenceProvider as provider to provides ReactiveStreams supports.</p><p>Next, add SmallRye related dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-core&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-web&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-pg-client&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>In the DemoApplication, expose a Mutiny.SessionFactory bean.</p><pre>@Bean<br>public Mutiny.SessionFactory sessionFactory() {<br>    return Persistence.createEntityManagerFactory(&quot;blogPU&quot;)<br>        .unwrap(Mutiny.SessionFactory.class);<br>}</pre><blockquote><em>Note: you have to update all imports to use items from package </em><em>io.vertx.mutiny, including </em><em>Vertx, etc.</em></blockquote><p>Replace the PostRepository with the following.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class PostRepository {<br>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</pre><pre>    private final Mutiny.SessionFactory sessionFactory;</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList());<br>    }</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) {</pre><pre>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);</pre><pre>        // if keyword is provided<br>        if (q != null &amp;&amp; !q.trim().isEmpty()) {<br>            query.where(<br>                cb.or(<br>                    cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;),<br>                    cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;)<br>                )<br>            );<br>        }<br>        //perform query<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query)<br>            .setFirstResult(offset)<br>            .setMaxResults(limit)<br>            .getResultList());<br>    }<br></pre><pre>    public Uni&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id))<br>            .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id));<br>    }</pre><pre>    public Uni&lt;Post&gt; save(Post post) {<br>        if (post.getId() == null) {<br>            return this.sessionFactory.withSession(session -&gt;<br>                session.persist(post)<br>                    .chain(session::flush)<br>                    .replaceWith(post)<br>            );<br>        } else {<br>            return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush));<br>        }<br>    }</pre><pre>    public Uni&lt;Post[]&gt; saveAll(List&lt;Post&gt; data) {<br>        Post[] array = data.toArray(new Post[0]);<br>        return this.sessionFactory.withSession(session -&gt; {<br>            session.persistAll(array);<br>            session.flush();<br>            return Uni.createFrom().item(array);<br>        });<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteById(UUID id) {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // set where clause<br>        delete.where(cb.equal(root.get(Post_.id), id));<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>}</pre><p>It is very similar to the standard JPA codes, but when using Mutiny.SessionFactory to perform the queries, it will return the SmallRye Mutiny specific Uni type instead.</p><p>Update the content of PostsHandler.</p><pre>@Component<br>@RequiredArgsConstructor<br>class PostsHandler {<br>    private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName());</pre><pre>    private final PostRepository posts;<br></pre><pre>    public void all(RoutingContext rc) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        this.posts.findAll()<br>            .subscribe()<br>            .with(<br>                data -&gt; {<br>                    LOGGER.log(Level.INFO, &quot;posts data: {0}&quot;, data);<br>                    rc.response().endAndAwait(Json.encode(data));<br>                },<br>                rc::fail<br>            );<br>    }</pre><pre>    public void get(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        this.posts.findById(UUID.fromString(id))<br>            .subscribe()<br>            .with(<br>                post -&gt; rc.response().endAndAwait(Json.encode(post)),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }</pre><pre>    public void save(RoutingContext rc) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body);<br>        var form = body.mapTo(CreatePostCommand.class);<br>        this.posts<br>            .save(Post.builder()<br>                .title(form.getTitle())<br>                .content(form.getContent())<br>                .build()<br>            )<br>            .subscribe()<br>            .with(<br>                savedId -&gt; rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId)<br>                    .setStatusCode(201)<br>                    .endAndAwait(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }</pre><pre>    public void update(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body});<br>        var form = body.mapTo(CreatePostCommand.class);<br>        this.posts.findById(UUID.fromString(id))<br>            .flatMap(<br>                post -&gt; {<br>                    post.setTitle(form.getTitle());<br>                    post.setContent(form.getContent());</pre><pre>                    return this.posts.save(post);<br>                }<br>            )<br>            .subscribe()<br>            .with(<br>                data -&gt; rc.response().setStatusCode(204).endAndAwait(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }</pre><pre>    public void delete(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);</pre><pre>        var uuid = UUID.fromString(id);<br>        this.posts.findById(uuid)<br>            .flatMap(<br>                post -&gt; this.posts.deleteById(uuid)<br>            )<br>            .subscribe()<br>            .with(<br>                data -&gt; rc.response().setStatusCode(204).endAndAwait(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );<br>    }<br>}</pre><p>Let’s have a look at MainVerticle .</p><pre>//...other imports.<br>import io.smallrye.mutiny.Uni;<br>import io.smallrye.mutiny.vertx.core.AbstractVerticle;<br>import io.vertx.core.json.jackson.DatabindCodec;<br>import io.vertx.mutiny.ext.web.Router;<br>import io.vertx.mutiny.ext.web.handler.BodyHandler;</pre><pre>@Component<br>@RequiredArgsConstructor<br>public class MainVerticle extends AbstractVerticle {<br>    final PostsHandler postHandlers;</pre><pre>    private final static Logger LOGGER = Logger.getLogger(MainVerticle.class.getName());</pre><pre>    static {<br>        LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;);<br>        var objectMapper = DatabindCodec.mapper();<br>        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>        objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br>        objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</pre><pre>        JavaTimeModule module = new JavaTimeModule();<br>        objectMapper.registerModule(module);<br>    }</pre><pre>    @Override<br>    public Uni&lt;Void&gt; asyncStart() {<br>        LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;);</pre><pre>        // Configure routes<br>        var router = routes(postHandlers);</pre><pre>        // Create the HTTP server<br>        return vertx.createHttpServer()<br>            // Handle every request using the router<br>            .requestHandler(router)<br>            // Start listening<br>            .listen(8888)<br>            // Print the port<br>            .onItem().invoke(() -&gt; LOGGER.info(&quot;Http server is listening on http://127.0.0.1:8888&quot;))<br>            .onFailure().invoke(Throwable::printStackTrace)<br>            .replaceWithVoid();<br>    }</pre><pre>    //create routes<br>    private Router routes(PostsHandler handlers) {</pre><pre>        // Create a Router<br>        Router router = Router.router(vertx);<br>        // register BodyHandler globally.<br>        //router.route().handler(BodyHandler.create());<br>        router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;)<br>            .handler(handlers::all);<br>        router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler(handlers::save);<br>        router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;)<br>            .handler(handlers::get)<br>            .failureHandler(frc -&gt; frc.response().setStatusCode(404).endAndAwait());<br>        router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler(handlers::update);<br>        router.delete(&quot;/posts/:id&quot;)<br>            .handler(handlers::delete);</pre><pre>        router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;));</pre><pre>        return router;<br>    }</pre><pre>}</pre><p>The above codes are very similar to the former Spring version.</p><p>The SmallRye Mutiny version Router provides some variant methods to accept a simple function instead of the original RequestHandler, eg. there is an example to use respond method.</p><pre>//MainVerticle.java<br>router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;)<br>    .respond(handlers::all);</pre><pre>//PostHandler.java<br>public Uni&lt;List&lt;Post&gt;&gt; all(RoutingContext rc) {<br>    return this.posts.findAll();<br>}</pre><p>To the test the application, add the following dependency into <em>test</em> scope.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;smallrye-mutiny-vertx-junit5&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-vertx.version}&lt;/version&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>It provides argument injection for io.vertx.mutiny.core.Vertx and TestContext in a test method .</p><pre>import io.vertx.mutiny.core.Vertx;<br>import io.vertx.mutiny.core.http.HttpClientRequest;<br>import io.vertx.mutiny.core.http.HttpClientResponse;<br>//other imports</pre><pre>@SpringJUnitConfig(classes = DemoApplication.class)<br>@TestInstance(TestInstance.Lifecycle.PER_CLASS)<br>@ExtendWith(VertxExtension.class)<br>public class TestMainVerticle {<br>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());</pre><pre>    @Autowired<br>    ApplicationContext context;</pre><pre>    Vertx vertx;</pre><pre>    @BeforeAll<br>    public void setupAll(VertxTestContext testContext) {<br>        vertx = context.getBean(Vertx.class);<br>        var factory = context.getBean(VerticleFactory.class);<br>        vertx.deployVerticle(factory.prefix() + &quot;:&quot; + MainVerticle.class.getName())<br>            .subscribe()<br>            .with(id -&gt; {<br>                    LOGGER.info(&quot;deployed:&quot; + id);<br>                    testContext.completeNow();<br>                },<br>                testContext::failNow<br>            );<br>    }</pre><pre>    @Test<br>    public void testVertx(VertxTestContext testContext) {<br>        assertThat(vertx).isNotNull();<br>        testContext.completeNow();<br>    }<br></pre><pre>    @Test<br>    void testGetAll(VertxTestContext testContext) {<br>        LOGGER.log(Level.INFO, &quot;running test: {0}&quot;, &quot;testGetAll&quot;);<br>        var options = new HttpClientOptions()<br>            .setDefaultPort(8888);<br>        var client = vertx.createHttpClient(options);</pre><pre>        client.request(HttpMethod.GET, &quot;/posts&quot;)<br>            .flatMap(HttpClientRequest::send)<br>            .flatMap(HttpClientResponse::body)<br>            .subscribe()<br>            .with(buffer -&gt;<br>                    testContext.verify(<br>                        () -&gt; {<br>                            LOGGER.log(Level.INFO, &quot;response buffer: {0}&quot;, new Object[]{buffer.toString()});<br>                            assertThat(buffer.toJsonArray().size()).isGreaterThan(0);<br>                            testContext.completeNow();<br>                        }<br>                    ),<br>                e -&gt; {<br>                    LOGGER.log(Level.ALL, &quot;error: {0}&quot;, e.getMessage());<br>                    testContext.failNow(e);<br>                }<br>            );<br>    }<br></pre><pre>}</pre><h4><a href="https://github.com/hantsy/vertx-sandbox/tree/master/mutiny-spring-hibernate">Get the example codes from my github.</a></h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5cf10b57983a" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive-5cf10b57983a">Building a Vertx application with SmallRye Mutiny Bindings, Spring and Hibernate Reactive</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
