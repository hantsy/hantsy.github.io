---
layout: post
title: Building Micronaut applications with Micronaut Mongo Reative
---

<p>In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of MongoClient from application properties.</p><figure><img alt="Photo by &lt;a href=”https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Fabian Mardi&lt;/a&gt; on &lt;a href=”https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText&quot;&gt;Unsplash&lt;/a&gt;" src="https://cdn-images-1.medium.com/max/1024/1*HcHUQFoIAU88lHg24zJINA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@fabianmardi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Fabian Mardi</a> on <a href="https://unsplash.com/s/photos/snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h3>Getting Started</h3><p>Open your browser and navigate to <a href="https://micronaut.io/launch">Micronaut Launch</a> to generate a new project skeleton for this post. Select the following items on this page.</p><ul><li>Java version: <strong>17</strong></li><li>Language: <strong>Java</strong></li><li>Build tool: <strong>Gradle</strong></li><li>Test framework: <strong>Spock</strong></li><li>Included Features: <strong>mongo-reactive</strong> etc.</li></ul><p>Click <strong>GENERATE PROJECT</strong> button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p><p>In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests.</p><p>Create a Mongo document entity class.</p><pre>@Data<br>@Builder<br>@NoArgsConstructor<br>@AllArgsConstructor(staticName = &quot;of&quot;)<br>public class Customer {<br>    private ObjectId id;<br>    private String name;<br>    private int age;<br>    private Address address;</pre><pre>    public static Customer of(String name, int age, Address address) {<br>        return Customer.of(null, name, age, address);<br>    }<br>}</pre><p>The Address is an embedded Document in a Customer Document.</p><pre>@Data<br>@Builder<br>@NoArgsConstructor<br>@AllArgsConstructor(staticName = &quot;of&quot;)<br>public class Address {<br>    private String street;<br>    private String city;<br>    private String zip;<br>}</pre><p>Create a Repository class to perform CRUD operations on Customer.</p><pre>@Singleton<br>@RequiredArgsConstructor<br>@Slf4j<br>public class CustomerRepository {<br>    private final MongoClient mongoClient;<br>    private final DefaultMongoConfiguration mongoConfiguration;</pre><pre>    public Flux&lt;Customer&gt; findAll() {<br>        return Flux.from(customersCollection().find());<br>    }</pre><pre>    public Mono&lt;Customer&gt; findById(ObjectId id) {<br>        return Mono.from(customersCollection().find(Filters.eq(id)));<br>    }</pre><pre>    public Mono&lt;ObjectId&gt; insertOne(Customer data) {<br>        return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false)))<br>                .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue());<br>    }</pre><pre>    public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) {<br>        return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true)))<br>                .map(InsertManyResult::getInsertedIds);<br>    }</pre><pre>    public Mono&lt;Long&gt; deleteById(ObjectId id) {<br>        return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions()))<br>                .map(DeleteResult::getDeletedCount);<br>    }</pre><pre>    public void init() {<br>        var people = List.of(<br>                Customer.of(&quot;Charles Babbage&quot;, 45, Address.of(&quot;5 Devonshire Street&quot;, &quot;London&quot;, &quot;W11&quot;)),<br>                Customer.of(&quot;Alan Turing&quot;, 28, Address.of(&quot;Bletchley Hall&quot;, &quot;Bletchley Park&quot;, &quot;MK12&quot;)),<br>                Customer.of(&quot;Timothy Berners-Lee&quot;, 61, Address.of(&quot;Colehill&quot;, &quot;Wimborne&quot;, null))<br>        );<br>        Mono.from(customersCollection().drop())<br>                .then()<br>                .thenMany(this.insertMany(people))<br>                .subscribe(<br>                        result -&gt; result.forEach((key, value) -&gt; log.debug(&quot;saved key: {}, value: {}&quot;, key, value)),<br>                        error -&gt; log.debug(&quot;initialization failed: {}&quot;, error),<br>                        () -&gt; log.debug(&quot;done&quot;)<br>                );<br>    }</pre><pre>    public Mono&lt;Long&gt; deleteAll() {<br>        return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions()))<br>                .map(DeleteResult::getDeletedCount);<br>    }</pre><pre>    private MongoCollection&lt;Customer&gt; customersCollection() {<br>        return mongoClient<br>                .getDatabase(&quot;userdb&quot;)<br>                .getCollection(&quot;customers&quot;, Customer.class);<br>    }</pre><pre>}</pre><p>When a mongo.uri is set in the <em>application.yml</em>, there is a <strong>reactive</strong> MongoClient bean is available.</p><p>In the above codes:</p><ul><li>The customersCollection() method defines a Mongo collection mapped to the Customer class. As you see, there is a ObjectId id field is defined in the Customer class, when saving a Customer instance, it will generate a new ObjectId for it and saving it to the <em>customers</em> document _id in MongoDB automatically.</li><li>The MongoClient provides methods for CRUD operations, but it is based on the <em>Reactive Streams</em> APIs. Here we use Reactor API in this project, we use Mono and Flux to wrap the operation result into Reactor friendly APIs.</li></ul><p>Now let’s create a test to test the CustomerRepository.</p><pre>@MicronautTest(startApplication = false)<br>@Slf4j<br>class CustomerRepositorySpec extends Specification {</pre><pre>    @Inject<br>    EmbeddedApplication&lt;?&gt; application</pre><pre>    @Inject<br>    CustomerRepository customerRepository;</pre><pre>    def setup() {<br>        CountDownLatch latch = new CountDownLatch(1)<br>        customerRepository.deleteAll()<br>                .doOnTerminate(_ -&gt; latch.countDown())<br>                .subscribe(it -&gt; log.debug &quot;deleted customers: {}&quot;, it)<br>        latch.await(1000, TimeUnit.MILLISECONDS)<br>    }</pre><pre>    void &#39;application is not running&#39;() {<br>        expect:<br>        !application.running<br>    }</pre><pre>    void &#39;test findAll&#39;() {<br>        given:<br>        this.customerRepository.insertMany(List.of(Customer.of(&quot;Jack&quot;, 40, null)))<br>                .block(Duration.ofMillis(5000L))</pre><pre>        when:<br>        def result = this.customerRepository.findAll()</pre><pre>        then:<br>        StepVerifier.create(result)<br>                .expectNextMatches(it -&gt; it.name == &quot;Jack&quot;)<br>                .expectComplete()<br>                .verify()<br>    }<br>}</pre><p>To test the persistence layer, we do not need a running server. So add startApplication = false to the MicronautTest annotation.</p><p>Generally, a Spock test is called a Specfication, you can override the lifecycle methods in your tests, such as setup, setupSpec , etc. Every test follows the BDD pattern, aka the given/ when/ then patten.</p><p>In the above codes, we override the setup method and clear the data in the database. And then create a test to verify the insert and find operations, in the then block, we use StepVerify to assert the result in Reactive Streams.</p><p>If you want to start up a Testcontainers Docker to serve the required Mongo database, try to define a Mongo container instance with Shared and AutoCleanup annotation, and override setupSpec to start the Mongo service and ensure it is available for all tests in this specification.</p><pre>@Shared<br>@AutoCleanup<br>GenericContainer mongo = new GenericContainer(&quot;mongo&quot;)<br>    .withExposedPorts(27017)</pre><pre>def setupSpec() {        <br>    mongo.start()<br>}</pre><p>Like the previous examples, we can create a bean to listen a ServerStartupEvent to initialize some sample data for test purpose.</p><pre>@Singleton<br>@Requires(notEnv = &quot;mock&quot;)<br>@Slf4j<br>@RequiredArgsConstructor<br>public class DataInitializer {<br>    private final CustomerRepository customerRepository;</pre><pre>    @EventListener<br>    public void onStart(ServerStartupEvent event) {<br>        log.debug(&quot;starting data initialization...&quot;);<br>        this.customerRepository.init();<br>    }<br>}</pre><p>Try to create a controller to expose the RESTful APIs.</p><pre>@Controller(&quot;/customers&quot;)<br>@RequiredArgsConstructor<br>@Slf4j<br>public class CustomerController {<br>    private final CustomerRepository customerRepository;</pre><pre>    @Get(uri = &quot;/&quot;, produces = {MediaType.APPLICATION_JSON})<br>    public Flux&lt;?&gt; all() {<br>        return this.customerRepository.findAll();<br>    }</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_JSON})<br>    public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) {<br>        return this.customerRepository.findById(id)<br>                .map(HttpResponse::ok)<br>                .switchIfEmpty(Mono.just(notFound()));<br>    }</pre><pre>    @Post(uri = &quot;/&quot;, consumes = {MediaType.APPLICATION_JSON})<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) {<br>        return this.customerRepository.insertOne(data)<br>                .map(id -&gt; created(URI.create(&quot;/customers/&quot; + id.toHexString())));<br>    }</pre><pre>    @Delete(uri = &quot;/{id}&quot;)<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {<br>        return this.customerRepository.deleteById(id)<br>                .map(deleted -&gt; {<br>                    if (deleted &gt; 0) {<br>                        return noContent();<br>                    } else {<br>                        return notFound();<br>                    }<br>                });<br>    }<br>}</pre><p>To process the ObjectId in the request path, create a TypeConverter to convert id from String type to ObjectId.</p><pre>@Singleton<br>public class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; {</pre><pre>    @Override<br>    public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) {<br>        return Optional.of(new ObjectId(object));<br>    }<br>}</pre><p>In order to serialize the id (ObjectId type) of Customer as a String in the HTTP response, create a JsonSerializer to customize the serialization process. When it is applied, the id field is serialized as a hex string instead of a JSON object.</p><pre>@Singleton<br>public class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; {<br>    <br>    @Override<br>    public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException {<br>        gen.writeString(value.toHexString());<br>    }<br>}</pre><p>Create a test for the CustomerController.</p><pre>@MicronautTest(environments = [&quot;mock&quot;])<br>class CustomerControllerSpec extends Specification {</pre><pre>    @Inject<br>    EmbeddedApplication&lt;?&gt; application</pre><pre>    @Inject<br>    @Client(&quot;/&quot;)<br>    ReactorHttpClient client</pre><pre>    @Inject<br>    CustomerRepository customerRepository</pre><pre>    def &#39;test it works&#39;() {<br>        expect:<br>        application.running<br>    }</pre><pre>    void &#39;get all customers&#39;() {<br>        given:<br>        1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null))</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers&quot;), String).log()</pre><pre>        then:<br>        //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null), Customer.of(ObjectId.get(), &quot;Rose&quot;, 20, null))<br>        StepVerifier.create(resFlux)<br>        //.expectNextCount(1)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.OK<br>                    assert s.body().contains(&#39;Jack&#39;)<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;create a new customer&#39;() {<br>        given:<br>        def objId = ObjectId.get()<br>        1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId)</pre><pre>        when:<br>        def body = Customer.of(null, &quot;Jack&quot;, 40, null)<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST(&quot;/customers&quot;, body), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.CREATED<br>                    assert s.header(&quot;Location&quot;) == &#39;/customers/&#39; + objId.toHexString()<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;get customer by id &#39;() {<br>        given:<br>        1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), &quot;Jack&quot;, 40, null))</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.OK<br>                    assert s.body().contains(&#39;Jack&#39;)<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;get customer by none-existing id &#39;() {<br>        given:<br>        1 * customerRepository.findById(_) &gt;&gt; Mono.empty()</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeErrorWith(error -&gt; {<br>                    assert error instanceof HttpClientResponseException<br>                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND<br>                })<br>                .verify()<br>    }</pre><pre>    void &#39;delete customer by id &#39;() {<br>        given:<br>        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L)</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeNextWith(s -&gt; {<br>                    assert s.getStatus() == HttpStatus.NO_CONTENT<br>                })<br>                .expectComplete()<br>                .verify()<br>    }</pre><pre>    void &#39;delete customer by none-existing id &#39;() {<br>        given:<br>        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L)</pre><pre>        when:<br>        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(&quot;/customers/&quot; + ObjectId.get().toHexString()), String).log()</pre><pre>        then:<br>        StepVerifier.create(resFlux)<br>                .consumeErrorWith(error -&gt; {<br>                    assert error instanceof HttpClientResponseException<br>                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND<br>                })<br>                .verify()<br>    }</pre><pre>    @MockBean(CustomerRepository)<br>    CustomerRepository mockedCustomerRepository() {// must use explicit type declaration<br>        Mock(CustomerRepository)<br>    }<br>}</pre><p>In this test, we create a mock bean for CustomerRepository, note you have to declare type explicitly. Note, in the given block, a little different from the Mockito, it setups the assumptions and assertions in a single place.</p><p>Another great feature of Mongo is the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service.</p><p>Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage.</p><p>Firstly declare a GridFSBucket bean.</p><pre>@Factory<br>public class GridFSConfig {</pre><pre>    @Bean<br>    GridFSBucket gridFSBucket(MongoClient client) {<br>        return GridFSBuckets.create(client.getDatabase(&quot;photos&quot;))<br>                .withChunkSizeBytes(4096)<br>                //.withReadConcern(ReadConcern.MAJORITY)<br>                .withWriteConcern(WriteConcern.MAJORITY);<br>    }<br>}</pre><p>Now create a controller to handle the file upload and download.</p><pre>@Controller(&quot;/photos&quot;)<br>@RequiredArgsConstructor<br>@Slf4j<br>public class PhotoController {</pre><pre>    private final GridFSBucket bucket;</pre><pre>    @Post(uri = &quot;/&quot;, consumes = {MediaType.MULTIPART_FORM_DATA})<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) {<br>        var filename = file.getFilename();<br>        var name = file.getName();<br>        var contentType = file.getContentType();<br>        var size = file.getSize();<br>        log.debug(&quot;uploading file...\n filename:{},\n name:{},\n contentType: {},\n size: {} &quot;, filename, name, contentType, size);<br>        var options = new GridFSUploadOptions();<br>        contentType.ifPresent(c -&gt; options.metadata(new Document(&quot;contentType&quot;, c)));<br>        return Mono.from(this.bucket.uploadFromPublisher(<br>                                filename,<br>                                Mono.from(file).mapNotNull(partData -&gt; {<br>                                    try {<br>                                        return partData.getByteBuffer();<br>                                    } catch (IOException e) {<br>                                        e.printStackTrace();<br>                                    }<br>                                    return null;<br>                                }),<br>                                options<br>                        )<br>                )<br>                .map(ObjectId::toHexString)<br>                .map(id -&gt; ok(Map.of(&quot;id&quot;, id)));<br>    }</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = {MediaType.APPLICATION_OCTET_STREAM})<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) {<br>        return Mono.from(this.bucket.downloadToPublisher(id))<br>                .map(HttpResponse::ok);<br>    }</pre><pre>    @Delete(uri = &quot;/{id}&quot;)<br>    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {<br>        return Mono.from(this.bucket.delete(id))<br>                .map(v -&gt; noContent());<br>    }<br>}</pre><p>To upload a file, use bucket.uploadFromPublisher to transfer the upload data into a Gridfs bucket. To download a file, call downloadToPublisher to read data into a ByteBuffer and send the HTTP response. To remove it from the bucket, just invoke the delete method.</p><h4>Get the complete <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/album-service">source codes</a> from my Github.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9c418b403bc1" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-micronaut-applications-with-micronaut-mongo-reative-9c418b403bc1">Building Micronaut applications with Micronaut Mongo Reative</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
