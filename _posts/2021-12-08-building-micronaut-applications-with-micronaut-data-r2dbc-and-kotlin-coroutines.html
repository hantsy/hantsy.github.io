---
layout: post
title: Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines
---

<p>In this post, we will continue to explore Micronaut Data R2dbc, and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qU5tVqVsr_jHM71udRktIw.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@ling_gigi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Gigi</a> on <a href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model.</p><h3>Getting Started</h3><p>Open your browser and navigate to <a href="https://micronaut.io/launch">Micronaut Launch</a> to generate a new project skeleton for this post. Select the following items on this page.</p><ul><li>Java version: <strong>17</strong></li><li>Language: <strong>Kotlin</strong></li><li>Build tool: <strong>Gradle Kotlin</strong></li><li>Test framework: <strong>Kotest</strong></li><li>Included Features: <strong>data-r2dbc</strong>, <strong>postgres</strong>, <strong>kotlin-extension-functions</strong> etc.</li></ul><p>Click <strong>GENERATE PROJECT</strong> button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p><p>Open <em>pom.xml</em> file, add Kotlin Coroutines into the project dependencies.</p><pre>//kotlin coroutines<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core&quot;)<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor&quot;)</pre><p>The kotlinx-coroutines-reactor provides exchanges between the Reactor API and Kotlin Coroutines API.</p><p>Create an Entity mapped to a table in the database.</p><pre>@MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)<br>data class Post(<br>    @AutoPopulated//generated value UUID does not work here.<br>    @field:Id var id: UUID? = null,<br>    var title: String,<br>    var content: String,<br>    var status: Status? = Status.DRAFT,<br>    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()<br>)</pre><p>Micronaut Data R2dbc does not include a UUID ID generator strategy, here we use @AutoPopulated to generate a random UUID before persisting into database.</p><p>Create a Repository interface for Post entity.</p><pre>@R2dbcRepository(dialect = Dialect.POSTGRES)<br>interface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt;</pre><p>Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is ReactorCrudRepository. The CoroutineCrudRepository is a Kotlin Coroutines compatible Repository interface which returns a <em>suspend</em> result in the functions.</p><blockquote><em>The </em><em>@R2dbcRepository requires a </em><em>dialect here, else it will fail at the application startup.</em></blockquote><p>Similarly, JpaSpecificationExecutor has some variants for Reactive Streams, the CoroutineJpaSpecificationExecutor is ready for Kotlin Coroutines. We have created a Specificaitons to setup several criteria for query, update and delete operations, we will reuse them in this post.</p><p>Let’s move to the Controller, create a new controller class named PostController.</p><pre>@Controller(&quot;/posts&quot;)<br>class PostController(private val posts: PostRepository) {</pre><pre>    @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON])<br>    fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll())</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON])<br>    suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {<br>        val post = posts.findById(id) ?: return notFound()<br>        return ok(post)<br>    }</pre><pre>    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])<br>    suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; {<br>        val saved = posts.save(body)<br>        return created(URI.create(&quot;/posts/&quot; + saved.id))<br>    }<br>}</pre><p>It looks very similar to Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific Flow type or use a suspend function. The difference is all of these methods are executed in an coroutine context.</p><p>Now let’s try to add some sample data via a DataInitializer bean,which listens to a ServerStartUpEvent.</p><pre>@Singleton<br>class DataInitializer(private val posts: PostRepository) {</pre><pre>    @EventListener//does not support `suspend`<br>    fun onStartUp(e: ServerStartupEvent) {<br>        log.info(&quot;starting data initialization at StartUpEvent: $e&quot;)</pre><pre>        runBlocking {<br>            val deleteAll = posts.deleteAll()<br>            log.info(&quot;deleted posts: $deleteAll&quot;)</pre><pre>            val data = listOf(<br>                Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine&quot;, content = &quot;test&quot;),<br>                Post(title = &quot;Building Restful APIs with Micronaut and Kotlin Coroutine: part 2&quot;, content = &quot;test&quot;)<br>            )<br>            data.forEach { log.debug(&quot;saving: $it&quot;) }<br>            posts.saveAll(data)<br>                .onEach { log.debug(&quot;saved post: $it&quot;) }<br>                .onCompletion { log.debug(&quot;completed.&quot;) }<br>                .flowOn(Dispatchers.IO)<br>                .launchIn(this);<br>        }</pre><pre>        log.info(&quot;data initialization is done...&quot;)<br>    }</pre><pre>    companion object DataInitializer {<br>        private val log = LoggerFactory.getLogger(DataInitializer::class.java)<br>    }</pre><pre>}</pre><p>The EventListener does not support a suspend function, use a runBlocking to block the current thread and run the <em>suspend</em> functions in sequence.</p><h3>JPA Criteria API</h3><p>Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some JpaSpecificationExecutor variants for Reactive Streams API, as mentioned in previous sections, there is a CoroutineJpaSpecificationExecutor for Kotlin Coroutines.</p><p>Add jakarta-persistence-api into dependencies to provide JPA Criteria API.</p><pre>implementation(&quot;jakarta.persistence:jakarta.persistence-api:3.0.0&quot;)</pre><p>Let’s reuse Specifications we have created in the last post.</p><p>Create a test to verify the criteria defined in the Specifications.</p><pre>@MicronautTest(environments = [Environment.TEST], startApplication = false)<br>class PostRepositoryTest(<br>    private val posts: PostRepository,<br>    private val template: R2dbcOperations<br>) : StringSpec({</pre><pre>    &quot;save and find posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Mono<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                Mono.from(<br>                    status.connection.createStatement(sql)<br>                        .bind(0, &quot;test title&quot;)<br>                        .bind(1, &quot;test content&quot;)<br>                        .bind(2, &quot;DRAFT&quot;)<br>                        .execute()<br>                ).flatMap { Mono.from(it.rowsUpdated) }<br>            })<br>            .log()<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val all = posts.findAll().toList()<br>            all shouldHaveSize 1<br>            log.debug(&quot;all posts: $all&quot;)<br>            all.map { it.title }.forAny { it shouldContain &quot;test&quot; }<br>        }</pre><pre>    }</pre><pre>    &quot;find by title&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Mono<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                Mono.from(<br>                    status.connection.createStatement(sql)<br>                        .bind(0, &quot;test title&quot;)<br>                        .bind(1, &quot;test content&quot;)<br>                        .bind(2, &quot;DRAFT&quot;)<br>                        .execute()<br>                ).flatMap { Mono.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val all = posts.findAll(Specifications.titleLike(&quot;test&quot;)).toList()<br>            log.debug(&quot;all posts size:{}&quot;, all.size)<br>            all shouldHaveSize 1</pre><pre>            val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;)).toList()<br>            log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>            all2 shouldHaveSize 0<br>        }</pre><pre>    }</pre><pre>    &quot;find by keyword&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Flux<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                val statement = status.connection.createStatement(sql)<br>                statement<br>                    .bind(0, &quot;test title&quot;)<br>                    .bind(1, &quot;test content&quot;)<br>                    .bind(2, &quot;DRAFT&quot;)<br>                    .add()<br>                statement.bind(0, &quot;test2 title&quot;)<br>                    .bind(1, &quot;test2 content&quot;)<br>                    .bind(2, &quot;DRAFT&quot;)<br>                    .add()</pre><pre>                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;)).toList()<br>            log.debug(&quot;all posts size:{}&quot;, all.size)<br>            all shouldHaveSize 2</pre><pre>            val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;)).toList()<br>            log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>            all2 shouldHaveSize 1<br>        }<br>    }</pre><pre>    &quot;update posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Flux<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                val statement = status.connection.createStatement(sql)<br>                statement<br>                    .bind(0, &quot;test title&quot;)<br>                    .bind(1, &quot;test content&quot;)<br>                    .bind(2, &quot;PENDING_MODERATED&quot;)<br>                    .add()</pre><pre>                statement<br>                    .bind(0, &quot;test2 title&quot;)<br>                    .bind(1, &quot;test2 content&quot;)<br>                    .bind(2, &quot;PENDING_MODERATED&quot;)<br>                    .add()</pre><pre>                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br>            log.debug(&quot;updated posts size:{}&quot;, updated)<br>            updated shouldBe 2</pre><pre>            val all = posts.findAll().toList()<br>            all shouldHaveSize 2<br>            all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br>        }<br>    }</pre><pre>    &quot;remove posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values ($1, $2, $3)&quot;;<br>        Flux<br>            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;<br>                val statement = status.connection.createStatement(sql)<br>                statement<br>                    .bind(0, &quot;test title&quot;)<br>                    .bind(1, &quot;test content&quot;)<br>                    .bind(2, &quot;REJECTED&quot;)<br>                    .add()<br>                statement<br>                    .bind(0, &quot;test2 title&quot;)<br>                    .bind(1, &quot;test2 content&quot;)<br>                    .bind(2, &quot;DRAFT&quot;)<br>                    .add()</pre><pre>                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }<br>            })<br>            .`as` { StepVerifier.create(it) }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .consumeNextWith { it shouldBeEqualComparingTo 1 }<br>            .verifyComplete()</pre><pre>        runBlocking {<br>            val deleted = posts.deleteAll(Specifications.removeAllRejected())<br>            log.debug(&quot;deleted posts size:{}&quot;, deleted)<br>            deleted shouldBe 1</pre><pre>            val all = posts.findAll().toList()<br>            all shouldHaveSize 1<br>            all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br>        }<br>    }</pre><pre>}) {<br>    companion object {<br>        private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java)<br>    }</pre><pre>    override fun beforeEach(testCase: TestCase) {<br>        val sql = &quot;delete from posts&quot;;</pre><pre>        val latch = CountDownLatch(1)<br>        Mono<br>            .from(<br>                this.template.withConnection { conn: Connection -&gt;<br>                    Mono.from(conn.beginTransaction())<br>                        .then(Mono.from(conn.createStatement(sql).execute())<br>                            .flatMap { Mono.from(it.rowsUpdated) }<br>                            .doOnNext { log.debug(&quot;deleted rows: $it &quot;) }<br>                        )<br>                        .then(Mono.from(conn.commitTransaction()))<br>                        .doOnError { Mono.from(conn.rollbackTransaction()).then() }<br>                }<br>            )<br>            .log()<br>            .doOnTerminate { latch.countDown() }<br>            .subscribe(<br>                { data -&gt; log.debug(&quot;deleted posts: $data &quot;) },<br>                { error -&gt; log.error(&quot;error of cleaning posts: $error&quot;) },<br>                { log.info(&quot;done&quot;) }<br>            )</pre><pre>        latch.await(5000, TimeUnit.MILLISECONDS)<br>    }<br>}</pre><p>We converted the existing Jdbc version to R2dbc, there are some mainly difference.</p><ul><li>Similar to the blocking TransactionOperations, R2dbcOperations provides withConnection and withTransaction to wrap data operations within a connection or transaction boundary.</li><li>R2dbc Connection is based on ReactiveStreams API.</li><li>When binding parameters to the SQL statement, the parameter indices start with <strong>0</strong>.</li><li>The SQL parameter placeholders are dependent on the database itself, for example, Postgres use $1, $2...</li></ul><h3>Testing Controller</h3><p>In this post, we still use Kotest as testing framework, as you see in the above PostRepositoryTest, we use a runBlocking to wrap the coroutines execution in a blocking context.</p><p>The kotlinx-coroutines-test provides some helpers to simplify the testing of Kotlin Coroutines, eg. runBlockingTest, etc. Add kotlinx-coroutines-test into the test dependencies.</p><pre>//gradle.properties<br>kotlinCoVersion=1.6.0-RC</pre><pre>//build.gradle.kt<br>val kotlinCoVersion=project.properties.get(&quot;kotlinCoVersoin&quot;)</pre><pre>//update versions of kotlin coroutines<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}&quot;)<br>implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}&quot;)</pre><pre>testImplementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}&quot;)</pre><blockquote><em>There is </em><a href="https://stackoverflow.com/questions/70243380/test-kotlin-coroutines-with-runblockingtest-failed"><em>an issue</em></a><em> to use </em><em>runBlockingTest in a test, make sure you are using the latest 1.6.0-RC, and use </em><em>runTest instead.</em></blockquote><p>Similar to the runBlocking, you can use runTest to wrap the testing functionality.</p><pre>@Test<br>fun `test GET all posts endpoint with runTest`() = runTest {<br>    val response = client.exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java).awaitSingle()<br>    response.status shouldBe HttpStatus.OK<br>    response.body()!!.map { it.title }.forAny {<br>        it shouldContain &quot;Micronaut&quot;<br>    }<br>}</pre><blockquote><em>The </em><em>runBlockingTest is deprecated in the latest 1.6.0 version of Kotlin Coroutines.</em></blockquote><p>We can also mock the repository when testing controllers, as we’ve done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as coEvery, coVerify, etc.</p><pre>@MicronautTest(environments = [&quot;mock&quot;])<br>class PostControllerTest(<br>    private val postRepository: PostRepository,<br>    @Client(&quot;/&quot;) private var client: HttpClient<br>) : FunSpec({</pre><pre>    test(&quot;test get posts endpoint&quot;) {<br>        val posts = getMock(postRepository)<br>        coEvery { posts.findAll() }<br>            .returns(<br>                flowOf(<br>                    Post(<br>                        id = UUID.randomUUID(),<br>                        title = &quot;test title&quot;,<br>                        content = &quot;test content&quot;,<br>                        status = Status.DRAFT,<br>                        createdAt = LocalDateTime.now()<br>                    )<br>                )<br>            )<br>        val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java)</pre><pre>        response.status shouldBe HttpStatus.OK<br>        response.body()!![0].title shouldBe &quot;test title&quot;</pre><pre>        coVerify(exactly = 1) { posts.findAll() }<br>    }<br>}) {<br>    @MockBean(PostRepository::class)<br>    fun mockedPostRepository() = mockk&lt;PostRepository&gt;()<br>}</pre><p>Firstly, create a mock bean for PostRepository , then do stubbing with a coEvery and verify the calls in the mocks with coVerify clause.</p><h4>Get the complete <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/r2dbc-kotlin-co">source codes</a> from my Github.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a1416db5a7d0" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-micronaut-applications-with-micronaut-data-r2dbc-and-kotlin-coroutines-a1416db5a7d0">Building Micronaut applications with Micronaut Data R2dbc and Kotlin Coroutines</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
