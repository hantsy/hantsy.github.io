---
layout: post
title: Building GraphQL APIs with Eclipse Vertx
---

<p>We have discussed GraphQL in a former <a href="https://itnext.io/building-graphql-apis-with-quarkus-dbbf23f897df">Quarkus GraphQL post</a>. In this post, we will explore the GraphQL support in Eclipse Vertx.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*m_nulmhV7cbLfrp0iAmbcg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@yangshuo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Yang Shuo</a> on <a href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><blockquote><em>Quarkus also includes an alternative GraphQL extension which use the Eclipse Vertx GraphQL feature.</em></blockquote><p>Follow the steps in the <a href="https://itnext.io/building-restful-apis-with-eclipse-vertx-4ce89d8eeb74">Building RESTful APIs with Eclipse Vertx</a> and create a new Eclipse Vertx project, do not forget to add <em>GraphQL</em> into <strong>Dependencies</strong>.</p><p>Or add the following dependency into the existing <em>pom.xml</em> file directly.</p><pre>&lt;dependency&gt;<br>     &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>     &lt;artifactId&gt;vertx-web-graphql&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h4>Checkout the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql">complete sample codes from my Github</a>.</h4><p>Vertx provides a specific GraphQLHandler to handle GraphQL request from client.</p><p>Fill the MainVerticle with the following content.</p><pre>@Slf4j<br>public class MainVerticle extends AbstractVerticle {</pre><pre>    static {<br>        log.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;);<br>        var objectMapper = DatabindCodec.mapper();<br>        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>        objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br>        objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</pre><pre>        JavaTimeModule module = new JavaTimeModule();<br>        objectMapper.registerModule(module);<br>    }</pre><pre>    @Override<br>    public void start(Promise&lt;Void&gt; startPromise) throws Exception {<br>        log.info(&quot;Starting HTTP server...&quot;);<br>        //setupLogging();</pre><pre>        //Create a PgPool instance<br>        var pgPool = pgPool();</pre><pre>        // instantiate repos<br>        var postRepository = new PostRepository(pgPool);<br>        var commentRepository = new CommentRepository(pgPool);<br>        var authorRepository = new AuthorRepository(pgPool);</pre><pre>        // Initializing the sample data<br>        var initializer = new DataInitializer(postRepository, commentRepository, authorRepository);<br>        initializer.run();</pre><pre>        //assemble PostService<br>        var postService = new PostService(postRepository, commentRepository, authorRepository);<br>        var authorService = new AuthorService(authorRepository);</pre><pre>        // assemble DataLoaders<br>        var dataLoaders = new DataLoaders(authorService, postService);</pre><pre>        //assemble DataFetcher<br>        var dataFetchers = new DataFetchers(postService);</pre><pre>        // setup GraphQL<br>        GraphQL graphQL = setupGraphQLJava(dataFetchers);</pre><pre>        // Configure routes<br>        var router = setupRoutes(graphQL, dataLoaders);</pre><pre>        // enable GraphQL Websocket Protocol<br>        HttpServerOptions httpServerOptions = new HttpServerOptions()<br>            .addWebSocketSubProtocol(&quot;graphql-ws&quot;);<br>        // Create the HTTP server<br>        vertx.createHttpServer(httpServerOptions)<br>            // Handle every request using the router<br>            .requestHandler(router)<br>            // Start listening<br>            .listen(8080)<br>            // Print the port<br>            .onSuccess(server -&gt; {<br>                startPromise.complete();<br>                log.info(&quot;HTTP server started on port &quot; + server.actualPort());<br>            })<br>            .onFailure(event -&gt; {<br>                startPromise.fail(event);<br>                log.info(&quot;Failed to start HTTP server:&quot; + event.getMessage());<br>            })<br>        ;<br>    }</pre><pre>    //create routes<br>    private Router setupRoutes(GraphQL graphQL, DataLoaders dataLoaders) {</pre><pre>        // Create a Router<br>        Router router = Router.router(vertx);</pre><pre>        // register BodyHandler globally.<br>        router.route().handler(BodyHandler.create());</pre><pre>        // register GraphQL Subscription websocket handler.<br>        ApolloWSOptions apolloWSOptions = new ApolloWSOptions();<br>        router.route(&quot;/graphql&quot;).handler(<br>            ApolloWSHandler.create(graphQL, apolloWSOptions)<br>                .connectionInitHandler(connectionInitEvent -&gt; {<br>                    JsonObject payload = connectionInitEvent.message().content().getJsonObject(&quot;payload&quot;);<br>                    log.info(&quot;connection init event: {}&quot;, payload);<br>                    if (payload != null &amp;&amp; payload.containsKey(&quot;rejectMessage&quot;)) {<br>                        connectionInitEvent.fail(payload.getString(&quot;rejectMessage&quot;));<br>                        return;<br>                    }<br>                    connectionInitEvent.complete(payload);<br>                })<br>                //.connectionHandler(event -&gt; log.info(&quot;connection event: {}&quot;, event))<br>                //.messageHandler(msg -&gt; log.info(&quot;websocket message: {}&quot;, msg.content().toString()))<br>                //.endHandler(event -&gt; log.info(&quot;end event: {}&quot;, event))<br>        );</pre><pre>        GraphQLHandlerOptions options = new GraphQLHandlerOptions()<br>            // enable multipart for file upload.<br>            .setRequestMultipartEnabled(true)<br>            .setRequestBatchingEnabled(true);<br>        // register `/graphql` for GraphQL handler<br>        // alternatively, use `router.route()` to enable GET and POST http methods<br>        router.post(&quot;/graphql&quot;)<br>            .handler(<br>                GraphQLHandler.create(graphQL, options)<br>                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))<br>                //.locale()<br>                //.queryContext()<br>            );</pre><pre>        // register `/graphiql` endpoint for the GraphiQL UI<br>        GraphiQLHandlerOptions graphiqlOptions = new GraphiQLHandlerOptions()<br>            .setEnabled(true);<br>        router.get(&quot;/graphiql/*&quot;).handler(GraphiQLHandler.create(graphiqlOptions));</pre><pre>        router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;));</pre><pre>        return router;<br>    }</pre><pre>    private Function&lt;RoutingContext, DataLoaderRegistry&gt; buildDataLoaderRegistry(DataLoaders dataLoaders) {<br>        DataLoaderRegistry registry = new DataLoaderRegistry();<br>        registry.register(&quot;commentsLoader&quot;, dataLoaders.commentsLoader());<br>        registry.register(&quot;authorsLoader&quot;, dataLoaders.authorsLoader());<br>        return rc -&gt; registry;<br>    }</pre><pre>    @SneakyThrows<br>    private GraphQL setupGraphQLJava(DataFetchers dataFetchers) {<br>        TypeDefinitionRegistry typeDefinitionRegistry = buildTypeDefinitionRegistry();<br>        RuntimeWiring runtimeWiring = buildRuntimeWiring(dataFetchers);<br>        GraphQLSchema graphQLSchema = buildGraphQLSchema(typeDefinitionRegistry, runtimeWiring);<br>        return buildGraphQL(graphQLSchema);<br>    }</pre><pre>    private GraphQL buildGraphQL(GraphQLSchema graphQLSchema) {<br>        return GraphQL.newGraphQL(graphQLSchema)<br>            .defaultDataFetcherExceptionHandler(new CustomDataFetchingExceptionHandler())<br>            //.queryExecutionStrategy()<br>            //.mutationExecutionStrategy()<br>            //.subscriptionExecutionStrategy()<br>            //.instrumentation()<br>            .build();<br>    }</pre><pre>    private GraphQLSchema buildGraphQLSchema(TypeDefinitionRegistry typeDefinitionRegistry, RuntimeWiring runtimeWiring) {<br>        SchemaGenerator schemaGenerator = new SchemaGenerator();<br>        GraphQLSchema graphQLSchema = schemaGenerator.makeExecutableSchema(typeDefinitionRegistry, runtimeWiring);<br>        return graphQLSchema;<br>    }</pre><pre>    private TypeDefinitionRegistry buildTypeDefinitionRegistry() throws IOException, URISyntaxException {<br>        var schema = Files.readString(Paths.get(getClass().getResource(&quot;/schema/schema.graphql&quot;).toURI()));<br>        //String schema = vertx.fileSystem().readFileBlocking(&quot;/schema/schema.graphql&quot;).toString();</pre><pre>        SchemaParser schemaParser = new SchemaParser();<br>        TypeDefinitionRegistry typeDefinitionRegistry = schemaParser.parse(schema);<br>        return typeDefinitionRegistry;<br>    }</pre><pre>    private RuntimeWiring buildRuntimeWiring(DataFetchers dataFetchers) {<br>        return newRuntimeWiring()<br>            // the following codes are moved to CodeRegistry, the central place to configure the execution codes.<br>            /*<br>            .wiringFactory(new WiringFactory() {<br>                @Override<br>                public DataFetcher&lt;Object&gt; getDefaultDataFetcher(FieldWiringEnvironment environment) {<br>                    return VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName());<br>                }<br>            })<br>            .type(&quot;Query&quot;, builder -&gt; builder<br>                .dataFetcher(&quot;postById&quot;, dataFetchers.getPostById())<br>                .dataFetcher(&quot;allPosts&quot;, dataFetchers.getAllPosts())<br>            )<br>            .type(&quot;Mutation&quot;, builder -&gt; builder.dataFetcher(&quot;createPost&quot;, dataFetchers.createPost()))<br>            .type(&quot;Post&quot;, builder -&gt; builder<br>                .dataFetcher(&quot;author&quot;, dataFetchers.authorOfPost())<br>                .dataFetcher(&quot;comments&quot;, dataFetchers.commentsOfPost())<br>            )<br>            */<br>            .codeRegistry(buildCodeRegistry(dataFetchers))<br>            .scalar(Scalars.localDateTimeType())<br>            .scalar(Scalars.uuidType())<br>            .scalar(UploadScalar.build())// handling `Upload` scalar<br>            .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring())<br>            .build();<br>    }</pre><pre>    private GraphQLCodeRegistry buildCodeRegistry(DataFetchers dataFetchers) {<br>        return GraphQLCodeRegistry.newCodeRegistry()<br>            .dataFetchers(&quot;Query&quot;, Map.of(<br>                &quot;postById&quot;, dataFetchers.getPostById(),<br>                &quot;allPosts&quot;, dataFetchers.getAllPosts()<br>            ))<br>            .dataFetchers(&quot;Mutation&quot;, Map.of(<br>                &quot;createPost&quot;, dataFetchers.createPost(),<br>                &quot;upload&quot;, dataFetchers.upload(),<br>                &quot;addComment&quot;, dataFetchers.addComment()<br>            ))<br>            .dataFetchers(&quot;Subscription&quot;, Map.of(<br>                &quot;commentAdded&quot;, dataFetchers.commentAdded()<br>            ))<br>            .dataFetchers(&quot;Post&quot;, Map.of(<br>                &quot;author&quot;, dataFetchers.authorOfPost(),<br>                &quot;comments&quot;, dataFetchers.commentsOfPost()<br>            ))<br>            //.typeResolver()<br>            //.fieldVisibility()<br>            .defaultDataFetcher(environment -&gt; VertxPropertyDataFetcher.create(environment.getFieldDefinition().getName()))<br>            .build();<br>    }</pre><pre>    private PgPool pgPool() {<br>        PgConnectOptions connectOptions = new PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;);</pre><pre>        // Pool Options<br>        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>        // Create the pool from the data object<br>        PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>        return pool;<br>    }</pre><pre>}</pre><p>The start method is similar to the one in the previous posts, but here it enabled <em>graphql-ws</em> WebSocket sub protocol to activate GraphQL <em>Subscription</em> support.</p><p>In the <em>setupRoutes</em> method, it adds the route <em>/graphql</em> to use GraphQLHanlder to handle the HTTP request and enable WebSocket support via <em>/graphql</em> endpoint, also adds route <em>/graphiql</em> to activate GraphiQL interactive Web UI.</p><p>As you see, the following is used to create a GraphQLHandler instance.</p><pre>GraphQLHandler.create(graphQL, options)<br>                    .dataLoaderRegistry(buildDataLoaderRegistry(dataLoaders))</pre><p>It requires a GraphQL instance and optional options to initialize a GraphQL instance.</p><p>To build a GraphQL instance, it requires a GraphQLSchema which depends on the following two essential objects:</p><ul><li>A TypeDefinitionRegistry to parse the graphql scheme definitions from files, see the above buildTypeDefinitionRegistry method.</li><li>A RuntimeWiring instance to assemble runtime handler to serve the GraphQL request, see the above buildRuntimeWiring method.</li></ul><p>In the GraphQLHandler, register the global data loaders which will be instantiated in every request. It is used to decrease the frequency of executing queries in a N+1 query and improve the application performance.</p><p>Let’s have a look at the graphql schema file under the <em>main/resources/schema/schema.graphql</em> folder.</p><pre>directive @uppercase on FIELD_DEFINITION</pre><pre>scalar LocalDateTime<br>scalar UUID<br>scalar Upload</pre><pre>type Post {<br>    id: ID!<br>    title: String! @uppercase<br>    content: String<br>    comments: [Comment]<br>    status: PostStatus<br>    createdAt: LocalDateTime<br>    authorId: String<br>    author: Author<br>}</pre><pre>type Author {<br>    id: ID!<br>    name: String!<br>    email: String!<br>    createdAt: LocalDateTime<br>    posts: [Post]<br>}<br>type Comment {<br>    id: ID!<br>    content: String!<br>    createdAt: LocalDateTime<br>    postId: String!<br>}</pre><pre>input CreatePostInput {<br>    title: String!<br>    content: String!<br>}</pre><pre>input CommentInput {<br>    postId: String!<br>    content: String!<br>}</pre><pre>type Query {<br>    allPosts: [Post!]!<br>    postById(postId: String!): Post<br>}</pre><pre>type Mutation {<br>    createPost(createPostInput: CreatePostInput!): UUID!<br>    upload(file: Upload!): Boolean<br>    addComment(commentInput: CommentInput!): UUID!<br>}</pre><pre>type Subscription{<br>    commentAdded: Comment!<br>}</pre><pre>enum PostStatus {<br>    DRAFT<br>    PENDING_MODERATION<br>    PUBLISHED<br>}</pre><p>In this schema file, we declare 3 top level types: <em>Query</em>, <em>Mutation</em> and <em>Subscription</em> which presents the basic operations defined in our application. The Post and Comment are generic types to present the types used in the returned response. The CreatePostInput and CommentInput are input arguments presents the payload of the graphql request. The <em>scalar</em> keyword defines custom scalar types. The <em>directive</em> defines custom directive <em>@uppercase</em> applied on field.</p><p>In the MainVerticle.buildCodeRegistry method, it assembles data fetchers according to the coordinates of the types defined in the schema definitions.</p><p>For example, when performing a <em>Query</em>: postById, it will execute the dataFetchers.postById defined in the buildCodeRegistry method.</p><pre>.dataFetchers(&quot;Query&quot;, Map.of(<br>                &quot;postById&quot;, dataFetchers.getPostById(),<br>    ...</pre><p>Looking into the buildRuntimeWiring, it also declars the Scalar, Directive, etc.</p><p>The following is an example of custom Scalar type.</p><pre>// LocalDateTimeScalar<br>public class LocalDateTimeScalar implements Coercing&lt;LocalDateTime, String&gt; {<br>    @Override<br>    public String serialize(Object dataFetcherResult) throws CoercingSerializeException {<br>        if (dataFetcherResult instanceof LocalDateTime) {<br>            return ((LocalDateTime) dataFetcherResult).format(DateTimeFormatter.ISO_DATE_TIME);<br>        } else {<br>            throw new CoercingSerializeException(&quot;Not a valid DateTime&quot;);<br>        }<br>    }</pre><pre>    @Override<br>    public LocalDateTime parseValue(Object input) throws CoercingParseValueException {<br>        return LocalDateTime.parse(input.toString(), DateTimeFormatter.ISO_DATE_TIME);<br>    }</pre><pre>    @Override<br>    public LocalDateTime parseLiteral(Object input) throws CoercingParseLiteralException {<br>        if (input instanceof StringValue) {<br>            return LocalDateTime.parse(((StringValue) input).getValue(), DateTimeFormatter.ISO_DATE_TIME);<br>        }</pre><pre>        throw new CoercingParseLiteralException(&quot;Value is not a valid ISO date time&quot;);<br>    }<br>}<br>//Scalars<br>public class Scalars {</pre><pre>    public static GraphQLScalarType localDateTimeType() {<br>        return GraphQLScalarType.newScalar()<br>                .name(&quot;LocalDateTime&quot;)<br>                .description(&quot;LocalDateTime type&quot;)<br>                .coercing(new LocalDateTimeScalar())<br>                .build();<br>    }<br>}</pre><pre>//register custom scalar type in the MainVertcle buildRuntimeWiring<br>newRuntimeWiring()<br>    ...<br>    .scalar(Scalars.localDateTimeType())</pre><p>Vertx GraphQL provide a UploadScalar for uploading files. Check out the source codes and explore the UUIDScalar implementation yourself.</p><p>Similarly register a custom <em>Directive</em> in the buildRuntimeWiring, eg. the @uppercase directive.</p><pre>//UpperCaseDirectiveWiring<br>public class UpperCaseDirectiveWiring implements SchemaDirectiveWiring {<br>    @Override<br>    public GraphQLFieldDefinition onField(SchemaDirectiveWiringEnvironment&lt;GraphQLFieldDefinition&gt; env) {</pre><pre>        var field = env.getElement();<br>        var parentType = env.getFieldsContainer();</pre><pre>        var originalDataFetcher = env.getCodeRegistry().getDataFetcher(parentType, field);<br>        var dataFetcher = DataFetcherFactories.wrapDataFetcher(originalDataFetcher,<br>                (dataFetchingEnvironment, value) -&gt; {<br>                    if (value instanceof String s) {<br>                        return s.toUpperCase();<br>                    }<br>                    return value;<br>                }<br>        );</pre><pre>        env.getCodeRegistry().dataFetcher(parentType, field, dataFetcher);<br>        return field;<br>    }<br>}<br>//register custom scalar directive in the MainVertcle buildRuntimeWiring<br>newRuntimeWiring()<br>    ...<br>    .directive(&quot;uppercase&quot;, new UpperCaseDirectiveWiring())</pre><p>Let’s move on to the data fetchers which are responsible for resolving the type values at runtime.</p><p>For example, in the GraphiQL UI page, try to send a predefined query like this.</p><pre>query {<br>    allPosts{<br>        id<br>        title<br>        content<br>        author{ name }<br>        comments{ content }<br>    }<br>}</pre><p>It means, it will perform an allPosts <em>Query</em>, and returns a Post array, each item includes fields id, title and content and an author object with an exact name field, and a comments array each item includes a single content field.</p><p>When the GraphQL request is sent, GraphQLHandler will handle it.</p><ul><li>Validate the GraphQL request and ensure it follows schema type definitions.</li><li>Locate the data fetchers via type coordinates, <em>Query</em> and <em>allPosts</em>.</li><li>Assemble the returned values according to the request format.</li><li>When resolving author field, it will try to locate <em>Post</em> and <em>author</em> to find the existing data fetcher (dataFetchers.authorOfPost()) to handle it. Similarly it handles <em>comments</em> via dataFetchers.commentsOfPost().</li><li>Other generic fields, use the default data fetcher to return the value of the corresponding field of this Post directly.</li></ul><p>The Mutation handling is similar to Query, but it is designed for performing some mutations. For example, use Mutation createPost to create a new post, it accepts a CreatePostInput input argument, then delegate to dataFecthers.createPost to handle it.</p><p>The file uploading is defined by <a href="https://github.com/jaydenseric/graphql-multipart-request-spec">GraphQL multipart request specification</a>, not part of the standard GraphQL spec.</p><p>The following is the data fetcher to handle the file uploading.</p><pre>public DataFetcher&lt;Boolean&gt; upload() {<br>    return (DataFetchingEnvironment dfe) -&gt; {</pre><pre>        FileUpload upload = dfe.getArgument(&quot;file&quot;);<br>        log.info(&quot;name: {}&quot;, upload.name());<br>        log.info(&quot;file name: {}&quot;, upload.fileName());<br>        log.info(&quot;uploaded file name: {}&quot;, upload.uploadedFileName());<br>        log.info(&quot;content type: {}&quot;, upload.contentType());<br>        log.info(&quot;charset: {}&quot;, upload.charSet());<br>        log.info(&quot;size: {}&quot;, upload.size());<br>        //            String fileContent = Vertx.vertx().fileSystem().readFileBlocking(upload.uploadedFileName()).toString();<br>        //            log.info(&quot;file content: {}&quot;, fileContent);<br>        return true;<br>    };<br>}</pre><p>Vertx creates a temporary file for the uploaded file, it is easy to read the files from local file system.</p><p>For the Subscription, it is used for tracking the updates from the backend, such as stock trade news, notification, etc. GraphQL Java requires that it has to return a ReactiveStreams Publisher type.</p><p>The following is an example of sending notification when a comment is added.</p><pre>public VertxDataFetcher&lt;UUID&gt; addComment() {<br>    return VertxDataFetcher.create((DataFetchingEnvironment dfe) -&gt; {<br>        var commentInputArg = dfe.getArgument(&quot;commentInput&quot;);<br>        var jacksonMapper = DatabindCodec.mapper();<br>        var input = jacksonMapper.convertValue(commentInputArg, CommentInput.class);<br>        return this.posts.addComment(input)<br>            .onSuccess(id -&gt; this.posts.getCommentById(id.toString())<br>                       .onSuccess(c -&gt; subject.onNext(c)));<br>    });<br>}</pre><pre>private ReplaySubject&lt;Comment&gt; subject = ReplaySubject.create(1);</pre><pre>public DataFetcher&lt;Publisher&lt;Comment&gt;&gt; commentAdded() {<br>    return (DataFetchingEnvironment dfe) -&gt; {<br>        ApolloWSMessage message = dfe.getContext();<br>        log.info(&quot;msg: {}, connectionParams: {}&quot;, message.content(), message.connectionParams());<br>        ConnectableObservable&lt;Comment&gt; connectableObservable = subject.share().publish();<br>        connectableObservable.connect();<br>        log.info(&quot;connect to `commentAdded`&quot;);<br>        return connectableObservable.toFlowable(BackpressureStrategy.BUFFER);<br>    };<br>}</pre><p>The above example uses RxJava 3’s ReplaySubject as a processor to emit the message to the connected clients. We have configured in MainVerticle to use WebSocket protocol to handle Subscription. In next post, we will create a WebSocket client to consume this message endpoints.</p><p>Here we skip other codes, which are similar to the former Quarkus GraphQL post, check out the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql">complete sample codes from my Github</a> and explore it yourself.</p><p>Not like Quarkus, Eclipse Vertx does not provides a specific GraphQL client to simplify the GraphQL request in Java.</p><p>To write tests for the GraphQL APIs, you have to switch to use the generic Vertx Http Client. And you have to know well about <a href="https://graphql.org/learn/serving-over-http/">GraphQL over HTTP specification</a>.</p><p>The following is an example of testing <em>allPosts</em> query and <em>createPost</em> mutation using Vertx HttpClient.</p><pre>@ExtendWith(VertxExtension.class)<br>@Slf4j<br>public class TestMainVerticle {</pre><pre>    HttpClient client;</pre><pre>    @BeforeEach<br>    void setup(Vertx vertx, VertxTestContext testContext) {<br>        vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow()));<br>        var options = new HttpClientOptions()<br>            .setDefaultHost(&quot;localhost&quot;)<br>            .setDefaultPort(8080);<br>        client = vertx.createHttpClient(options);<br>    }</pre><pre>    @Test<br>    void getAllPosts(Vertx vertx, VertxTestContext testContext) throws Throwable {<br>        var query = &quot;&quot;&quot;<br>            query {<br>                allPosts{<br>                    id<br>                    title<br>                    content<br>                    author{ name }<br>                    comments{ content }<br>                }<br>            }&quot;&quot;&quot;;<br>        client.request(HttpMethod.POST, &quot;/graphql&quot;)<br>            .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                .putHeader(&quot;Accept&quot;, &quot;application/json&quot;)<br>                .send(Json.encode(Map.of(&quot;query&quot;, query)))//have to use Json.encode to convert objects to json string.<br>                .flatMap(HttpClientResponse::body)<br>            )<br>            .onComplete(<br>                testContext.succeeding(<br>                    buffer -&gt; testContext.verify(<br>                        () -&gt; {<br>                            log.info(&quot;buf: {}&quot;, buffer.toString());<br>                            JsonArray array = buffer.toJsonObject()<br>                                .getJsonObject(&quot;data&quot;)<br>                                .getJsonArray(&quot;allPosts&quot;);<br>                            assertThat(array.size()).isGreaterThan(0);</pre><pre>                            var titles = array.getList().stream().map(o -&gt; ((Map&lt;String, Object&gt;) o).get(&quot;title&quot;)).toList();<br>                            assertThat(titles).allMatch(s -&gt; ((String) s).startsWith(&quot;DGS POST&quot;));<br>                            testContext.completeNow();<br>                        }<br>                    )<br>                )<br>            );<br>    }</pre><pre>    @Test<br>    void createPost(Vertx vertx, VertxTestContext testContext) throws Throwable {<br>        String TITLE = &quot;My post created by Vertx HttpClient&quot;;<br>        //var creatPostQuery = &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;;<br>        var creatPostQuery = &quot;&quot;&quot;<br>            mutation newPost($input:CreatePostInput!){<br>                createPost(createPostInput:$input)<br>            }&quot;&quot;&quot;;<br>        client.request(HttpMethod.POST, &quot;/graphql&quot;)<br>            .flatMap(req -&gt; {<br>                    String encodedJson = Json.encode(Map.of(<br>                        &quot;query&quot;, creatPostQuery,<br>                        &quot;variables&quot;, Map.of(<br>                            &quot;input&quot;, Map.of(<br>                                &quot;title&quot;, TITLE,<br>                                &quot;content&quot;, &quot;content of my post&quot;<br>                            )<br>                        )<br>                    ));<br>                    log.info(&quot;sending encoded json: {}&quot;, encodedJson);<br>                    return req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                        .putHeader(&quot;Accept&quot;, &quot;application/json&quot;)<br>                        .send(encodedJson)//have to use Json.encode to convert objects to json string.<br>                        .flatMap(HttpClientResponse::body);<br>                }<br>            )<br>            .flatMap(buf -&gt; {<br>                Object id = buf.toJsonObject().getJsonObject(&quot;data&quot;).getValue(&quot;createPost&quot;);</pre><pre>                log.info(&quot;created post: {}&quot;, id);<br>                assertThat(id).isNotNull();</pre><pre>                var postById = &quot;&quot;&quot;<br>                    query post($id:String!) {<br>                        postById(postId:$id){id title content}<br>                    }&quot;&quot;&quot;;</pre><pre>                return client.request(HttpMethod.POST, &quot;/graphql&quot;)<br>                    .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                        .putHeader(&quot;Accept&quot;, &quot;application/json&quot;)<br>                        .send(Json.encode(Map.of(<br>                            &quot;query&quot;, postById,<br>                            &quot;variables&quot;, Map.of(&quot;id&quot;, id.toString())<br>                        )))//have to use Json.encode to convert objects to json string.<br>                        .flatMap(HttpClientResponse::body)<br>                    );<br>            })<br>            .onComplete(<br>                testContext.succeeding(<br>                    buffer -&gt; testContext.verify(<br>                        () -&gt; {<br>                            log.info(&quot;buf: {}&quot;, buffer.toString());<br>                            String title = buffer.toJsonObject()<br>                                .getJsonObject(&quot;data&quot;)<br>                                .getJsonObject(&quot;postById&quot;)<br>                                .getString(&quot;title&quot;);<br>                            assertThat(title).isEqualTo(TITLE.toUpperCase());<br>                            testContext.completeNow();<br>                        }<br>                    )<br>                )<br>            );<br>    }<br>}</pre><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql">sample codes from my Github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2f3a4e584370" width="1" height="1" alt="">
