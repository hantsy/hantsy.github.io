---
layout: post
title: Building a Vertx application with Kotlin Coroutines
---

<p>In <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/kotlin.md">the last post</a>, we rebuild the example application with Kotlin language. Besides basic language support, Eclipse Vertx’s Kotlin bindings provides Kotlin extensions to convert Vertx’s Future to Kotlin Coroutines.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zi-wSXYA9KsoR2ALXGWNwg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@yuzkiwww?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Yuzki Wang</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Follow the steps in the last post to create a Kotlin based Vertx project, we will rebuild the project with Kotlin Coroutines.</p><p>Firstly let’s have a look at the PostRepository.</p><pre>class PostRepository(private val client: PgPool) {</pre><pre>    suspend fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;)<br>        .execute()<br>        .map { rs: RowSet&lt;Row?&gt; -&gt;<br>            StreamSupport.stream(rs.spliterator(), false)<br>                .map { mapFun(it!!) }<br>                .toList()<br>        }.await()<br></pre><pre>    suspend fun findById(id: UUID): Post? = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;)<br>        .execute(Tuple.of(id))<br>        .map { it.iterator() }<br>        .map { if (it.hasNext()) mapFun(it.next()) else null }<br>        .await()<br></pre><pre>    suspend fun save(data: Post) =<br>        client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;)<br>            .execute(Tuple.of(data.title, data.content))<br>            .map { it.iterator().next().getUUID(&quot;id&quot;) }<br>            .await()<br></pre><pre>    suspend fun saveAll(data: List&lt;Post&gt;): Int? {<br>        val tuples = data.map { Tuple.of(it.title, it.content) }</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .executeBatch(tuples)<br>            .map { it.rowCount() }<br>            .await()<br>    }</pre><pre>    suspend fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>        .execute(Tuple.of(data.title, data.content, data.id))<br>        .map { it.rowCount() }<br>        .await()<br></pre><pre>    suspend fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute()<br>        .map { it.rowCount() }<br>        .await()<br></pre><pre>    suspend fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>        .map { it.rowCount() }<br>        .await()</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostRepository::class.java.name)<br>        val mapFun: (Row) -&gt; Post = { row: Row -&gt;<br>            Post(<br>                row.getUUID(&quot;id&quot;),<br>                row.getString(&quot;title&quot;),<br>                row.getString(&quot;content&quot;),<br>                row.getLocalDateTime(&quot;created_at&quot;)<br>            )<br>        }</pre><pre>    }<br>}</pre><p>As you see it is almost same as the Kotlin version, but at the end line of every function it calls an await method to return a <em>suspended</em> result.</p><p>Let’s move to PostHandlers.</p><pre>class PostsHandler(val posts: PostRepository) {<br>    suspend fun all(rc: RoutingContext) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        val data = posts.findAll()<br>        rc.response().end(Json.encode(data)).await()<br>    }</pre><pre>    suspend fun getById(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        val data = posts.findById(uuid)<br>        if (data != null) {<br>            rc.response().end(Json.encode(data)).await()<br>        } else {<br>            rc.fail(404, PostNotFoundException(uuid))<br>        }<br>    }</pre><pre>    suspend fun save(rc: RoutingContext) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body)<br>        val (title, content) = body.mapTo(CreatePostCommand::class.java)<br>        val savedId = posts.save(Post(title = title, content = content))<br>        rc.response()<br>            .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;)<br>            .setStatusCode(201)<br>            .end()<br>            .await()</pre><pre>    }</pre><pre>    suspend fun update(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body))<br>        var (title, content) = body.mapTo(CreatePostCommand::class.java)</pre><pre>        var existing: Post? = posts.findById(uuid)<br>        if (existing != null) {<br>            val data: Post = existing.apply {<br>                title = title<br>                content = content<br>            }<br>            posts.update(data)<br>            rc.response().setStatusCode(204).end().await()<br>        } else {<br>            rc.fail(404, PostNotFoundException(uuid))<br>        }<br>    }</pre><pre>    suspend fun delete(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        val existing = posts.findById(uuid)<br>        if (existing != null) {<br>            rc.response().setStatusCode(204).end().await()<br>        } else {<br>            rc.fail(404, PostNotFoundException(uuid))<br>        }<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName)<br>    }<br>}</pre><p>In the above codes, it uses sequential statements instead of Future with chained functionalities</p><p>Eclipse Vertx Kotlin bindings provides a CooutineVerticle.</p><pre>class MainVerticle : CoroutineVerticle() {<br>    companion object {<br>        private val LOGGER = Logger.getLogger(MainVerticle::class.java.name)</pre><pre>        /**<br>         * Configure logging from logging.properties file.<br>         * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties<br>         * or set java.util.logging.config.file system property to locate the properties file.<br>         */<br>        @Throws(IOException::class)<br>        private fun setupLogging() {<br>            MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;)<br>                .use { f -&gt; LogManager.getLogManager().readConfiguration(f) }<br>        }</pre><pre>        init {<br>            LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;)<br>            val objectMapper = DatabindCodec.mapper()<br>            objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br>            objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            val module = JavaTimeModule()<br>            objectMapper.registerModule(module)<br>        }<br>    }</pre><pre>    override suspend fun start() {<br>        LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;)<br>        //setupLogging();</pre><pre>        //Create a PgPool instance<br>        val pgPool = pgPool()</pre><pre>        //Creating PostRepository<br>        val postRepository = PostRepository(pgPool)</pre><pre>        //Creating PostHandler<br>        val postHandlers = PostsHandler(postRepository)</pre><pre>        // Initializing the sample data<br>        val initializer = DataInitializer(pgPool)<br>        initializer.run()</pre><pre>        // Configure routes<br>        val router = routes(postHandlers)</pre><pre>        // Create the HTTP server<br>        val options = httpServerOptionsOf(idleTimeout = 5, idleTimeoutUnit = TimeUnit.MINUTES, logActivity = true)<br>        vertx.createHttpServer(options) // Handle every request using the router<br>            .requestHandler(router) // Start listening<br>            .listen(8888) // Print the port<br>            .onComplete { println(&quot;HttpSever started at ${it.result().actualPort()}&quot;) }<br>            .await()<br>    }</pre><pre>    override suspend fun stop() {<br>        super.stop()<br>    }</pre><pre>    //create routes<br>    private fun routes(handlers: PostsHandler): Router {</pre><pre>        // Create a Router<br>        val router = Router.router(vertx)<br>        // register BodyHandler globally.<br>        //router.route().handler(BodyHandler.create());</pre><pre>        router.get(&quot;/posts&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .coroutineHandler {<br>                handlers.all(it)<br>            }</pre><pre>        router.post(&quot;/posts&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .coroutineHandler {<br>                handlers.save(it)<br>            }</pre><pre>        router.get(&quot;/posts/:id&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .coroutineHandler {<br>                handlers.getById(it)<br>            }<br></pre><pre>        router.put(&quot;/posts/:id&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .coroutineHandler {<br>                handlers.update(it)<br>            }</pre><pre>        router.delete(&quot;/posts/:id&quot;)<br>            .coroutineHandler {<br>                handlers.delete(it)<br>            }</pre><pre>        router.route().failureHandler {<br>            if (it.failure() is PostNotFoundException) {<br>                it.response()<br>                    .setStatusCode(404)<br>                    .end(<br>                        json {// an example using JSON DSL<br>                            obj(<br>                                &quot;message&quot; to &quot;${it.failure().message}&quot;,<br>                                &quot;code&quot; to &quot;not_found&quot;<br>                            )<br>                        }.toString()<br>                    )<br>            }<br>        }</pre><pre>        router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) }</pre><pre>        return router<br>    }</pre><pre>    private fun pgPool(): PgPool {<br>        val connectOptions = PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;)</pre><pre>        // Pool Options<br>        val poolOptions = PoolOptions().setMaxSize(5)</pre><pre>        // Create the pool from the data object<br>        return PgPool.pool(vertx, connectOptions, poolOptions)<br>    }</pre><pre>    private fun Route.coroutineHandler(fn: suspend (RoutingContext) -&gt; Unit) = handler {<br>        launch(it.vertx().dispatcher()) {<br>            try {<br>                fn(it)<br>            } catch (e: Exception) {<br>                it.fail(e)<br>            }<br>        }<br>    }</pre><pre>}</pre><p>Currently Kotlin bindings does not provides a handler methods to accept a coroutine based RequestHandler. We create coroutineHandler extension method to overcome this issue temporarily, see issue <a href="https://github.com/vert-x3/vertx-lang-kotlin/issues/194">vert-x3/vertx-lang-kotlin #194</a>.</p><p>Let’s convert the DataIntializer to use Kotlin Coroutines.</p><pre>class DataInitializer(private val client: PgPool) {</pre><pre>    suspend fun run() {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;)<br>        val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;)<br>        val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;)<br></pre><pre>        val result = client<br>            .withTransaction { conn: SqlConnection -&gt;<br>                conn.query(&quot;DELETE FROM posts&quot;)<br>                    .execute()<br>                    .flatMap {<br>                        conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>                            .executeBatch(listOf(first, second))<br>                    }<br>                    .flatMap {<br>                        conn.query(&quot;SELECT * FROM posts&quot;)<br>                            .execute()<br>                    }</pre><pre>            }.await()</pre><pre>        result.forEach { println(it.toJson()) }<br>        LOGGER.info(&quot;Data initialization is done...&quot;)<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(DataInitializer::class.java.name)<br>    }<br>}</pre><p>Get <a href="https://github.com/hantsy/vertx-sandbox/tree/master/kotlin">the example codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c7dbb7ad893" width="1" height="1" alt="">
