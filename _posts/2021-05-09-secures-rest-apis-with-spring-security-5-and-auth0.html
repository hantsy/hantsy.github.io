---
layout: post
title: Secures REST APIs with Spring Security 5 and Auth0
---

<p>Spring Security 5 deprecated the original Spring Security OAuth module and rewrote the OAuth2/Oidc implementation, make it available as part of the core modules.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*QhbQzmBZJD2sMMlR-Cacrg.jpeg" /><figcaption><a href="https://unsplash.com/photos/SwbsW4uf1Qs">The image is from https://unsplash.com/photos/SwbsW4uf1Qs</a></figcaption></figure><p>OAuth protocol defines 4 roles, including <em>Resource Owner</em>, <em>Client</em>, <em>Authorization server</em> and <em>Resource server</em>. Imagine you are using an app in your mobile, you(<em>Resource owner</em>) authorizes the app(presents a <em>Client</em> role itself) to perform an authorization flow to get access token from the authorization server, then utilizes this token to interact with the protected resources(from <em>Resource server</em>).</p><p>Oidc is an additional supplement to enrich OAuth2 protocol. In Spring Security 5, it does not differentiate them explicitly in the API level and configuration. And nowadays most OAuth2 compatible provider supports the Oidc protocol.</p><blockquote><em>If you are new to OAuth2 and OIDC, please check the official </em><a href="https://oauth.net/2/"><em>OAuth 2 docs</em></a><em> and explore </em><a href="https://openid.net/connect/"><em>OpenId Connect</em></a><em> related specs. For impatient users, </em><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2"><em>this introductory article</em></a><em> from DigitalOcean is a good start point.</em></blockquote><p>With Spring Security 5, it is easy to set up OAuth2 <em>Client</em> and <em>Resource server</em> roles in your applications. And there is <a href="https://github.com/spring-projects-experimental/spring-authorization-server">another incubator project</a> which allow you to serve a custom <em>Authorization server</em>. In a real world application, I think it is a smart choice that choosing a mature IDP service to simplify the integration work of multiple authentication services and advanced features, for example, you want to integrate Google accounts, Facebook, Twitter and custom username/password authentication, and enable two-phases authentication in your applications. <a href="https://www.auth0.com">Auth0</a> and <a href="https://www.okta.com">Okta</a> are the leading IDP services in this area, they provide excellent administrative UI and rich SDK of all use case in your applications. In the open source world, <a href="https://www.keycloak.org/">Keycloak</a> is widely used to host a custom authentication server.</p><blockquote><em>From the official Okta blog, Auth0 has joined the Okta family. I am a little afraid Auth0 will be disappeared like Stormpath. But the Okta guys declared that Auth0 will operate as a standalone brand.</em></blockquote><p>In this post, we will use Auth0 as the authentication server role to simplify our development progress.</p><p>To demonstrate the OAuth2 flow, firstly we will create a RESTful API <em>application</em> that acts as <em>Resource server</em>. In the further post, we will create an Angular SPA client app to interact with this API backend.</p><p>There are plenty of tutorials provided on the official <a href="https://auth0.com/docs/">auth0 docs page</a>. Usually you can find the use cases matched your applications in these docs, go to the <em>Backend API</em> doc to go through the tutorial, esp. there is a <a href="https://auth0.com/docs/quickstart/backend/java-spring-security5">great tutorial for Spring Security 5</a>.</p><p>Firstly register an Auth0 account if you don’t have one before. Or login using a social network account directly. After logged in, you will find Auth0 has created a development-purpose domain for you, it categories all resources for your new application.</p><p>In the dashboard UI, expand the <em>Applications/APIs</em> in the left pane, let’s create a new API application(<em>Resource server</em> role in the OAuth2 protocol).</p><ul><li>Click the <em>Create API</em> button to start the progress.</li><li>Fill the essential fields, the <em>audience</em> field is used to identify this API, it is recommended to fill a URL like value. For example. Here I created a new API application named <em>Backend API</em>, and set the audience to <a href="https://hantsy.github.io/api"><em>https://hantsy.github.io/api</em></a>.</li></ul><p>Auth0 also provides an <em>Auth0 Management API</em> for you to access the Auth0 APIs, and for test purpose, Auth0 also created a <em>Machine to Machine</em> application automatically which allow you to interact with your own APIs.</p><p>Next let’s create our <em>Backend API</em> application. Go to <a href="https://start.spring.io">https://start.spring.io</a>, fill the required fields, and select <em>Maven</em> as build tools and <em>Java</em> as language, then add the following dependencies,</p><ul><li>Web Starter</li><li>Validation</li><li>Data JPA</li><li>Spring Security</li><li>Lombok</li></ul><p>Hit the Generate button to generate the project skeleton into an archive, download it and extract the files into your disk. Import the project into your IDEA, open the <em>pom.xml</em> file, add spring security oauth2 related dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-security-oauth2-jose&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>In this post, we are going to integrate Auth0 with Spring Security to protect the RESTful APIs, and we will focus on the security configuration for an API application. To simplify the development work, I copied the existing codes from <a href="https://github.com/hantsy/spring-webmvc-functional-sample">hantsy/spring-webmvc-functional-sample</a>, which is used to produce RESTful APIs for a simple blog application.</p><blockquote><em>For the introduction of Spring WebMvc functional programming, check </em><a href="https://hantsy.medium.com/functional-programming-in-spring-mvc-20957653da1"><em>my post published on Medium</em></a><em>.</em></blockquote><p>Declares a SecurityFilterChain bean to configure the details of Spring Security.</p><pre>@Bean<br>SecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception {<br>    return http<br>        .httpBasic(AbstractHttpConfigurer::disable)<br>        .csrf(AbstractHttpConfigurer::disable)<br>        .sessionManagement(c -&gt; c.sessionCreationPolicy(SessionCreationPolicy.STATELESS))<br>        .authorizeRequests(c -&gt; c<br>                           .antMatchers(&quot;/&quot;, &quot;/info&quot;).permitAll()<br>                           .antMatchers(HttpMethod.GET, &quot;/posts/**&quot;).permitAll()//.hasAuthority(&quot;SCOPE_read:posts&quot;)<br>                           .antMatchers(HttpMethod.POST, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;)<br>                           .antMatchers(HttpMethod.PUT, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_write:posts&quot;)<br>                           .antMatchers(HttpMethod.DELETE, &quot;/posts/**&quot;).hasAuthority(&quot;SCOPE_delete:posts&quot;)<br>                           .anyRequest().authenticated()<br>                          )<br>        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt)<br>        .build();<br>}</pre><ol><li>The oauth2ResourceServer indicates this application will work as a <em>Resource server</em> role, and it uses a JWT token to validate the incoming request.</li><li>The authorizeRequests section defines the security rules againt HTTP URI and verbs, eg. requires a write:posts permission when creating new posts.</li></ol><p>Unlike the <em>opaque</em> token, a JWT token can be simply validated by a local public key or JWK set uri prvided by the authorization server.</p><p>In Spring Security 5, a JWT token can be decoded from a configured <em>issurer_uri</em> if the auth provider implements OpenId Configuration spec, and exposes the whole OAuth2/Oidc configuration metadata such as token url, authorization server url, jwk set uri, user info uri etc. through a single url .well-known/openid-configuration.</p><p>Add the following configuration in the <em>application.properties</em>.</p><pre>spring:<br>  ...<br>  security:<br>    oauth2:<br>      resourceserver:<br>        jwt:<br>          # Replace with the domain of your Auth0 tenant.<br>          # Note the trailing slash is important!<br>          issuer-uri: <a href="https://dev-ese8241b.us.auth0.com/">https://dev-ese8241b.us.auth0.com/</a></pre><p>To check if the audience is set and included in the access token, add a custom audience validator.</p><pre>@RequiredArgsConstructor(staticName = &quot;of&quot;)<br>public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {<br>    private final String audience;<br>    <br>    public OAuth2TokenValidatorResult validate(Jwt jwt) {<br>        OAuth2Error error = new OAuth2Error(&quot;invalid_token&quot;, &quot;The required audience is missing&quot;, null);<br>        <br>        if (jwt.getAudience().contains(audience)) {<br>            return OAuth2TokenValidatorResult.success();<br>        }<br>        <br>        return OAuth2TokenValidatorResult.failure(error);<br>    }<br>}</pre><p>And add this validator in the JwtDecoder bean.</p><pre>@Bean<br>JwtDecoder jwtDecoder(OAuth2ResourceServerProperties properties, @Value(&quot;${auth0.audience}&quot;) String audience) {<br>    /*<br>        By default, Spring Security does not validate the &quot;aud&quot; claim of the token, to ensure that this token is<br>        indeed intended for our app. Adding our own validator is easy to do:<br>        */</pre><pre>    String issuerUri = properties.getJwt().getIssuerUri();<br>    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder) JwtDecoders.fromOidcIssuerLocation(issuerUri);</pre><pre>    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = AudienceValidator.of(audience);<br>    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);<br>    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);</pre><pre>    jwtDecoder.setJwtValidator(withAudience);</pre><pre>    return jwtDecoder;<br>}</pre><p>Next, let’s add some permissions configuration in the Auth0 administration dashboard.</p><p>Go to the <em>Settings</em> page of <em>Backend API</em>, and click the <em>Permissions</em> tab, add the following permissions.</p><ul><li><em>read:posts</em> — Read posts</li><li><em>write:posts</em> — Create and update Posts</li><li><em>delete:posts</em> — Delete posts</li></ul><p>Switch to <em>Machine to Machine applications</em> tab, make sure the <em>Test application</em> is enabled, and expand the configuration of this application, make sure all permissions are checked on, the hit the <strong>Update</strong> button to apply the changes.</p><p>Now switch to the <em>Test</em> tab, there is a guide for testing your API application with token, it is available in different scripts. Just copy the <strong>cURL</strong> command, and open a Unix/bash like terminal, and paste and execute it.</p><pre>$ curl --request POST \<br>&gt;   --url <a href="https://dev-ese8241b.us.auth0.com/oauth/token">https://dev-ese8241b.us.auth0.com/oauth/token</a> \<br>&gt;   --header &#39;content-type: application/json&#39; \<br>&gt;   --data &#39;{&quot;client_id&quot;:&quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1&quot;,&quot;client_secret&quot;:&quot;OknFJUkFpBe_tpFPAP2hL10NliMbCGxMRiFH_DkTxylBnZ5WjP9aq6zQOtL2L7ea&quot;,&quot;audience&quot;:&quot;https://hantsy.github.io/api&quot;,&quot;grant_type&quot;:&quot;client_credentials&quot;}&#39;<br>{&quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgzMjAsImV4cCI6MTYyMDYzNDcyMCwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.UCdmcIb8xREC_rQp3EVBx8EALzhPcpJL1Mh1n6UX-Sf2cHkSsiUFISkHHM-qa5qZ34aNxJwKfvKPnZsfcIH9xwaGMeZjHub22PwAyVscQpZBq2mPRe_28GiwMP9jtFmSPhuGQec6-K7f0410tZTEKggnX3qFDdsJBWEhnu4zeFSwn865--Lbgk52owdncMd8jp2O5olKdnkeieChGQaYsLQ_vM8JTDN-eu5hm1DEL8WcfCd_foIG6klcm_gzgHpAru6zJQb48OmWIxlL6VGQl7RqIQIfds2NBBG7xYVr_38M2cltx8EUyIcXedR-d4YG_Dfp-NJbFkpZcSs9PPTagw&quot;,&quot;scope&quot;:&quot;read:posts write:posts delete:posts&quot;,&quot;expires_in&quot;:86400,&quot;token_type&quot;:&quot;Bearer&quot;}</pre><p>Copy to the access_token, open <a href="https://jwt.io">https://jwt.io</a> page, and paste the token in the <em>Encode</em> box, you can see the decoded result.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LumBCwNgFd73at0i.png" /></figure><p>Now let’s use this token to access the protected APIs in our <em>Backend API</em> application.</p><p>Firstly start up a Postgres server. Simply run the following docker command.</p><pre>$ docker compose up postgres</pre><p>Then run the application.</p><pre>$ mvn clean spring-boot:run<br>// or <br>$ mvn clean package<br>$ java -jar ./target/xxx.jar</pre><p>Try to create a new post.</p><pre>$ curl --request POST \<br>  --url <a href="http://localhost:8080/posts">http://localhost:8080/posts</a> \<br>  --header &#39;authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlYzM1lvNzk5cC1XeFI2NHpJZ29QMyJ9.eyJpc3MiOiJodHRwczovL2Rldi1lc2U4MjQxYi51cy5hdXRoMC5jb20vIiwic3ViIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDFAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vaGFudHN5LmdpdGh1Yi5pby9hcGkiLCJpYXQiOjE2MjA1NDgwNzEsImV4cCI6MTYyMDYzNDQ3MSwiYXpwIjoiSUVYVjJNYkFpdUVrVjBKN3VmSDBCcXEyYTJZSUYzaDEiLCJzY29wZSI6InJlYWQ6cG9zdHMgd3JpdGU6cG9zdHMgZGVsZXRlOnBvc3RzIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.Rg6UqIb2kjrPg39QRLOLsvI54TUsQM4B7j_6Eb4hlxFkzHWglD-V0b5kXfgSMIcBQ-fq5oLt7Fj8etgqMMpstyx-2Ob20rbCBd-msZ1o-xGQidkQsyEM6lL6GMX7d79Vw0H9eZN8D8j8_mVoqd-wENhWsBiSp3xq8Jz6KSdslrxGnMaQKbQ2IL7dgw8Y1kJBz8FgBcUUF5k-dhMB-DDLkaLsurwcb380Qk3gMD2JW97fxQWM_mi38ufcoopSWxznDE118ng7hQXT18vFB9N_RCNaPHslsKZsE6ytiwx6kiSYvGFN5RMWIa3Dyp6Rt4UjfTLx1WO9JDtxNc4NMSPQ-g&#39; \<br>  --header &#39;Content-Type: application/json&#39; \<br>  --data &#39;{&quot;title&quot;: &quot;New Post about Spring Secrity and Auth0&quot;, &quot;content&quot;: &quot;Content of this post, TBD&quot;}&#39;</pre><p>Then list all posts and check if the post is created as expected.</p><pre>$ curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a><br>[ {<br>  &quot;id&quot; : 1,<br>  &quot;version&quot; : 0,<br>  &quot;createdDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;,<br>  &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:11.984273&quot;,<br>  &quot;title&quot; : &quot;Post one&quot;,<br>  &quot;content&quot; : &quot;content of Post one&quot;<br>}, {<br>  &quot;id&quot; : 2,<br>  &quot;version&quot; : 0,<br>  &quot;createdDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;,<br>  &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:37:12.068004&quot;,<br>  &quot;title&quot; : &quot;Post two&quot;,<br>  &quot;content&quot; : &quot;content of Post two&quot;<br>}, {<br>  &quot;id&quot; : 3,<br>  &quot;version&quot; : 0,<br>  &quot;createdDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;,<br>  &quot;lastModifiedDate&quot; : &quot;2021-05-09T16:38:27.881024&quot;,<br>  &quot;createdBy&quot; : {<br>    &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot;<br>  },<br>  &quot;lastModifiedBy&quot; : {<br>    &quot;username&quot; : &quot;IEXV2MbAiuEkV0J7ufH0Bqq2a2YIF3h1@clients&quot;<br>  },<br>  &quot;title&quot; : &quot;New Post about Spring Secrity and Auth0&quot;,<br>  &quot;content&quot; : &quot;Content of this post, TBD&quot;<br>} ]</pre><p>The <em>Backend API</em> is ready for being accessed by client applications. Now let’s explore the testing facilities provided in the Spring Security Test module to test the APIs protected by a JWT token.</p><p>Spring Security provides a simple SecurityMockMvcRequestPostProcessors.jwt to mock JWT processing and bypass the JWT decoding in a Spring MockMvc environment.</p><pre>@Test<br>public void testSave() throws Exception {</pre><pre>    given(this.posts.save(any(Post.class)))<br>        .willReturn(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build());</pre><pre>    this.mockMvc<br>        .perform(<br>        post(&quot;/posts&quot;)<br>        .with(jwt().jwt(jwtBuilder().claim(&quot;scope&quot;, &quot;write:posts&quot;).build()))<br>        .content(this.objectMapper.writeValueAsBytes(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build()))<br>        .contentType(MediaType.APPLICATION_JSON)<br>    )<br>        .andExpect(status().isCreated());</pre><pre>    verify(this.posts, times(1)).save(any(Post.class));<br>    verifyNoMoreInteractions(this.posts);<br>}</pre><pre>private Jwt.Builder jwtBuilder() {<br>    return Jwt.withTokenValue(&quot;token&quot;).header(&quot;alg&quot;, &quot;none&quot;).audience(List.of(audience));<br>}</pre><p>In an integration test, you can use the same access token generated from the <em>Test application</em> to interact with the <em>Backend API</em>. Adding the token into the HTTP header to access the APIs, the following testing codes are written with Rest Assured.</p><pre>@SpringBootTest(webEnvironment = RANDOM_PORT)<br>@Slf4j<br>public class IntegrationTests {</pre><pre>    @LocalServerPort<br>    private int port;</pre><pre>    @Autowired<br>    ObjectMapper objectMapper;</pre><pre>    @Value(&quot;${auth0.audience}&quot;)<br>    private String audience;</pre><pre>    private String token = &quot;...&quot;;<br>    <br>    @BeforeEach<br>    public void setup() {<br>        RestAssured.port = this.port;<br>    }<br></pre><pre>    @Test<br>    public void createPostWithoutToken() throws Exception {<br>        //@formatter:off<br>        given()<br>            .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;/posts&quot;)<br>        .then()<br>            .assertThat()<br>            .statusCode(HttpStatus.SC_UNAUTHORIZED);<br>        //@formatter:on<br>    }</pre><pre>    @Test<br>    public void createPost() throws Exception {<br>        //@formatter:off<br>        given()<br>            .auth().oauth2(token)<br>            .body(Post.builder().title(&quot;test&quot;).content(&quot;test content&quot;).build())<br>            .contentType(ContentType.JSON)<br>        .when()<br>            .post(&quot;/posts&quot;)<br>        .then()<br>            .assertThat()<br>            .statusCode(HttpStatus.SC_CREATED)<br>            .header(&quot;Location&quot;, notNullValue());<br>        //@formatter:on<br>    }</pre><pre>}</pre><h4><strong>Grab a copy of the source codes from </strong><a href="https://github.com/hantsy/spring-security-auth0-sample/tree/master/api"><strong>my Github</strong></a><strong>.</strong></h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=41d579ca1e27" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/secures-rest-apis-with-spring-security-5-and-auth0-41d579ca1e27">Secures REST APIs with Spring Security 5 and Auth0</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
