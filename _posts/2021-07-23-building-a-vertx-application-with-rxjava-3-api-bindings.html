---
layout: post
title: Building a Vertx application with RxJava 3 API Bindings
---

<p>Eclipse Vertx has a great codegen mechanism to bring its <em>Event Loop</em> based asynchronous programming model to diverse platforms, including other asynchronous libraries, such as <a href="https://github.com/ReactiveX/RxJava">RxJava2/3</a> and <a href="https://smallrye.io/smallrye-mutiny/">SmallRye Mutiny</a> and different languages, such as Kotlin, Kotlin Coroutines, and even Node/Typescript, PHP etc.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xUpUuE_39Cz_fbfa_G6okQ.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@justin73?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Mèng Jiǎ</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In this post, we will refactor the RESTful APIs we have done in <a href="https://itnext.io/building-restful-apis-with-eclipse-vertx-4ce89d8eeb74">the last post</a> and reimplement it with RxJava 3. RxJava 3 fully implements <a href="http://www.reactive-streams.org/">Reactive Steams specification</a>.</p><p>Open your browser, go to <a href="https://start.vertx.io">Vertx Starter</a>, create a Vertx project skeleton. Do not forget to add <em>RxJava 3</em> to the dependencies.</p><p>If you are working on an existing project, add the <em>rxjava3</em> dependency directly.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>    &lt;artifactId&gt;vertx-rx-java3&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Import the project source codes into your IDE, eg. Intellij IDEA.</p><p>Firstly let’s have a look at MainVerticle.</p><pre>import io.vertx.rxjava3.core.AbstractVerticle;<br>import io.vertx.rxjava3.ext.web.Router;<br>import io.vertx.rxjava3.ext.web.RoutingContext;<br>import io.vertx.rxjava3.ext.web.handler.BodyHandler;<br>import io.vertx.rxjava3.ext.web.validation.ValidationHandler;<br>import io.vertx.rxjava3.json.schema.SchemaParser;<br>import io.vertx.rxjava3.json.schema.SchemaRouter;<br>import io.vertx.rxjava3.pgclient.PgPool;<br>// other imports</pre><pre>@Slf4j<br>public class MainVerticle extends AbstractVerticle {</pre><pre>    @Override<br>    public Completable rxStart() {}<br>    <br>     //create routes<br>    private Router routes(PostsHandler handlers) {}<br>    <br>    private PgPool pgPool() {}<br>}</pre><p>As you see, we import all essential classes from io.vertx.rxjava3, and use RxJava 3 API instead of the Vertx built-in Future and Promise. In this implementation, we override the rxStart which return a RxJava Completable.</p><p>Ok, let’s move to the PostRepository class.</p><pre>import io.reactivex.rxjava3.core.Flowable;<br>import io.reactivex.rxjava3.core.Single;<br>import io.vertx.rxjava3.pgclient.PgPool;<br>import io.vertx.rxjava3.sqlclient.Row;<br>import io.vertx.rxjava3.sqlclient.RowSet;<br>import io.vertx.rxjava3.sqlclient.SqlResult;<br>import io.vertx.rxjava3.sqlclient.Tuple;<br>// other imports...</pre><pre>@Slf4j<br>public class PostRepository {</pre><pre>    private static Function&lt;Row, Post&gt; MAPPER = (row) -&gt;<br>        Post.of(<br>            row.getUUID(&quot;id&quot;),<br>            row.getString(&quot;title&quot;),<br>            row.getString(&quot;content&quot;),<br>            row.getLocalDateTime(&quot;created_at&quot;)<br>        );<br></pre><pre>    private final PgPool client;</pre><pre>    private PostRepository(PgPool _client) {<br>        this.client = _client;<br>    }</pre><pre>    //factory method<br>    public static PostRepository create(PgPool client) {<br>        return new PostRepository(client);<br>    }</pre><pre>    public Flowable&lt;Post&gt; findAll() {<br>        return this.client<br>            .query(&quot;SELECT * FROM posts&quot;)<br>            .rxExecute()<br>            .flattenAsFlowable(<br>                rows -&gt; StreamSupport.stream(rows.spliterator(), false)<br>                    .map(MAPPER)<br>                    .collect(Collectors.toList())<br>            );<br>    }<br></pre><pre>    public Single&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;).rxExecute(Tuple.of(id))<br>            .map(RowSet::iterator)<br>            .flatMap(iterator -&gt; iterator.hasNext() ? Single.just(MAPPER.apply(iterator.next())) : Single.error(new PostNotFoundException(id)));<br>    }</pre><pre>    public Single&lt;UUID&gt; save(Post data) {<br>        return client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;)<br>            .rxExecute(Tuple.of(data.getTitle(), data.getContent()))<br>            .map(rs -&gt; rs.iterator().next().getUUID(&quot;id&quot;));<br>    }</pre><pre>    public Single&lt;Integer&gt; saveAll(List&lt;Post&gt; data) {<br>        var tuples = data.stream()<br>            .map(d -&gt; Tuple.of(d.getTitle(), d.getContent()))<br>            .collect(Collectors.toList());</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .rxExecuteBatch(tuples)<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Single&lt;Integer&gt; update(Post data) {<br>        return client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>            .rxExecute(Tuple.of(data.getTitle(), data.getContent(), data.getId()))<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Single&lt;Integer&gt; deleteAll() {<br>        return client.query(&quot;DELETE FROM posts&quot;).rxExecute()<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Single&lt;Integer&gt; deleteById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).rxExecute(Tuple.of(id))<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>}</pre><p>In this class, we use a RxJava 3 API based PgPool instead which wraps the original Vertx PgPool and add extra RxJava 3 APIs support. All methods are similar to the former Vertx version, here we use a rxExecute method to execute the SQL query and the returned result is switched to the RxJava 3 world.</p><p>Let’s have a look at the PostsHandler.</p><pre>import io.vertx.rxjava3.ext.web.RoutingContext;<br>//other imports</pre><pre>@Slf4j<br>class PostsHandler {</pre><pre>    PostRepository posts;</pre><pre>    private PostsHandler(PostRepository _posts) {<br>        this.posts = _posts;<br>    }</pre><pre>    //factory method<br>    public static PostsHandler create(PostRepository posts) {<br>        return new PostsHandler(posts);<br>    }</pre><pre>    public void all(RoutingContext rc) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        this.posts.findAll().takeLast(10).toList()<br>            .subscribe(<br>                data -&gt; rc.response().end(Json.encode(data))<br>            );<br>    }</pre><pre>    public void get(RoutingContext rc) throws PostNotFoundException {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        var uuid = UUID.fromString(id);<br>        this.posts.findById(uuid)<br>            .subscribe(<br>                post -&gt; rc.response().end(Json.encode(post)),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }<br></pre><pre>    public void save(RoutingContext rc) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        var body = rc.getBodyAsJson();<br>        log.info(&quot;request body: {0}&quot;, body);<br>        var form = body.mapTo(CreatePostCommand.class);<br>        this.posts<br>            .save(Post.builder()<br>                .title(form.getTitle())<br>                .content(form.getContent())<br>                .build()<br>            )<br>            .subscribe(<br>                savedId -&gt; rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId)<br>                    .setStatusCode(201)<br>                    .end()</pre><pre>            );<br>    }</pre><pre>    public void update(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        var body = rc.getBodyAsJson();<br>        log.info(&quot;\npath param id: {}\nrequest body: {}&quot;, id, body);<br>        var form = body.mapTo(CreatePostCommand.class);<br>        this.posts.findById(UUID.fromString(id))<br>            .flatMap(<br>                post -&gt; {<br>                    post.setTitle(form.getTitle());<br>                    post.setContent(form.getContent());</pre><pre>                    return this.posts.update(post);<br>                }<br>            )<br>            .subscribe(<br>                data -&gt; rc.response().setStatusCode(204).end(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }</pre><pre>    public void delete(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);</pre><pre>        var uuid = UUID.fromString(id);<br>        this.posts.findById(uuid)<br>            .flatMap(<br>                post -&gt; this.posts.deleteById(uuid)<br>            )<br>            .subscribe(<br>                data -&gt; rc.response().setStatusCode(204).end(),<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }</pre><pre>}</pre><p>In the subscribe method, use the RxJava 3 specific RoutingContext to send response.</p><p>Refactor the DataInitializer to use the RxJava 3 API bindings.</p><pre>@Slf4j<br>public class DataInitializer {</pre><pre>    private PgPool client;</pre><pre>    public DataInitializer(PgPool client) {<br>        this.client = client;<br>    }</pre><pre>    public static DataInitializer create(PgPool client) {<br>        return new DataInitializer(client);<br>    }</pre><pre>    public void run() {<br>        log.info(&quot;Data initialization is starting...&quot;);</pre><pre>        Tuple first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;);<br>        Tuple second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;);</pre><pre>        client<br>            .rxWithTransaction(<br>                (SqlConnection tx) -&gt; tx.query(&quot;DELETE FROM posts&quot;).rxExecute()<br>                    .flatMap(result -&gt; tx.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;).rxExecuteBatch(List.of(first, second)))<br>                    .toMaybe()<br>            )<br>            .flatMapSingle(d -&gt; client.query(&quot;SELECT * FROM posts&quot;).rxExecute())<br>            .subscribe(<br>                (data) -&gt; {<br>                    data.forEach(row -&gt; {<br>                        log.info(&quot;saved row: {}&quot;, row.toJson());<br>                    });<br>                },<br>                err -&gt; log.warn(&quot;failed to initializing: {}&quot;, err.getMessage())<br>            );<br>    }<br>}</pre><p>The complete codes of the rxStart method in the MainVerticle class.</p><pre>@Override<br>public Completable rxStart() {<br>    log.info(&quot;Starting HTTP server...&quot;);<br>    InternalLoggerFactory.setDefaultFactory(Slf4JLoggerFactory.INSTANCE);</pre><pre>    //Create a PgPool instance<br>    var pgPool = pgPool();</pre><pre>    //Creating PostRepository<br>    var postRepository = PostRepository.create(pgPool);</pre><pre>    //Creating PostHandler<br>    var postHandlers = PostsHandler.create(postRepository);</pre><pre>    // Initializing the sample data<br>    var initializer = DataInitializer.create(pgPool);<br>    initializer.run();</pre><pre>    // Configure routes<br>    var router = routes(postHandlers);</pre><pre>    // Create the HTTP server<br>    return vertx.createHttpServer()<br>        // Handle every request using the router<br>        .requestHandler(router)<br>        // Start listening<br>        .rxListen(8888)<br>        // to Completable<br>        .ignoreElement()<br>        ;<br>}</pre><p>Now you can run the application.</p><pre>mvn clean compile exec:java</pre><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/rxjava3">source codes from my github</a>, if you are still using the RxJava 2, there also includes a <a href="https://github.com/hantsy/vertx-sandbox/tree/master/rxjava2">RxJava 2 version</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e373077d7002" width="1" height="1" alt="">
