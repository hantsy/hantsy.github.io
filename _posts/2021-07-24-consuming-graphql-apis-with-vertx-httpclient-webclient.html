---
layout: post
title: Consuming GraphQL APIs with Vertx HttpClient/WebClient
---

<p>In <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/client">a previous post</a>, we have covered consuming RESTful APIs with Vertx HttpClient and WebClient. In this post, we will consuming the GraphQL APIs we created in <a href="https://github.com/hantsy/vertx-sandbox/blob/master/docs/graphql.md">the last post</a>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*jVl9u3hRpyj1g8ySAxcD3w.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@sambalye?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Sam Balye</a> on <a href="https://unsplash.com/s/photos/china-mountain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Firstly, let’s review the difference between the HttpClient and WebClient.</p><ul><li>The HttpClient is a low level API, which provides fine-grained control to interact with the Http Server.</li><li>The WebClient is a high level API, which provides more convenient approaches to simplify handling web request and response. In most of the cases, WebClient is preferred, but it lacks of WebSocket support, so when starting a WebSocket connection, we have to switch to HttpClient.</li></ul><h4>Checkout the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient">complete sample codes from my Github</a>.</h4><p>Assume you have read the <a href="https://graphql.org/learn/serving-over-http/">GraphQL over HTTP specification</a> and <a href="https://github.com/jaydenseric/graphql-multipart-request-spec">GraphQL multipart request specification</a>.</p><p>Create a Eclipse Vertx project through the <a href="https://start.vertx.io">Eclipse Vertx Starter</a>.</p><p>In the start method of the MainVerticle class, create a WebClient object firstly.</p><pre>var options = new WebClientOptions()<br>    .setUserAgent(WebClientOptions.loadUserAgent())<br>    .setDefaultHost(&quot;localhost&quot;)<br>    .setDefaultPort(8080);</pre><pre>var client = WebClient.create(vertx, options);</pre><p>The following is an example sending a GraphQL request to retrieve all posts.</p><pre>client.post(&quot;/graphql&quot;)<br>     .sendJson(Map.of(<br>         &quot;query&quot;, &quot;query posts{ allPosts{ id title content author{ name } comments{ content createdAt} createdAt}}&quot;,<br>         &quot;variables&quot;, Map.of()<br>     ))<br>     .onSuccess(<br>         data -&gt; log.info(&quot;data of allPosts: {}&quot;, data.bodyAsString())<br>     )<br>     .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));</pre><p>The request body format is like the following.</p><pre>{<br>  &quot;query&quot;: &quot;...&quot;,<br>  &quot;operationName&quot;: &quot;...&quot;,<br>  &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }<br>}</pre><p>The query is accepting a <em>Schema Definition Language</em> in string. The <em>operationName</em> and <em>variables</em> are optional.</p><p>And the response body is like.</p><pre>{<br>  &quot;data&quot;: &quot;...&quot;,<br>  &quot;errors&quot;: &quot;...&quot;<br>}</pre><p>When an error occurs, data is empty, and errors will contains the error details to describe the error or exception.</p><blockquote><em>Unlike RESTful APIs, in most of the cases, if there is an error occurred, and the error is from our application itself, the HTTP response status code is always 200.</em></blockquote><p>The following example is to demonstrate how to create a post and then retrieve the newly created post by id.</p><pre>client.post(&quot;/graphql&quot;)<br>     .sendJson(Map.of(<br>         &quot;query&quot;, &quot;mutation newPost($input:CreatePostInput!){ createPost(createPostInput:$input)}&quot;,<br>         &quot;variables&quot;, Map.of(<br>             &quot;input&quot;, Map.of(&quot;title&quot;, &quot;create post from WebClient&quot;, &quot;content&quot;, &quot;content of the new post&quot;)<br>         )<br>     ))<br>     .onSuccess(<br>         data -&gt; {<br>             log.info(&quot;data of createPost: {}&quot;, data.bodyAsString());<br>             var createdId = data.bodyAsJsonObject().getJsonObject(&quot;data&quot;).getString(&quot;createPost&quot;);<br>             // get the created post.<br>             getPostById(client, createdId);<br>             // add comment.<br>             addComment(client, createdId);<br>         }<br>     )<br>     .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));</pre><pre>//getPostById<br>private void getPostById(WebClient client, String id) {<br>        client.post(&quot;/graphql&quot;)<br>            .sendJson(Map.of(<br>                &quot;query&quot;, &quot;query post($id:String!){ postById(postId:$id){ id title content author{ name } comments{ content createdAt} createdAt}}&quot;,<br>                &quot;variables&quot;, Map.of(<br>                    &quot;id&quot;, id<br>                )<br>            ))<br>            .onSuccess(<br>                data -&gt; log.info(&quot;data of postByID: {}&quot;, data.bodyAsString())<br>            )<br>            .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));<br>    }</pre><p>Add a addComment method to demonstrate the progress of creating a comment for the post, at the same it subscribes the commentAdded event (<em>Subscription</em>).</p><pre>private void addComment(WebClient client, String id) {<br></pre><pre>    // switch to HttpClient to handle WebSocket<br>    var options = new HttpClientOptions()<br>        .setWebSocketClosingTimeout(7200)<br>        .setDefaultHost(&quot;localhost&quot;)<br>        .setDefaultPort(8080);</pre><pre>    // see: <a href="https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java">https://github.com/vert-x3/vertx-web/blob/master/vertx-web-graphql/src/test/java/io/vertx/ext/web/handler/graphql/ApolloWSHandlerTest.java</a><br>    var httpClient = vertx.createHttpClient(options);<br>    httpClient.webSocket(&quot;/graphql&quot;)<br>        .onSuccess(ws -&gt; {<br>            ws.closeHandler(v -&gt; log.info(&quot;websocket is being closed&quot;));<br>            ws.endHandler(v -&gt; log.info(&quot;websocket is being ended&quot;));<br>            ws.exceptionHandler(e -&gt; log.info(&quot;catching websocket exception: {}&quot;, e.getMessage()));</pre><pre>            ws.textMessageHandler(text -&gt; {<br>                //log.info(&quot;websocket message handler:{}&quot;, text);<br>                JsonObject obj = new JsonObject(text);<br>                ApolloWSMessageType type = ApolloWSMessageType.from(obj.getString(&quot;type&quot;));<br>                if (type.equals(CONNECTION_KEEP_ALIVE)) {<br>                    return;// do nothing when ka.<br>                } else if (type.equals(DATA)) {<br>                    // handle the subscription `commentAdded` data.<br>                    log.info(&quot;subscription commentAdded data: {}&quot;, obj.getJsonObject(&quot;payload&quot;).getJsonObject(&quot;data&quot;).getJsonObject(&quot;commentAdded&quot;));<br>                }<br>            });</pre><pre>            JsonObject messageInit = new JsonObject()<br>                .put(&quot;type&quot;, &quot;connection_init&quot;)//this is required to initialize a connection.<br>                .put(&quot;id&quot;, &quot;1&quot;);</pre><pre>            JsonObject message = new JsonObject()<br>                .put(&quot;payload&quot;, new JsonObject()<br>                     .put(&quot;query&quot;, &quot;subscription onCommentAdded { commentAdded { id content } }&quot;))<br>                .put(&quot;type&quot;, &quot;start&quot;)<br>                .put(&quot;id&quot;, &quot;1&quot;);</pre><pre>            ws.write(messageInit.toBuffer());<br>            ws.write(message.toBuffer());<br>        })<br>        .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));</pre><pre>    addCommentToPost(client, id);<br>    addCommentToPost(client, id);<br>    addCommentToPost(client, id);<br>}</pre><p>In the above addComment method, we have switch to use HttpClient to handle WebSocket request.</p><p>Firstly it opens a WebSocket connection to <em>/graphql</em> WebSocket endpoint, and then write the GraphQL request as message payload, and use a textMessageHandler callback hook to tap the WebSocket response from the server side.</p><p>Let’s have a look at the file uploads.</p><pre>private void uploadFile(WebClient client) {<br>    Buffer fileBuf = vertx.fileSystem().readFileBlocking(&quot;test.txt&quot;);<br>    MultipartForm form = MultipartForm.create();<br>    String query = &quot;&quot;&quot;<br>        mutation upload($file:Upload!){<br>        upload(file:$file)<br>    }<br>    &quot;&quot;&quot;;<br>        var variables = new HashMap&lt;String, Object&gt;();<br>    variables.put(&quot;file&quot;, null);<br>    form.attribute(&quot;operations&quot;, Json.encode(Map.of(&quot;query&quot;, query, &quot;variables&quot;, variables)));<br>    form.attribute(&quot;map&quot;, Json.encode(Map.of(&quot;file0&quot;, List.of(&quot;variables.file&quot;))));<br>    form.textFileUpload(&quot;file0&quot;, &quot;test.txt&quot;, fileBuf, &quot;text/plain&quot;);</pre><pre>    client.post(&quot;/graphql&quot;)<br>        .sendMultipartForm(form)<br>        .onSuccess(<br>        data -&gt; log.info(&quot;data of upload: {}&quot;, data.bodyAsString())<br>    )<br>    .onFailure(e -&gt; log.error(&quot;error: {}&quot;, e));<br>}</pre><p>As you see, it is very easy to create a multipart form and send it via sendMultipartForm directly with the advanced WebClient API.</p><p>Get the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/graphql-webclient">sample codes from my Github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=db410c410aa2" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/consuming-graphql-apis-with-vertx-httpclient-webclient-db410c410aa2">Consuming GraphQL APIs with Vertx HttpClient/WebClient</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
