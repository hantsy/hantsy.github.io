---
layout: post
title: Building RESTful APIs with Eclipse Vertx
---

<p>In this post, we will explore how to build a simple RESTful example application with Eclipse Vertx and reactive Postgres Client.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xR6gc7dEF0E7gXxf_57izA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@sam_beasley?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Sam Beasley</a> on <a href="https://unsplash.com/s/photos/china-gugong?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Unlike other frameworks in which <em>reactive</em> is an addition to the existing features, Eclipse Vertx is born for <em>reactive applications</em>, read <a href="https://vertx.io/introduction-to-vertx-and-reactive/">the official introduction guide</a> to get know the reactive support in Vertx .</p><p>Similar to the <a href="https://start.spring.io">Spring Boot intializr</a>, Eclipse Vertx also provides a scaffold tool to generate the project skeleton for you.</p><p>Open your browser, navigate to the <a href="https://start.vertx.io/">Vertx Starter page</a>. In the <strong>Dependencies</strong> field, select <em>Vertx Web</em>, <em>Reactive PostgreSQL Client</em>, and optionally expand the <strong>Advance options</strong> and select the <em>latest Java version</em>(at the moment it is <strong>16</strong>).</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JJa1u3eVqoVUlw7k.png" /></figure><p>Leave others options as they are, it will use the default values, then hit <strong>Generate Project</strong> button to generate the project into an archive for downloading.</p><p>Download the project archive, and extract the files into local disc, and import into your IDEs, eg. Intellij IDEA.</p><p>Open the <em>pom.xml</em>. As you see, it uses maven-shade-plugin to package the built results into a fat jar, and the <em>Main-Class</em> is the Vertx built-in io.vertx.core.Launcher. When running the application via java -jar target\xxx.jar , it will use the Launcher to deploy the declared MainVerticle . A Verticle is a Vertx specific deployment unit to group the resources, such as Network, HTTP, etc.</p><p>Let’s move to the MainVerticle class.</p><pre>public class MainVerticle extends AbstractVerticle {<br>    <br>}</pre><p>Generally , to code our business logic, you just need to override the start() method or start(Promise&lt;Void&gt; startPromise).</p><p>In our application, we will start a HTTP Server to serve the HTTP requests. Replace the content of the start(Promise&lt;Void&gt; startPromise) method with the following.</p><pre>// Create the HTTP server<br>vertx.createHttpServer()<br>    // Handle every request using the router<br>    .requestHandler(router)<br>    // Start listening<br>    .listen(8888)<br>    // Print the port<br>    .onSuccess(server -&gt; {<br>        startPromise.complete();<br>        System.out.println(&quot;HTTP server started on port &quot; + server.actualPort());<br>    })<br>    .onFailure(event -&gt; {<br>        startPromise.fail(event);<br>        System.out.println(&quot;Failed to start HTTP server:&quot; + event.getMessage());<br>    });</pre><p>The request handling work is done by the above .requestHandler(Handler&lt;HttpServerRequest&gt;). The Router is a specific Handler&lt;HttpServerRequest&gt; which simplifies the handling HTTP requests and allows chaining a sequence of handlers.</p><p>Add a reoutes method to handle requests of all routes in a central place, it returns the router.</p><pre>//create routes<br>private Router routes(PostsHandler handlers) {</pre><pre>    // Create a Router<br>    Router router = Router.router(vertx);<br>    // register BodyHandler globally.<br>    //router.route().handler(BodyHandler.create());<br>    router.get(&quot;/posts&quot;).produces(&quot;application/json&quot;).handler(handlers::all);<br>   	router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::save);<br>    router.get(&quot;/posts/:id&quot;).produces(&quot;application/json&quot;).handler(handlers::get).failureHandler(frc -&gt; frc.response().setStatusCode(404).end());<br>    router.put(&quot;/posts/:id&quot;).consumes(&quot;application/json&quot;).handler(BodyHandler.create()).handler(handlers::update);<br>    router.delete(&quot;/posts/:id&quot;).handler(handlers::delete);</pre><pre>    router.get(&quot;/hello&quot;).handler(rc -&gt; rc.response().end(&quot;Hello from my route&quot;));</pre><pre>    return router;<br>}</pre><p>For post and put HTTP methods, the BodyHandler is required to handling consuming the HTTP request body.</p><p>Extract all handing details into a new PostHandler class.</p><pre>class PostsHandler {<br>    private static final Logger LOGGER = Logger.getLogger(PostsHandler.class.getSimpleName());</pre><pre>    PostRepository posts;</pre><pre>    private PostsHandler(PostRepository _posts) {<br>        this.posts = _posts;<br>    }</pre><pre>    //factory method<br>    public static PostsHandler create(PostRepository posts) {<br>        return new PostsHandler(posts);<br>    }</pre><pre>    public void all(RoutingContext rc) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        this.posts.findAll()<br>            .onSuccess(<br>                data -&gt; rc.response().end(Json.encode(data))<br>            );<br>    }</pre><pre>    public void get(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        this.posts.findById(UUID.fromString(id))<br>            .onSuccess(<br>                post -&gt; rc.response().end(Json.encode(post))<br>            )<br>            .onFailure(<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }<br></pre><pre>    public void save(RoutingContext rc) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body);<br>        var form = body.mapTo(PostForm.class);<br>        this.posts.save(Post.of(form.getTitle(), form.getContent()))<br>            .onSuccess(<br>                savedId -&gt; rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/&quot; + savedId)<br>                    .setStatusCode(201)<br>                    .end()</pre><pre>            );<br>    }</pre><pre>    public void update(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);<br>        var body = rc.getBodyAsJson();<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, new Object[]{id, body});<br>        var form = body.mapTo(PostForm.class);<br>        this.posts.findById(UUID.fromString(id))<br>            .compose(<br>                post -&gt; {<br>                    post.setTitle(form.getTitle());<br>                    post.setContent(form.getContent());</pre><pre>                    return this.posts.update(post);<br>                }<br>            )<br>            .onSuccess(<br>                data -&gt; rc.response().setStatusCode(204).end()<br>            )<br>            .onFailure(<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }</pre><pre>    public void delete(RoutingContext rc) {<br>        var params = rc.pathParams();<br>        var id = params.get(&quot;id&quot;);</pre><pre>        var uuid = UUID.fromString(id);<br>        this.posts.findById(uuid)<br>            .compose(<br>                post -&gt; this.posts.deleteById(uuid)<br>            )<br>            .onSuccess(<br>                data -&gt; rc.response().setStatusCode(204).end()<br>            )<br>            .onFailure(<br>                throwable -&gt; rc.fail(404, throwable)<br>            );</pre><pre>    }</pre><pre>}</pre><p>From the RoutingContext, it is easy to read the request params etc. PostRepository is responsible for interacting with your backend database Postgres, when the database operation is done, then send result to the HTTP response through RoutingContext.response().</p><p>Let’s have a look at the PostRepository class.</p><pre>public class PostRepository {<br>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</pre><pre>    private static Function&lt;Row, Post&gt; MAPPER = (row) -&gt;<br>        Post.of(<br>            row.getUUID(&quot;id&quot;),<br>            row.getString(&quot;title&quot;),<br>            row.getString(&quot;content&quot;),<br>            row.getLocalDateTime(&quot;created_at&quot;)<br>        );<br></pre><pre>    private final PgPool client;</pre><pre>    private PostRepository(PgPool _client) {<br>        this.client = _client;<br>    }</pre><pre>    //factory method<br>    public static PostRepository create(PgPool client) {<br>        return new PostRepository(client);<br>    }</pre><pre>    public Future&lt;List&lt;Post&gt;&gt; findAll() {<br>        return client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;)<br>            .execute()<br>            .map(rs -&gt; StreamSupport.stream(rs.spliterator(), false)<br>                .map(MAPPER)<br>                .collect(Collectors.toList())<br>            );<br>    }<br></pre><pre>    public Future&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>            .map(RowSet::iterator)<br>            .map(iterator -&gt; iterator.hasNext() ? MAPPER.apply(iterator.next()) : null)<br>            .map(Optional::ofNullable)<br>            .map(p -&gt; p.orElseThrow(() -&gt; new PostNotFoundException(id)));<br>    }</pre><pre>    public Future&lt;UUID&gt; save(Post data) {<br>        return client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;).execute(Tuple.of(data.getTitle(), data.getContent()))<br>            .map(rs -&gt; rs.iterator().next().getUUID(&quot;id&quot;));<br>    }</pre><pre>    public Future&lt;Integer&gt; saveAll(List&lt;Post&gt; data) {<br>        var tuples = data.stream()<br>            .map(<br>                d -&gt; Tuple.of(d.getTitle(), d.getContent())<br>            )<br>            .collect(Collectors.toList());</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .executeBatch(tuples)<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Future&lt;Integer&gt; update(Post data) {<br>        return client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>            .execute(Tuple.of(data.getTitle(), data.getContent(), data.getId()))<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Future&lt;Integer&gt; deleteAll() {<br>        return client.query(&quot;DELETE FROM posts&quot;).execute()<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>    public Future&lt;Integer&gt; deleteById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>            .map(SqlResult::rowCount);<br>    }</pre><pre>}</pre><p>The pgPool is a Postgres client to interact with the Postgres database, the operations are very similar to the traditional JDBC, but it is based on the Vertx&#39;s Future API. Similar to Java 8 CompletionStage or Reactor Mono /Flux, Vertx Future provides very limited APIs for producing, transforming and observing the completed result in an asynchronous mode.</p><blockquote><em>More details about the Reactive PostgreSQL Client, read </em><a href="https://vertx.io/docs/vertx-pg-client/java/"><em>PostgreSQL Client docs</em></a><em>.</em></blockquote><blockquote><em>Almost all async methods in Vertx it provides a variant of accepting a </em><em>Promise callback as parameter instead of return a </em><em>Future instance. But personally I think the </em><em>Promise is evil if the progress is passed into a sequence of transitions, thus the </em><em>Promise will nest another </em><em>Promise, and so on. It will put yourself in the infinite </em><em>Promise hole.</em></blockquote><p>Create a method in the MainVerticle to produce a PgPool instance.</p><pre>private PgPool pgPool() {<br>    PgConnectOptions connectOptions = new PgConnectOptions()<br>        .setPort(5432)<br>        .setHost(&quot;localhost&quot;)<br>        .setDatabase(&quot;blogdb&quot;)<br>        .setUser(&quot;user&quot;)<br>        .setPassword(&quot;password&quot;);</pre><pre>    // Pool Options<br>    PoolOptions poolOptions = new PoolOptions().setMaxSize(5);</pre><pre>    // Create the pool from the data object<br>    PgPool pool = PgPool.pool(vertx, connectOptions, poolOptions);</pre><pre>    return pool;<br>}</pre><p>Create a class to initialize some sample data.</p><pre>public class DataInitializer {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());</pre><pre>    private PgPool client;</pre><pre>    public DataInitializer(PgPool client) {<br>        this.client = client;<br>    }</pre><pre>    public static DataInitializer create(PgPool client) {<br>        return new DataInitializer(client);<br>    }</pre><pre>    public void run() {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;);</pre><pre>        Tuple first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;);<br>        Tuple second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;);</pre><pre>        client<br>            .withTransaction(<br>                conn -&gt; conn.query(&quot;DELETE FROM posts&quot;).execute()<br>                    .flatMap(r -&gt; conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>                        .executeBatch(List.of(first, second))<br>                    )<br>                    .flatMap(r -&gt; conn.query(&quot;SELECT * FROM posts&quot;).execute())<br>            )<br>            .onSuccess(data -&gt; StreamSupport.stream(data.spliterator(), true)<br>                .forEach(row -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, new Object[]{row.toJson()}))<br>            )<br>            .onComplete(<br>                r -&gt; {<br>                    //client.close(); will block the application.<br>                    LOGGER.info(&quot;Data initialization is done...&quot;);<br>                }<br>            )<br>            .onFailure(<br>                throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage())<br>            );<br>    }<br>}</pre><p>In the above codes, use the withTransaction method to wrap a series of database operations in a single transaction.</p><p>Let’s assemble all the resources in the MainVerticle&#39;s start method.</p><pre>@Override<br>public void start(Promise&lt;Void&gt; startPromise) throws Exception {<br>    LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;);<br>    //setupLogging();</pre><pre>    //Create a PgPool instance<br>    var pgPool = pgPool();</pre><pre>    //Creating PostRepository<br>    var postRepository = PostRepository.create(pgPool);</pre><pre>    //Creating PostHandler<br>    var postHandlers = PostsHandler.create(postRepository);</pre><pre>    // Initializing the sample data<br>    var initializer = DataInitializer.create(pgPool);<br>    initializer.run();</pre><pre>    // Configure routes<br>    var router = routes(postHandlers);</pre><pre>    // Create the HTTP server<br>    vertx.createHttpServer()<br>        // Handle every request using the router<br>    	.requestHandler(router)<br>        ...<br>}</pre><p>By default Vertx Web uses Jackson to serialize and deserialize the request/response payload. Unfortunately it does not register a Java DateTime module by default.</p><p>Add the following dependencies in the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br>    &lt;version&gt;${jackson.version}&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;<br>    &lt;version&gt;${jackson.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>Add a jackson.version property to the properties section.</p><pre>&lt;jackson.version&gt;2.11.3&lt;/jackson.version&gt;</pre><p>Then add a static block to configure DateTime serialization and deserialization in the MainVerticle class.</p><pre>static {<br>    LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;);<br>    var objectMapper = DatabindCodec.mapper();<br>    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>    objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);<br>    objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS);</pre><pre>    JavaTimeModule module = new JavaTimeModule();<br>    objectMapper.registerModule(module);<br>}</pre><p>Let’s start the application.</p><p>Simply fetch <a href="https://github.com/hantsy/vertx-sandbox">the source codes</a>, it provides a docker compose file.</p><p>Run the following command to start a Postgres instance in Docker container.</p><pre>docker compose postgres</pre><p>It will prepare the essential tables through <a href="https://github.com/hantsy/vertx-sandbox/tree/master/pg-initdb.d">the initial scripts</a> when the database is starting.</p><p>Now switch to the project folder, run the following command to start the application.</p><pre>mvn clean compile exec:java</pre><p>Or build the project firstly, and run the final jar file.</p><pre>mvn clean package<br>java -jar target/demo.jar</pre><p>After the application is started, open a terminal, and use curl to test the /posts endpoints.</p><pre>curl <a href="http://localhost:8888/posts">http://localhost:8888/posts</a> -H &quot;Accept: application/json&quot;<br>[{&quot;id&quot;:&quot;1f99032b-3bb0-4795-ba9f-b0437b59cfbe&quot;,&quot;title&quot;:&quot;Hello Quarkus&quot;,&quot;content&quot;:&quot;My first post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;},{&quot;id&quot;:&quot;adda9ca6-2c4c-4223-9cb6-b8407c15ba03&quot;,&quot;title&quot;:&quot;Hello Again, Quarkus&quot;,&quot;content&quot;:&quot;My second post of Quarkus&quot;,&quot;createdAt&quot;:&quot;2021-07-02T09:35:21.341037&quot;}]</pre><p>Get <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service">the complete source codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4ce89d8eeb74" width="1" height="1" alt="">
