---
layout: post
title: Exception Handling and Validation Handler in Vertx applications
---

<p>In the last post, we have built a simple RESTful APIs example application using Eclipse Vertx. In this post, we will discuss web related topic, such as exception handling and input validation, etc.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PQDKc_j3QZ-LsuMNdcK4lg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@patrickxt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Patrick Xu</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Vertx’s Future includes some hooks to be executed when the asynchronous flow is done.</p><ul><li>onComplete will in invoked when the execution is completed, either it is succeeded or failed.</li><li>onSuccess handles the successful result.</li><li>onFailure catches the exception thrown in the execution.</li></ul><p>Let’s explore how to handle the exceptions in the former example application.</p><p>Assume retrieving Post via a none-existing id, throw a PostNotFoundException instead of returning the correct result.</p><p>Declare a PostNotFoundException .</p><pre>public class PostNotFoundException extends RuntimeException {<br>    public PostNotFoundException(UUID id) {<br>        super(&quot;Post id: &quot; + id + &quot; was not found. &quot;);<br>    }<br>}</pre><p>In the PostRepository, change the content of findById like the following.</p><pre>public Future&lt;Post&gt; findById(UUID id) {<br>    Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>    return client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;)<br>        .execute(Tuple.of(id))<br>        .map(RowSet::iterator)<br>        .map(iterator -&gt; {<br>            if (iterator.hasNext()) {<br>                return MAPPER.apply(iterator.next());<br>            }<br>            throw new PostNotFoundException(id);<br>        });<br>}</pre><p>In the PostsHandler, the get method handles <em>/posts/:id</em> route like this.</p><pre>public void get(RoutingContext rc) {<br>    var params = rc.pathParams();<br>    var id = params.get(&quot;id&quot;);<br>    this.posts.findById(UUID.fromString(id))<br>        .onSuccess(<br>            post -&gt; rc.response().end(Json.encode(post))<br>        )<br>        .onFailure(<br>            throwable -&gt; rc.fail(throwable)<br>        );</pre><pre>}</pre><p>In the onFailure hook, use RoutingContext.fail to transit the exception state in route.</p><p>Let’s review the router definition in the <em>/posts/:id</em> route.</p><pre>router.get(&quot;/posts/:id&quot;)<br>    .produces(&quot;application/json&quot;)<br>    .handler(handlers::get)<br>    .failureHandler(frc -&gt; {<br>        Throwable failure = frc.failure();<br>        if (failure instanceof PostNotFoundException) {<br>            frc.response().setStatusCode(404).end();<br>        }<br>        frc.response().setStatusCode(500).setStatusMessage(&quot;Server internal error:&quot; + failure.getMessage()).end();<br>    });</pre><p>There is a failure handler to handle exceptions in details.</p><p>In the above PostsHandler example, there is a fail alternative method accepts a status code parameter. If there is there is no failure handler in the router definition, it will send the the code as HTTP Status code to the client response.</p><p>Check the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service">source codes from my Github</a>.</p><p>For those cases which include a request body, such as <em>create a new post</em> , the request body should be validated to ensure it satisfies the requirements.</p><p>The validation progress can be done by a validation handler, similar to other request handlers, you can chain the handlers in your router definition.</p><pre>router.post(&quot;/posts&quot;).consumes(&quot;application/json&quot;)<br>    .handler(BodyHandler.create())<br>    .handler(validation)<br>    .handler(handlers::save)<br>    .failureHandler(validationFailureHandler);</pre><p>The BodyHandler is used to deserialize the request body, then validate the decoded body via a validation handler. If the validation is successful, call handlers::save to save the post data. A failure handler is declared in the last position to handle the possible validation exception thrown in the execution.</p><p>Vertx supports rich validation rule definitions based on Json Schema specification.</p><p>Add the following dependency into your <em>pom.xml</em>.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>    &lt;artifactId&gt;vertx-json-schema&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>The following is an example of defining a validation handler to validate the request body of <em>creating a new post</em>.</p><pre>SchemaRouter schemaRouter = SchemaRouter.create(vertx, new SchemaRouterOptions());<br>SchemaParser schemaParser = SchemaParser.createDraft201909SchemaParser(schemaRouter);</pre><pre>ObjectSchemaBuilder bodySchemaBuilder = objectSchema()<br>    .requiredProperty(&quot;title&quot;, stringSchema().with(minLength(5)).with(maxLength(100)))<br>    .requiredProperty(&quot;content&quot;, stringSchema().with(minLength(10)).with(maxLength(2000)));</pre><pre>ValidationHandler validation = ValidationHandler.newInstance(<br>    ValidationHandler<br>    .builder(schemaParser)<br>    //.queryParameter(param(&quot;parameterName&quot;, intSchema()))<br>    //.pathParameter(param(&quot;pathParam&quot;, numberSchema()))<br>    .body(Bodies.json(bodySchemaBuilder))<br>    //.body(Bodies.formUrlEncoded(bodySchemaBuilder))<br>    .predicate(RequestPredicate.BODY_REQUIRED)<br>    .build()<br>);</pre><p>The above is an example of using RxJava 3 Validation binding APIs, but there is <a href="https://github.com/vert-x3/vertx-web/issues/1822">an issue</a>, you have to wrap the instance to create a RxJava3 specific validation handler.</p><p>When request body is failed to validate, it will throw a BodyProcessorException. The failure handler is used to handle the exception and send desired status to the response.</p><pre>Handler&lt;RoutingContext&gt; validationFailureHandler = (RoutingContext rc) -&gt; {<br>            if (rc.failure() instanceof BodyProcessorException exception) {<br>                rc.response()<br>                    .setStatusCode(400)<br>                    .end(&quot;validation failed.&quot;);<br>                //.end(exception.toJson().encode());<br>            }<br>        };</pre><p>Check the <a href="https://github.com/hantsy/vertx-sandbox/tree/master/rxjava3">source codes from my Github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=16a410ff53a3" width="1" height="1" alt="">
