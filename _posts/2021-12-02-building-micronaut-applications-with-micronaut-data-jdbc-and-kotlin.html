---
layout: post
title: Building Micronaut applications with Micronaut Data Jdbc and Kotlin
---

<p>Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vpMi-XOcWMHQnUiqVqNeOg.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@dongmingwei?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">mingwei dong</a> on <a href="https://unsplash.com/s/photos/china-snow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><h3>Getting Started</h3><p>Open your browser and navigate to <a href="https://micronaut.io/launch">Micronaut Launch</a> to generate a new project skeleton for this post. Select the following items on this page.</p><ul><li>Java version: <strong>17</strong></li><li>Language: <strong>Kotlin</strong></li><li>Build tool: <strong>Gradle</strong></li><li>Test framework: <strong>Kotest</strong></li><li>Included Features: <strong>data-jdbc</strong>, <strong>postgres</strong>, etc.</li></ul><p>Click <strong>GENERATE PROJECT</strong> button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p><p>Create an Entity class.</p><pre>@MappedEntity(value = &quot;posts&quot;, namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)<br>data class Post(<br>    @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null,<br>    var title: String,<br>    var content: String,<br>    var status: Status? = Status.DRAFT,<br>    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()<br>)</pre><p>Here we declare a Kotlin data class to present the data in the mapped table. Similar to the JPA annotations, you can set ID and GeneratedValue on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the createdAt field annotated with @DateCreated will be filled automatically when the entity is being persisted.</p><p>The status is an enum class.</p><pre>enum class Status {<br>    DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED<br>}</pre><blockquote><em>Note: The </em><em>ID and </em><em>GeneratedValue is from </em><em>io.micronaut.data.annotation package.</em></blockquote><p>Create a Repository for Post Entity class.</p><pre>@JdbcRepository<br>interface PostRepository : PageableRepository&lt;Post, UUID&gt;</pre><p>Here we used a JdbcRepository to indicate this Repository is a <strong>data-jdbc</strong> Repository.</p><p>Create a bean to initialize some sample data.</p><pre>@Singleton<br>@Requires(notEnv = [&quot;mock&quot;])<br>class DataInitializer(private val posts: PostRepository) {</pre><pre>    @EventListener<br>    fun onStartUp(e: ServerStartupEvent) {<br>        log.info(&quot;starting data initialization at ServerStartupEvent: $e&quot;)</pre><pre>        posts.deleteAll()</pre><pre>        val data = listOf(<br>            Post(title = &quot;Building Restful APIs with Micronaut and Kotlin&quot;, content = &quot;test&quot;),<br>            Post(title = &quot;Building Restful APIs with Micronaut and Kotlin: part 2&quot;, content = &quot;test&quot;)<br>        )<br>        data.forEach { log.debug(&quot;saving: $it&quot;) }<br>        posts.saveAll(data).forEach { log.debug(&quot;saved post: $it&quot;) }<br>        log.info(&quot;data initialization is done...&quot;)<br>    }</pre><pre>    companion object DataInitializer {<br>        private val log = LoggerFactory.getLogger(DataInitializer::class.java)<br>    }</pre><pre>}</pre><p>Now create a controller to expose RESTful APIs.</p><pre>@Controller(&quot;/posts&quot;)<br>class PostController(private val posts: PostRepository) {</pre><pre>    @Get(uri = &quot;/&quot;, produces = [MediaType.APPLICATION_JSON])<br>    fun all(): HttpResponse&lt;List&lt;Post&gt;&gt; = ok(posts.findAll().toList())</pre><pre>    @Get(uri = &quot;/{id}&quot;, produces = [MediaType.APPLICATION_JSON])<br>    fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {<br>        val post = posts.findById(id) ?: return notFound()<br>        return ok(post)<br>    }</pre><pre>    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])<br>    fun create(@Body body: Post): HttpResponse&lt;Any&gt; {<br>        val saved = posts.save(body)<br>        return created(URI.create(&quot;/posts/&quot; + saved.id))<br>    }<br>}</pre><p>Now let’s try to start up the application, make sure there is a running Postgres database, the database settings should match the configuration in the <em>application.yaml</em>.</p><p>Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the <em>docker-compose.yaml</em>.</p><pre># docker compose up postgres</pre><p>Now run the application.</p><pre># gradlew run <br>// or <br># gradlew build<br># java build/xxx.jar</pre><p>You can use curl command to test the <em>/posts</em> endpoint.</p><pre># curl <a href="http://localhost:8080/posts">http://localhost:8080/posts</a></pre><h3>Query by Specification</h3><p>If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the <strong>data-jdbc</strong> also supports query by JPA Specification.</p><p>Add jakarta.persistence:jakarta.persistence-api:3.0.0 into dependencies.</p><p>Change PostRepository, make it extends JpaSpecificationExecutor.</p><pre>@JdbcRepository<br>interface PostRepository : PageableRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt;</pre><p>Create a series of Specfication, eg. find by title, find by keyword, or reject all posts that status is PENDING_MODERATED, remove all REJECTED posts. In the Micronaut Data, there are some variants of the PredicateSpecification, such as QuerySpecificaiton, UpdateSpecification, and DeleteSpecification.</p><pre>object Specifications {</pre><pre>    fun titleLike(title: String): PredicateSpecification&lt;Post&gt; {<br>        return PredicateSpecification&lt;Post&gt; { root, criteriaBuilder -&gt;<br>            criteriaBuilder.like(<br>                root.get(&quot;title&quot;),<br>                &quot;%$title%&quot;<br>            )<br>        }<br>    }</pre><pre>    fun byKeyword(q: String): QuerySpecification&lt;Post&gt; {<br>        return QuerySpecification&lt;Post&gt; { root, query, criteriaBuilder -&gt;<br>            criteriaBuilder.or(<br>                criteriaBuilder.like(root.get(&quot;title&quot;), &quot;%$q%&quot;),<br>                criteriaBuilder.like(root.get(&quot;content&quot;), &quot;%$q%&quot;)<br>            )<br>        }<br>    }</pre><pre>    fun rejectAllPendingModerated(): UpdateSpecification&lt;Post&gt; {<br>        return UpdateSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt;<br>            query.set(root.get(&quot;status&quot;), Status.REJECTED)<br>            criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.PENDING_MODERATED)<br>        }<br>    }</pre><pre>    fun removeAllRejected(): DeleteSpecification&lt;Post&gt; {<br>        return DeleteSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt;<br>            criteriaBuilder.equal(root.get&lt;Status&gt;(&quot;status&quot;), Status.REJECTED)<br>        }<br>    }</pre><pre>}</pre><p>Let’s create some tests to verify these Specifications.</p><pre>@MicronautTest(environments = [Environment.TEST], startApplication = false)<br>open class PostRepositoryAnnotationSpec() : AnnotationSpec() {<br>    companion object {<br>        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)<br>    }</pre><pre>    @Inject<br>    private lateinit var posts: PostRepository</pre><pre>    @Inject<br>    private lateinit var template: JdbcOperations</pre><pre>    @Inject<br>    private lateinit var tx: TransactionOperations&lt;Any&gt;</pre><pre>    @BeforeEach<br>    fun beforeEach() {<br>        val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt;<br>            val sql = &quot;delete from posts&quot;;<br>            this.template.prepareStatement(sql) {<br>                it.executeUpdate()<br>            }<br>        }</pre><pre>        val cnt = tx.executeWrite(callback)<br>        println(&quot;deleted $cnt&quot;);<br>    }</pre><pre>    @Test<br>    fun `test save and find posts`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        log.debug(&quot;all posts: $all&quot;)<br>        all.map { it.title }.forAny { it shouldContain &quot;test&quot; }<br>    }</pre><pre>    @Test<br>    fun `find by title`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll(Specifications.titleLike(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 1</pre><pre>        val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 0<br>    }</pre><pre>    @Test<br>    fun `find by keyword`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 2</pre><pre>        val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 1<br>    }</pre><pre>    @Test<br>    fun `update posts`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br>        log.debug(&quot;updated posts size:{}&quot;, updated)<br>        updated shouldBe 2</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 2<br>        all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br>    }</pre><pre>    @Test<br>    fun `remove posts`() {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;REJECTED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val deleted = posts.deleteAll(Specifications.removeAllRejected())<br>        log.debug(&quot;deleted posts size:{}&quot;, deleted)<br>        deleted shouldBe 1</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br>    }<br>}</pre><p>Similar to Spring Jdbc and Spring Data Jdbc, there is a template based JdbcOperations bean available for programmatic database operations. In the above testing codes, we used JdbcOperations to prepare and clean up sample data for each tests.</p><p>In this application, we use Kotest as testing framework.</p><p>Kotest provides a lot of testing code styles, some are inspired by the existing describe/it clause from NodeJS ecosystem or ScalaTest.</p><p>The AnnotationSpec is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework.</p><h3>Kotest</h3><p>The simplest is SpringSpec, use a <em>string</em> to describe functionality. Let&#39;s rewrite the above testing codes with StringSepc.</p><pre>@MicronautTest(environments = [Environment.TEST], startApplication = false)<br>class PostRepositoryTest(<br>    private val posts: PostRepository,<br>    private val template: JdbcOperations,<br>    private val tx: TransactionOperations&lt;Any&gt;<br>) : StringSpec({</pre><pre>    &quot;test save and find posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        log.debug(&quot;all posts: $all&quot;)<br>        all.map { it.title }.forAny { it shouldContain &quot;test&quot; }<br>    }</pre><pre>    &quot;find by title&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.executeUpdate()<br>        }</pre><pre>        insertedCnt shouldBeEqualComparingTo 1<br>        val all = posts.findAll(Specifications.titleLike(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 1</pre><pre>        val all2 = posts.findAll(Specifications.titleLike(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 0<br>    }</pre><pre>    &quot;find by keyword&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val all = posts.findAll(Specifications.byKeyword(&quot;test&quot;))<br>        log.debug(&quot;all posts size:{}&quot;, all.size)<br>        all shouldHaveSize 2</pre><pre>        val all2 = posts.findAll(Specifications.byKeyword(&quot;test2&quot;))<br>        log.debug(&quot;all2 posts size:{}&quot;, all2.size)<br>        all2 shouldHaveSize 1<br>    }</pre><pre>    &quot;update posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;PENDING_MODERATED&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())<br>        log.debug(&quot;updated posts size:{}&quot;, updated)<br>        updated shouldBe 2</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 2<br>        all.map { it.status }.forAny { it shouldBe Status.REJECTED }<br>    }</pre><pre>    &quot;remove posts&quot; {<br>        val sql = &quot;insert into posts(title, content, status) values (?, ?, ?)&quot;;<br>        val insertedCnt = template.prepareStatement(sql) {<br>            it.setString(1, &quot;test title&quot;)<br>            it.setString(2, &quot;test content&quot;)<br>            it.setString(3, &quot;REJECTED&quot;)<br>            it.addBatch()<br>            it.setString(1, &quot;test2 title&quot;)<br>            it.setString(2, &quot;test2 content&quot;)<br>            it.setString(3, &quot;DRAFT&quot;)<br>            it.addBatch()<br>            it.executeBatch()<br>        }</pre><pre>        insertedCnt.any { it == 1 }<br>        val deleted = posts.deleteAll(Specifications.removeAllRejected())<br>        log.debug(&quot;deleted posts size:{}&quot;, deleted)<br>        deleted shouldBe 1</pre><pre>        val all = posts.findAll()<br>        all shouldHaveSize 1<br>        all.map { it.status }.forAny { it shouldBe Status.DRAFT }<br>    }</pre><pre>}) {<br>    companion object {<br>        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)<br>    }</pre><pre>    override fun beforeEach(testCase: TestCase) {<br>        val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt;<br>            val sql = &quot;delete from posts&quot;;<br>            this.template.prepareStatement(sql) {<br>                it.executeUpdate()<br>            }<br>        }</pre><pre>        val cnt = tx.executeWrite(callback)<br>        println(&quot;deleted $cnt&quot;);<br>    }<br>}</pre><p>Create a test to test PostController, here we use FunSpec which wraps tests in a test method block.</p><pre>@MicronautTest(environments = [&quot;mock&quot;])<br>class PostControllerTest(<br>    private val postsBean: PostRepository,<br>    @Client(&quot;/&quot;) private var client: HttpClient<br>) : FunSpec({</pre><pre>    test(&quot;test get posts endpoint&quot;) {<br>        val posts = getMock(postsBean)<br>        every { posts.findAll() }<br>            .returns(<br>                listOf(<br>                    Post(<br>                        id = UUID.randomUUID(),<br>                        title = &quot;test title&quot;,<br>                        content = &quot;test content&quot;,<br>                        status = Status.DRAFT,<br>                        createdAt = LocalDateTime.now()<br>                    )<br>                )<br>            )<br>        val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java)</pre><pre>        response.status shouldBe HttpStatus.OK<br>        response.body()!![0].title shouldBe &quot;test title&quot;</pre><pre>        verify(exactly = 1) { posts.findAll() }<br>    }<br>}) {<br>    @MockBean(PostRepository::class)<br>    fun posts() = mockk&lt;PostRepository&gt;()<br>}</pre><p>Here we use <strong>mockk</strong> to create a mocked PostRepository and the MockBean is located in the body of SpringSpec.</p><p>The following is an integration example which use SpringSpec .</p><pre>@MicronautTest<br>class IntegrationTests(<br>    private val application: EmbeddedApplication&lt;*&gt;,<br>    @Client(&quot;/&quot;) private val client: HttpClient<br>) : StringSpec({</pre><pre>    &quot;test the server is running&quot; {<br>        assert(application.isRunning)<br>    }</pre><pre>    &quot;test GET /posts endpoint&quot; {<br>        val response = client.toBlocking().exchange(&quot;/posts&quot;, Array&lt;Post&gt;::class.java)</pre><pre>        response.status shouldBe HttpStatus.OK<br>        response.body()!!.map { it.title }.forAny {<br>            it shouldContain &quot;Micronaut&quot;<br>        }<br>    }<br>})</pre><p>Get the complete <a href="https://github.com/hantsy/micronaut-sandbox/tree/master/jdbc-kotlin">source codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=81c1b6cf4b10" width="1" height="1" alt="">
