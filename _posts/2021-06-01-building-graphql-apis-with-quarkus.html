---
layout: post
title: Building GraphQL APIs with Quarkus
---

<p><a href="https://graphql.org/">GraphQL</a> is used as an alternative of REST to build Web APIs and becomes more and more popular in these days.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-fdiPOs2J-hfZZJxlMLvHw.jpeg" /></figure><h3>What is GraphQL?</h3><p>The initial GraphQL protocol is created by Facebook, and now it is maintained by the GraphQL Foundation. From the home page of the official GraphQL website, GraphQL was described as:</p><blockquote><em>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</em></blockquote><p>Go to the GraphQL <a href="https://graphql.org/code">Code</a> page, it lists the current GraphQL tools and libraries implemented in different languages.</p><p>The latest Quarkus adds an extra MicroProfile GraphQL implementation (via SmallRye GraphQL) to replace the original Vertx implementation.</p><p>In this post, we will create a Quarkus project and experience this built-in GraphQL feature.</p><h3>Generating Project Skeleton</h3><p>Open your browser, navigate to <a href="https://code.quarkus.io">Quarkus Code</a> page, add <em>SmallRye GraphQL</em> into the project dependencies, then hit the <em>Generate your application</em> to generate the project skeleton. Download the generated archive and extract the files in your disc, and import the project into your IDE.</p><p>For the existing Quarkus project, open a terminal and switch to the project root folder, and run the following command to add <em>SmallRye GraphQL</em> extension.</p><pre>mvn quarkus:add-extension -Dextensions=&quot;smallrye-graphql&quot;</pre><p>Finally, you will find the following dependency is added in the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br>    &lt;artifactId&gt;quarkus-smallrye-graphql&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Next, let’s cook the GraphQL API.</p><p>Similar to building RESTful APIs, there are two principles to choose, <strong>code first</strong> or <strong>schema first</strong>.</p><p>SmallRye GraphQL follows the <strong>code first</strong> principle and generate the GraphQL schema from codes at runtime.</p><h3>Declaring GraphQL API</h3><p>Create a class and add a @GraphQLApi annotation on the class to declare the GraphQL API.</p><pre>@GraphQLApi<br>@RequiredArgsConstructor<br>public class GraphQLResource {<br>    final PostService postService;</pre><pre>    @Query<br>    @Description(&quot;Get all posts&quot;)<br>    public List&lt;Post&gt; getAllPosts() {<br>        return this.postService.getAllPosts();<br>    }</pre><pre>    @Query<br>    @Description(&quot;Get a specific post by providing an id&quot;)<br>    public Optional&lt;Post&gt; getPostById(@Name(&quot;postId&quot;) String id) {<br>        return this.postService.getPostById(id);<br>    }</pre><pre>    @Mutation<br>    @Description(&quot;Create a new post&quot;)<br>    public Post createPost(@Valid CreatePost createPostInput) {<br>        return this.postService.createPost(createPostInput);<br>    }<br>}</pre><p>In the above code snippets, @RequiredArgsConstructor is a <a href="https://projectlombok.org/">Lombok</a> annotation(do not forget add org.projectlombok:lombok into your dependencies).</p><p>The PostService is a CDI bean to handle the certain business logic.</p><p>The @Query defines a query operation, Post is mapped to a GraphQL <em>ObjectType</em>, @Name(&quot;postId&quot;) defines the name of a GraphQL <em>Argument</em>, and @Mutation is a mutation operation, CreatePost is mapped to a GraphQL <em>Input</em> type.</p><p>More about the concept of GraphQL, such as <em>Query</em>, <em>Mutation</em>, <em>Object Type</em>, and <em>Input Type</em>, please refer to the <a href="https://graphql.org/learn/">GraphQL Learn page</a>.</p><p>Let’s have a look at the content of Post, Comment, and CreatePost.</p><pre>@Data<br>@Builder<br>@ToString<br>@Type<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class Post {<br>    @Id<br>    String id;<br>    String title;<br>    String content;</pre><pre>    int countOfComments;</pre><pre>    @Builder.Default<br>    List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();<br>}</pre><pre>@Data<br>@Builder<br>@Type<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class Comment {<br>    @Id<br>    String id;<br>    String content;<br>}<br></pre><pre>@Data<br>@Builder<br>@NoArgsConstructor<br>@AllArgsConstructor<br>@Input<br>public class CreatePost {<br>    String title;</pre><pre>    String content;<br>}</pre><p>Note there are two annotations: @Type and @Input are added on the classes. Other annotations are from Lombok.</p><p>Let’s move on to the PostService class.</p><pre>@ApplicationScoped<br>public class PostService {</pre><pre>    static List&lt;Post&gt; STORE = new ArrayList&lt;&gt;();</pre><pre>    public void init(List&lt;Post&gt; data) {<br>        STORE.clear();<br>        STORE.addAll(data);<br>    }</pre><pre>    List&lt;Post&gt; getAllPosts() {<br>        return STORE;<br>    }</pre><pre>    Optional&lt;Post&gt; getPostById(String id) {<br>        return STORE.stream().filter(p -&gt; p.id.equals(id)).findFirst();<br>    }</pre><pre>    Post createPost(CreatePost postInput) {<br>        var data = Post.builder().id(UUID.randomUUID().toString())<br>                .title(postInput.title)<br>                .content(postInput.content)<br>                .build();<br>        STORE.add(data);<br>        return data;<br>    }<br>}</pre><p>It is a dummy implementation to erase the backend database requirements. You can simply replace it with the codes accessing the real database.</p><h3>Running Application</h3><p>Before running the application, let’s add some sample data. Create a CDI bean to observe the StartupEvent event, it will be executed when the application is already started.</p><pre>@ApplicationScoped<br>@RequiredArgsConstructor<br>public class DataInitializer {<br>    public static final Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());<br>    //<br>    final PostService postService;</pre><pre>    //<br>    public void onStartup(@Observes StartupEvent e) {</pre><pre>        var initData = IntStream.range(1, 5).mapToObj(<br>                i -&gt; {<br>                    var comments = IntStream.range(1, new Random().nextInt(5)+1).mapToObj(c -&gt; Comment.builder().id(UUID.randomUUID().toString()).content(&quot;comment #&quot; + c).build())<br>                            .toList();<br>                    var data = Post.builder().title(&quot;title #&quot; + i)<br>                            .id(UUID.randomUUID().toString())<br>                            .content(&quot;test content of #&quot; + i)<br>                            .comments(comments)<br>                            .build();<br>                    return data;<br>                }<br>        ).toList();</pre><pre>        this.postService.init(initData);</pre><pre>        this.postService.getAllPosts()<br>                .forEach(p -&gt; LOGGER.log(Level.INFO, &quot;post data : {0}&quot;, p));</pre><pre>    }<br>}</pre><p>Open a terminal, and run mvn quarkus:dev in the project root folder.</p><pre>2021-06-01 18:10:27,726 INFO  [io.quarkus] (Quarkus Main Thread) quarkus-examples-graphql 1.0.0-SNAPSHOT on JVM (powered by Quarkus 2.0.0.CR2) started in 5.654s. Listening on: <a href="http://l">http://l</a><br>ocalhost:8080<br>2021-06-01 18:10:27,727 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.<br>2021-06-01 18:10:27,728 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, hibernate-validator, resteasy, smallrye-context-propagation, smallrye-graphql]</pre><pre>--<br>Tests paused, press [r] to resume</pre><p>When the application is started, then open a browser and navigate to the <a href="http://localhost:8080/q/dev/">Dev UI</a>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*yDcKylzwdwUP5svF.png" /></figure><p>There is a <strong>SmallRye GraphQL</strong> card for our application. The <em>GraphQL Schema</em> is the generated schema definition. And the <em>GraphQL UI</em> is the an interactive UI for developers to test the GraphQL operations directly.</p><p>Click the <em>GraphQL UI</em> to open the Graph UI page.</p><p>Try to perform an <em>allPosts</em> query and click the execute button, you will will the following page.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Pk0ZGUmxCpmwc8ZT.png" /></figure><p>To get a post by ID, try the following query instead, it requires an extra argument. Set the postId variable in the <em>Query variables</em> input box, it is JSON format.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*jOf3BWIMA88xEnGT.png" /></figure><p>If the postId is a non-existing id, it will return a null result like this.</p><pre>{<br>    &quot;data&quot;:{<br>    	&quot;postById&quot;:null<br>	}<br>}</pre><p>You can define a custom Exception and convert it into a GraphQL error.</p><h3>Exception Handling</h3><p>Create a PostNotFoundException.</p><pre>import io.smallrye.graphql.api.ErrorCode;</pre><pre>@ErrorCode(&quot;POST_NOT_FOUND&quot;)<br>public class PostNotFoundException extends RuntimeException{</pre><pre>    public PostNotFoundException(String id) {<br>        super(&quot;Post: &quot;+ id +&quot; was not found.&quot;);<br>    }<br>}</pre><p>And add the following configuration in the <em>application.properties</em>.</p><pre>mp.graphql.showErrorMessage=com.example.demo.PostNotFoundException<br>smallrye.graphql.errorExtensionFields=exception,classification,code,description,validationErrorType,queryPath</pre><p>Run the application again, and provide a non-existing post ID, then execute the query. As you see the errors is added into the query result, it includes the code and message you have defined in your exception class.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*jlwaKY5PARWnrUMn.png" /></figure><h3>Resolving Fields</h3><p>In our former example, a Post includes the comments fields directly, it is an <em>eager</em> approach. In a real world application, you could want to fetch data of the related comments on demand. When a <em>comments</em> field is set in the result field list of a query string, it could hit the backend database or retrieve from cache and return the result for the specified post ID.</p><pre>@GraphQLApi<br>@RequiredArgsConstructor<br>public class GraphQLResource {<br>    final PostService postService;</pre><pre>    public int comments(@Source Post post) {<br>        return postService.commentsByPostId(post.getId());<br>    }<br>}</pre><p>You can also apply the resolving rule on some <em>virtual</em> fields( here I mean those are not existed in the backend database and evaluated at runtime), there are some examples :</p><pre>// calculate the comments count of a specified post<br>public int countOfComments(@Source Post post) {<br>     return ...<br>}</pre><pre>// retrieve the current user info from the GraphQL context <br>// and determine if he/her has voted the current post<br>public boolean voted(@Source Post post, @Context context) {<br>     return ...<br>}</pre><h3>Input Validation</h3><p>You can apply some bean validation annotations on the input type to check if it satisfies your requirements.</p><pre>public class CreatePost {</pre><pre>    @NotEmpty//add hibernate-validator, else bean validation dose not work.<br>    @Length(min = 5)<br>    String title;</pre><pre>    String content;<br>}</pre><p>And do not forget to add the hibernate-validator extension into the project deps.</p><pre>mvn quarkus:add-extension -Dextensions=&quot;hibernate-validator&quot;</pre><p>Run the application and have a try. Leave the <em>title</em> empty , hit the <em>execute</em> button, the validation exceptions are converted into GraphQL errors.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*hQrPD2svFxYJ4BKu.png" /></figure><p>In this post, we have not explored the Subscription type - the messaging contract in the GraphQL specification. We will discuss it in the further posts.</p><p><a href="https://github.com/hantsy/quarkus-sandbox/tree/master/graphql">Grab the source codes from my Github</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dbbf23f897df" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/building-graphql-apis-with-quarkus-dbbf23f897df">Building GraphQL APIs with Quarkus</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
