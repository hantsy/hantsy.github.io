---
layout: post
title: Building a Vertx application with Kotlin
---

<p>As mentioned in the former posts, Eclipse Vertx expands its API to different languages such as Kotlin, Groovy via official bindings, and even Node/Typescript and PHP via community supports.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*fwQOVagDLdc4Yon5G-yrHA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@bengao?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Ben Gao</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In this post, we will re-implement the former RESTful APIs with Kotlin language.</p><p>Open your browser and navigate to <a href="https://start.vertx.io">Eclipse Vertx Starter</a>, and generate the project skeleton. Do not forget to select <strong>Kotlin</strong> in the <em>language</em> field.</p><p>For the existing project, add the following dependency into the <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>    &lt;artifactId&gt;vertx-lang-kotlin&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Configure kotlin-compiler-plugin to compile the Kotlin source codes.</p><pre>&lt;plugin&gt;<br>    &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br>    &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;${kotlin.version}&lt;/version&gt;<br>    &lt;configuration&gt;<br>        &lt;jvmTarget&gt;16&lt;/jvmTarget&gt;<br>    &lt;/configuration&gt;<br>    &lt;executions&gt;<br>        &lt;execution&gt;<br>            &lt;id&gt;compile&lt;/id&gt;<br>            &lt;goals&gt;<br>                &lt;goal&gt;compile&lt;/goal&gt;<br>            &lt;/goals&gt;<br>        &lt;/execution&gt;<br>        &lt;execution&gt;<br>            &lt;id&gt;test-compile&lt;/id&gt;<br>            &lt;goals&gt;<br>                &lt;goal&gt;test-compile&lt;/goal&gt;<br>            &lt;/goals&gt;<br>        &lt;/execution&gt;<br>    &lt;/executions&gt;<br>&lt;/plugin&gt;</pre><p>We will use the same file structure and migrate <a href="https://github.com/hantsy/vertx-sandbox/tree/master/post-service">the original project(written in Java)</a> to Kotlin.</p><p>Firstly let’s have a look at the entry class — MainVerticle.</p><pre>class MainVerticle : AbstractVerticle() {<br>    companion object {<br>        private val LOGGER = Logger.getLogger(MainVerticle::class.java.name)</pre><pre>        /**<br>         * Configure logging from logging.properties file.<br>         * When using custom JUL logging properties, named it to vertx-default-jul-logging.properties<br>         * or set java.util.logging.config.file system property to locate the properties file.<br>         */<br>        @Throws(IOException::class)<br>        private fun setupLogging() {<br>            MainVerticle::class.java.getResourceAsStream(&quot;/logging.properties&quot;)<br>                .use { f -&gt; LogManager.getLogManager().readConfiguration(f) }<br>        }</pre><pre>        init {<br>            LOGGER.info(&quot;Customizing the built-in jackson ObjectMapper...&quot;)<br>            val objectMapper = DatabindCodec.mapper()<br>            objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br>            objectMapper.disable(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            objectMapper.disable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)<br>            val module = JavaTimeModule()<br>            objectMapper.registerModule(module)<br>        }<br>    }</pre><pre>    @Throws(Exception::class)<br>    override fun start(startPromise: Promise&lt;Void&gt;) {<br>        LOGGER.log(Level.INFO, &quot;Starting HTTP server...&quot;)<br>        //setupLogging();</pre><pre>        //Create a PgPool instance<br>        val pgPool = pgPool()</pre><pre>        //Creating PostRepository<br>        val postRepository = PostRepository(pgPool)</pre><pre>        //Creating PostHandler<br>        val postHandlers = PostsHandler(postRepository)</pre><pre>        // Initializing the sample data<br>        val initializer = DataInitializer(pgPool)<br>        initializer.run()</pre><pre>        // Configure routes<br>        val router = routes(postHandlers)</pre><pre>        // Create the HTTP server<br>        vertx.createHttpServer() // Handle every request using the router<br>            .requestHandler(router) // Start listening<br>            .listen(8888) // Print the port<br>            .onSuccess {<br>                startPromise.complete()<br>                println(&quot;HTTP server started on port &quot; + it.actualPort())<br>            }<br>            .onFailure {<br>                startPromise.fail(it)<br>                println(&quot;Failed to start HTTP server:&quot; + it.message)<br>            }<br>    }</pre><pre>    //create routes<br>    private fun routes(handlers: PostsHandler): Router {</pre><pre>        // Create a Router<br>        val router = Router.router(vertx)<br>        // register BodyHandler globally.<br>        //router.route().handler(BodyHandler.create());<br>        router.get(&quot;/posts&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .handler { handlers.all(it) }</pre><pre>        router.post(&quot;/posts&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler { handlers.save(it) }</pre><pre>        router.get(&quot;/posts/:id&quot;)<br>            .produces(&quot;application/json&quot;)<br>            .handler { handlers.getById(it) }<br>            .failureHandler {<br>                val error = it.failure()<br>                if (error is PostNotFoundException) {<br>                    it.response().setStatusCode(404).end(error.message)<br>                }<br>            }</pre><pre>        router.put(&quot;/posts/:id&quot;)<br>            .consumes(&quot;application/json&quot;)<br>            .handler(BodyHandler.create())<br>            .handler { handlers.update(it) }</pre><pre>        router.delete(&quot;/posts/:id&quot;)<br>            .handler { handlers.delete(it) }</pre><pre>        router.get(&quot;/hello&quot;).handler { it.response().end(&quot;Hello from my route&quot;) }</pre><pre>        return router<br>    }</pre><pre>    private fun pgPool(): PgPool {<br>        val connectOptions = PgConnectOptions()<br>            .setPort(5432)<br>            .setHost(&quot;localhost&quot;)<br>            .setDatabase(&quot;blogdb&quot;)<br>            .setUser(&quot;user&quot;)<br>            .setPassword(&quot;password&quot;)</pre><pre>        // Pool Options<br>        val poolOptions = PoolOptions().setMaxSize(5)</pre><pre>        // Create the pool from the data object<br>        return PgPool.pool(vertx, connectOptions, poolOptions)<br>    }<br>}</pre><p>In this class we move the original <em>static</em> block to a <em>companion object</em>.</p><p>In the router function, it assembles request handlers in routes. Let’s have a look at the PostsHandlers class.</p><pre>class PostsHandler(val posts: PostRepository) {<br>    fun all(rc: RoutingContext) {<br>//        var params = rc.queryParams();<br>//        var q = params.get(&quot;q&quot;);<br>//        var limit = params.get(&quot;limit&quot;) == null ? 10 : Integer.parseInt(params.get(&quot;q&quot;));<br>//        var offset = params.get(&quot;offset&quot;) == null ? 0 : Integer.parseInt(params.get(&quot;offset&quot;));<br>//        LOGGER.log(Level.INFO, &quot; find by keyword: q={0}, limit={1}, offset={2}&quot;, new Object[]{q, limit, offset});<br>        posts.findAll()<br>            .onSuccess {<br>                rc.response().end(Json.encode(it))<br>            }</pre><pre>    }</pre><pre>    fun getById(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        posts.findById(UUID.fromString(id))<br>            .onSuccess { rc.response().end(Json.encode(it)) }<br>            .onFailure { rc.fail(404, it) }<br>    }</pre><pre>    fun save(rc: RoutingContext) {<br>        //rc.getBodyAsJson().mapTo(PostForm.class)<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;request body: {0}&quot;, body)<br>        val (title, content) = body.mapTo(CreatePostCommand::class.java)<br>        posts.save(Post(title = title, content = content))<br>            .onSuccess { savedId: UUID -&gt;<br>                rc.response()<br>                    .putHeader(&quot;Location&quot;, &quot;/posts/$savedId&quot;)<br>                    .setStatusCode(201)<br>                    .end()<br>            }<br>    }</pre><pre>    fun update(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val body = rc.bodyAsJson<br>        LOGGER.log(Level.INFO, &quot;\npath param id: {0}\nrequest body: {1}&quot;, arrayOf(id, body))<br>        var (title, content) = body.mapTo(CreatePostCommand::class.java)<br>        posts.findById(UUID.fromString(id))<br>            .flatMap { post: Post -&gt;<br>                post.apply {<br>                    title = title<br>                    content = content<br>                }<br>                posts.update(post)<br>            }<br>            .onSuccess { rc.response().setStatusCode(204).end() }<br>            .onFailure { rc.fail(it) }<br>    }</pre><pre>    fun delete(rc: RoutingContext) {<br>        val params = rc.pathParams()<br>        val id = params[&quot;id&quot;]<br>        val uuid = UUID.fromString(id)<br>        posts.findById(uuid)<br>            .flatMap { posts.deleteById(uuid) }<br>            .onSuccess { rc.response().setStatusCode(204).end() }<br>            .onFailure { rc.fail(404, it) }<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostsHandler::class.java.simpleName)<br>    }<br>}</pre><p>Let’s move to the PostRepository class.</p><pre>class PostRepository(private val client: PgPool) {</pre><pre>    fun findAll() = client.query(&quot;SELECT * FROM posts ORDER BY id ASC&quot;)<br>        .execute()<br>        .map { rs: RowSet&lt;Row?&gt; -&gt;<br>            StreamSupport.stream(rs.spliterator(), false)<br>                .map { mapFun(it!!) }<br>                .toList()<br>        }<br></pre><pre>    fun findById(id: UUID) = client.preparedQuery(&quot;SELECT * FROM posts WHERE id=$1&quot;)<br>        .execute(Tuple.of(id))<br>        .map { it.iterator() }<br>        .map {<br>            if (it.hasNext()) mapFun(it.next());<br>            throw PostNotFoundException(id)<br>        }<br></pre><pre>    fun save(data: Post) = client.preparedQuery(&quot;INSERT INTO posts(title, content) VALUES ($1, $2) RETURNING (id)&quot;)<br>        .execute(Tuple.of(data.title, data.content))<br>        .map { it.iterator().next().getUUID(&quot;id&quot;) }<br></pre><pre>    fun saveAll(data: List&lt;Post&gt;): Future&lt;Int&gt; {<br>        val tuples = data.map { Tuple.of(it.title, it.content) }</pre><pre>        return client.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>            .executeBatch(tuples)<br>            .map { it.rowCount() }<br>    }</pre><pre>    fun update(data: Post) = client.preparedQuery(&quot;UPDATE posts SET title=$1, content=$2 WHERE id=$3&quot;)<br>        .execute(Tuple.of(data.title, data.content, data.id))<br>        .map { it.rowCount() }<br></pre><pre>    fun deleteAll() = client.query(&quot;DELETE FROM posts&quot;).execute()<br>        .map { it.rowCount() }<br></pre><pre>    fun deleteById(id: UUID) = client.preparedQuery(&quot;DELETE FROM posts WHERE id=$1&quot;).execute(Tuple.of(id))<br>        .map { it.rowCount() }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(PostRepository::class.java.name)<br>        val mapFun: (Row) -&gt; Post = { row: Row -&gt;<br>            Post(<br>                row.getUUID(&quot;id&quot;),<br>                row.getString(&quot;title&quot;),<br>                row.getString(&quot;content&quot;),<br>                row.getLocalDateTime(&quot;created_at&quot;)<br>            )<br>        }</pre><pre>    }<br>}</pre><p>The POJO classes are converted to Kotlin data classes.</p><pre>//Models.kt<br>data class Post(<br>    var id: UUID? = null,<br>    var title: String,<br>    var content: String,<br>    var createdAt: LocalDateTime? = LocalDateTime.now()<br>)</pre><pre>data class CreatePostCommand(<br>    val title: String,<br>    val content: String<br>)</pre><p>The DataIntializer is still used to insert some sample data at the application startup.</p><pre>class DataInitializer(private val client: PgPool) {</pre><pre>    fun run() {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;)<br>        val first = Tuple.of(&quot;Hello Quarkus&quot;, &quot;My first post of Quarkus&quot;)<br>        val second = Tuple.of(&quot;Hello Again, Quarkus&quot;, &quot;My second post of Quarkus&quot;)<br>        client<br>            .withTransaction { conn: SqlConnection -&gt;<br>                conn.query(&quot;DELETE FROM posts&quot;).execute()<br>                    .flatMap {<br>                        conn.preparedQuery(&quot;INSERT INTO posts (title, content) VALUES ($1, $2)&quot;)<br>                            .executeBatch(listOf(first, second))<br>                    }<br>                    .flatMap {<br>                        conn.query(&quot;SELECT * FROM posts&quot;).execute()<br>                    }<br>            }<br>            .onSuccess { data: RowSet&lt;Row?&gt; -&gt;<br>                StreamSupport.stream(data.spliterator(), true)<br>                    .forEach {<br>                        LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, it!!.toJson())<br>                    }<br>            }<br>            .onComplete {<br>                //client.close(); will block the application.<br>                LOGGER.info(&quot;Data initialization is done...&quot;)<br>            }<br>            .onFailure { LOGGER.warning(&quot;Data initialization is failed:&quot; + it.message) }<br>    }</pre><pre>    companion object {<br>        private val LOGGER = Logger.getLogger(DataInitializer::class.java.name)<br>    }<br>}</pre><p>Run the application via maven command.</p><pre>mvn clean compile exec:java</pre><p>Additionally, Vertx Kotlin bindings provides a Json DSL extension to simplify the JSON encoding.</p><pre>it.response()<br>     .setStatusCode(404)<br>     .end(<br>         json {// an example using JSON DSL<br>             obj(<br>                 &quot;message&quot; to &quot;${it.failure().message}&quot;,<br>                 &quot;code&quot; to &quot;not_found&quot;<br>             )<br>         }.toString()<br>     )</pre><p>Get <a href="https://github.com/hantsy/vertx-sandbox/tree/master/kotlin">the source codes</a> from my Github.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1d55cb389f67" width="1" height="1" alt=""><hr><p><a href="https://medium.com/nerd-for-tech/building-avertx-application-with-kotlin-1d55cb389f67">Building a Vertx application with Kotlin</a> was originally published in <a href="https://medium.com/nerd-for-tech">Nerd For Tech</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
