---
layout: post
title: Integrating Hibernate Reactive with Spring
---

<p>Hibernate started a subproject — Hibernate Reactive for Reactive Streams support, but at the moment when I wrote this post, Spring still did not embrace Hibernate Reactive. The good news is the integration work is not complex. In this post, we will attempt to integrate the latest Hibernate Reactive with Spring framework.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*n4q8pWVkhuvNGMID3AOKHw.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@qriusv?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Vivek Kumar</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>In the former post <a href="https://itnext.io/integrating-vertx-application-with-spring-framework-fb8fca81a357">Integrating Vertx with Spring framework</a> and <a href="https://itnext.io/building-a-vertx-application-with-smallrye-mutiny-bindings-spring-and-hibernate-reactive-5cf10b57983a">the further post</a> , we have integrated Hibernate Reactive with Spring IOC container, but in those the posts, the web handling is done by Vertx Web. In this post, we will use the existing Spring WebFlux instead.</p><p>Open your browser and navigate to <a href="https://start.spring.io">https://start.spring.io</a>, and generate a Spring project skeleton with the following dependencies,</p><ul><li><em>WebFlux</em></li><li><em>Lombok</em></li></ul><p>Extract the downloaded files into disc, and import the project into your IDE.</p><p>Open the project <em>pom.xml</em> file, add the following dependencies.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.vertx&lt;/groupId&gt;<br>    &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt;<br>    &lt;version&gt;${vertx-pg-client.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-reactive-core&lt;/artifactId&gt;<br>    &lt;version&gt;${hibernate-reactive.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br>    &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;<br>    &lt;optional&gt;true&lt;/optional&gt;<br>&lt;/dependency&gt;</pre><p>In the above the codes:</p><ul><li>The vertx-pg-client is the Postgres reactive driver which is required by Hibernate Reactive.</li><li>The hibernate-reactive-core is the core dependency of Hibernate Reactive.</li><li>Similar to the general Hibernate/JPA support, hibernate-jpamodelgen is used to generate entity metadata classes from the @Entity classes.</li></ul><p>Add a <em>persistence.xml</em> to <em>src/main/resources/META-INF</em> folder.</p><pre>&lt;persistence xmlns=&quot;http://xmlns.jcp.org/xml/ns/persistence&quot;<br>             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>             xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd&quot;<br>             version=&quot;2.2&quot;&gt;</pre><pre>    &lt;persistence-unit name=&quot;blogPU&quot;&gt;<br>        &lt;provider&gt;org.hibernate.reactive.provider.ReactivePersistenceProvider&lt;/provider&gt;</pre><pre>        &lt;class&gt;com.example.demo.Post&lt;/class&gt;</pre><pre>        &lt;properties&gt;</pre><pre>            &lt;!-- PostgreSQL --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.url&quot;<br>                      value=&quot;jdbc:postgresql://localhost:5432/blogdb&quot;/&gt;</pre><pre>            &lt;!-- Credentials --&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.user&quot;<br>                      value=&quot;user&quot;/&gt;<br>            &lt;property name=&quot;javax.persistence.jdbc.password&quot;<br>                      value=&quot;password&quot;/&gt;</pre><pre>            &lt;!-- The Vert.x SQL Client connection pool size --&gt;<br>            &lt;property name=&quot;hibernate.connection.pool_size&quot;<br>                      value=&quot;10&quot;/&gt;</pre><pre>            &lt;!-- Automatic schema export --&gt;<br>            &lt;property name=&quot;javax.persistence.schema-generation.database.action&quot;<br>                      value=&quot;drop-and-create&quot;/&gt;</pre><pre>            &lt;!-- SQL statement logging --&gt;<br>            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;<br>            &lt;property name=&quot;hibernate.highlight_sql&quot; value=&quot;true&quot;/&gt;</pre><pre>        &lt;/properties&gt;</pre><pre>    &lt;/persistence-unit&gt;</pre><pre>&lt;/persistence&gt;</pre><p>Note the provider must use the ReactivePersistenceProvider class which is provided in the new Hibernate Reactive. And you have to add all your entity classes in this <em>persistence.xml</em> file.</p><p>Then declare a Mutiny.SessionFactory bean. The blogPU is the persistence unit name configured in the <em>persistence.xml</em> file.</p><pre>@Bean<br>public Mutiny.SessionFactory sessionFactory() {<br>    return Persistence.createEntityManagerFactory(&quot;blogPU&quot;)<br>        .unwrap(Mutiny.SessionFactory.class);<br>}</pre><p>Create a sample entity class.</p><pre>@Data<br>@NoArgsConstructor<br>@AllArgsConstructor(staticName = &quot;of&quot;)<br>@Builder<br>@Entity<br>@Table(name = &quot;posts&quot;)<br>public class Post {</pre><pre>    @Id<br>    @GeneratedValue(generator = &quot;uuid&quot;)<br>    @GenericGenerator(name = &quot;uuid&quot;, strategy = &quot;uuid2&quot;)<br>    UUID id;<br>    String title;<br>    String content;</pre><pre>    @Builder.Default<br>    @Column(name = &quot;created_at&quot;)<br>    @CreationTimestamp<br>    LocalDateTime createdAt = LocalDateTime.now();<br>}</pre><p>And then create a Repository class for it.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class PostRepository {<br>    private static final Logger LOGGER = Logger.getLogger(PostRepository.class.getName());</pre><pre>    private final Mutiny.SessionFactory sessionFactory;</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query).getResultList());<br>    }</pre><pre>    public Uni&lt;List&lt;Post&gt;&gt; findByKeyword(String q, int offset, int limit) {</pre><pre>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create query<br>        CriteriaQuery&lt;Post&gt; query = cb.createQuery(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = query.from(Post.class);</pre><pre>        // if keyword is provided<br>        if (q != null &amp;&amp; !q.trim().isEmpty()) {<br>            query.where(<br>                cb.or(<br>                    cb.like(root.get(Post_.title), &quot;%&quot; + q + &quot;%&quot;),<br>                    cb.like(root.get(Post_.content), &quot;%&quot; + q + &quot;%&quot;)<br>                )<br>            );<br>        }<br>        //perform query<br>        return this.sessionFactory.withSession(session -&gt; session.createQuery(query)<br>            .setFirstResult(offset)<br>            .setMaxResults(limit)<br>            .getResultList());<br>    }<br></pre><pre>    public Uni&lt;Post&gt; findById(UUID id) {<br>        Objects.requireNonNull(id, &quot;id can not be null&quot;);<br>        return this.sessionFactory.withSession(session -&gt; session.find(Post.class, id))<br>            .onItem().ifNull().failWith(() -&gt; new PostNotFoundException(id));<br>    }</pre><pre>    public Uni&lt;Post&gt; save(Post post) {<br>        if (post.getId() == null) {<br>            return this.sessionFactory.withSession(session -&gt;<br>                session.persist(post)<br>                    .chain(session::flush)<br>                    .replaceWith(post)<br>            );<br>        } else {<br>            return this.sessionFactory.withSession(session -&gt; session.merge(post).onItem().call(session::flush));<br>        }<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteById(UUID id) {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // set where clause<br>        delete.where(cb.equal(root.get(Post_.id), id));<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>    public Uni&lt;Integer&gt; deleteAll() {<br>        CriteriaBuilder cb = this.sessionFactory.getCriteriaBuilder();<br>        // create delete<br>        CriteriaDelete&lt;Post&gt; delete = cb.createCriteriaDelete(Post.class);<br>        // set the root class<br>        Root&lt;Post&gt; root = delete.from(Post.class);<br>        // perform update<br>        return this.sessionFactory.withTransaction((session, tx) -&gt;<br>            session.createQuery(delete).executeUpdate()<br>        );<br>    }</pre><pre>}</pre><p>Till now, we have integrated Hibernate Reactive with Spring IOC container, next we will use the PostRepositoy to shake hands with the backend database. Let&#39;s begin to build the web handling part.</p><p>There are two different types of asynchronous APIs available in Hibernate Reactive, one is based on Java 8 CompletionStage, another is built on <a href="https://smallrye.io/smallrye-mutiny">Smallrye Munity project</a>. The later fully implements the Reactive Streams specification, we use SmallRye Mutiny in this post.</p><p>But unfortunately, Spring does not include built-in Smallrye Mutiny support as RxJava 2/3, etc.</p><p>There are some possible solutions that we can use to overcome this barrier.</p><ul><li>Convert the SmallRye APIs to Reactor APIs, then use the Reactor APIs directly in RouterFunction or Controller class.</li><li>Similar to the existing RxJava 1/2/3, JDK 9+ Flow support in Spring WebFlux, we can register Smallry Munity as another ReactiveStreams alternative of the official Reactor.</li></ul><p>Let’s explore them one by one.</p><p>Firstly let’s try to convert the Munity APIs to Reactor APIs. Assume we will use RouterFunction to handle the web request.</p><p>Add the following dependency to the project <em>pom.xml</em> file.</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;io.smallrye.reactive&lt;/groupId&gt;<br>    &lt;artifactId&gt;mutiny-reactor&lt;/artifactId&gt;<br>    &lt;version&gt;${mutiny-reactor.version}&lt;/version&gt;<br>&lt;/dependency&gt;</pre><p>The mutiny-reactor provides some utilities that can be use to convert APIs between SmallRye Mutiny and Reactor.</p><p>The following is an example of PostsHandler, where we centralize all web handlers in one class. In this class we convert all Mutiny APIs to Reactor APIs.</p><pre>@Component<br>@RequiredArgsConstructor<br>class PostsHandler {</pre><pre>    private final PostRepository posts;</pre><pre>    public Mono&lt;ServerResponse&gt; all(ServerRequest req) {<br>        return ServerResponse.ok().body(this.posts.findAll().convert().with(toMono()), Post.class);<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; create(ServerRequest req) {<br>        return req.bodyToMono(CreatePostCommand.class)<br>            .flatMap(post -&gt; this.posts.save(<br>                        Post.builder()<br>                            .title(post.getTitle())<br>                            .content(post.getContent())<br>                            .build()<br>                    )<br>                    .convert().with(toMono())<br>            )<br>            .flatMap(p -&gt; ServerResponse.created(URI.create(&quot;/posts/&quot; + p.getId())).build());<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; get(ServerRequest req) {<br>        var id = UUID.fromString(req.pathVariable(&quot;id&quot;));<br>        return this.posts.findById(id).convert().with(toMono())<br>            .flatMap(post -&gt; ServerResponse.ok().body(Mono.just(post), Post.class))<br>            .switchIfEmpty(ServerResponse.notFound().build());<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; update(ServerRequest req) {</pre><pre>        var id = UUID.fromString(req.pathVariable(&quot;id&quot;));<br>        return Mono.zip((data) -&gt; {<br>                    Post p = (Post) data[0];<br>                    UpdatePostCommand p2 = (UpdatePostCommand) data[1];<br>                    p.setTitle(p2.getTitle());<br>                    p.setContent(p2.getContent());<br>                    return p;<br>                },<br>                this.posts.findById(id).convert().with(toMono()),<br>                req.bodyToMono(UpdatePostCommand.class)<br>            )<br>            //.cast(Post.class)<br>            .flatMap(post -&gt; this.posts.save(post).convert().with(toMono()))<br>            .flatMap(post -&gt; ServerResponse.noContent().build());<br>    }</pre><pre>    public Mono&lt;ServerResponse&gt; delete(ServerRequest req) {<br>        var id = UUID.fromString(req.pathVariable(&quot;id&quot;));<br>        return this.posts.deleteById(id).convert().with(toMono())<br>            .flatMap(d -&gt; ServerResponse.noContent().build());<br>    }<br>}</pre><p>Then assemble the web handlers in a RouterFunction bean.</p><pre>@Bean<br>public RouterFunction&lt;ServerResponse&gt; routes(PostsHandler handler) {<br>    return route(GET(&quot;/posts&quot;), handler::all)<br>        .andRoute(POST(&quot;/posts&quot;), handler::create)<br>        .andRoute(GET(&quot;/posts/{id}&quot;), handler::get)<br>        .andRoute(PUT(&quot;/posts/{id}&quot;), handler::update)<br>        .andRoute(DELETE(&quot;/posts/{id}&quot;), handler::delete);<br>}</pre><p>Add a DataInitializer bean to initialize some sample data when starting up the application.</p><pre>@Component<br>@RequiredArgsConstructor<br>public class DataInitializer implements ApplicationRunner {</pre><pre>    private final static Logger LOGGER = Logger.getLogger(DataInitializer.class.getName());</pre><pre>    private final Mutiny.SessionFactory sessionFactory;</pre><pre>    @Override<br>    public void run(ApplicationArguments args) throws Exception {<br>        LOGGER.info(&quot;Data initialization is starting...&quot;);</pre><pre>        Post first = Post.of(null, &quot;Hello Spring&quot;, &quot;My first post of Spring&quot;, null);<br>        Post second = Post.of(null, &quot;Hello Hibernate Reactive&quot;, &quot;My second Hibernate Reactive&quot;, null);</pre><pre>        sessionFactory<br>            .withTransaction(<br>                (conn, tx) -&gt; conn.createQuery(&quot;DELETE FROM Post&quot;).executeUpdate()<br>                    .flatMap(r -&gt; conn.persistAll(first, second))<br>                    .chain(conn::flush)<br>                    .flatMap(r -&gt; conn.createQuery(&quot;SELECT p from Post p&quot;, Post.class).getResultList())<br>            )<br>            .subscribe()<br>            .with(<br>                data -&gt; LOGGER.log(Level.INFO, &quot;saved data:{0}&quot;, data),<br>                throwable -&gt; LOGGER.warning(&quot;Data initialization is failed:&quot; + throwable.getMessage())<br>            );<br>    }<br>}</pre><p>Start up a Postgres database. There is a <a href="https://github.com/hantsy/spring-puzzles/blob/master/hibernate-reactive/docker-compose.yml"><em>docker-compose.yml</em></a> file available to start a Postgres instance in Docker container.</p><p>Then run the application via Spring Boot Maven plugin.</p><pre>// start postgres database<br>docker compose up </pre><pre>// run the application<br>mvn clean spring-root:run</pre><p>When the application is running successfully, open your terminal, and try to test <a href="http://localhost:8080/posts">http://localhost:8080/posts</a> endpoints with curl command.</p><pre># curl http://localhost:8080/posts<br>[{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;},{&quot;id&quot;:&quot;e09ffa71-905f-4241-9449-0860977de666&quot;,&quot;title&quot;:&quot;Hello Hibernate Reactive&quot;,&quot;content&quot;:&quot;My second Hibernate Reactive&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.116677&quot;}]</pre><pre># curl http://localhost:8080/posts/0998578e-0553-480b-bbb7-e96fd402455f<br>{&quot;id&quot;:&quot;0998578e-0553-480b-bbb7-e96fd402455f&quot;,&quot;title&quot;:&quot;Hello Spring&quot;,&quot;content&quot;:&quot;My first post of Spring&quot;,&quot;createdAt&quot;:&quot;2021-08-26T22:37:02.076284&quot;}</pre><p>Then let’s discuss the second solution.</p><p>Spring internally uses a ReactiveAdapterRegistry to register all reactive streams implementations, such as RxJava 2/3, JDK 9+ Flow, etc. When serializing the implementor&#39;s specific APIs, it will look up the registry and convert it into the standard RectiveStreams APIs which can be processed by Spring framework.</p><p>We’ll create a new adapter to register Mutiny APIs as expected.</p><pre>@Component<br>@RequiredArgsConstructor<br>@Slf4j<br>public class MutinyAdapter {<br>    private final ReactiveAdapterRegistry registry;</pre><pre>    @PostConstruct<br>    public void registerAdapters(){<br>        log.debug(&quot;registering MutinyAdapter&quot;);<br>        registry.registerReactiveType(<br>            ReactiveTypeDescriptor.singleOptionalValue(Uni.class, ()-&gt; Uni.createFrom().nothing()),<br>            uni -&gt;((Uni&lt;?&gt;)uni).convert().toPublisher(),<br>            publisher -&gt;  Uni.createFrom().publisher(publisher)<br>        );</pre><pre>        registry.registerReactiveType(<br>            ReactiveTypeDescriptor.multiValue(Multi.class, ()-&gt; Multi.createFrom().empty()),<br>            multi -&gt; (Multi&lt;?&gt;) multi,<br>            publisher-&gt; Multi.createFrom().publisher(publisher));<br>    }<br>}</pre><p>Then create a @RestController bean which invokes PostRepository directly. As you see, all methods return a ResponseEntity type or a Uni&lt;ResponseEntity&gt; type directly, no need explicit conversion work there.</p><pre>@RestController<br>@RequestMapping(&quot;/posts&quot;)<br>@RequiredArgsConstructor<br>class PostController {</pre><pre>    private final PostRepository posts;</pre><pre>    @GetMapping(value = &quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE)<br>    public ResponseEntity&lt;?&gt; all() {<br>        return ok().body(this.posts.findAll());<br>    }</pre><pre>    @PostMapping(value = &quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)<br>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; create(@RequestBody CreatePostCommand data) {<br>        return this.posts.save(<br>                Post.builder()<br>                    .title(data.getTitle())<br>                    .content(data.getContent())<br>                    .build()<br>            )<br>            .map(p -&gt; created(URI.create(&quot;/posts/&quot; + p.getId())).build());<br>    }</pre><pre>    @GetMapping(value = &quot;{id}&quot;, produces = MediaType.APPLICATION_JSON_VALUE)<br>    public Uni&lt;ResponseEntity&lt;Post&gt;&gt; get(@PathVariable UUID id) {<br>        return this.posts.findById(id)<br>            .map(post -&gt; ok().body(post));<br>    }</pre><pre>    @PutMapping(value = &quot;{id}&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)<br>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; update(@PathVariable UUID id, @RequestBody UpdatePostCommand data) {</pre><pre>        return Uni.combine().all()<br>            .unis(<br>                this.posts.findById(id),<br>                Uni.createFrom().item(data)<br>            )<br>            .combinedWith((p, d) -&gt; {<br>                p.setTitle(d.getTitle());<br>                p.setContent(d.getContent());<br>                return p;<br>            })<br>            .flatMap(this.posts::save)<br>            .map(post -&gt; noContent().build());<br>    }</pre><pre>    @DeleteMapping(&quot;{id}&quot;)<br>    public Uni&lt;ResponseEntity&lt;?&gt;&gt; delete(@PathVariable UUID id) {<br>        return this.posts.deleteById(id).map(d -&gt; noContent().build());<br>    }<br>}</pre><p>Run this application again, you will get the same result as the former solution.</p><h4>Get the source codes of this post from my GitHub, they are available in two separate projects, <a href="https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive">hibernate-reactive</a> and <a href="https://github.com/hantsy/spring-puzzles/tree/master/hibernate-reactive-mutiny">hibernate-reactive-mutiny</a>.</h4><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5427440607fe" width="1" height="1" alt=""><hr><p><a href="https://itnext.io/integrating-hibernate-reactive-with-spring-5427440607fe">Integrating Hibernate Reactive with Spring</a> was originally published in <a href="https://itnext.io">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
