---
layout: post
title: Consuming with RESTful APIs with Vertx HttpClient/WebClient
---

<p>We have discussed how to build RESTful APIs with the basic Eclipse Vertx Web feature. In this post, we will cover how to create a <em>Http Client</em> and interact with RESTful APIs.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2y5DM9RtKpVzypW4HUnJdA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/@joshuaearle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Joshua Earle</a> on <a href="https://unsplash.com/s/photos/china-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Similar to the creating of HttpServer, you can create a HttpClient from Vertx instance.</p><pre>var options = new HttpClientOptions()<br>    .setDefaultPort(8888);<br>var client = vertx.createHttpClient(options);</pre><p>Then you can send request to the server like the following.</p><pre>client.request(HttpMethod.GET, &quot;/hello&quot;)<br>    .compose(req -&gt; req.send().compose(HttpClientResponse::body))<br>    .onSuccess(...)<br>    .onFailure(...)</pre><p>The HttpClient is a low-level APIs and provides find-grained control of the request and response info. Vertx provides a more advanced API to shake hands with the server side, it is called WebClient.</p><p>Similar to the creating of HttpClient, create a WebClient instance like this.</p><pre>var options = new WebClientOptions()<br>            .setDefaultHost(&quot;localhost&quot;)<br>            .setDefaultPort(8888);<br>var webclient = WebClient.create(vertx, options);</pre><p>Or create a WebClient from the existing HttpClient instance.</p><pre>var webclient = WebClient.wrap(httpClient, options);</pre><p>An example using WebClient to send requests.</p><pre>client.get(&quot;/posts&quot;)<br>    .send()<br>    .onSuccess(...)<br>    .onFailure(...)</pre><p>Compare to the HttpClient , it provides more comprehensive methods to send request body, eg. JSON object, multipart form, etc.</p><p>Next let’s move to the testing of Vertx, and use HttpClient/WebClient to test RESTful API endpoints.</p><p>The following example is a simple JUnit 5 tests.</p><pre>@ExtendWith(VertxExtension.class)<br>public class TestMainVerticle {<br>    private final static Logger LOGGER = Logger.getLogger(TestMainVerticle.class.getName());<br>    HttpClient client;</pre><pre>    @BeforeEach<br>    void setup(Vertx vertx, VertxTestContext testContext) {<br>        vertx.deployVerticle(new MainVerticle(), testContext.succeeding(id -&gt; testContext.completeNow()));<br>        var options = new HttpClientOptions()<br>            .setDefaultPort(8888);<br>        this.client = vertx.createHttpClient(options);<br>    }</pre><pre>    @DisplayName(&quot;Check the HTTP response...&quot;)<br>    void testHello(Vertx vertx, VertxTestContext testContext) {<br>        client.request(HttpMethod.GET, &quot;/hello&quot;)<br>            .compose(req -&gt; req.send().compose(HttpClientResponse::body))<br>            .onComplete(<br>                testContext.succeeding(<br>                    buffer -&gt; testContext.verify(<br>                        () -&gt; {<br>                            assertThat(buffer.toString()).isEqualTo(&quot;Hello from my route&quot;);<br>                            testContext.completeNow();<br>                        }<br>                    )<br>                )<br>            );<br>    }</pre><pre>}</pre><p>With the @ExtendWith(VertxExtension.class), it allows you to inject Vertx and VertxTestContext parameter in the test methods. The VertxTestContext wrap a CountDownLatch to indicate the asynchronous execution is done, you have to call the completeNow or failNow to end execution, else the test execution will be blocked till it is timeout.</p><p>Let’s have a look at an example of testing the <em>/posts</em> endpoint to get all posts.</p><pre>@Test<br>void testGetAll(Vertx vertx, VertxTestContext testContext) {<br>    client.request(HttpMethod.GET, &quot;/posts&quot;)<br>        .flatMap(HttpClientRequest::send)<br>        .flatMap(HttpClientResponse::body)<br>        .onComplete(<br>        testContext.succeeding(<br>            buffer -&gt; testContext.verify(<br>                () -&gt; {<br>                    assertThat(buffer.toJsonArray().size()).isEqualTo(2);<br>                    testContext.completeNow();<br>                }<br>            )<br>        )<br>    );<br>}</pre><p>The following example is testing the PostNotFoundException which return a 404 HTTP status code.</p><pre>@Test<br>void testGetByNoneExistingId(Vertx vertx, VertxTestContext testContext) {<br>    var postByIdUrl = &quot;/posts/&quot; + UUID.randomUUID();<br>    client.request(HttpMethod.GET, postByIdUrl)<br>        .flatMap(HttpClientRequest::send)<br>        .onComplete(<br>        testContext.succeeding(<br>            response -&gt; testContext.verify(<br>                () -&gt; {<br>                    assertThat(response.statusCode()).isEqualTo(404);<br>                    testContext.completeNow();<br>                }<br>            )<br>        )<br>    );<br>}</pre><p>The client operations can be chained. The following is an example to test a CRUD flow.</p><pre>@Test<br>void testCreatePost(Vertx vertx, VertxTestContext testContext) {<br>    client.request(HttpMethod.POST, &quot;/posts&quot;)<br>        .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                 .send(Json.encode(CreatePostCommand.of(&quot;test title&quot;, &quot;test content of my post&quot;)))<br>                 .onSuccess(<br>                     response -&gt; assertThat(response.statusCode()).isEqualTo(201)<br>                 )<br>                )<br>        .flatMap(response -&gt; {<br>            String location = response.getHeader(&quot;Location&quot;);<br>            LOGGER.log(Level.INFO, &quot;location header: {0}&quot;, location);<br>            assertThat(location).isNotNull();</pre><pre>            return Future.succeededFuture(location);<br>        })<br>        .flatMap(url -&gt; client.request(HttpMethod.GET, url)<br>                 .flatMap(HttpClientRequest::send)<br>                 .onSuccess(response -&gt; {<br>                     LOGGER.log(Level.INFO, &quot;http status: {0}&quot;, response.statusCode());<br>                     assertThat(response.statusCode()).isEqualTo(200);<br>                 })<br>                 .flatMap(res -&gt; client.request(HttpMethod.PUT, url)<br>                          .flatMap(req -&gt; req.putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)<br>                                   .send(Json.encode(CreatePostCommand.of(&quot;updated test title&quot;, &quot;updated test content of my post&quot;)))<br>                                  )<br>                          .onSuccess(response -&gt; {<br>                              LOGGER.log(Level.INFO, &quot;http status: {0}&quot;, response.statusCode());<br>                              assertThat(response.statusCode()).isEqualTo(204);<br>                          })<br>                         )<br>                 .flatMap(res -&gt; client.request(HttpMethod.GET, url)<br>                          .flatMap(HttpClientRequest::send)<br>                          .onSuccess(response -&gt; {<br>                              LOGGER.log(Level.INFO, &quot;http status: {0}&quot;, response.statusCode());<br>                              assertThat(response.statusCode()).isEqualTo(200);</pre><pre>                          })<br>                          .flatMap(HttpClientResponse::body)<br>                          .onSuccess(body -&gt; assertThat(body.toJsonObject().getString(&quot;title&quot;)).isEqualTo(&quot;updated test title&quot;))<br>                         )<br>                 .flatMap(res -&gt; client.request(HttpMethod.DELETE, url)<br>                          .flatMap(HttpClientRequest::send)<br>                          .onSuccess(response -&gt; {<br>                              LOGGER.log(Level.INFO, &quot;http status: {0}&quot;, response.statusCode());<br>                              assertThat(response.statusCode()).isEqualTo(204);<br>                          })<br>                         )<br>                 .flatMap(res -&gt; client.request(HttpMethod.GET, url)<br>                          .flatMap(HttpClientRequest::send)<br>                          .onSuccess(response -&gt; {<br>                              LOGGER.log(Level.INFO, &quot;http status: {0}&quot;, response.statusCode());<br>                              assertThat(response.statusCode()).isEqualTo(404);<br>                          })<br>                         )<br>                )<br>        .onComplete(<br>        testContext.succeeding(id -&gt; testContext.completeNow())<br>    );<br>}</pre><p>Similarly, you can use WebClient in the tests.</p><p>The following is an example using WebClient with RxJava 3 bindings.</p><pre>@Test<br>void testGetAll(Vertx vertx, VertxTestContext testContext) {<br>    client.get(&quot;/posts&quot;)<br>        .rxSend()<br>        .subscribe(<br>        response -&gt; {<br>            assertThat(response.statusCode()).isEqualTo(200);<br>            assertThat(response.bodyAsJsonArray().size()).isEqualTo(2);</pre><pre>            testContext.completeNow();<br>        }<br>    );<br>}</pre><p>The WebClient provides more fluent APIs. In most of cases of sending a request it is easier than the raw HttpClient, esp. handling the multipart form. We will explore it in future.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6a2f61d94029" width="1" height="1" alt="">
